"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@google";
exports.ids = ["vendor-chunks/@google"];
exports.modules = {

/***/ "(rsc)/./node_modules/@google/genai/dist/node/index.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@google/genai/dist/node/index.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ActivityHandling: () => (/* binding */ ActivityHandling),\n/* harmony export */   AdapterSize: () => (/* binding */ AdapterSize),\n/* harmony export */   ApiError: () => (/* binding */ ApiError),\n/* harmony export */   ApiSpec: () => (/* binding */ ApiSpec),\n/* harmony export */   AuthType: () => (/* binding */ AuthType),\n/* harmony export */   Batches: () => (/* binding */ Batches),\n/* harmony export */   Behavior: () => (/* binding */ Behavior),\n/* harmony export */   BlockedReason: () => (/* binding */ BlockedReason),\n/* harmony export */   Caches: () => (/* binding */ Caches),\n/* harmony export */   Chat: () => (/* binding */ Chat),\n/* harmony export */   Chats: () => (/* binding */ Chats),\n/* harmony export */   ComputeTokensResponse: () => (/* binding */ ComputeTokensResponse),\n/* harmony export */   ContentReferenceImage: () => (/* binding */ ContentReferenceImage),\n/* harmony export */   ControlReferenceImage: () => (/* binding */ ControlReferenceImage),\n/* harmony export */   ControlReferenceType: () => (/* binding */ ControlReferenceType),\n/* harmony export */   CountTokensResponse: () => (/* binding */ CountTokensResponse),\n/* harmony export */   CreateFileResponse: () => (/* binding */ CreateFileResponse),\n/* harmony export */   DeleteCachedContentResponse: () => (/* binding */ DeleteCachedContentResponse),\n/* harmony export */   DeleteFileResponse: () => (/* binding */ DeleteFileResponse),\n/* harmony export */   DeleteModelResponse: () => (/* binding */ DeleteModelResponse),\n/* harmony export */   DocumentState: () => (/* binding */ DocumentState),\n/* harmony export */   DynamicRetrievalConfigMode: () => (/* binding */ DynamicRetrievalConfigMode),\n/* harmony export */   EditImageResponse: () => (/* binding */ EditImageResponse),\n/* harmony export */   EditMode: () => (/* binding */ EditMode),\n/* harmony export */   EmbedContentResponse: () => (/* binding */ EmbedContentResponse),\n/* harmony export */   EndSensitivity: () => (/* binding */ EndSensitivity),\n/* harmony export */   Environment: () => (/* binding */ Environment),\n/* harmony export */   FeatureSelectionPreference: () => (/* binding */ FeatureSelectionPreference),\n/* harmony export */   FileSource: () => (/* binding */ FileSource),\n/* harmony export */   FileState: () => (/* binding */ FileState),\n/* harmony export */   Files: () => (/* binding */ Files),\n/* harmony export */   FinishReason: () => (/* binding */ FinishReason),\n/* harmony export */   FunctionCallingConfigMode: () => (/* binding */ FunctionCallingConfigMode),\n/* harmony export */   FunctionResponse: () => (/* binding */ FunctionResponse),\n/* harmony export */   FunctionResponseBlob: () => (/* binding */ FunctionResponseBlob),\n/* harmony export */   FunctionResponseFileData: () => (/* binding */ FunctionResponseFileData),\n/* harmony export */   FunctionResponsePart: () => (/* binding */ FunctionResponsePart),\n/* harmony export */   FunctionResponseScheduling: () => (/* binding */ FunctionResponseScheduling),\n/* harmony export */   GenerateContentResponse: () => (/* binding */ GenerateContentResponse),\n/* harmony export */   GenerateContentResponsePromptFeedback: () => (/* binding */ GenerateContentResponsePromptFeedback),\n/* harmony export */   GenerateContentResponseUsageMetadata: () => (/* binding */ GenerateContentResponseUsageMetadata),\n/* harmony export */   GenerateImagesResponse: () => (/* binding */ GenerateImagesResponse),\n/* harmony export */   GenerateVideosOperation: () => (/* binding */ GenerateVideosOperation),\n/* harmony export */   GenerateVideosResponse: () => (/* binding */ GenerateVideosResponse),\n/* harmony export */   GoogleGenAI: () => (/* binding */ GoogleGenAI),\n/* harmony export */   HarmBlockMethod: () => (/* binding */ HarmBlockMethod),\n/* harmony export */   HarmBlockThreshold: () => (/* binding */ HarmBlockThreshold),\n/* harmony export */   HarmCategory: () => (/* binding */ HarmCategory),\n/* harmony export */   HarmProbability: () => (/* binding */ HarmProbability),\n/* harmony export */   HarmSeverity: () => (/* binding */ HarmSeverity),\n/* harmony export */   HttpElementLocation: () => (/* binding */ HttpElementLocation),\n/* harmony export */   HttpResponse: () => (/* binding */ HttpResponse),\n/* harmony export */   ImagePromptLanguage: () => (/* binding */ ImagePromptLanguage),\n/* harmony export */   ImportFileOperation: () => (/* binding */ ImportFileOperation),\n/* harmony export */   ImportFileResponse: () => (/* binding */ ImportFileResponse),\n/* harmony export */   InlinedEmbedContentResponse: () => (/* binding */ InlinedEmbedContentResponse),\n/* harmony export */   InlinedResponse: () => (/* binding */ InlinedResponse),\n/* harmony export */   JobState: () => (/* binding */ JobState),\n/* harmony export */   Language: () => (/* binding */ Language),\n/* harmony export */   ListBatchJobsResponse: () => (/* binding */ ListBatchJobsResponse),\n/* harmony export */   ListCachedContentsResponse: () => (/* binding */ ListCachedContentsResponse),\n/* harmony export */   ListDocumentsResponse: () => (/* binding */ ListDocumentsResponse),\n/* harmony export */   ListFileSearchStoresResponse: () => (/* binding */ ListFileSearchStoresResponse),\n/* harmony export */   ListFilesResponse: () => (/* binding */ ListFilesResponse),\n/* harmony export */   ListModelsResponse: () => (/* binding */ ListModelsResponse),\n/* harmony export */   ListTuningJobsResponse: () => (/* binding */ ListTuningJobsResponse),\n/* harmony export */   Live: () => (/* binding */ Live),\n/* harmony export */   LiveClientToolResponse: () => (/* binding */ LiveClientToolResponse),\n/* harmony export */   LiveMusicPlaybackControl: () => (/* binding */ LiveMusicPlaybackControl),\n/* harmony export */   LiveMusicServerMessage: () => (/* binding */ LiveMusicServerMessage),\n/* harmony export */   LiveSendToolResponseParameters: () => (/* binding */ LiveSendToolResponseParameters),\n/* harmony export */   LiveServerMessage: () => (/* binding */ LiveServerMessage),\n/* harmony export */   MaskReferenceImage: () => (/* binding */ MaskReferenceImage),\n/* harmony export */   MaskReferenceMode: () => (/* binding */ MaskReferenceMode),\n/* harmony export */   MediaModality: () => (/* binding */ MediaModality),\n/* harmony export */   MediaResolution: () => (/* binding */ MediaResolution),\n/* harmony export */   Modality: () => (/* binding */ Modality),\n/* harmony export */   Mode: () => (/* binding */ Mode),\n/* harmony export */   Models: () => (/* binding */ Models),\n/* harmony export */   MusicGenerationMode: () => (/* binding */ MusicGenerationMode),\n/* harmony export */   Operations: () => (/* binding */ Operations),\n/* harmony export */   Outcome: () => (/* binding */ Outcome),\n/* harmony export */   PagedItem: () => (/* binding */ PagedItem),\n/* harmony export */   Pager: () => (/* binding */ Pager),\n/* harmony export */   PartMediaResolutionLevel: () => (/* binding */ PartMediaResolutionLevel),\n/* harmony export */   PersonGeneration: () => (/* binding */ PersonGeneration),\n/* harmony export */   PhishBlockThreshold: () => (/* binding */ PhishBlockThreshold),\n/* harmony export */   RawReferenceImage: () => (/* binding */ RawReferenceImage),\n/* harmony export */   RecontextImageResponse: () => (/* binding */ RecontextImageResponse),\n/* harmony export */   ReplayResponse: () => (/* binding */ ReplayResponse),\n/* harmony export */   SafetyFilterLevel: () => (/* binding */ SafetyFilterLevel),\n/* harmony export */   Scale: () => (/* binding */ Scale),\n/* harmony export */   SegmentImageResponse: () => (/* binding */ SegmentImageResponse),\n/* harmony export */   SegmentMode: () => (/* binding */ SegmentMode),\n/* harmony export */   Session: () => (/* binding */ Session),\n/* harmony export */   SingleEmbedContentResponse: () => (/* binding */ SingleEmbedContentResponse),\n/* harmony export */   StartSensitivity: () => (/* binding */ StartSensitivity),\n/* harmony export */   StyleReferenceImage: () => (/* binding */ StyleReferenceImage),\n/* harmony export */   SubjectReferenceImage: () => (/* binding */ SubjectReferenceImage),\n/* harmony export */   SubjectReferenceType: () => (/* binding */ SubjectReferenceType),\n/* harmony export */   ThinkingLevel: () => (/* binding */ ThinkingLevel),\n/* harmony export */   Tokens: () => (/* binding */ Tokens),\n/* harmony export */   TrafficType: () => (/* binding */ TrafficType),\n/* harmony export */   TuningMethod: () => (/* binding */ TuningMethod),\n/* harmony export */   TuningMode: () => (/* binding */ TuningMode),\n/* harmony export */   TuningTask: () => (/* binding */ TuningTask),\n/* harmony export */   TurnCompleteReason: () => (/* binding */ TurnCompleteReason),\n/* harmony export */   TurnCoverage: () => (/* binding */ TurnCoverage),\n/* harmony export */   Type: () => (/* binding */ Type),\n/* harmony export */   UploadToFileSearchStoreOperation: () => (/* binding */ UploadToFileSearchStoreOperation),\n/* harmony export */   UploadToFileSearchStoreResponse: () => (/* binding */ UploadToFileSearchStoreResponse),\n/* harmony export */   UploadToFileSearchStoreResumableResponse: () => (/* binding */ UploadToFileSearchStoreResumableResponse),\n/* harmony export */   UpscaleImageResponse: () => (/* binding */ UpscaleImageResponse),\n/* harmony export */   UrlRetrievalStatus: () => (/* binding */ UrlRetrievalStatus),\n/* harmony export */   VideoCompressionQuality: () => (/* binding */ VideoCompressionQuality),\n/* harmony export */   VideoGenerationMaskMode: () => (/* binding */ VideoGenerationMaskMode),\n/* harmony export */   VideoGenerationReferenceType: () => (/* binding */ VideoGenerationReferenceType),\n/* harmony export */   createFunctionResponsePartFromBase64: () => (/* binding */ createFunctionResponsePartFromBase64),\n/* harmony export */   createFunctionResponsePartFromUri: () => (/* binding */ createFunctionResponsePartFromUri),\n/* harmony export */   createModelContent: () => (/* binding */ createModelContent),\n/* harmony export */   createPartFromBase64: () => (/* binding */ createPartFromBase64),\n/* harmony export */   createPartFromCodeExecutionResult: () => (/* binding */ createPartFromCodeExecutionResult),\n/* harmony export */   createPartFromExecutableCode: () => (/* binding */ createPartFromExecutableCode),\n/* harmony export */   createPartFromFunctionCall: () => (/* binding */ createPartFromFunctionCall),\n/* harmony export */   createPartFromFunctionResponse: () => (/* binding */ createPartFromFunctionResponse),\n/* harmony export */   createPartFromText: () => (/* binding */ createPartFromText),\n/* harmony export */   createPartFromUri: () => (/* binding */ createPartFromUri),\n/* harmony export */   createUserContent: () => (/* binding */ createUserContent),\n/* harmony export */   mcpToTool: () => (/* binding */ mcpToTool),\n/* harmony export */   setDefaultBaseUrls: () => (/* binding */ setDefaultBaseUrls)\n/* harmony export */ });\n/* harmony import */ var google_auth_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! google-auth-library */ \"(rsc)/./node_modules/google-auth-library/build/src/index.js\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs_promises__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fs/promises */ \"fs/promises\");\n/* harmony import */ var node_stream__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! node:stream */ \"node:stream\");\n/* harmony import */ var node_stream_promises__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! node:stream/promises */ \"node:stream/promises\");\n/* harmony import */ var ws__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ws */ \"(rsc)/./node_modules/ws/wrapper.mjs\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! path */ \"path\");\n\n\n\n\n\n\n\n\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nlet _defaultBaseGeminiUrl = undefined;\nlet _defaultBaseVertexUrl = undefined;\n/**\n * Overrides the base URLs for the Gemini API and Vertex AI API.\n *\n * @remarks This function should be called before initializing the SDK. If the\n * base URLs are set after initializing the SDK, the base URLs will not be\n * updated. Base URLs provided in the HttpOptions will also take precedence over\n * URLs set here.\n *\n * @example\n * ```ts\n * import {GoogleGenAI, setDefaultBaseUrls} from '@google/genai';\n * // Override the base URL for the Gemini API.\n * setDefaultBaseUrls({geminiUrl:'https://gemini.google.com'});\n *\n * // Override the base URL for the Vertex AI API.\n * setDefaultBaseUrls({vertexUrl: 'https://vertexai.googleapis.com'});\n *\n * const ai = new GoogleGenAI({apiKey: 'GEMINI_API_KEY'});\n * ```\n */\nfunction setDefaultBaseUrls(baseUrlParams) {\n    _defaultBaseGeminiUrl = baseUrlParams.geminiUrl;\n    _defaultBaseVertexUrl = baseUrlParams.vertexUrl;\n}\n/**\n * Returns the default base URLs for the Gemini API and Vertex AI API.\n */\nfunction getDefaultBaseUrls() {\n    return {\n        geminiUrl: _defaultBaseGeminiUrl,\n        vertexUrl: _defaultBaseVertexUrl,\n    };\n}\n/**\n * Returns the default base URL based on the following priority:\n *   1. Base URLs set via HttpOptions.\n *   2. Base URLs set via the latest call to setDefaultBaseUrls.\n *   3. Base URLs set via environment variables.\n */\nfunction getBaseUrl(httpOptions, vertexai, vertexBaseUrlFromEnv, geminiBaseUrlFromEnv) {\n    var _a, _b;\n    if (!(httpOptions === null || httpOptions === void 0 ? void 0 : httpOptions.baseUrl)) {\n        const defaultBaseUrls = getDefaultBaseUrls();\n        if (vertexai) {\n            return (_a = defaultBaseUrls.vertexUrl) !== null && _a !== void 0 ? _a : vertexBaseUrlFromEnv;\n        }\n        else {\n            return (_b = defaultBaseUrls.geminiUrl) !== null && _b !== void 0 ? _b : geminiBaseUrlFromEnv;\n        }\n    }\n    return httpOptions.baseUrl;\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nclass BaseModule {\n}\nfunction formatMap(templateString, valueMap) {\n    // Use a regular expression to find all placeholders in the template string\n    const regex = /\\{([^}]+)\\}/g;\n    // Replace each placeholder with its corresponding value from the valueMap\n    return templateString.replace(regex, (match, key) => {\n        if (Object.prototype.hasOwnProperty.call(valueMap, key)) {\n            const value = valueMap[key];\n            // Convert the value to a string if it's not a string already\n            return value !== undefined && value !== null ? String(value) : '';\n        }\n        else {\n            // Handle missing keys\n            throw new Error(`Key '${key}' not found in valueMap.`);\n        }\n    });\n}\nfunction setValueByPath(data, keys, value) {\n    for (let i = 0; i < keys.length - 1; i++) {\n        const key = keys[i];\n        if (key.endsWith('[]')) {\n            const keyName = key.slice(0, -2);\n            if (!(keyName in data)) {\n                if (Array.isArray(value)) {\n                    data[keyName] = Array.from({ length: value.length }, () => ({}));\n                }\n                else {\n                    throw new Error(`Value must be a list given an array path ${key}`);\n                }\n            }\n            if (Array.isArray(data[keyName])) {\n                const arrayData = data[keyName];\n                if (Array.isArray(value)) {\n                    for (let j = 0; j < arrayData.length; j++) {\n                        const entry = arrayData[j];\n                        setValueByPath(entry, keys.slice(i + 1), value[j]);\n                    }\n                }\n                else {\n                    for (const d of arrayData) {\n                        setValueByPath(d, keys.slice(i + 1), value);\n                    }\n                }\n            }\n            return;\n        }\n        else if (key.endsWith('[0]')) {\n            const keyName = key.slice(0, -3);\n            if (!(keyName in data)) {\n                data[keyName] = [{}];\n            }\n            const arrayData = data[keyName];\n            setValueByPath(arrayData[0], keys.slice(i + 1), value);\n            return;\n        }\n        if (!data[key] || typeof data[key] !== 'object') {\n            data[key] = {};\n        }\n        data = data[key];\n    }\n    const keyToSet = keys[keys.length - 1];\n    const existingData = data[keyToSet];\n    if (existingData !== undefined) {\n        if (!value ||\n            (typeof value === 'object' && Object.keys(value).length === 0)) {\n            return;\n        }\n        if (value === existingData) {\n            return;\n        }\n        if (typeof existingData === 'object' &&\n            typeof value === 'object' &&\n            existingData !== null &&\n            value !== null) {\n            Object.assign(existingData, value);\n        }\n        else {\n            throw new Error(`Cannot set value for an existing key. Key: ${keyToSet}`);\n        }\n    }\n    else {\n        if (keyToSet === '_self' &&\n            typeof value === 'object' &&\n            value !== null &&\n            !Array.isArray(value)) {\n            const valueAsRecord = value;\n            Object.assign(data, valueAsRecord);\n        }\n        else {\n            data[keyToSet] = value;\n        }\n    }\n}\nfunction getValueByPath(data, keys, defaultValue = undefined) {\n    try {\n        if (keys.length === 1 && keys[0] === '_self') {\n            return data;\n        }\n        for (let i = 0; i < keys.length; i++) {\n            if (typeof data !== 'object' || data === null) {\n                return defaultValue;\n            }\n            const key = keys[i];\n            if (key.endsWith('[]')) {\n                const keyName = key.slice(0, -2);\n                if (keyName in data) {\n                    const arrayData = data[keyName];\n                    if (!Array.isArray(arrayData)) {\n                        return defaultValue;\n                    }\n                    return arrayData.map((d) => getValueByPath(d, keys.slice(i + 1), defaultValue));\n                }\n                else {\n                    return defaultValue;\n                }\n            }\n            else {\n                data = data[key];\n            }\n        }\n        return data;\n    }\n    catch (error) {\n        if (error instanceof TypeError) {\n            return defaultValue;\n        }\n        throw error;\n    }\n}\n/**\n * Moves values from source paths to destination paths.\n *\n * Examples:\n *   moveValueByPath(\n *     {'requests': [{'content': v1}, {'content': v2}]},\n *     {'requests[].*': 'requests[].request.*'}\n *   )\n *     -> {'requests': [{'request': {'content': v1}}, {'request': {'content': v2}}]}\n */\nfunction moveValueByPath(data, paths) {\n    for (const [sourcePath, destPath] of Object.entries(paths)) {\n        const sourceKeys = sourcePath.split('.');\n        const destKeys = destPath.split('.');\n        // Determine keys to exclude from wildcard to avoid cyclic references\n        const excludeKeys = new Set();\n        let wildcardIdx = -1;\n        for (let i = 0; i < sourceKeys.length; i++) {\n            if (sourceKeys[i] === '*') {\n                wildcardIdx = i;\n                break;\n            }\n        }\n        if (wildcardIdx !== -1 && destKeys.length > wildcardIdx) {\n            // Extract the intermediate key between source and dest paths\n            // Example: source=['requests[]', '*'], dest=['requests[]', 'request', '*']\n            // We want to exclude 'request'\n            for (let i = wildcardIdx; i < destKeys.length; i++) {\n                const key = destKeys[i];\n                if (key !== '*' && !key.endsWith('[]') && !key.endsWith('[0]')) {\n                    excludeKeys.add(key);\n                }\n            }\n        }\n        _moveValueRecursive(data, sourceKeys, destKeys, 0, excludeKeys);\n    }\n}\n/**\n * Recursively moves values from source path to destination path.\n */\nfunction _moveValueRecursive(data, sourceKeys, destKeys, keyIdx, excludeKeys) {\n    if (keyIdx >= sourceKeys.length) {\n        return;\n    }\n    if (typeof data !== 'object' || data === null) {\n        return;\n    }\n    const key = sourceKeys[keyIdx];\n    if (key.endsWith('[]')) {\n        const keyName = key.slice(0, -2);\n        const dataRecord = data;\n        if (keyName in dataRecord && Array.isArray(dataRecord[keyName])) {\n            for (const item of dataRecord[keyName]) {\n                _moveValueRecursive(item, sourceKeys, destKeys, keyIdx + 1, excludeKeys);\n            }\n        }\n    }\n    else if (key === '*') {\n        // wildcard - move all fields\n        if (typeof data === 'object' && data !== null && !Array.isArray(data)) {\n            const dataRecord = data;\n            const keysToMove = Object.keys(dataRecord).filter((k) => !k.startsWith('_') && !excludeKeys.has(k));\n            const valuesToMove = {};\n            for (const k of keysToMove) {\n                valuesToMove[k] = dataRecord[k];\n            }\n            // Set values at destination\n            for (const [k, v] of Object.entries(valuesToMove)) {\n                const newDestKeys = [];\n                for (const dk of destKeys.slice(keyIdx)) {\n                    if (dk === '*') {\n                        newDestKeys.push(k);\n                    }\n                    else {\n                        newDestKeys.push(dk);\n                    }\n                }\n                setValueByPath(dataRecord, newDestKeys, v);\n            }\n            for (const k of keysToMove) {\n                delete dataRecord[k];\n            }\n        }\n    }\n    else {\n        // Navigate to next level\n        const dataRecord = data;\n        if (key in dataRecord) {\n            _moveValueRecursive(dataRecord[key], sourceKeys, destKeys, keyIdx + 1, excludeKeys);\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nfunction tBytes$1(fromBytes) {\n    if (typeof fromBytes !== 'string') {\n        throw new Error('fromImageBytes must be a string');\n    }\n    // TODO(b/389133914): Remove dummy bytes converter.\n    return fromBytes;\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n// Code generated by the Google Gen AI SDK generator DO NOT EDIT.\nfunction fetchPredictOperationParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromOperationName = getValueByPath(fromObject, [\n        'operationName',\n    ]);\n    if (fromOperationName != null) {\n        setValueByPath(toObject, ['operationName'], fromOperationName);\n    }\n    const fromResourceName = getValueByPath(fromObject, ['resourceName']);\n    if (fromResourceName != null) {\n        setValueByPath(toObject, ['_url', 'resourceName'], fromResourceName);\n    }\n    return toObject;\n}\nfunction generateVideosOperationFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, ['metadata']);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, ['metadata'], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, ['done']);\n    if (fromDone != null) {\n        setValueByPath(toObject, ['done'], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, ['error']);\n    if (fromError != null) {\n        setValueByPath(toObject, ['error'], fromError);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        'response',\n        'generateVideoResponse',\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, ['response'], generateVideosResponseFromMldev$1(fromResponse));\n    }\n    return toObject;\n}\nfunction generateVideosOperationFromVertex$1(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, ['metadata']);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, ['metadata'], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, ['done']);\n    if (fromDone != null) {\n        setValueByPath(toObject, ['done'], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, ['error']);\n    if (fromError != null) {\n        setValueByPath(toObject, ['error'], fromError);\n    }\n    const fromResponse = getValueByPath(fromObject, ['response']);\n    if (fromResponse != null) {\n        setValueByPath(toObject, ['response'], generateVideosResponseFromVertex$1(fromResponse));\n    }\n    return toObject;\n}\nfunction generateVideosResponseFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromGeneratedVideos = getValueByPath(fromObject, [\n        'generatedSamples',\n    ]);\n    if (fromGeneratedVideos != null) {\n        let transformedList = fromGeneratedVideos;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return generatedVideoFromMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, ['generatedVideos'], transformedList);\n    }\n    const fromRaiMediaFilteredCount = getValueByPath(fromObject, [\n        'raiMediaFilteredCount',\n    ]);\n    if (fromRaiMediaFilteredCount != null) {\n        setValueByPath(toObject, ['raiMediaFilteredCount'], fromRaiMediaFilteredCount);\n    }\n    const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [\n        'raiMediaFilteredReasons',\n    ]);\n    if (fromRaiMediaFilteredReasons != null) {\n        setValueByPath(toObject, ['raiMediaFilteredReasons'], fromRaiMediaFilteredReasons);\n    }\n    return toObject;\n}\nfunction generateVideosResponseFromVertex$1(fromObject) {\n    const toObject = {};\n    const fromGeneratedVideos = getValueByPath(fromObject, ['videos']);\n    if (fromGeneratedVideos != null) {\n        let transformedList = fromGeneratedVideos;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return generatedVideoFromVertex$1(item);\n            });\n        }\n        setValueByPath(toObject, ['generatedVideos'], transformedList);\n    }\n    const fromRaiMediaFilteredCount = getValueByPath(fromObject, [\n        'raiMediaFilteredCount',\n    ]);\n    if (fromRaiMediaFilteredCount != null) {\n        setValueByPath(toObject, ['raiMediaFilteredCount'], fromRaiMediaFilteredCount);\n    }\n    const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [\n        'raiMediaFilteredReasons',\n    ]);\n    if (fromRaiMediaFilteredReasons != null) {\n        setValueByPath(toObject, ['raiMediaFilteredReasons'], fromRaiMediaFilteredReasons);\n    }\n    return toObject;\n}\nfunction generatedVideoFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromVideo = getValueByPath(fromObject, ['video']);\n    if (fromVideo != null) {\n        setValueByPath(toObject, ['video'], videoFromMldev$1(fromVideo));\n    }\n    return toObject;\n}\nfunction generatedVideoFromVertex$1(fromObject) {\n    const toObject = {};\n    const fromVideo = getValueByPath(fromObject, ['_self']);\n    if (fromVideo != null) {\n        setValueByPath(toObject, ['video'], videoFromVertex$1(fromVideo));\n    }\n    return toObject;\n}\nfunction getOperationParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromOperationName = getValueByPath(fromObject, [\n        'operationName',\n    ]);\n    if (fromOperationName != null) {\n        setValueByPath(toObject, ['_url', 'operationName'], fromOperationName);\n    }\n    return toObject;\n}\nfunction getOperationParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromOperationName = getValueByPath(fromObject, [\n        'operationName',\n    ]);\n    if (fromOperationName != null) {\n        setValueByPath(toObject, ['_url', 'operationName'], fromOperationName);\n    }\n    return toObject;\n}\nfunction importFileOperationFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, ['metadata']);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, ['metadata'], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, ['done']);\n    if (fromDone != null) {\n        setValueByPath(toObject, ['done'], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, ['error']);\n    if (fromError != null) {\n        setValueByPath(toObject, ['error'], fromError);\n    }\n    const fromResponse = getValueByPath(fromObject, ['response']);\n    if (fromResponse != null) {\n        setValueByPath(toObject, ['response'], importFileResponseFromMldev$1(fromResponse));\n    }\n    return toObject;\n}\nfunction importFileResponseFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromParent = getValueByPath(fromObject, ['parent']);\n    if (fromParent != null) {\n        setValueByPath(toObject, ['parent'], fromParent);\n    }\n    const fromDocumentName = getValueByPath(fromObject, ['documentName']);\n    if (fromDocumentName != null) {\n        setValueByPath(toObject, ['documentName'], fromDocumentName);\n    }\n    return toObject;\n}\nfunction uploadToFileSearchStoreOperationFromMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, ['metadata']);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, ['metadata'], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, ['done']);\n    if (fromDone != null) {\n        setValueByPath(toObject, ['done'], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, ['error']);\n    if (fromError != null) {\n        setValueByPath(toObject, ['error'], fromError);\n    }\n    const fromResponse = getValueByPath(fromObject, ['response']);\n    if (fromResponse != null) {\n        setValueByPath(toObject, ['response'], uploadToFileSearchStoreResponseFromMldev(fromResponse));\n    }\n    return toObject;\n}\nfunction uploadToFileSearchStoreResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromParent = getValueByPath(fromObject, ['parent']);\n    if (fromParent != null) {\n        setValueByPath(toObject, ['parent'], fromParent);\n    }\n    const fromDocumentName = getValueByPath(fromObject, ['documentName']);\n    if (fromDocumentName != null) {\n        setValueByPath(toObject, ['documentName'], fromDocumentName);\n    }\n    return toObject;\n}\nfunction videoFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromUri = getValueByPath(fromObject, ['uri']);\n    if (fromUri != null) {\n        setValueByPath(toObject, ['uri'], fromUri);\n    }\n    const fromVideoBytes = getValueByPath(fromObject, ['encodedVideo']);\n    if (fromVideoBytes != null) {\n        setValueByPath(toObject, ['videoBytes'], tBytes$1(fromVideoBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, ['encoding']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction videoFromVertex$1(fromObject) {\n    const toObject = {};\n    const fromUri = getValueByPath(fromObject, ['gcsUri']);\n    if (fromUri != null) {\n        setValueByPath(toObject, ['uri'], fromUri);\n    }\n    const fromVideoBytes = getValueByPath(fromObject, [\n        'bytesBase64Encoded',\n    ]);\n    if (fromVideoBytes != null) {\n        setValueByPath(toObject, ['videoBytes'], tBytes$1(fromVideoBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n/** Outcome of the code execution. */\nvar Outcome;\n(function (Outcome) {\n    /**\n     * Unspecified status. This value should not be used.\n     */\n    Outcome[\"OUTCOME_UNSPECIFIED\"] = \"OUTCOME_UNSPECIFIED\";\n    /**\n     * Code execution completed successfully.\n     */\n    Outcome[\"OUTCOME_OK\"] = \"OUTCOME_OK\";\n    /**\n     * Code execution finished but with a failure. `stderr` should contain the reason.\n     */\n    Outcome[\"OUTCOME_FAILED\"] = \"OUTCOME_FAILED\";\n    /**\n     * Code execution ran for too long, and was cancelled. There may or may not be a partial output present.\n     */\n    Outcome[\"OUTCOME_DEADLINE_EXCEEDED\"] = \"OUTCOME_DEADLINE_EXCEEDED\";\n})(Outcome || (Outcome = {}));\n/** Programming language of the `code`. */\nvar Language;\n(function (Language) {\n    /**\n     * Unspecified language. This value should not be used.\n     */\n    Language[\"LANGUAGE_UNSPECIFIED\"] = \"LANGUAGE_UNSPECIFIED\";\n    /**\n     * Python >= 3.10, with numpy and simpy available.\n     */\n    Language[\"PYTHON\"] = \"PYTHON\";\n})(Language || (Language = {}));\n/** Specifies how the response should be scheduled in the conversation. */\nvar FunctionResponseScheduling;\n(function (FunctionResponseScheduling) {\n    /**\n     * This value is unused.\n     */\n    FunctionResponseScheduling[\"SCHEDULING_UNSPECIFIED\"] = \"SCHEDULING_UNSPECIFIED\";\n    /**\n     * Only add the result to the conversation context, do not interrupt or trigger generation.\n     */\n    FunctionResponseScheduling[\"SILENT\"] = \"SILENT\";\n    /**\n     * Add the result to the conversation context, and prompt to generate output without interrupting ongoing generation.\n     */\n    FunctionResponseScheduling[\"WHEN_IDLE\"] = \"WHEN_IDLE\";\n    /**\n     * Add the result to the conversation context, interrupt ongoing generation and prompt to generate output.\n     */\n    FunctionResponseScheduling[\"INTERRUPT\"] = \"INTERRUPT\";\n})(FunctionResponseScheduling || (FunctionResponseScheduling = {}));\n/** The type of the data. */\nvar Type;\n(function (Type) {\n    /**\n     * Not specified, should not be used.\n     */\n    Type[\"TYPE_UNSPECIFIED\"] = \"TYPE_UNSPECIFIED\";\n    /**\n     * OpenAPI string type\n     */\n    Type[\"STRING\"] = \"STRING\";\n    /**\n     * OpenAPI number type\n     */\n    Type[\"NUMBER\"] = \"NUMBER\";\n    /**\n     * OpenAPI integer type\n     */\n    Type[\"INTEGER\"] = \"INTEGER\";\n    /**\n     * OpenAPI boolean type\n     */\n    Type[\"BOOLEAN\"] = \"BOOLEAN\";\n    /**\n     * OpenAPI array type\n     */\n    Type[\"ARRAY\"] = \"ARRAY\";\n    /**\n     * OpenAPI object type\n     */\n    Type[\"OBJECT\"] = \"OBJECT\";\n    /**\n     * Null type\n     */\n    Type[\"NULL\"] = \"NULL\";\n})(Type || (Type = {}));\n/** The mode of the predictor to be used in dynamic retrieval. */\nvar Mode;\n(function (Mode) {\n    /**\n     * Always trigger retrieval.\n     */\n    Mode[\"MODE_UNSPECIFIED\"] = \"MODE_UNSPECIFIED\";\n    /**\n     * Run retrieval only when system decides it is necessary.\n     */\n    Mode[\"MODE_DYNAMIC\"] = \"MODE_DYNAMIC\";\n})(Mode || (Mode = {}));\n/** The API spec that the external API implements. This enum is not supported in Gemini API. */\nvar ApiSpec;\n(function (ApiSpec) {\n    /**\n     * Unspecified API spec. This value should not be used.\n     */\n    ApiSpec[\"API_SPEC_UNSPECIFIED\"] = \"API_SPEC_UNSPECIFIED\";\n    /**\n     * Simple search API spec.\n     */\n    ApiSpec[\"SIMPLE_SEARCH\"] = \"SIMPLE_SEARCH\";\n    /**\n     * Elastic search API spec.\n     */\n    ApiSpec[\"ELASTIC_SEARCH\"] = \"ELASTIC_SEARCH\";\n})(ApiSpec || (ApiSpec = {}));\n/** Type of auth scheme. This enum is not supported in Gemini API. */\nvar AuthType;\n(function (AuthType) {\n    AuthType[\"AUTH_TYPE_UNSPECIFIED\"] = \"AUTH_TYPE_UNSPECIFIED\";\n    /**\n     * No Auth.\n     */\n    AuthType[\"NO_AUTH\"] = \"NO_AUTH\";\n    /**\n     * API Key Auth.\n     */\n    AuthType[\"API_KEY_AUTH\"] = \"API_KEY_AUTH\";\n    /**\n     * HTTP Basic Auth.\n     */\n    AuthType[\"HTTP_BASIC_AUTH\"] = \"HTTP_BASIC_AUTH\";\n    /**\n     * Google Service Account Auth.\n     */\n    AuthType[\"GOOGLE_SERVICE_ACCOUNT_AUTH\"] = \"GOOGLE_SERVICE_ACCOUNT_AUTH\";\n    /**\n     * OAuth auth.\n     */\n    AuthType[\"OAUTH\"] = \"OAUTH\";\n    /**\n     * OpenID Connect (OIDC) Auth.\n     */\n    AuthType[\"OIDC_AUTH\"] = \"OIDC_AUTH\";\n})(AuthType || (AuthType = {}));\n/** The location of the API key. This enum is not supported in Gemini API. */\nvar HttpElementLocation;\n(function (HttpElementLocation) {\n    HttpElementLocation[\"HTTP_IN_UNSPECIFIED\"] = \"HTTP_IN_UNSPECIFIED\";\n    /**\n     * Element is in the HTTP request query.\n     */\n    HttpElementLocation[\"HTTP_IN_QUERY\"] = \"HTTP_IN_QUERY\";\n    /**\n     * Element is in the HTTP request header.\n     */\n    HttpElementLocation[\"HTTP_IN_HEADER\"] = \"HTTP_IN_HEADER\";\n    /**\n     * Element is in the HTTP request path.\n     */\n    HttpElementLocation[\"HTTP_IN_PATH\"] = \"HTTP_IN_PATH\";\n    /**\n     * Element is in the HTTP request body.\n     */\n    HttpElementLocation[\"HTTP_IN_BODY\"] = \"HTTP_IN_BODY\";\n    /**\n     * Element is in the HTTP request cookie.\n     */\n    HttpElementLocation[\"HTTP_IN_COOKIE\"] = \"HTTP_IN_COOKIE\";\n})(HttpElementLocation || (HttpElementLocation = {}));\n/** Sites with confidence level chosen & above this value will be blocked from the search results. This enum is not supported in Gemini API. */\nvar PhishBlockThreshold;\n(function (PhishBlockThreshold) {\n    /**\n     * Defaults to unspecified.\n     */\n    PhishBlockThreshold[\"PHISH_BLOCK_THRESHOLD_UNSPECIFIED\"] = \"PHISH_BLOCK_THRESHOLD_UNSPECIFIED\";\n    /**\n     * Blocks Low and above confidence URL that is risky.\n     */\n    PhishBlockThreshold[\"BLOCK_LOW_AND_ABOVE\"] = \"BLOCK_LOW_AND_ABOVE\";\n    /**\n     * Blocks Medium and above confidence URL that is risky.\n     */\n    PhishBlockThreshold[\"BLOCK_MEDIUM_AND_ABOVE\"] = \"BLOCK_MEDIUM_AND_ABOVE\";\n    /**\n     * Blocks High and above confidence URL that is risky.\n     */\n    PhishBlockThreshold[\"BLOCK_HIGH_AND_ABOVE\"] = \"BLOCK_HIGH_AND_ABOVE\";\n    /**\n     * Blocks Higher and above confidence URL that is risky.\n     */\n    PhishBlockThreshold[\"BLOCK_HIGHER_AND_ABOVE\"] = \"BLOCK_HIGHER_AND_ABOVE\";\n    /**\n     * Blocks Very high and above confidence URL that is risky.\n     */\n    PhishBlockThreshold[\"BLOCK_VERY_HIGH_AND_ABOVE\"] = \"BLOCK_VERY_HIGH_AND_ABOVE\";\n    /**\n     * Blocks Extremely high confidence URL that is risky.\n     */\n    PhishBlockThreshold[\"BLOCK_ONLY_EXTREMELY_HIGH\"] = \"BLOCK_ONLY_EXTREMELY_HIGH\";\n})(PhishBlockThreshold || (PhishBlockThreshold = {}));\n/** The level of thoughts tokens that the model should generate. */\nvar ThinkingLevel;\n(function (ThinkingLevel) {\n    /**\n     * Default value.\n     */\n    ThinkingLevel[\"THINKING_LEVEL_UNSPECIFIED\"] = \"THINKING_LEVEL_UNSPECIFIED\";\n    /**\n     * Low thinking level.\n     */\n    ThinkingLevel[\"LOW\"] = \"LOW\";\n    /**\n     * High thinking level.\n     */\n    ThinkingLevel[\"HIGH\"] = \"HIGH\";\n})(ThinkingLevel || (ThinkingLevel = {}));\n/** Harm category. */\nvar HarmCategory;\n(function (HarmCategory) {\n    /**\n     * The harm category is unspecified.\n     */\n    HarmCategory[\"HARM_CATEGORY_UNSPECIFIED\"] = \"HARM_CATEGORY_UNSPECIFIED\";\n    /**\n     * The harm category is harassment.\n     */\n    HarmCategory[\"HARM_CATEGORY_HARASSMENT\"] = \"HARM_CATEGORY_HARASSMENT\";\n    /**\n     * The harm category is hate speech.\n     */\n    HarmCategory[\"HARM_CATEGORY_HATE_SPEECH\"] = \"HARM_CATEGORY_HATE_SPEECH\";\n    /**\n     * The harm category is sexually explicit content.\n     */\n    HarmCategory[\"HARM_CATEGORY_SEXUALLY_EXPLICIT\"] = \"HARM_CATEGORY_SEXUALLY_EXPLICIT\";\n    /**\n     * The harm category is dangerous content.\n     */\n    HarmCategory[\"HARM_CATEGORY_DANGEROUS_CONTENT\"] = \"HARM_CATEGORY_DANGEROUS_CONTENT\";\n    /**\n     * Deprecated: Election filter is not longer supported. The harm category is civic integrity.\n     */\n    HarmCategory[\"HARM_CATEGORY_CIVIC_INTEGRITY\"] = \"HARM_CATEGORY_CIVIC_INTEGRITY\";\n    /**\n     * The harm category is image hate. This enum value is not supported in Gemini API.\n     */\n    HarmCategory[\"HARM_CATEGORY_IMAGE_HATE\"] = \"HARM_CATEGORY_IMAGE_HATE\";\n    /**\n     * The harm category is image dangerous content. This enum value is not supported in Gemini API.\n     */\n    HarmCategory[\"HARM_CATEGORY_IMAGE_DANGEROUS_CONTENT\"] = \"HARM_CATEGORY_IMAGE_DANGEROUS_CONTENT\";\n    /**\n     * The harm category is image harassment. This enum value is not supported in Gemini API.\n     */\n    HarmCategory[\"HARM_CATEGORY_IMAGE_HARASSMENT\"] = \"HARM_CATEGORY_IMAGE_HARASSMENT\";\n    /**\n     * The harm category is image sexually explicit content. This enum value is not supported in Gemini API.\n     */\n    HarmCategory[\"HARM_CATEGORY_IMAGE_SEXUALLY_EXPLICIT\"] = \"HARM_CATEGORY_IMAGE_SEXUALLY_EXPLICIT\";\n    /**\n     * The harm category is for jailbreak prompts. This enum value is not supported in Gemini API.\n     */\n    HarmCategory[\"HARM_CATEGORY_JAILBREAK\"] = \"HARM_CATEGORY_JAILBREAK\";\n})(HarmCategory || (HarmCategory = {}));\n/** Specify if the threshold is used for probability or severity score. If not specified, the threshold is used for probability score. This enum is not supported in Gemini API. */\nvar HarmBlockMethod;\n(function (HarmBlockMethod) {\n    /**\n     * The harm block method is unspecified.\n     */\n    HarmBlockMethod[\"HARM_BLOCK_METHOD_UNSPECIFIED\"] = \"HARM_BLOCK_METHOD_UNSPECIFIED\";\n    /**\n     * The harm block method uses both probability and severity scores.\n     */\n    HarmBlockMethod[\"SEVERITY\"] = \"SEVERITY\";\n    /**\n     * The harm block method uses the probability score.\n     */\n    HarmBlockMethod[\"PROBABILITY\"] = \"PROBABILITY\";\n})(HarmBlockMethod || (HarmBlockMethod = {}));\n/** The harm block threshold. */\nvar HarmBlockThreshold;\n(function (HarmBlockThreshold) {\n    /**\n     * Unspecified harm block threshold.\n     */\n    HarmBlockThreshold[\"HARM_BLOCK_THRESHOLD_UNSPECIFIED\"] = \"HARM_BLOCK_THRESHOLD_UNSPECIFIED\";\n    /**\n     * Block low threshold and above (i.e. block more).\n     */\n    HarmBlockThreshold[\"BLOCK_LOW_AND_ABOVE\"] = \"BLOCK_LOW_AND_ABOVE\";\n    /**\n     * Block medium threshold and above.\n     */\n    HarmBlockThreshold[\"BLOCK_MEDIUM_AND_ABOVE\"] = \"BLOCK_MEDIUM_AND_ABOVE\";\n    /**\n     * Block only high threshold (i.e. block less).\n     */\n    HarmBlockThreshold[\"BLOCK_ONLY_HIGH\"] = \"BLOCK_ONLY_HIGH\";\n    /**\n     * Block none.\n     */\n    HarmBlockThreshold[\"BLOCK_NONE\"] = \"BLOCK_NONE\";\n    /**\n     * Turn off the safety filter.\n     */\n    HarmBlockThreshold[\"OFF\"] = \"OFF\";\n})(HarmBlockThreshold || (HarmBlockThreshold = {}));\n/** Output only. The reason why the model stopped generating tokens.\n\nIf empty, the model has not stopped generating the tokens. */\nvar FinishReason;\n(function (FinishReason) {\n    /**\n     * The finish reason is unspecified.\n     */\n    FinishReason[\"FINISH_REASON_UNSPECIFIED\"] = \"FINISH_REASON_UNSPECIFIED\";\n    /**\n     * Token generation reached a natural stopping point or a configured stop sequence.\n     */\n    FinishReason[\"STOP\"] = \"STOP\";\n    /**\n     * Token generation reached the configured maximum output tokens.\n     */\n    FinishReason[\"MAX_TOKENS\"] = \"MAX_TOKENS\";\n    /**\n     * Token generation stopped because the content potentially contains safety violations. NOTE: When streaming, [content][] is empty if content filters blocks the output.\n     */\n    FinishReason[\"SAFETY\"] = \"SAFETY\";\n    /**\n     * The token generation stopped because of potential recitation.\n     */\n    FinishReason[\"RECITATION\"] = \"RECITATION\";\n    /**\n     * The token generation stopped because of using an unsupported language.\n     */\n    FinishReason[\"LANGUAGE\"] = \"LANGUAGE\";\n    /**\n     * All other reasons that stopped the token generation.\n     */\n    FinishReason[\"OTHER\"] = \"OTHER\";\n    /**\n     * Token generation stopped because the content contains forbidden terms.\n     */\n    FinishReason[\"BLOCKLIST\"] = \"BLOCKLIST\";\n    /**\n     * Token generation stopped for potentially containing prohibited content.\n     */\n    FinishReason[\"PROHIBITED_CONTENT\"] = \"PROHIBITED_CONTENT\";\n    /**\n     * Token generation stopped because the content potentially contains Sensitive Personally Identifiable Information (SPII).\n     */\n    FinishReason[\"SPII\"] = \"SPII\";\n    /**\n     * The function call generated by the model is invalid.\n     */\n    FinishReason[\"MALFORMED_FUNCTION_CALL\"] = \"MALFORMED_FUNCTION_CALL\";\n    /**\n     * Token generation stopped because generated images have safety violations.\n     */\n    FinishReason[\"IMAGE_SAFETY\"] = \"IMAGE_SAFETY\";\n    /**\n     * The tool call generated by the model is invalid.\n     */\n    FinishReason[\"UNEXPECTED_TOOL_CALL\"] = \"UNEXPECTED_TOOL_CALL\";\n    /**\n     * Image generation stopped because the generated images have prohibited content.\n     */\n    FinishReason[\"IMAGE_PROHIBITED_CONTENT\"] = \"IMAGE_PROHIBITED_CONTENT\";\n    /**\n     * The model was expected to generate an image, but none was generated.\n     */\n    FinishReason[\"NO_IMAGE\"] = \"NO_IMAGE\";\n})(FinishReason || (FinishReason = {}));\n/** Output only. Harm probability levels in the content. */\nvar HarmProbability;\n(function (HarmProbability) {\n    /**\n     * Harm probability unspecified.\n     */\n    HarmProbability[\"HARM_PROBABILITY_UNSPECIFIED\"] = \"HARM_PROBABILITY_UNSPECIFIED\";\n    /**\n     * Negligible level of harm.\n     */\n    HarmProbability[\"NEGLIGIBLE\"] = \"NEGLIGIBLE\";\n    /**\n     * Low level of harm.\n     */\n    HarmProbability[\"LOW\"] = \"LOW\";\n    /**\n     * Medium level of harm.\n     */\n    HarmProbability[\"MEDIUM\"] = \"MEDIUM\";\n    /**\n     * High level of harm.\n     */\n    HarmProbability[\"HIGH\"] = \"HIGH\";\n})(HarmProbability || (HarmProbability = {}));\n/** Output only. Harm severity levels in the content. This enum is not supported in Gemini API. */\nvar HarmSeverity;\n(function (HarmSeverity) {\n    /**\n     * Harm severity unspecified.\n     */\n    HarmSeverity[\"HARM_SEVERITY_UNSPECIFIED\"] = \"HARM_SEVERITY_UNSPECIFIED\";\n    /**\n     * Negligible level of harm severity.\n     */\n    HarmSeverity[\"HARM_SEVERITY_NEGLIGIBLE\"] = \"HARM_SEVERITY_NEGLIGIBLE\";\n    /**\n     * Low level of harm severity.\n     */\n    HarmSeverity[\"HARM_SEVERITY_LOW\"] = \"HARM_SEVERITY_LOW\";\n    /**\n     * Medium level of harm severity.\n     */\n    HarmSeverity[\"HARM_SEVERITY_MEDIUM\"] = \"HARM_SEVERITY_MEDIUM\";\n    /**\n     * High level of harm severity.\n     */\n    HarmSeverity[\"HARM_SEVERITY_HIGH\"] = \"HARM_SEVERITY_HIGH\";\n})(HarmSeverity || (HarmSeverity = {}));\n/** Status of the url retrieval. */\nvar UrlRetrievalStatus;\n(function (UrlRetrievalStatus) {\n    /**\n     * Default value. This value is unused.\n     */\n    UrlRetrievalStatus[\"URL_RETRIEVAL_STATUS_UNSPECIFIED\"] = \"URL_RETRIEVAL_STATUS_UNSPECIFIED\";\n    /**\n     * Url retrieval is successful.\n     */\n    UrlRetrievalStatus[\"URL_RETRIEVAL_STATUS_SUCCESS\"] = \"URL_RETRIEVAL_STATUS_SUCCESS\";\n    /**\n     * Url retrieval is failed due to error.\n     */\n    UrlRetrievalStatus[\"URL_RETRIEVAL_STATUS_ERROR\"] = \"URL_RETRIEVAL_STATUS_ERROR\";\n    /**\n     * Url retrieval is failed because the content is behind paywall. This enum value is not supported in Vertex AI.\n     */\n    UrlRetrievalStatus[\"URL_RETRIEVAL_STATUS_PAYWALL\"] = \"URL_RETRIEVAL_STATUS_PAYWALL\";\n    /**\n     * Url retrieval is failed because the content is unsafe. This enum value is not supported in Vertex AI.\n     */\n    UrlRetrievalStatus[\"URL_RETRIEVAL_STATUS_UNSAFE\"] = \"URL_RETRIEVAL_STATUS_UNSAFE\";\n})(UrlRetrievalStatus || (UrlRetrievalStatus = {}));\n/** Output only. The reason why the prompt was blocked. */\nvar BlockedReason;\n(function (BlockedReason) {\n    /**\n     * The blocked reason is unspecified.\n     */\n    BlockedReason[\"BLOCKED_REASON_UNSPECIFIED\"] = \"BLOCKED_REASON_UNSPECIFIED\";\n    /**\n     * The prompt was blocked for safety reasons.\n     */\n    BlockedReason[\"SAFETY\"] = \"SAFETY\";\n    /**\n     * The prompt was blocked for other reasons. For example, it may be due to the prompt's language, or because it contains other harmful content.\n     */\n    BlockedReason[\"OTHER\"] = \"OTHER\";\n    /**\n     * The prompt was blocked because it contains a term from the terminology blocklist.\n     */\n    BlockedReason[\"BLOCKLIST\"] = \"BLOCKLIST\";\n    /**\n     * The prompt was blocked because it contains prohibited content.\n     */\n    BlockedReason[\"PROHIBITED_CONTENT\"] = \"PROHIBITED_CONTENT\";\n    /**\n     * The prompt was blocked because it contains content that is unsafe for image generation.\n     */\n    BlockedReason[\"IMAGE_SAFETY\"] = \"IMAGE_SAFETY\";\n    /**\n     * The prompt was blocked by Model Armor. This enum value is not supported in Gemini API.\n     */\n    BlockedReason[\"MODEL_ARMOR\"] = \"MODEL_ARMOR\";\n    /**\n     * The prompt was blocked as a jailbreak attempt. This enum value is not supported in Gemini API.\n     */\n    BlockedReason[\"JAILBREAK\"] = \"JAILBREAK\";\n})(BlockedReason || (BlockedReason = {}));\n/** Output only. The traffic type for this request. This enum is not supported in Gemini API. */\nvar TrafficType;\n(function (TrafficType) {\n    /**\n     * Unspecified request traffic type.\n     */\n    TrafficType[\"TRAFFIC_TYPE_UNSPECIFIED\"] = \"TRAFFIC_TYPE_UNSPECIFIED\";\n    /**\n     * The request was processed using Pay-As-You-Go quota.\n     */\n    TrafficType[\"ON_DEMAND\"] = \"ON_DEMAND\";\n    /**\n     * Type for Provisioned Throughput traffic.\n     */\n    TrafficType[\"PROVISIONED_THROUGHPUT\"] = \"PROVISIONED_THROUGHPUT\";\n})(TrafficType || (TrafficType = {}));\n/** Server content modalities. */\nvar Modality;\n(function (Modality) {\n    /**\n     * The modality is unspecified.\n     */\n    Modality[\"MODALITY_UNSPECIFIED\"] = \"MODALITY_UNSPECIFIED\";\n    /**\n     * Indicates the model should return text\n     */\n    Modality[\"TEXT\"] = \"TEXT\";\n    /**\n     * Indicates the model should return images.\n     */\n    Modality[\"IMAGE\"] = \"IMAGE\";\n    /**\n     * Indicates the model should return audio.\n     */\n    Modality[\"AUDIO\"] = \"AUDIO\";\n})(Modality || (Modality = {}));\n/** The media resolution to use. */\nvar MediaResolution;\n(function (MediaResolution) {\n    /**\n     * Media resolution has not been set\n     */\n    MediaResolution[\"MEDIA_RESOLUTION_UNSPECIFIED\"] = \"MEDIA_RESOLUTION_UNSPECIFIED\";\n    /**\n     * Media resolution set to low (64 tokens).\n     */\n    MediaResolution[\"MEDIA_RESOLUTION_LOW\"] = \"MEDIA_RESOLUTION_LOW\";\n    /**\n     * Media resolution set to medium (256 tokens).\n     */\n    MediaResolution[\"MEDIA_RESOLUTION_MEDIUM\"] = \"MEDIA_RESOLUTION_MEDIUM\";\n    /**\n     * Media resolution set to high (zoomed reframing with 256 tokens).\n     */\n    MediaResolution[\"MEDIA_RESOLUTION_HIGH\"] = \"MEDIA_RESOLUTION_HIGH\";\n})(MediaResolution || (MediaResolution = {}));\n/** Tuning mode. This enum is not supported in Gemini API. */\nvar TuningMode;\n(function (TuningMode) {\n    /**\n     * Tuning mode is unspecified.\n     */\n    TuningMode[\"TUNING_MODE_UNSPECIFIED\"] = \"TUNING_MODE_UNSPECIFIED\";\n    /**\n     * Full fine-tuning mode.\n     */\n    TuningMode[\"TUNING_MODE_FULL\"] = \"TUNING_MODE_FULL\";\n    /**\n     * PEFT adapter tuning mode.\n     */\n    TuningMode[\"TUNING_MODE_PEFT_ADAPTER\"] = \"TUNING_MODE_PEFT_ADAPTER\";\n})(TuningMode || (TuningMode = {}));\n/** Adapter size for tuning. This enum is not supported in Gemini API. */\nvar AdapterSize;\n(function (AdapterSize) {\n    /**\n     * Adapter size is unspecified.\n     */\n    AdapterSize[\"ADAPTER_SIZE_UNSPECIFIED\"] = \"ADAPTER_SIZE_UNSPECIFIED\";\n    /**\n     * Adapter size 1.\n     */\n    AdapterSize[\"ADAPTER_SIZE_ONE\"] = \"ADAPTER_SIZE_ONE\";\n    /**\n     * Adapter size 2.\n     */\n    AdapterSize[\"ADAPTER_SIZE_TWO\"] = \"ADAPTER_SIZE_TWO\";\n    /**\n     * Adapter size 4.\n     */\n    AdapterSize[\"ADAPTER_SIZE_FOUR\"] = \"ADAPTER_SIZE_FOUR\";\n    /**\n     * Adapter size 8.\n     */\n    AdapterSize[\"ADAPTER_SIZE_EIGHT\"] = \"ADAPTER_SIZE_EIGHT\";\n    /**\n     * Adapter size 16.\n     */\n    AdapterSize[\"ADAPTER_SIZE_SIXTEEN\"] = \"ADAPTER_SIZE_SIXTEEN\";\n    /**\n     * Adapter size 32.\n     */\n    AdapterSize[\"ADAPTER_SIZE_THIRTY_TWO\"] = \"ADAPTER_SIZE_THIRTY_TWO\";\n})(AdapterSize || (AdapterSize = {}));\n/** Job state. */\nvar JobState;\n(function (JobState) {\n    /**\n     * The job state is unspecified.\n     */\n    JobState[\"JOB_STATE_UNSPECIFIED\"] = \"JOB_STATE_UNSPECIFIED\";\n    /**\n     * The job has been just created or resumed and processing has not yet begun.\n     */\n    JobState[\"JOB_STATE_QUEUED\"] = \"JOB_STATE_QUEUED\";\n    /**\n     * The service is preparing to run the job.\n     */\n    JobState[\"JOB_STATE_PENDING\"] = \"JOB_STATE_PENDING\";\n    /**\n     * The job is in progress.\n     */\n    JobState[\"JOB_STATE_RUNNING\"] = \"JOB_STATE_RUNNING\";\n    /**\n     * The job completed successfully.\n     */\n    JobState[\"JOB_STATE_SUCCEEDED\"] = \"JOB_STATE_SUCCEEDED\";\n    /**\n     * The job failed.\n     */\n    JobState[\"JOB_STATE_FAILED\"] = \"JOB_STATE_FAILED\";\n    /**\n     * The job is being cancelled. From this state the job may only go to either `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED` or `JOB_STATE_CANCELLED`.\n     */\n    JobState[\"JOB_STATE_CANCELLING\"] = \"JOB_STATE_CANCELLING\";\n    /**\n     * The job has been cancelled.\n     */\n    JobState[\"JOB_STATE_CANCELLED\"] = \"JOB_STATE_CANCELLED\";\n    /**\n     * The job has been stopped, and can be resumed.\n     */\n    JobState[\"JOB_STATE_PAUSED\"] = \"JOB_STATE_PAUSED\";\n    /**\n     * The job has expired.\n     */\n    JobState[\"JOB_STATE_EXPIRED\"] = \"JOB_STATE_EXPIRED\";\n    /**\n     * The job is being updated. Only jobs in the `JOB_STATE_RUNNING` state can be updated. After updating, the job goes back to the `JOB_STATE_RUNNING` state.\n     */\n    JobState[\"JOB_STATE_UPDATING\"] = \"JOB_STATE_UPDATING\";\n    /**\n     * The job is partially succeeded, some results may be missing due to errors.\n     */\n    JobState[\"JOB_STATE_PARTIALLY_SUCCEEDED\"] = \"JOB_STATE_PARTIALLY_SUCCEEDED\";\n})(JobState || (JobState = {}));\n/** The tuning task. Either I2V or T2V. This enum is not supported in Gemini API. */\nvar TuningTask;\n(function (TuningTask) {\n    /**\n     * Default value. This value is unused.\n     */\n    TuningTask[\"TUNING_TASK_UNSPECIFIED\"] = \"TUNING_TASK_UNSPECIFIED\";\n    /**\n     * Tuning task for image to video.\n     */\n    TuningTask[\"TUNING_TASK_I2V\"] = \"TUNING_TASK_I2V\";\n    /**\n     * Tuning task for text to video.\n     */\n    TuningTask[\"TUNING_TASK_T2V\"] = \"TUNING_TASK_T2V\";\n    /**\n     * Tuning task for reference to video.\n     */\n    TuningTask[\"TUNING_TASK_R2V\"] = \"TUNING_TASK_R2V\";\n})(TuningTask || (TuningTask = {}));\n/** The tokenization quality used for given media. */\nvar PartMediaResolutionLevel;\n(function (PartMediaResolutionLevel) {\n    /**\n     * Media resolution has not been set.\n     */\n    PartMediaResolutionLevel[\"MEDIA_RESOLUTION_UNSPECIFIED\"] = \"MEDIA_RESOLUTION_UNSPECIFIED\";\n    /**\n     * Media resolution set to low.\n     */\n    PartMediaResolutionLevel[\"MEDIA_RESOLUTION_LOW\"] = \"MEDIA_RESOLUTION_LOW\";\n    /**\n     * Media resolution set to medium.\n     */\n    PartMediaResolutionLevel[\"MEDIA_RESOLUTION_MEDIUM\"] = \"MEDIA_RESOLUTION_MEDIUM\";\n    /**\n     * Media resolution set to high.\n     */\n    PartMediaResolutionLevel[\"MEDIA_RESOLUTION_HIGH\"] = \"MEDIA_RESOLUTION_HIGH\";\n})(PartMediaResolutionLevel || (PartMediaResolutionLevel = {}));\n/** Options for feature selection preference. */\nvar FeatureSelectionPreference;\n(function (FeatureSelectionPreference) {\n    FeatureSelectionPreference[\"FEATURE_SELECTION_PREFERENCE_UNSPECIFIED\"] = \"FEATURE_SELECTION_PREFERENCE_UNSPECIFIED\";\n    FeatureSelectionPreference[\"PRIORITIZE_QUALITY\"] = \"PRIORITIZE_QUALITY\";\n    FeatureSelectionPreference[\"BALANCED\"] = \"BALANCED\";\n    FeatureSelectionPreference[\"PRIORITIZE_COST\"] = \"PRIORITIZE_COST\";\n})(FeatureSelectionPreference || (FeatureSelectionPreference = {}));\n/** Defines the function behavior. Defaults to `BLOCKING`. */\nvar Behavior;\n(function (Behavior) {\n    /**\n     * This value is unused.\n     */\n    Behavior[\"UNSPECIFIED\"] = \"UNSPECIFIED\";\n    /**\n     * If set, the system will wait to receive the function response before continuing the conversation.\n     */\n    Behavior[\"BLOCKING\"] = \"BLOCKING\";\n    /**\n     * If set, the system will not wait to receive the function response. Instead, it will attempt to handle function responses as they become available while maintaining the conversation between the user and the model.\n     */\n    Behavior[\"NON_BLOCKING\"] = \"NON_BLOCKING\";\n})(Behavior || (Behavior = {}));\n/** Config for the dynamic retrieval config mode. */\nvar DynamicRetrievalConfigMode;\n(function (DynamicRetrievalConfigMode) {\n    /**\n     * Always trigger retrieval.\n     */\n    DynamicRetrievalConfigMode[\"MODE_UNSPECIFIED\"] = \"MODE_UNSPECIFIED\";\n    /**\n     * Run retrieval only when system decides it is necessary.\n     */\n    DynamicRetrievalConfigMode[\"MODE_DYNAMIC\"] = \"MODE_DYNAMIC\";\n})(DynamicRetrievalConfigMode || (DynamicRetrievalConfigMode = {}));\n/** The environment being operated. */\nvar Environment;\n(function (Environment) {\n    /**\n     * Defaults to browser.\n     */\n    Environment[\"ENVIRONMENT_UNSPECIFIED\"] = \"ENVIRONMENT_UNSPECIFIED\";\n    /**\n     * Operates in a web browser.\n     */\n    Environment[\"ENVIRONMENT_BROWSER\"] = \"ENVIRONMENT_BROWSER\";\n})(Environment || (Environment = {}));\n/** Config for the function calling config mode. */\nvar FunctionCallingConfigMode;\n(function (FunctionCallingConfigMode) {\n    /**\n     * The function calling config mode is unspecified. Should not be used.\n     */\n    FunctionCallingConfigMode[\"MODE_UNSPECIFIED\"] = \"MODE_UNSPECIFIED\";\n    /**\n     * Default model behavior, model decides to predict either function calls or natural language response.\n     */\n    FunctionCallingConfigMode[\"AUTO\"] = \"AUTO\";\n    /**\n     * Model is constrained to always predicting function calls only. If \"allowed_function_names\" are set, the predicted function calls will be limited to any one of \"allowed_function_names\", else the predicted function calls will be any one of the provided \"function_declarations\".\n     */\n    FunctionCallingConfigMode[\"ANY\"] = \"ANY\";\n    /**\n     * Model will not predict any function calls. Model behavior is same as when not passing any function declarations.\n     */\n    FunctionCallingConfigMode[\"NONE\"] = \"NONE\";\n    /**\n     * Model decides to predict either a function call or a natural language response, but will validate function calls with constrained decoding. If \"allowed_function_names\" are set, the predicted function call will be limited to any one of \"allowed_function_names\", else the predicted function call will be any one of the provided \"function_declarations\".\n     */\n    FunctionCallingConfigMode[\"VALIDATED\"] = \"VALIDATED\";\n})(FunctionCallingConfigMode || (FunctionCallingConfigMode = {}));\n/** Enum that controls the safety filter level for objectionable content. */\nvar SafetyFilterLevel;\n(function (SafetyFilterLevel) {\n    SafetyFilterLevel[\"BLOCK_LOW_AND_ABOVE\"] = \"BLOCK_LOW_AND_ABOVE\";\n    SafetyFilterLevel[\"BLOCK_MEDIUM_AND_ABOVE\"] = \"BLOCK_MEDIUM_AND_ABOVE\";\n    SafetyFilterLevel[\"BLOCK_ONLY_HIGH\"] = \"BLOCK_ONLY_HIGH\";\n    SafetyFilterLevel[\"BLOCK_NONE\"] = \"BLOCK_NONE\";\n})(SafetyFilterLevel || (SafetyFilterLevel = {}));\n/** Enum that controls the generation of people. */\nvar PersonGeneration;\n(function (PersonGeneration) {\n    /**\n     * Block generation of images of people.\n     */\n    PersonGeneration[\"DONT_ALLOW\"] = \"DONT_ALLOW\";\n    /**\n     * Generate images of adults, but not children.\n     */\n    PersonGeneration[\"ALLOW_ADULT\"] = \"ALLOW_ADULT\";\n    /**\n     * Generate images that include adults and children.\n     */\n    PersonGeneration[\"ALLOW_ALL\"] = \"ALLOW_ALL\";\n})(PersonGeneration || (PersonGeneration = {}));\n/** Enum that specifies the language of the text in the prompt. */\nvar ImagePromptLanguage;\n(function (ImagePromptLanguage) {\n    /**\n     * Auto-detect the language.\n     */\n    ImagePromptLanguage[\"auto\"] = \"auto\";\n    /**\n     * English\n     */\n    ImagePromptLanguage[\"en\"] = \"en\";\n    /**\n     * Japanese\n     */\n    ImagePromptLanguage[\"ja\"] = \"ja\";\n    /**\n     * Korean\n     */\n    ImagePromptLanguage[\"ko\"] = \"ko\";\n    /**\n     * Hindi\n     */\n    ImagePromptLanguage[\"hi\"] = \"hi\";\n    /**\n     * Chinese\n     */\n    ImagePromptLanguage[\"zh\"] = \"zh\";\n    /**\n     * Portuguese\n     */\n    ImagePromptLanguage[\"pt\"] = \"pt\";\n    /**\n     * Spanish\n     */\n    ImagePromptLanguage[\"es\"] = \"es\";\n})(ImagePromptLanguage || (ImagePromptLanguage = {}));\n/** Enum representing the mask mode of a mask reference image. */\nvar MaskReferenceMode;\n(function (MaskReferenceMode) {\n    MaskReferenceMode[\"MASK_MODE_DEFAULT\"] = \"MASK_MODE_DEFAULT\";\n    MaskReferenceMode[\"MASK_MODE_USER_PROVIDED\"] = \"MASK_MODE_USER_PROVIDED\";\n    MaskReferenceMode[\"MASK_MODE_BACKGROUND\"] = \"MASK_MODE_BACKGROUND\";\n    MaskReferenceMode[\"MASK_MODE_FOREGROUND\"] = \"MASK_MODE_FOREGROUND\";\n    MaskReferenceMode[\"MASK_MODE_SEMANTIC\"] = \"MASK_MODE_SEMANTIC\";\n})(MaskReferenceMode || (MaskReferenceMode = {}));\n/** Enum representing the control type of a control reference image. */\nvar ControlReferenceType;\n(function (ControlReferenceType) {\n    ControlReferenceType[\"CONTROL_TYPE_DEFAULT\"] = \"CONTROL_TYPE_DEFAULT\";\n    ControlReferenceType[\"CONTROL_TYPE_CANNY\"] = \"CONTROL_TYPE_CANNY\";\n    ControlReferenceType[\"CONTROL_TYPE_SCRIBBLE\"] = \"CONTROL_TYPE_SCRIBBLE\";\n    ControlReferenceType[\"CONTROL_TYPE_FACE_MESH\"] = \"CONTROL_TYPE_FACE_MESH\";\n})(ControlReferenceType || (ControlReferenceType = {}));\n/** Enum representing the subject type of a subject reference image. */\nvar SubjectReferenceType;\n(function (SubjectReferenceType) {\n    SubjectReferenceType[\"SUBJECT_TYPE_DEFAULT\"] = \"SUBJECT_TYPE_DEFAULT\";\n    SubjectReferenceType[\"SUBJECT_TYPE_PERSON\"] = \"SUBJECT_TYPE_PERSON\";\n    SubjectReferenceType[\"SUBJECT_TYPE_ANIMAL\"] = \"SUBJECT_TYPE_ANIMAL\";\n    SubjectReferenceType[\"SUBJECT_TYPE_PRODUCT\"] = \"SUBJECT_TYPE_PRODUCT\";\n})(SubjectReferenceType || (SubjectReferenceType = {}));\n/** Enum representing the editing mode. */\nvar EditMode;\n(function (EditMode) {\n    EditMode[\"EDIT_MODE_DEFAULT\"] = \"EDIT_MODE_DEFAULT\";\n    EditMode[\"EDIT_MODE_INPAINT_REMOVAL\"] = \"EDIT_MODE_INPAINT_REMOVAL\";\n    EditMode[\"EDIT_MODE_INPAINT_INSERTION\"] = \"EDIT_MODE_INPAINT_INSERTION\";\n    EditMode[\"EDIT_MODE_OUTPAINT\"] = \"EDIT_MODE_OUTPAINT\";\n    EditMode[\"EDIT_MODE_CONTROLLED_EDITING\"] = \"EDIT_MODE_CONTROLLED_EDITING\";\n    EditMode[\"EDIT_MODE_STYLE\"] = \"EDIT_MODE_STYLE\";\n    EditMode[\"EDIT_MODE_BGSWAP\"] = \"EDIT_MODE_BGSWAP\";\n    EditMode[\"EDIT_MODE_PRODUCT_IMAGE\"] = \"EDIT_MODE_PRODUCT_IMAGE\";\n})(EditMode || (EditMode = {}));\n/** Enum that represents the segmentation mode. */\nvar SegmentMode;\n(function (SegmentMode) {\n    SegmentMode[\"FOREGROUND\"] = \"FOREGROUND\";\n    SegmentMode[\"BACKGROUND\"] = \"BACKGROUND\";\n    SegmentMode[\"PROMPT\"] = \"PROMPT\";\n    SegmentMode[\"SEMANTIC\"] = \"SEMANTIC\";\n    SegmentMode[\"INTERACTIVE\"] = \"INTERACTIVE\";\n})(SegmentMode || (SegmentMode = {}));\n/** Enum for the reference type of a video generation reference image. */\nvar VideoGenerationReferenceType;\n(function (VideoGenerationReferenceType) {\n    /**\n     * A reference image that provides assets to the generated video,\n        such as the scene, an object, a character, etc.\n     */\n    VideoGenerationReferenceType[\"ASSET\"] = \"ASSET\";\n    /**\n     * A reference image that provides aesthetics including colors,\n        lighting, texture, etc., to be used as the style of the generated video,\n        such as 'anime', 'photography', 'origami', etc.\n     */\n    VideoGenerationReferenceType[\"STYLE\"] = \"STYLE\";\n})(VideoGenerationReferenceType || (VideoGenerationReferenceType = {}));\n/** Enum for the mask mode of a video generation mask. */\nvar VideoGenerationMaskMode;\n(function (VideoGenerationMaskMode) {\n    /**\n     * The image mask contains a masked rectangular region which is\n        applied on the first frame of the input video. The object described in\n        the prompt is inserted into this region and will appear in subsequent\n        frames.\n     */\n    VideoGenerationMaskMode[\"INSERT\"] = \"INSERT\";\n    /**\n     * The image mask is used to determine an object in the\n        first video frame to track. This object is removed from the video.\n     */\n    VideoGenerationMaskMode[\"REMOVE\"] = \"REMOVE\";\n    /**\n     * The image mask is used to determine a region in the\n        video. Objects in this region will be removed.\n     */\n    VideoGenerationMaskMode[\"REMOVE_STATIC\"] = \"REMOVE_STATIC\";\n    /**\n     * The image mask contains a masked rectangular region where\n        the input video will go. The remaining area will be generated. Video\n        masks are not supported.\n     */\n    VideoGenerationMaskMode[\"OUTPAINT\"] = \"OUTPAINT\";\n})(VideoGenerationMaskMode || (VideoGenerationMaskMode = {}));\n/** Enum that controls the compression quality of the generated videos. */\nvar VideoCompressionQuality;\n(function (VideoCompressionQuality) {\n    /**\n     * Optimized video compression quality. This will produce videos\n        with a compressed, smaller file size.\n     */\n    VideoCompressionQuality[\"OPTIMIZED\"] = \"OPTIMIZED\";\n    /**\n     * Lossless video compression quality. This will produce videos\n        with a larger file size.\n     */\n    VideoCompressionQuality[\"LOSSLESS\"] = \"LOSSLESS\";\n})(VideoCompressionQuality || (VideoCompressionQuality = {}));\n/** Enum representing the tuning method. */\nvar TuningMethod;\n(function (TuningMethod) {\n    /**\n     * Supervised fine tuning.\n     */\n    TuningMethod[\"SUPERVISED_FINE_TUNING\"] = \"SUPERVISED_FINE_TUNING\";\n    /**\n     * Preference optimization tuning.\n     */\n    TuningMethod[\"PREFERENCE_TUNING\"] = \"PREFERENCE_TUNING\";\n})(TuningMethod || (TuningMethod = {}));\n/** State for the lifecycle of a Document. */\nvar DocumentState;\n(function (DocumentState) {\n    DocumentState[\"STATE_UNSPECIFIED\"] = \"STATE_UNSPECIFIED\";\n    DocumentState[\"STATE_PENDING\"] = \"STATE_PENDING\";\n    DocumentState[\"STATE_ACTIVE\"] = \"STATE_ACTIVE\";\n    DocumentState[\"STATE_FAILED\"] = \"STATE_FAILED\";\n})(DocumentState || (DocumentState = {}));\n/** State for the lifecycle of a File. */\nvar FileState;\n(function (FileState) {\n    FileState[\"STATE_UNSPECIFIED\"] = \"STATE_UNSPECIFIED\";\n    FileState[\"PROCESSING\"] = \"PROCESSING\";\n    FileState[\"ACTIVE\"] = \"ACTIVE\";\n    FileState[\"FAILED\"] = \"FAILED\";\n})(FileState || (FileState = {}));\n/** Source of the File. */\nvar FileSource;\n(function (FileSource) {\n    FileSource[\"SOURCE_UNSPECIFIED\"] = \"SOURCE_UNSPECIFIED\";\n    FileSource[\"UPLOADED\"] = \"UPLOADED\";\n    FileSource[\"GENERATED\"] = \"GENERATED\";\n})(FileSource || (FileSource = {}));\n/** The reason why the turn is complete. */\nvar TurnCompleteReason;\n(function (TurnCompleteReason) {\n    /**\n     * Default value. Reason is unspecified.\n     */\n    TurnCompleteReason[\"TURN_COMPLETE_REASON_UNSPECIFIED\"] = \"TURN_COMPLETE_REASON_UNSPECIFIED\";\n    /**\n     * The function call generated by the model is invalid.\n     */\n    TurnCompleteReason[\"MALFORMED_FUNCTION_CALL\"] = \"MALFORMED_FUNCTION_CALL\";\n    /**\n     * The response is rejected by the model.\n     */\n    TurnCompleteReason[\"RESPONSE_REJECTED\"] = \"RESPONSE_REJECTED\";\n    /**\n     * Needs more input from the user.\n     */\n    TurnCompleteReason[\"NEED_MORE_INPUT\"] = \"NEED_MORE_INPUT\";\n})(TurnCompleteReason || (TurnCompleteReason = {}));\n/** Server content modalities. */\nvar MediaModality;\n(function (MediaModality) {\n    /**\n     * The modality is unspecified.\n     */\n    MediaModality[\"MODALITY_UNSPECIFIED\"] = \"MODALITY_UNSPECIFIED\";\n    /**\n     * Plain text.\n     */\n    MediaModality[\"TEXT\"] = \"TEXT\";\n    /**\n     * Images.\n     */\n    MediaModality[\"IMAGE\"] = \"IMAGE\";\n    /**\n     * Video.\n     */\n    MediaModality[\"VIDEO\"] = \"VIDEO\";\n    /**\n     * Audio.\n     */\n    MediaModality[\"AUDIO\"] = \"AUDIO\";\n    /**\n     * Document, e.g. PDF.\n     */\n    MediaModality[\"DOCUMENT\"] = \"DOCUMENT\";\n})(MediaModality || (MediaModality = {}));\n/** Start of speech sensitivity. */\nvar StartSensitivity;\n(function (StartSensitivity) {\n    /**\n     * The default is START_SENSITIVITY_LOW.\n     */\n    StartSensitivity[\"START_SENSITIVITY_UNSPECIFIED\"] = \"START_SENSITIVITY_UNSPECIFIED\";\n    /**\n     * Automatic detection will detect the start of speech more often.\n     */\n    StartSensitivity[\"START_SENSITIVITY_HIGH\"] = \"START_SENSITIVITY_HIGH\";\n    /**\n     * Automatic detection will detect the start of speech less often.\n     */\n    StartSensitivity[\"START_SENSITIVITY_LOW\"] = \"START_SENSITIVITY_LOW\";\n})(StartSensitivity || (StartSensitivity = {}));\n/** End of speech sensitivity. */\nvar EndSensitivity;\n(function (EndSensitivity) {\n    /**\n     * The default is END_SENSITIVITY_LOW.\n     */\n    EndSensitivity[\"END_SENSITIVITY_UNSPECIFIED\"] = \"END_SENSITIVITY_UNSPECIFIED\";\n    /**\n     * Automatic detection ends speech more often.\n     */\n    EndSensitivity[\"END_SENSITIVITY_HIGH\"] = \"END_SENSITIVITY_HIGH\";\n    /**\n     * Automatic detection ends speech less often.\n     */\n    EndSensitivity[\"END_SENSITIVITY_LOW\"] = \"END_SENSITIVITY_LOW\";\n})(EndSensitivity || (EndSensitivity = {}));\n/** The different ways of handling user activity. */\nvar ActivityHandling;\n(function (ActivityHandling) {\n    /**\n     * If unspecified, the default behavior is `START_OF_ACTIVITY_INTERRUPTS`.\n     */\n    ActivityHandling[\"ACTIVITY_HANDLING_UNSPECIFIED\"] = \"ACTIVITY_HANDLING_UNSPECIFIED\";\n    /**\n     * If true, start of activity will interrupt the model's response (also called \"barge in\"). The model's current response will be cut-off in the moment of the interruption. This is the default behavior.\n     */\n    ActivityHandling[\"START_OF_ACTIVITY_INTERRUPTS\"] = \"START_OF_ACTIVITY_INTERRUPTS\";\n    /**\n     * The model's response will not be interrupted.\n     */\n    ActivityHandling[\"NO_INTERRUPTION\"] = \"NO_INTERRUPTION\";\n})(ActivityHandling || (ActivityHandling = {}));\n/** Options about which input is included in the user's turn. */\nvar TurnCoverage;\n(function (TurnCoverage) {\n    /**\n     * If unspecified, the default behavior is `TURN_INCLUDES_ONLY_ACTIVITY`.\n     */\n    TurnCoverage[\"TURN_COVERAGE_UNSPECIFIED\"] = \"TURN_COVERAGE_UNSPECIFIED\";\n    /**\n     * The users turn only includes activity since the last turn, excluding inactivity (e.g. silence on the audio stream). This is the default behavior.\n     */\n    TurnCoverage[\"TURN_INCLUDES_ONLY_ACTIVITY\"] = \"TURN_INCLUDES_ONLY_ACTIVITY\";\n    /**\n     * The users turn includes all realtime input since the last turn, including inactivity (e.g. silence on the audio stream).\n     */\n    TurnCoverage[\"TURN_INCLUDES_ALL_INPUT\"] = \"TURN_INCLUDES_ALL_INPUT\";\n})(TurnCoverage || (TurnCoverage = {}));\n/** Scale of the generated music. */\nvar Scale;\n(function (Scale) {\n    /**\n     * Default value. This value is unused.\n     */\n    Scale[\"SCALE_UNSPECIFIED\"] = \"SCALE_UNSPECIFIED\";\n    /**\n     * C major or A minor.\n     */\n    Scale[\"C_MAJOR_A_MINOR\"] = \"C_MAJOR_A_MINOR\";\n    /**\n     * Db major or Bb minor.\n     */\n    Scale[\"D_FLAT_MAJOR_B_FLAT_MINOR\"] = \"D_FLAT_MAJOR_B_FLAT_MINOR\";\n    /**\n     * D major or B minor.\n     */\n    Scale[\"D_MAJOR_B_MINOR\"] = \"D_MAJOR_B_MINOR\";\n    /**\n     * Eb major or C minor\n     */\n    Scale[\"E_FLAT_MAJOR_C_MINOR\"] = \"E_FLAT_MAJOR_C_MINOR\";\n    /**\n     * E major or Db minor.\n     */\n    Scale[\"E_MAJOR_D_FLAT_MINOR\"] = \"E_MAJOR_D_FLAT_MINOR\";\n    /**\n     * F major or D minor.\n     */\n    Scale[\"F_MAJOR_D_MINOR\"] = \"F_MAJOR_D_MINOR\";\n    /**\n     * Gb major or Eb minor.\n     */\n    Scale[\"G_FLAT_MAJOR_E_FLAT_MINOR\"] = \"G_FLAT_MAJOR_E_FLAT_MINOR\";\n    /**\n     * G major or E minor.\n     */\n    Scale[\"G_MAJOR_E_MINOR\"] = \"G_MAJOR_E_MINOR\";\n    /**\n     * Ab major or F minor.\n     */\n    Scale[\"A_FLAT_MAJOR_F_MINOR\"] = \"A_FLAT_MAJOR_F_MINOR\";\n    /**\n     * A major or Gb minor.\n     */\n    Scale[\"A_MAJOR_G_FLAT_MINOR\"] = \"A_MAJOR_G_FLAT_MINOR\";\n    /**\n     * Bb major or G minor.\n     */\n    Scale[\"B_FLAT_MAJOR_G_MINOR\"] = \"B_FLAT_MAJOR_G_MINOR\";\n    /**\n     * B major or Ab minor.\n     */\n    Scale[\"B_MAJOR_A_FLAT_MINOR\"] = \"B_MAJOR_A_FLAT_MINOR\";\n})(Scale || (Scale = {}));\n/** The mode of music generation. */\nvar MusicGenerationMode;\n(function (MusicGenerationMode) {\n    /**\n     * Rely on the server default generation mode.\n     */\n    MusicGenerationMode[\"MUSIC_GENERATION_MODE_UNSPECIFIED\"] = \"MUSIC_GENERATION_MODE_UNSPECIFIED\";\n    /**\n     * Steer text prompts to regions of latent space with higher quality\n        music.\n     */\n    MusicGenerationMode[\"QUALITY\"] = \"QUALITY\";\n    /**\n     * Steer text prompts to regions of latent space with a larger\n        diversity of music.\n     */\n    MusicGenerationMode[\"DIVERSITY\"] = \"DIVERSITY\";\n    /**\n     * Steer text prompts to regions of latent space more likely to\n        generate music with vocals.\n     */\n    MusicGenerationMode[\"VOCALIZATION\"] = \"VOCALIZATION\";\n})(MusicGenerationMode || (MusicGenerationMode = {}));\n/** The playback control signal to apply to the music generation. */\nvar LiveMusicPlaybackControl;\n(function (LiveMusicPlaybackControl) {\n    /**\n     * This value is unused.\n     */\n    LiveMusicPlaybackControl[\"PLAYBACK_CONTROL_UNSPECIFIED\"] = \"PLAYBACK_CONTROL_UNSPECIFIED\";\n    /**\n     * Start generating the music.\n     */\n    LiveMusicPlaybackControl[\"PLAY\"] = \"PLAY\";\n    /**\n     * Hold the music generation. Use PLAY to resume from the current position.\n     */\n    LiveMusicPlaybackControl[\"PAUSE\"] = \"PAUSE\";\n    /**\n     * Stop the music generation and reset the context (prompts retained).\n        Use PLAY to restart the music generation.\n     */\n    LiveMusicPlaybackControl[\"STOP\"] = \"STOP\";\n    /**\n     * Reset the context of the music generation without stopping it.\n        Retains the current prompts and config.\n     */\n    LiveMusicPlaybackControl[\"RESET_CONTEXT\"] = \"RESET_CONTEXT\";\n})(LiveMusicPlaybackControl || (LiveMusicPlaybackControl = {}));\n/** Raw media bytes for function response.\n\nText should not be sent as raw bytes, use the FunctionResponse.response\nfield. */\nclass FunctionResponseBlob {\n}\n/** URI based data for function response. */\nclass FunctionResponseFileData {\n}\n/** A datatype containing media that is part of a `FunctionResponse` message.\n\nA `FunctionResponsePart` consists of data which has an associated datatype. A\n`FunctionResponsePart` can only contain one of the accepted types in\n`FunctionResponsePart.data`.\n\nA `FunctionResponsePart` must have a fixed IANA MIME type identifying the\ntype and subtype of the media if the `inline_data` field is filled with raw\nbytes. */\nclass FunctionResponsePart {\n}\n/**\n * Creates a `FunctionResponsePart` object from a `base64` encoded `string`.\n */\nfunction createFunctionResponsePartFromBase64(data, mimeType) {\n    return {\n        inlineData: {\n            data: data,\n            mimeType: mimeType,\n        },\n    };\n}\n/**\n * Creates a `FunctionResponsePart` object from a `URI` string.\n */\nfunction createFunctionResponsePartFromUri(uri, mimeType) {\n    return {\n        fileData: {\n            fileUri: uri,\n            mimeType: mimeType,\n        },\n    };\n}\n/** A function response. */\nclass FunctionResponse {\n}\n/**\n * Creates a `Part` object from a `URI` string.\n */\nfunction createPartFromUri(uri, mimeType, mediaResolution) {\n    return Object.assign({ fileData: {\n            fileUri: uri,\n            mimeType: mimeType,\n        } }, (mediaResolution && { mediaResolution: { level: mediaResolution } }));\n}\n/**\n * Creates a `Part` object from a `text` string.\n */\nfunction createPartFromText(text) {\n    return {\n        text: text,\n    };\n}\n/**\n * Creates a `Part` object from a `FunctionCall` object.\n */\nfunction createPartFromFunctionCall(name, args) {\n    return {\n        functionCall: {\n            name: name,\n            args: args,\n        },\n    };\n}\n/**\n * Creates a `Part` object from a `FunctionResponse` object.\n */\nfunction createPartFromFunctionResponse(id, name, response, parts = []) {\n    return {\n        functionResponse: Object.assign({ id: id, name: name, response: response }, (parts.length > 0 && { parts })),\n    };\n}\n/**\n * Creates a `Part` object from a `base64` encoded `string`.\n */\nfunction createPartFromBase64(data, mimeType, mediaResolution) {\n    return Object.assign({ inlineData: {\n            data: data,\n            mimeType: mimeType,\n        } }, (mediaResolution && { mediaResolution: { level: mediaResolution } }));\n}\n/**\n * Creates a `Part` object from the `outcome` and `output` of a `CodeExecutionResult` object.\n */\nfunction createPartFromCodeExecutionResult(outcome, output) {\n    return {\n        codeExecutionResult: {\n            outcome: outcome,\n            output: output,\n        },\n    };\n}\n/**\n * Creates a `Part` object from the `code` and `language` of an `ExecutableCode` object.\n */\nfunction createPartFromExecutableCode(code, language) {\n    return {\n        executableCode: {\n            code: code,\n            language: language,\n        },\n    };\n}\nfunction _isPart(obj) {\n    if (typeof obj === 'object' && obj !== null) {\n        return ('fileData' in obj ||\n            'text' in obj ||\n            'functionCall' in obj ||\n            'functionResponse' in obj ||\n            'inlineData' in obj ||\n            'videoMetadata' in obj ||\n            'codeExecutionResult' in obj ||\n            'executableCode' in obj);\n    }\n    return false;\n}\nfunction _toParts(partOrString) {\n    const parts = [];\n    if (typeof partOrString === 'string') {\n        parts.push(createPartFromText(partOrString));\n    }\n    else if (_isPart(partOrString)) {\n        parts.push(partOrString);\n    }\n    else if (Array.isArray(partOrString)) {\n        if (partOrString.length === 0) {\n            throw new Error('partOrString cannot be an empty array');\n        }\n        for (const part of partOrString) {\n            if (typeof part === 'string') {\n                parts.push(createPartFromText(part));\n            }\n            else if (_isPart(part)) {\n                parts.push(part);\n            }\n            else {\n                throw new Error('element in PartUnion must be a Part object or string');\n            }\n        }\n    }\n    else {\n        throw new Error('partOrString must be a Part object, string, or array');\n    }\n    return parts;\n}\n/**\n * Creates a `Content` object with a user role from a `PartListUnion` object or `string`.\n */\nfunction createUserContent(partOrString) {\n    return {\n        role: 'user',\n        parts: _toParts(partOrString),\n    };\n}\n/**\n * Creates a `Content` object with a model role from a `PartListUnion` object or `string`.\n */\nfunction createModelContent(partOrString) {\n    return {\n        role: 'model',\n        parts: _toParts(partOrString),\n    };\n}\n/** A wrapper class for the http response. */\nclass HttpResponse {\n    constructor(response) {\n        // Process the headers.\n        const headers = {};\n        for (const pair of response.headers.entries()) {\n            headers[pair[0]] = pair[1];\n        }\n        this.headers = headers;\n        // Keep the original response.\n        this.responseInternal = response;\n    }\n    json() {\n        return this.responseInternal.json();\n    }\n}\n/** Content filter results for a prompt sent in the request. Note: This is sent only in the first stream chunk and only if no candidates were generated due to content violations. */\nclass GenerateContentResponsePromptFeedback {\n}\n/** Usage metadata about the content generation request and response. This message provides a detailed breakdown of token usage and other relevant metrics. This data type is not supported in Gemini API. */\nclass GenerateContentResponseUsageMetadata {\n}\n/** Response message for PredictionService.GenerateContent. */\nclass GenerateContentResponse {\n    /**\n     * Returns the concatenation of all text parts from the first candidate in the response.\n     *\n     * @remarks\n     * If there are multiple candidates in the response, the text from the first\n     * one will be returned.\n     * If there are non-text parts in the response, the concatenation of all text\n     * parts will be returned, and a warning will be logged.\n     * If there are thought parts in the response, the concatenation of all text\n     * parts excluding the thought parts will be returned.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.generateContent({\n     *   model: 'gemini-2.0-flash',\n     *   contents:\n     *     'Why is the sky blue?',\n     * });\n     *\n     * console.debug(response.text);\n     * ```\n     */\n    get text() {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {\n            return undefined;\n        }\n        if (this.candidates && this.candidates.length > 1) {\n            console.warn('there are multiple candidates in the response, returning text from the first one.');\n        }\n        let text = '';\n        let anyTextPartText = false;\n        const nonTextParts = [];\n        for (const part of (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) !== null && _h !== void 0 ? _h : []) {\n            for (const [fieldName, fieldValue] of Object.entries(part)) {\n                if (fieldName !== 'text' &&\n                    fieldName !== 'thought' &&\n                    fieldName !== 'thoughtSignature' &&\n                    (fieldValue !== null || fieldValue !== undefined)) {\n                    nonTextParts.push(fieldName);\n                }\n            }\n            if (typeof part.text === 'string') {\n                if (typeof part.thought === 'boolean' && part.thought) {\n                    continue;\n                }\n                anyTextPartText = true;\n                text += part.text;\n            }\n        }\n        if (nonTextParts.length > 0) {\n            console.warn(`there are non-text parts ${nonTextParts} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`);\n        }\n        // part.text === '' is different from part.text is null\n        return anyTextPartText ? text : undefined;\n    }\n    /**\n     * Returns the concatenation of all inline data parts from the first candidate\n     * in the response.\n     *\n     * @remarks\n     * If there are multiple candidates in the response, the inline data from the\n     * first one will be returned. If there are non-inline data parts in the\n     * response, the concatenation of all inline data parts will be returned, and\n     * a warning will be logged.\n     */\n    get data() {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {\n            return undefined;\n        }\n        if (this.candidates && this.candidates.length > 1) {\n            console.warn('there are multiple candidates in the response, returning data from the first one.');\n        }\n        let data = '';\n        const nonDataParts = [];\n        for (const part of (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) !== null && _h !== void 0 ? _h : []) {\n            for (const [fieldName, fieldValue] of Object.entries(part)) {\n                if (fieldName !== 'inlineData' &&\n                    (fieldValue !== null || fieldValue !== undefined)) {\n                    nonDataParts.push(fieldName);\n                }\n            }\n            if (part.inlineData && typeof part.inlineData.data === 'string') {\n                data += atob(part.inlineData.data);\n            }\n        }\n        if (nonDataParts.length > 0) {\n            console.warn(`there are non-data parts ${nonDataParts} in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.`);\n        }\n        return data.length > 0 ? btoa(data) : undefined;\n    }\n    /**\n     * Returns the function calls from the first candidate in the response.\n     *\n     * @remarks\n     * If there are multiple candidates in the response, the function calls from\n     * the first one will be returned.\n     * If there are no function calls in the response, undefined will be returned.\n     *\n     * @example\n     * ```ts\n     * const controlLightFunctionDeclaration: FunctionDeclaration = {\n     *   name: 'controlLight',\n     *   parameters: {\n     *   type: Type.OBJECT,\n     *   description: 'Set the brightness and color temperature of a room light.',\n     *   properties: {\n     *     brightness: {\n     *       type: Type.NUMBER,\n     *       description:\n     *         'Light level from 0 to 100. Zero is off and 100 is full brightness.',\n     *     },\n     *     colorTemperature: {\n     *       type: Type.STRING,\n     *       description:\n     *         'Color temperature of the light fixture which can be `daylight`, `cool` or `warm`.',\n     *     },\n     *   },\n     *   required: ['brightness', 'colorTemperature'],\n     *  };\n     *  const response = await ai.models.generateContent({\n     *     model: 'gemini-2.0-flash',\n     *     contents: 'Dim the lights so the room feels cozy and warm.',\n     *     config: {\n     *       tools: [{functionDeclarations: [controlLightFunctionDeclaration]}],\n     *       toolConfig: {\n     *         functionCallingConfig: {\n     *           mode: FunctionCallingConfigMode.ANY,\n     *           allowedFunctionNames: ['controlLight'],\n     *         },\n     *       },\n     *     },\n     *   });\n     *  console.debug(JSON.stringify(response.functionCalls));\n     * ```\n     */\n    get functionCalls() {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {\n            return undefined;\n        }\n        if (this.candidates && this.candidates.length > 1) {\n            console.warn('there are multiple candidates in the response, returning function calls from the first one.');\n        }\n        const functionCalls = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part) => part.functionCall).map((part) => part.functionCall).filter((functionCall) => functionCall !== undefined);\n        if ((functionCalls === null || functionCalls === void 0 ? void 0 : functionCalls.length) === 0) {\n            return undefined;\n        }\n        return functionCalls;\n    }\n    /**\n     * Returns the first executable code from the first candidate in the response.\n     *\n     * @remarks\n     * If there are multiple candidates in the response, the executable code from\n     * the first one will be returned.\n     * If there are no executable code in the response, undefined will be\n     * returned.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.generateContent({\n     *   model: 'gemini-2.0-flash',\n     *   contents:\n     *     'What is the sum of the first 50 prime numbers? Generate and run code for the calculation, and make sure you get all 50.'\n     *   config: {\n     *     tools: [{codeExecution: {}}],\n     *   },\n     * });\n     *\n     * console.debug(response.executableCode);\n     * ```\n     */\n    get executableCode() {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {\n            return undefined;\n        }\n        if (this.candidates && this.candidates.length > 1) {\n            console.warn('there are multiple candidates in the response, returning executable code from the first one.');\n        }\n        const executableCode = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part) => part.executableCode).map((part) => part.executableCode).filter((executableCode) => executableCode !== undefined);\n        if ((executableCode === null || executableCode === void 0 ? void 0 : executableCode.length) === 0) {\n            return undefined;\n        }\n        return (_j = executableCode === null || executableCode === void 0 ? void 0 : executableCode[0]) === null || _j === void 0 ? void 0 : _j.code;\n    }\n    /**\n     * Returns the first code execution result from the first candidate in the response.\n     *\n     * @remarks\n     * If there are multiple candidates in the response, the code execution result from\n     * the first one will be returned.\n     * If there are no code execution result in the response, undefined will be returned.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.generateContent({\n     *   model: 'gemini-2.0-flash',\n     *   contents:\n     *     'What is the sum of the first 50 prime numbers? Generate and run code for the calculation, and make sure you get all 50.'\n     *   config: {\n     *     tools: [{codeExecution: {}}],\n     *   },\n     * });\n     *\n     * console.debug(response.codeExecutionResult);\n     * ```\n     */\n    get codeExecutionResult() {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {\n            return undefined;\n        }\n        if (this.candidates && this.candidates.length > 1) {\n            console.warn('there are multiple candidates in the response, returning code execution result from the first one.');\n        }\n        const codeExecutionResult = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part) => part.codeExecutionResult).map((part) => part.codeExecutionResult).filter((codeExecutionResult) => codeExecutionResult !== undefined);\n        if ((codeExecutionResult === null || codeExecutionResult === void 0 ? void 0 : codeExecutionResult.length) === 0) {\n            return undefined;\n        }\n        return (_j = codeExecutionResult === null || codeExecutionResult === void 0 ? void 0 : codeExecutionResult[0]) === null || _j === void 0 ? void 0 : _j.output;\n    }\n}\n/** Response for the embed_content method. */\nclass EmbedContentResponse {\n}\n/** The output images response. */\nclass GenerateImagesResponse {\n}\n/** Response for the request to edit an image. */\nclass EditImageResponse {\n}\nclass UpscaleImageResponse {\n}\n/** The output images response. */\nclass RecontextImageResponse {\n}\n/** The output images response. */\nclass SegmentImageResponse {\n}\nclass ListModelsResponse {\n}\nclass DeleteModelResponse {\n}\n/** Response for counting tokens. */\nclass CountTokensResponse {\n}\n/** Response for computing tokens. */\nclass ComputeTokensResponse {\n}\n/** Response with generated videos. */\nclass GenerateVideosResponse {\n}\n/** A video generation operation. */\nclass GenerateVideosOperation {\n    /**\n     * Instantiates an Operation of the same type as the one being called with the fields set from the API response.\n     * @internal\n     */\n    _fromAPIResponse({ apiResponse, _isVertexAI, }) {\n        const operation = new GenerateVideosOperation();\n        let response;\n        const op = apiResponse;\n        if (_isVertexAI) {\n            response = generateVideosOperationFromVertex$1(op);\n        }\n        else {\n            response = generateVideosOperationFromMldev$1(op);\n        }\n        Object.assign(operation, response);\n        return operation;\n    }\n}\n/** Response for the list tuning jobs method. */\nclass ListTuningJobsResponse {\n}\n/** Empty response for caches.delete method. */\nclass DeleteCachedContentResponse {\n}\nclass ListCachedContentsResponse {\n}\n/** Config for documents.list return value. */\nclass ListDocumentsResponse {\n}\n/** Config for file_search_stores.list return value. */\nclass ListFileSearchStoresResponse {\n}\n/** Response for the resumable upload method. */\nclass UploadToFileSearchStoreResumableResponse {\n}\n/** Response for ImportFile to import a File API file with a file search store. */\nclass ImportFileResponse {\n}\n/** Long-running operation for importing a file to a FileSearchStore. */\nclass ImportFileOperation {\n    /**\n     * Instantiates an Operation of the same type as the one being called with the fields set from the API response.\n     * @internal\n     */\n    _fromAPIResponse({ apiResponse, _isVertexAI, }) {\n        const operation = new ImportFileOperation();\n        const op = apiResponse;\n        const response = importFileOperationFromMldev$1(op);\n        Object.assign(operation, response);\n        return operation;\n    }\n}\n/** Response for the list files method. */\nclass ListFilesResponse {\n}\n/** Response for the create file method. */\nclass CreateFileResponse {\n}\n/** Response for the delete file method. */\nclass DeleteFileResponse {\n}\n/** Config for `inlined_responses` parameter. */\nclass InlinedResponse {\n}\n/** Config for `response` parameter. */\nclass SingleEmbedContentResponse {\n}\n/** Config for `inlined_embedding_responses` parameter. */\nclass InlinedEmbedContentResponse {\n}\n/** Config for batches.list return value. */\nclass ListBatchJobsResponse {\n}\n/** Represents a single response in a replay. */\nclass ReplayResponse {\n}\n/** A raw reference image.\n\nA raw reference image represents the base image to edit, provided by the user.\nIt can optionally be provided in addition to a mask reference image or\na style reference image. */\nclass RawReferenceImage {\n    /** Internal method to convert to ReferenceImageAPIInternal. */\n    toReferenceImageAPI() {\n        const referenceImageAPI = {\n            referenceType: 'REFERENCE_TYPE_RAW',\n            referenceImage: this.referenceImage,\n            referenceId: this.referenceId,\n        };\n        return referenceImageAPI;\n    }\n}\n/** A mask reference image.\n\nThis encapsulates either a mask image provided by the user and configs for\nthe user provided mask, or only config parameters for the model to generate\na mask.\n\nA mask image is an image whose non-zero values indicate where to edit the base\nimage. If the user provides a mask image, the mask must be in the same\ndimensions as the raw image. */\nclass MaskReferenceImage {\n    /** Internal method to convert to ReferenceImageAPIInternal. */\n    toReferenceImageAPI() {\n        const referenceImageAPI = {\n            referenceType: 'REFERENCE_TYPE_MASK',\n            referenceImage: this.referenceImage,\n            referenceId: this.referenceId,\n            maskImageConfig: this.config,\n        };\n        return referenceImageAPI;\n    }\n}\n/** A control reference image.\n\nThe image of the control reference image is either a control image provided\nby the user, or a regular image which the backend will use to generate a\ncontrol image of. In the case of the latter, the\nenable_control_image_computation field in the config should be set to True.\n\nA control image is an image that represents a sketch image of areas for the\nmodel to fill in based on the prompt. */\nclass ControlReferenceImage {\n    /** Internal method to convert to ReferenceImageAPIInternal. */\n    toReferenceImageAPI() {\n        const referenceImageAPI = {\n            referenceType: 'REFERENCE_TYPE_CONTROL',\n            referenceImage: this.referenceImage,\n            referenceId: this.referenceId,\n            controlImageConfig: this.config,\n        };\n        return referenceImageAPI;\n    }\n}\n/** A style reference image.\n\nThis encapsulates a style reference image provided by the user, and\nadditionally optional config parameters for the style reference image.\n\nA raw reference image can also be provided as a destination for the style to\nbe applied to. */\nclass StyleReferenceImage {\n    /** Internal method to convert to ReferenceImageAPIInternal. */\n    toReferenceImageAPI() {\n        const referenceImageAPI = {\n            referenceType: 'REFERENCE_TYPE_STYLE',\n            referenceImage: this.referenceImage,\n            referenceId: this.referenceId,\n            styleImageConfig: this.config,\n        };\n        return referenceImageAPI;\n    }\n}\n/** A subject reference image.\n\nThis encapsulates a subject reference image provided by the user, and\nadditionally optional config parameters for the subject reference image.\n\nA raw reference image can also be provided as a destination for the subject to\nbe applied to. */\nclass SubjectReferenceImage {\n    /* Internal method to convert to ReferenceImageAPIInternal. */\n    toReferenceImageAPI() {\n        const referenceImageAPI = {\n            referenceType: 'REFERENCE_TYPE_SUBJECT',\n            referenceImage: this.referenceImage,\n            referenceId: this.referenceId,\n            subjectImageConfig: this.config,\n        };\n        return referenceImageAPI;\n    }\n}\n/** A content reference image.\n\nA content reference image represents a subject to reference (ex. person,\nproduct, animal) provided by the user. It can optionally be provided in\naddition to a style reference image (ex. background, style reference). */\nclass ContentReferenceImage {\n    /** Internal method to convert to ReferenceImageAPIInternal. */\n    toReferenceImageAPI() {\n        const referenceImageAPI = {\n            referenceType: 'REFERENCE_TYPE_CONTENT',\n            referenceImage: this.referenceImage,\n            referenceId: this.referenceId,\n        };\n        return referenceImageAPI;\n    }\n}\n/** Response message for API call. */\nclass LiveServerMessage {\n    /**\n     * Returns the concatenation of all text parts from the server content if present.\n     *\n     * @remarks\n     * If there are non-text parts in the response, the concatenation of all text\n     * parts will be returned, and a warning will be logged.\n     */\n    get text() {\n        var _a, _b, _c;\n        let text = '';\n        let anyTextPartFound = false;\n        const nonTextParts = [];\n        for (const part of (_c = (_b = (_a = this.serverContent) === null || _a === void 0 ? void 0 : _a.modelTurn) === null || _b === void 0 ? void 0 : _b.parts) !== null && _c !== void 0 ? _c : []) {\n            for (const [fieldName, fieldValue] of Object.entries(part)) {\n                if (fieldName !== 'text' &&\n                    fieldName !== 'thought' &&\n                    fieldValue !== null) {\n                    nonTextParts.push(fieldName);\n                }\n            }\n            if (typeof part.text === 'string') {\n                if (typeof part.thought === 'boolean' && part.thought) {\n                    continue;\n                }\n                anyTextPartFound = true;\n                text += part.text;\n            }\n        }\n        if (nonTextParts.length > 0) {\n            console.warn(`there are non-text parts ${nonTextParts} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`);\n        }\n        // part.text === '' is different from part.text is null\n        return anyTextPartFound ? text : undefined;\n    }\n    /**\n     * Returns the concatenation of all inline data parts from the server content if present.\n     *\n     * @remarks\n     * If there are non-inline data parts in the\n     * response, the concatenation of all inline data parts will be returned, and\n     * a warning will be logged.\n     */\n    get data() {\n        var _a, _b, _c;\n        let data = '';\n        const nonDataParts = [];\n        for (const part of (_c = (_b = (_a = this.serverContent) === null || _a === void 0 ? void 0 : _a.modelTurn) === null || _b === void 0 ? void 0 : _b.parts) !== null && _c !== void 0 ? _c : []) {\n            for (const [fieldName, fieldValue] of Object.entries(part)) {\n                if (fieldName !== 'inlineData' && fieldValue !== null) {\n                    nonDataParts.push(fieldName);\n                }\n            }\n            if (part.inlineData && typeof part.inlineData.data === 'string') {\n                data += atob(part.inlineData.data);\n            }\n        }\n        if (nonDataParts.length > 0) {\n            console.warn(`there are non-data parts ${nonDataParts} in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.`);\n        }\n        return data.length > 0 ? btoa(data) : undefined;\n    }\n}\n/** Client generated response to a `ToolCall` received from the server.\n\nIndividual `FunctionResponse` objects are matched to the respective\n`FunctionCall` objects by the `id` field.\n\nNote that in the unary and server-streaming GenerateContent APIs function\ncalling happens by exchanging the `Content` parts, while in the bidi\nGenerateContent APIs function calling happens over this dedicated set of\nmessages. */\nclass LiveClientToolResponse {\n}\n/** Parameters for sending tool responses to the live API. */\nclass LiveSendToolResponseParameters {\n    constructor() {\n        /** Tool responses to send to the session. */\n        this.functionResponses = [];\n    }\n}\n/** Response message for the LiveMusicClientMessage call. */\nclass LiveMusicServerMessage {\n    /**\n     * Returns the first audio chunk from the server content, if present.\n     *\n     * @remarks\n     * If there are no audio chunks in the response, undefined will be returned.\n     */\n    get audioChunk() {\n        if (this.serverContent &&\n            this.serverContent.audioChunks &&\n            this.serverContent.audioChunks.length > 0) {\n            return this.serverContent.audioChunks[0];\n        }\n        return undefined;\n    }\n}\n/** The response when long-running operation for uploading a file to a FileSearchStore complete. */\nclass UploadToFileSearchStoreResponse {\n}\n/** Long-running operation for uploading a file to a FileSearchStore. */\nclass UploadToFileSearchStoreOperation {\n    /**\n     * Instantiates an Operation of the same type as the one being called with the fields set from the API response.\n     * @internal\n     */\n    _fromAPIResponse({ apiResponse, _isVertexAI, }) {\n        const operation = new UploadToFileSearchStoreOperation();\n        const op = apiResponse;\n        const response = uploadToFileSearchStoreOperationFromMldev(op);\n        Object.assign(operation, response);\n        return operation;\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nfunction tModel(apiClient, model) {\n    if (!model || typeof model !== 'string') {\n        throw new Error('model is required and must be a string');\n    }\n    if (model.includes('..') || model.includes('?') || model.includes('&')) {\n        throw new Error('invalid model parameter');\n    }\n    if (apiClient.isVertexAI()) {\n        if (model.startsWith('publishers/') ||\n            model.startsWith('projects/') ||\n            model.startsWith('models/')) {\n            return model;\n        }\n        else if (model.indexOf('/') >= 0) {\n            const parts = model.split('/', 2);\n            return `publishers/${parts[0]}/models/${parts[1]}`;\n        }\n        else {\n            return `publishers/google/models/${model}`;\n        }\n    }\n    else {\n        if (model.startsWith('models/') || model.startsWith('tunedModels/')) {\n            return model;\n        }\n        else {\n            return `models/${model}`;\n        }\n    }\n}\nfunction tCachesModel(apiClient, model) {\n    const transformedModel = tModel(apiClient, model);\n    if (!transformedModel) {\n        return '';\n    }\n    if (transformedModel.startsWith('publishers/') && apiClient.isVertexAI()) {\n        // vertex caches only support model name start with projects.\n        return `projects/${apiClient.getProject()}/locations/${apiClient.getLocation()}/${transformedModel}`;\n    }\n    else if (transformedModel.startsWith('models/') && apiClient.isVertexAI()) {\n        return `projects/${apiClient.getProject()}/locations/${apiClient.getLocation()}/publishers/google/${transformedModel}`;\n    }\n    else {\n        return transformedModel;\n    }\n}\nfunction tBlobs(blobs) {\n    if (Array.isArray(blobs)) {\n        return blobs.map((blob) => tBlob(blob));\n    }\n    else {\n        return [tBlob(blobs)];\n    }\n}\nfunction tBlob(blob) {\n    if (typeof blob === 'object' && blob !== null) {\n        return blob;\n    }\n    throw new Error(`Could not parse input as Blob. Unsupported blob type: ${typeof blob}`);\n}\nfunction tImageBlob(blob) {\n    const transformedBlob = tBlob(blob);\n    if (transformedBlob.mimeType &&\n        transformedBlob.mimeType.startsWith('image/')) {\n        return transformedBlob;\n    }\n    throw new Error(`Unsupported mime type: ${transformedBlob.mimeType}`);\n}\nfunction tAudioBlob(blob) {\n    const transformedBlob = tBlob(blob);\n    if (transformedBlob.mimeType &&\n        transformedBlob.mimeType.startsWith('audio/')) {\n        return transformedBlob;\n    }\n    throw new Error(`Unsupported mime type: ${transformedBlob.mimeType}`);\n}\nfunction tPart(origin) {\n    if (origin === null || origin === undefined) {\n        throw new Error('PartUnion is required');\n    }\n    if (typeof origin === 'object') {\n        return origin;\n    }\n    if (typeof origin === 'string') {\n        return { text: origin };\n    }\n    throw new Error(`Unsupported part type: ${typeof origin}`);\n}\nfunction tParts(origin) {\n    if (origin === null ||\n        origin === undefined ||\n        (Array.isArray(origin) && origin.length === 0)) {\n        throw new Error('PartListUnion is required');\n    }\n    if (Array.isArray(origin)) {\n        return origin.map((item) => tPart(item));\n    }\n    return [tPart(origin)];\n}\nfunction _isContent(origin) {\n    return (origin !== null &&\n        origin !== undefined &&\n        typeof origin === 'object' &&\n        'parts' in origin &&\n        Array.isArray(origin.parts));\n}\nfunction _isFunctionCallPart(origin) {\n    return (origin !== null &&\n        origin !== undefined &&\n        typeof origin === 'object' &&\n        'functionCall' in origin);\n}\nfunction _isFunctionResponsePart(origin) {\n    return (origin !== null &&\n        origin !== undefined &&\n        typeof origin === 'object' &&\n        'functionResponse' in origin);\n}\nfunction tContent(origin) {\n    if (origin === null || origin === undefined) {\n        throw new Error('ContentUnion is required');\n    }\n    if (_isContent(origin)) {\n        // _isContent is a utility function that checks if the\n        // origin is a Content.\n        return origin;\n    }\n    return {\n        role: 'user',\n        parts: tParts(origin),\n    };\n}\nfunction tContentsForEmbed(apiClient, origin) {\n    if (!origin) {\n        return [];\n    }\n    if (apiClient.isVertexAI() && Array.isArray(origin)) {\n        return origin.flatMap((item) => {\n            const content = tContent(item);\n            if (content.parts &&\n                content.parts.length > 0 &&\n                content.parts[0].text !== undefined) {\n                return [content.parts[0].text];\n            }\n            return [];\n        });\n    }\n    else if (apiClient.isVertexAI()) {\n        const content = tContent(origin);\n        if (content.parts &&\n            content.parts.length > 0 &&\n            content.parts[0].text !== undefined) {\n            return [content.parts[0].text];\n        }\n        return [];\n    }\n    if (Array.isArray(origin)) {\n        return origin.map((item) => tContent(item));\n    }\n    return [tContent(origin)];\n}\nfunction tContents(origin) {\n    if (origin === null ||\n        origin === undefined ||\n        (Array.isArray(origin) && origin.length === 0)) {\n        throw new Error('contents are required');\n    }\n    if (!Array.isArray(origin)) {\n        // If it's not an array, it's a single content or a single PartUnion.\n        if (_isFunctionCallPart(origin) || _isFunctionResponsePart(origin)) {\n            throw new Error('To specify functionCall or functionResponse parts, please wrap them in a Content object, specifying the role for them');\n        }\n        return [tContent(origin)];\n    }\n    const result = [];\n    const accumulatedParts = [];\n    const isContentArray = _isContent(origin[0]);\n    for (const item of origin) {\n        const isContent = _isContent(item);\n        if (isContent != isContentArray) {\n            throw new Error('Mixing Content and Parts is not supported, please group the parts into a the appropriate Content objects and specify the roles for them');\n        }\n        if (isContent) {\n            // `isContent` contains the result of _isContent, which is a utility\n            // function that checks if the item is a Content.\n            result.push(item);\n        }\n        else if (_isFunctionCallPart(item) || _isFunctionResponsePart(item)) {\n            throw new Error('To specify functionCall or functionResponse parts, please wrap them, and any other parts, in Content objects as appropriate, specifying the role for them');\n        }\n        else {\n            accumulatedParts.push(item);\n        }\n    }\n    if (!isContentArray) {\n        result.push({ role: 'user', parts: tParts(accumulatedParts) });\n    }\n    return result;\n}\n/*\nTransform the type field from an array of types to an array of anyOf fields.\nExample:\n  {type: ['STRING', 'NUMBER']}\nwill be transformed to\n  {anyOf: [{type: 'STRING'}, {type: 'NUMBER'}]}\n*/\nfunction flattenTypeArrayToAnyOf(typeList, resultingSchema) {\n    if (typeList.includes('null')) {\n        resultingSchema['nullable'] = true;\n    }\n    const listWithoutNull = typeList.filter((type) => type !== 'null');\n    if (listWithoutNull.length === 1) {\n        resultingSchema['type'] = Object.values(Type).includes(listWithoutNull[0].toUpperCase())\n            ? listWithoutNull[0].toUpperCase()\n            : Type.TYPE_UNSPECIFIED;\n    }\n    else {\n        resultingSchema['anyOf'] = [];\n        for (const i of listWithoutNull) {\n            resultingSchema['anyOf'].push({\n                'type': Object.values(Type).includes(i.toUpperCase())\n                    ? i.toUpperCase()\n                    : Type.TYPE_UNSPECIFIED,\n            });\n        }\n    }\n}\nfunction processJsonSchema(_jsonSchema) {\n    const genAISchema = {};\n    const schemaFieldNames = ['items'];\n    const listSchemaFieldNames = ['anyOf'];\n    const dictSchemaFieldNames = ['properties'];\n    if (_jsonSchema['type'] && _jsonSchema['anyOf']) {\n        throw new Error('type and anyOf cannot be both populated.');\n    }\n    /*\n    This is to handle the nullable array or object. The _jsonSchema will\n    be in the format of {anyOf: [{type: 'null'}, {type: 'object'}]}. The\n    logic is to check if anyOf has 2 elements and one of the element is null,\n    if so, the anyOf field is unnecessary, so we need to get rid of the anyOf\n    field and make the schema nullable. Then use the other element as the new\n    _jsonSchema for processing. This is because the backend doesn't have a null\n    type.\n    This has to be checked before we process any other fields.\n    For example:\n      const objectNullable = z.object({\n        nullableArray: z.array(z.string()).nullable(),\n      });\n    Will have the raw _jsonSchema as:\n    {\n      type: 'OBJECT',\n      properties: {\n          nullableArray: {\n             anyOf: [\n                {type: 'null'},\n                {\n                  type: 'array',\n                  items: {type: 'string'},\n                },\n              ],\n          }\n      },\n      required: [ 'nullableArray' ],\n    }\n    Will result in following schema compatible with Gemini API:\n      {\n        type: 'OBJECT',\n        properties: {\n           nullableArray: {\n              nullable: true,\n              type: 'ARRAY',\n              items: {type: 'string'},\n           }\n        },\n        required: [ 'nullableArray' ],\n      }\n    */\n    const incomingAnyOf = _jsonSchema['anyOf'];\n    if (incomingAnyOf != null && incomingAnyOf.length == 2) {\n        if (incomingAnyOf[0]['type'] === 'null') {\n            genAISchema['nullable'] = true;\n            _jsonSchema = incomingAnyOf[1];\n        }\n        else if (incomingAnyOf[1]['type'] === 'null') {\n            genAISchema['nullable'] = true;\n            _jsonSchema = incomingAnyOf[0];\n        }\n    }\n    if (_jsonSchema['type'] instanceof Array) {\n        flattenTypeArrayToAnyOf(_jsonSchema['type'], genAISchema);\n    }\n    for (const [fieldName, fieldValue] of Object.entries(_jsonSchema)) {\n        // Skip if the fieldvalue is undefined or null.\n        if (fieldValue == null) {\n            continue;\n        }\n        if (fieldName == 'type') {\n            if (fieldValue === 'null') {\n                throw new Error('type: null can not be the only possible type for the field.');\n            }\n            if (fieldValue instanceof Array) {\n                // we have already handled the type field with array of types in the\n                // beginning of this function.\n                continue;\n            }\n            genAISchema['type'] = Object.values(Type).includes(fieldValue.toUpperCase())\n                ? fieldValue.toUpperCase()\n                : Type.TYPE_UNSPECIFIED;\n        }\n        else if (schemaFieldNames.includes(fieldName)) {\n            genAISchema[fieldName] =\n                processJsonSchema(fieldValue);\n        }\n        else if (listSchemaFieldNames.includes(fieldName)) {\n            const listSchemaFieldValue = [];\n            for (const item of fieldValue) {\n                if (item['type'] == 'null') {\n                    genAISchema['nullable'] = true;\n                    continue;\n                }\n                listSchemaFieldValue.push(processJsonSchema(item));\n            }\n            genAISchema[fieldName] =\n                listSchemaFieldValue;\n        }\n        else if (dictSchemaFieldNames.includes(fieldName)) {\n            const dictSchemaFieldValue = {};\n            for (const [key, value] of Object.entries(fieldValue)) {\n                dictSchemaFieldValue[key] = processJsonSchema(value);\n            }\n            genAISchema[fieldName] =\n                dictSchemaFieldValue;\n        }\n        else {\n            // additionalProperties is not included in JSONSchema, skipping it.\n            if (fieldName === 'additionalProperties') {\n                continue;\n            }\n            genAISchema[fieldName] = fieldValue;\n        }\n    }\n    return genAISchema;\n}\n// we take the unknown in the schema field because we want enable user to pass\n// the output of major schema declaration tools without casting. Tools such as\n// zodToJsonSchema, typebox, zodToJsonSchema function can return JsonSchema7Type\n// or object, see details in\n// https://github.com/StefanTerdell/zod-to-json-schema/blob/70525efe555cd226691e093d171370a3b10921d1/src/zodToJsonSchema.ts#L7\n// typebox can return unknown, see details in\n// https://github.com/sinclairzx81/typebox/blob/5a5431439f7d5ca6b494d0d18fbfd7b1a356d67c/src/type/create/type.ts#L35\n// Note: proper json schemas with the $schema field set never arrive to this\n// transformer. Schemas with $schema are routed to the equivalent API json\n// schema field.\nfunction tSchema(schema) {\n    return processJsonSchema(schema);\n}\nfunction tSpeechConfig(speechConfig) {\n    if (typeof speechConfig === 'object') {\n        return speechConfig;\n    }\n    else if (typeof speechConfig === 'string') {\n        return {\n            voiceConfig: {\n                prebuiltVoiceConfig: {\n                    voiceName: speechConfig,\n                },\n            },\n        };\n    }\n    else {\n        throw new Error(`Unsupported speechConfig type: ${typeof speechConfig}`);\n    }\n}\nfunction tLiveSpeechConfig(speechConfig) {\n    if ('multiSpeakerVoiceConfig' in speechConfig) {\n        throw new Error('multiSpeakerVoiceConfig is not supported in the live API.');\n    }\n    return speechConfig;\n}\nfunction tTool(tool) {\n    if (tool.functionDeclarations) {\n        for (const functionDeclaration of tool.functionDeclarations) {\n            if (functionDeclaration.parameters) {\n                if (!Object.keys(functionDeclaration.parameters).includes('$schema')) {\n                    functionDeclaration.parameters = processJsonSchema(functionDeclaration.parameters);\n                }\n                else {\n                    if (!functionDeclaration.parametersJsonSchema) {\n                        functionDeclaration.parametersJsonSchema =\n                            functionDeclaration.parameters;\n                        delete functionDeclaration.parameters;\n                    }\n                }\n            }\n            if (functionDeclaration.response) {\n                if (!Object.keys(functionDeclaration.response).includes('$schema')) {\n                    functionDeclaration.response = processJsonSchema(functionDeclaration.response);\n                }\n                else {\n                    if (!functionDeclaration.responseJsonSchema) {\n                        functionDeclaration.responseJsonSchema =\n                            functionDeclaration.response;\n                        delete functionDeclaration.response;\n                    }\n                }\n            }\n        }\n    }\n    return tool;\n}\nfunction tTools(tools) {\n    // Check if the incoming type is defined.\n    if (tools === undefined || tools === null) {\n        throw new Error('tools is required');\n    }\n    if (!Array.isArray(tools)) {\n        throw new Error('tools is required and must be an array of Tools');\n    }\n    const result = [];\n    for (const tool of tools) {\n        result.push(tool);\n    }\n    return result;\n}\n/**\n * Prepends resource name with project, location, resource_prefix if needed.\n *\n * @param client The API client.\n * @param resourceName The resource name.\n * @param resourcePrefix The resource prefix.\n * @param splitsAfterPrefix The number of splits after the prefix.\n * @returns The completed resource name.\n *\n * Examples:\n *\n * ```\n * resource_name = '123'\n * resource_prefix = 'cachedContents'\n * splits_after_prefix = 1\n * client.vertexai = True\n * client.project = 'bar'\n * client.location = 'us-west1'\n * _resource_name(client, resource_name, resource_prefix, splits_after_prefix)\n * returns: 'projects/bar/locations/us-west1/cachedContents/123'\n * ```\n *\n * ```\n * resource_name = 'projects/foo/locations/us-central1/cachedContents/123'\n * resource_prefix = 'cachedContents'\n * splits_after_prefix = 1\n * client.vertexai = True\n * client.project = 'bar'\n * client.location = 'us-west1'\n * _resource_name(client, resource_name, resource_prefix, splits_after_prefix)\n * returns: 'projects/foo/locations/us-central1/cachedContents/123'\n * ```\n *\n * ```\n * resource_name = '123'\n * resource_prefix = 'cachedContents'\n * splits_after_prefix = 1\n * client.vertexai = False\n * _resource_name(client, resource_name, resource_prefix, splits_after_prefix)\n * returns 'cachedContents/123'\n * ```\n *\n * ```\n * resource_name = 'some/wrong/cachedContents/resource/name/123'\n * resource_prefix = 'cachedContents'\n * splits_after_prefix = 1\n * client.vertexai = False\n * # client.vertexai = True\n * _resource_name(client, resource_name, resource_prefix, splits_after_prefix)\n * -> 'some/wrong/resource/name/123'\n * ```\n */\nfunction resourceName(client, resourceName, resourcePrefix, splitsAfterPrefix = 1) {\n    const shouldAppendPrefix = !resourceName.startsWith(`${resourcePrefix}/`) &&\n        resourceName.split('/').length === splitsAfterPrefix;\n    if (client.isVertexAI()) {\n        if (resourceName.startsWith('projects/')) {\n            return resourceName;\n        }\n        else if (resourceName.startsWith('locations/')) {\n            return `projects/${client.getProject()}/${resourceName}`;\n        }\n        else if (resourceName.startsWith(`${resourcePrefix}/`)) {\n            return `projects/${client.getProject()}/locations/${client.getLocation()}/${resourceName}`;\n        }\n        else if (shouldAppendPrefix) {\n            return `projects/${client.getProject()}/locations/${client.getLocation()}/${resourcePrefix}/${resourceName}`;\n        }\n        else {\n            return resourceName;\n        }\n    }\n    if (shouldAppendPrefix) {\n        return `${resourcePrefix}/${resourceName}`;\n    }\n    return resourceName;\n}\nfunction tCachedContentName(apiClient, name) {\n    if (typeof name !== 'string') {\n        throw new Error('name must be a string');\n    }\n    return resourceName(apiClient, name, 'cachedContents');\n}\nfunction tTuningJobStatus(status) {\n    switch (status) {\n        case 'STATE_UNSPECIFIED':\n            return 'JOB_STATE_UNSPECIFIED';\n        case 'CREATING':\n            return 'JOB_STATE_RUNNING';\n        case 'ACTIVE':\n            return 'JOB_STATE_SUCCEEDED';\n        case 'FAILED':\n            return 'JOB_STATE_FAILED';\n        default:\n            return status;\n    }\n}\nfunction tBytes(fromImageBytes) {\n    return tBytes$1(fromImageBytes);\n}\nfunction _isFile(origin) {\n    return (origin !== null &&\n        origin !== undefined &&\n        typeof origin === 'object' &&\n        'name' in origin);\n}\nfunction isGeneratedVideo(origin) {\n    return (origin !== null &&\n        origin !== undefined &&\n        typeof origin === 'object' &&\n        'video' in origin);\n}\nfunction isVideo(origin) {\n    return (origin !== null &&\n        origin !== undefined &&\n        typeof origin === 'object' &&\n        'uri' in origin);\n}\nfunction tFileName(fromName) {\n    var _a;\n    let name;\n    if (_isFile(fromName)) {\n        name = fromName.name;\n    }\n    if (isVideo(fromName)) {\n        name = fromName.uri;\n        if (name === undefined) {\n            return undefined;\n        }\n    }\n    if (isGeneratedVideo(fromName)) {\n        name = (_a = fromName.video) === null || _a === void 0 ? void 0 : _a.uri;\n        if (name === undefined) {\n            return undefined;\n        }\n    }\n    if (typeof fromName === 'string') {\n        name = fromName;\n    }\n    if (name === undefined) {\n        throw new Error('Could not extract file name from the provided input.');\n    }\n    if (name.startsWith('https://')) {\n        const suffix = name.split('files/')[1];\n        const match = suffix.match(/[a-z0-9]+/);\n        if (match === null) {\n            throw new Error(`Could not extract file name from URI ${name}`);\n        }\n        name = match[0];\n    }\n    else if (name.startsWith('files/')) {\n        name = name.split('files/')[1];\n    }\n    return name;\n}\nfunction tModelsUrl(apiClient, baseModels) {\n    let res;\n    if (apiClient.isVertexAI()) {\n        res = baseModels ? 'publishers/google/models' : 'models';\n    }\n    else {\n        res = baseModels ? 'models' : 'tunedModels';\n    }\n    return res;\n}\nfunction tExtractModels(response) {\n    for (const key of ['models', 'tunedModels', 'publisherModels']) {\n        if (hasField(response, key)) {\n            return response[key];\n        }\n    }\n    return [];\n}\nfunction hasField(data, fieldName) {\n    return data !== null && typeof data === 'object' && fieldName in data;\n}\nfunction mcpToGeminiTool(mcpTool, config = {}) {\n    const mcpToolSchema = mcpTool;\n    const functionDeclaration = {\n        name: mcpToolSchema['name'],\n        description: mcpToolSchema['description'],\n        parametersJsonSchema: mcpToolSchema['inputSchema'],\n    };\n    if (mcpToolSchema['outputSchema']) {\n        functionDeclaration['responseJsonSchema'] = mcpToolSchema['outputSchema'];\n    }\n    if (config.behavior) {\n        functionDeclaration['behavior'] = config.behavior;\n    }\n    const geminiTool = {\n        functionDeclarations: [\n            functionDeclaration,\n        ],\n    };\n    return geminiTool;\n}\n/**\n * Converts a list of MCP tools to a single Gemini tool with a list of function\n * declarations.\n */\nfunction mcpToolsToGeminiTool(mcpTools, config = {}) {\n    const functionDeclarations = [];\n    const toolNames = new Set();\n    for (const mcpTool of mcpTools) {\n        const mcpToolName = mcpTool.name;\n        if (toolNames.has(mcpToolName)) {\n            throw new Error(`Duplicate function name ${mcpToolName} found in MCP tools. Please ensure function names are unique.`);\n        }\n        toolNames.add(mcpToolName);\n        const geminiTool = mcpToGeminiTool(mcpTool, config);\n        if (geminiTool.functionDeclarations) {\n            functionDeclarations.push(...geminiTool.functionDeclarations);\n        }\n    }\n    return { functionDeclarations: functionDeclarations };\n}\n// Transforms a source input into a BatchJobSource object with validation.\nfunction tBatchJobSource(client, src) {\n    let sourceObj;\n    if (typeof src === 'string') {\n        if (client.isVertexAI()) {\n            if (src.startsWith('gs://')) {\n                sourceObj = { format: 'jsonl', gcsUri: [src] };\n            }\n            else if (src.startsWith('bq://')) {\n                sourceObj = { format: 'bigquery', bigqueryUri: src };\n            }\n            else {\n                throw new Error(`Unsupported string source for Vertex AI: ${src}`);\n            }\n        }\n        else {\n            // MLDEV\n            if (src.startsWith('files/')) {\n                sourceObj = { fileName: src }; // Default to fileName for string input\n            }\n            else {\n                throw new Error(`Unsupported string source for Gemini API: ${src}`);\n            }\n        }\n    }\n    else if (Array.isArray(src)) {\n        if (client.isVertexAI()) {\n            throw new Error('InlinedRequest[] is not supported in Vertex AI.');\n        }\n        sourceObj = { inlinedRequests: src };\n    }\n    else {\n        // It's already a BatchJobSource object\n        sourceObj = src;\n    }\n    // Validation logic\n    const vertexSourcesCount = [sourceObj.gcsUri, sourceObj.bigqueryUri].filter(Boolean).length;\n    const mldevSourcesCount = [\n        sourceObj.inlinedRequests,\n        sourceObj.fileName,\n    ].filter(Boolean).length;\n    if (client.isVertexAI()) {\n        if (mldevSourcesCount > 0 || vertexSourcesCount !== 1) {\n            throw new Error('Exactly one of `gcsUri` or `bigqueryUri` must be set for Vertex AI.');\n        }\n    }\n    else {\n        // MLDEV\n        if (vertexSourcesCount > 0 || mldevSourcesCount !== 1) {\n            throw new Error('Exactly one of `inlinedRequests`, `fileName`, ' +\n                'must be set for Gemini API.');\n        }\n    }\n    return sourceObj;\n}\nfunction tBatchJobDestination(dest) {\n    if (typeof dest !== 'string') {\n        return dest;\n    }\n    const destString = dest;\n    if (destString.startsWith('gs://')) {\n        return {\n            format: 'jsonl',\n            gcsUri: destString,\n        };\n    }\n    else if (destString.startsWith('bq://')) {\n        return {\n            format: 'bigquery',\n            bigqueryUri: destString,\n        };\n    }\n    else {\n        throw new Error(`Unsupported destination: ${destString}`);\n    }\n}\nfunction tRecvBatchJobDestination(dest) {\n    // Ensure dest is a non-null object before proceeding.\n    if (typeof dest !== 'object' || dest === null) {\n        // If the input is not an object, it cannot be a valid BatchJobDestination\n        // based on the operations performed. Return it cast, or handle as an error.\n        // Casting an empty object might be a safe default.\n        return {};\n    }\n    // Cast to Record<string, unknown> to allow string property access.\n    const obj = dest;\n    // Safely access nested properties.\n    const inlineResponsesVal = obj['inlinedResponses'];\n    if (typeof inlineResponsesVal !== 'object' || inlineResponsesVal === null) {\n        return dest;\n    }\n    const inlineResponsesObj = inlineResponsesVal;\n    const responsesArray = inlineResponsesObj['inlinedResponses'];\n    if (!Array.isArray(responsesArray) || responsesArray.length === 0) {\n        return dest;\n    }\n    // Check if any response has the 'embedding' property.\n    let hasEmbedding = false;\n    for (const responseItem of responsesArray) {\n        if (typeof responseItem !== 'object' || responseItem === null) {\n            continue;\n        }\n        const responseItemObj = responseItem;\n        const responseVal = responseItemObj['response'];\n        if (typeof responseVal !== 'object' || responseVal === null) {\n            continue;\n        }\n        const responseObj = responseVal;\n        // Check for the existence of the 'embedding' key.\n        if (responseObj['embedding'] !== undefined) {\n            hasEmbedding = true;\n            break;\n        }\n    }\n    // Perform the transformation if an embedding was found.\n    if (hasEmbedding) {\n        obj['inlinedEmbedContentResponses'] = obj['inlinedResponses'];\n        delete obj['inlinedResponses'];\n    }\n    // Cast the (potentially) modified object to the target type.\n    return dest;\n}\nfunction tBatchJobName(apiClient, name) {\n    const nameString = name;\n    if (!apiClient.isVertexAI()) {\n        const mldevPattern = /batches\\/[^/]+$/;\n        if (mldevPattern.test(nameString)) {\n            return nameString.split('/').pop();\n        }\n        else {\n            throw new Error(`Invalid batch job name: ${nameString}.`);\n        }\n    }\n    const vertexPattern = /^projects\\/[^/]+\\/locations\\/[^/]+\\/batchPredictionJobs\\/[^/]+$/;\n    if (vertexPattern.test(nameString)) {\n        return nameString.split('/').pop();\n    }\n    else if (/^\\d+$/.test(nameString)) {\n        return nameString;\n    }\n    else {\n        throw new Error(`Invalid batch job name: ${nameString}.`);\n    }\n}\nfunction tJobState(state) {\n    const stateString = state;\n    if (stateString === 'BATCH_STATE_UNSPECIFIED') {\n        return 'JOB_STATE_UNSPECIFIED';\n    }\n    else if (stateString === 'BATCH_STATE_PENDING') {\n        return 'JOB_STATE_PENDING';\n    }\n    else if (stateString === 'BATCH_STATE_RUNNING') {\n        return 'JOB_STATE_RUNNING';\n    }\n    else if (stateString === 'BATCH_STATE_SUCCEEDED') {\n        return 'JOB_STATE_SUCCEEDED';\n    }\n    else if (stateString === 'BATCH_STATE_FAILED') {\n        return 'JOB_STATE_FAILED';\n    }\n    else if (stateString === 'BATCH_STATE_CANCELLED') {\n        return 'JOB_STATE_CANCELLED';\n    }\n    else if (stateString === 'BATCH_STATE_EXPIRED') {\n        return 'JOB_STATE_EXPIRED';\n    }\n    else {\n        return stateString;\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nfunction batchJobDestinationFromMldev(fromObject) {\n    const toObject = {};\n    const fromFileName = getValueByPath(fromObject, ['responsesFile']);\n    if (fromFileName != null) {\n        setValueByPath(toObject, ['fileName'], fromFileName);\n    }\n    const fromInlinedResponses = getValueByPath(fromObject, [\n        'inlinedResponses',\n        'inlinedResponses',\n    ]);\n    if (fromInlinedResponses != null) {\n        let transformedList = fromInlinedResponses;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return inlinedResponseFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, ['inlinedResponses'], transformedList);\n    }\n    const fromInlinedEmbedContentResponses = getValueByPath(fromObject, [\n        'inlinedEmbedContentResponses',\n        'inlinedResponses',\n    ]);\n    if (fromInlinedEmbedContentResponses != null) {\n        let transformedList = fromInlinedEmbedContentResponses;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['inlinedEmbedContentResponses'], transformedList);\n    }\n    return toObject;\n}\nfunction batchJobDestinationFromVertex(fromObject) {\n    const toObject = {};\n    const fromFormat = getValueByPath(fromObject, ['predictionsFormat']);\n    if (fromFormat != null) {\n        setValueByPath(toObject, ['format'], fromFormat);\n    }\n    const fromGcsUri = getValueByPath(fromObject, [\n        'gcsDestination',\n        'outputUriPrefix',\n    ]);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, ['gcsUri'], fromGcsUri);\n    }\n    const fromBigqueryUri = getValueByPath(fromObject, [\n        'bigqueryDestination',\n        'outputUri',\n    ]);\n    if (fromBigqueryUri != null) {\n        setValueByPath(toObject, ['bigqueryUri'], fromBigqueryUri);\n    }\n    return toObject;\n}\nfunction batchJobDestinationToVertex(fromObject) {\n    const toObject = {};\n    const fromFormat = getValueByPath(fromObject, ['format']);\n    if (fromFormat != null) {\n        setValueByPath(toObject, ['predictionsFormat'], fromFormat);\n    }\n    const fromGcsUri = getValueByPath(fromObject, ['gcsUri']);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, ['gcsDestination', 'outputUriPrefix'], fromGcsUri);\n    }\n    const fromBigqueryUri = getValueByPath(fromObject, ['bigqueryUri']);\n    if (fromBigqueryUri != null) {\n        setValueByPath(toObject, ['bigqueryDestination', 'outputUri'], fromBigqueryUri);\n    }\n    if (getValueByPath(fromObject, ['fileName']) !== undefined) {\n        throw new Error('fileName parameter is not supported in Vertex AI.');\n    }\n    if (getValueByPath(fromObject, ['inlinedResponses']) !== undefined) {\n        throw new Error('inlinedResponses parameter is not supported in Vertex AI.');\n    }\n    if (getValueByPath(fromObject, ['inlinedEmbedContentResponses']) !==\n        undefined) {\n        throw new Error('inlinedEmbedContentResponses parameter is not supported in Vertex AI.');\n    }\n    return toObject;\n}\nfunction batchJobFromMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        'metadata',\n        'displayName',\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, ['displayName'], fromDisplayName);\n    }\n    const fromState = getValueByPath(fromObject, ['metadata', 'state']);\n    if (fromState != null) {\n        setValueByPath(toObject, ['state'], tJobState(fromState));\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        'metadata',\n        'createTime',\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, ['createTime'], fromCreateTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, [\n        'metadata',\n        'endTime',\n    ]);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, ['endTime'], fromEndTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, [\n        'metadata',\n        'updateTime',\n    ]);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, ['updateTime'], fromUpdateTime);\n    }\n    const fromModel = getValueByPath(fromObject, ['metadata', 'model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['model'], fromModel);\n    }\n    const fromDest = getValueByPath(fromObject, ['metadata', 'output']);\n    if (fromDest != null) {\n        setValueByPath(toObject, ['dest'], batchJobDestinationFromMldev(tRecvBatchJobDestination(fromDest)));\n    }\n    return toObject;\n}\nfunction batchJobFromVertex(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, ['displayName']);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, ['displayName'], fromDisplayName);\n    }\n    const fromState = getValueByPath(fromObject, ['state']);\n    if (fromState != null) {\n        setValueByPath(toObject, ['state'], tJobState(fromState));\n    }\n    const fromError = getValueByPath(fromObject, ['error']);\n    if (fromError != null) {\n        setValueByPath(toObject, ['error'], fromError);\n    }\n    const fromCreateTime = getValueByPath(fromObject, ['createTime']);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, ['createTime'], fromCreateTime);\n    }\n    const fromStartTime = getValueByPath(fromObject, ['startTime']);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, ['startTime'], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, ['endTime']);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, ['endTime'], fromEndTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, ['updateTime']);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, ['updateTime'], fromUpdateTime);\n    }\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['model'], fromModel);\n    }\n    const fromSrc = getValueByPath(fromObject, ['inputConfig']);\n    if (fromSrc != null) {\n        setValueByPath(toObject, ['src'], batchJobSourceFromVertex(fromSrc));\n    }\n    const fromDest = getValueByPath(fromObject, ['outputConfig']);\n    if (fromDest != null) {\n        setValueByPath(toObject, ['dest'], batchJobDestinationFromVertex(tRecvBatchJobDestination(fromDest)));\n    }\n    const fromCompletionStats = getValueByPath(fromObject, [\n        'completionStats',\n    ]);\n    if (fromCompletionStats != null) {\n        setValueByPath(toObject, ['completionStats'], fromCompletionStats);\n    }\n    return toObject;\n}\nfunction batchJobSourceFromVertex(fromObject) {\n    const toObject = {};\n    const fromFormat = getValueByPath(fromObject, ['instancesFormat']);\n    if (fromFormat != null) {\n        setValueByPath(toObject, ['format'], fromFormat);\n    }\n    const fromGcsUri = getValueByPath(fromObject, ['gcsSource', 'uris']);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, ['gcsUri'], fromGcsUri);\n    }\n    const fromBigqueryUri = getValueByPath(fromObject, [\n        'bigquerySource',\n        'inputUri',\n    ]);\n    if (fromBigqueryUri != null) {\n        setValueByPath(toObject, ['bigqueryUri'], fromBigqueryUri);\n    }\n    return toObject;\n}\nfunction batchJobSourceToMldev(apiClient, fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['format']) !== undefined) {\n        throw new Error('format parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['gcsUri']) !== undefined) {\n        throw new Error('gcsUri parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['bigqueryUri']) !== undefined) {\n        throw new Error('bigqueryUri parameter is not supported in Gemini API.');\n    }\n    const fromFileName = getValueByPath(fromObject, ['fileName']);\n    if (fromFileName != null) {\n        setValueByPath(toObject, ['fileName'], fromFileName);\n    }\n    const fromInlinedRequests = getValueByPath(fromObject, [\n        'inlinedRequests',\n    ]);\n    if (fromInlinedRequests != null) {\n        let transformedList = fromInlinedRequests;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return inlinedRequestToMldev(apiClient, item);\n            });\n        }\n        setValueByPath(toObject, ['requests', 'requests'], transformedList);\n    }\n    return toObject;\n}\nfunction batchJobSourceToVertex(fromObject) {\n    const toObject = {};\n    const fromFormat = getValueByPath(fromObject, ['format']);\n    if (fromFormat != null) {\n        setValueByPath(toObject, ['instancesFormat'], fromFormat);\n    }\n    const fromGcsUri = getValueByPath(fromObject, ['gcsUri']);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, ['gcsSource', 'uris'], fromGcsUri);\n    }\n    const fromBigqueryUri = getValueByPath(fromObject, ['bigqueryUri']);\n    if (fromBigqueryUri != null) {\n        setValueByPath(toObject, ['bigquerySource', 'inputUri'], fromBigqueryUri);\n    }\n    if (getValueByPath(fromObject, ['fileName']) !== undefined) {\n        throw new Error('fileName parameter is not supported in Vertex AI.');\n    }\n    if (getValueByPath(fromObject, ['inlinedRequests']) !== undefined) {\n        throw new Error('inlinedRequests parameter is not supported in Vertex AI.');\n    }\n    return toObject;\n}\nfunction blobToMldev$4(fromObject) {\n    const toObject = {};\n    const fromData = getValueByPath(fromObject, ['data']);\n    if (fromData != null) {\n        setValueByPath(toObject, ['data'], fromData);\n    }\n    if (getValueByPath(fromObject, ['displayName']) !== undefined) {\n        throw new Error('displayName parameter is not supported in Gemini API.');\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction cancelBatchJobParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], tBatchJobName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction cancelBatchJobParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], tBatchJobName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction candidateFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromContent = getValueByPath(fromObject, ['content']);\n    if (fromContent != null) {\n        setValueByPath(toObject, ['content'], fromContent);\n    }\n    const fromCitationMetadata = getValueByPath(fromObject, [\n        'citationMetadata',\n    ]);\n    if (fromCitationMetadata != null) {\n        setValueByPath(toObject, ['citationMetadata'], citationMetadataFromMldev$1(fromCitationMetadata));\n    }\n    const fromTokenCount = getValueByPath(fromObject, ['tokenCount']);\n    if (fromTokenCount != null) {\n        setValueByPath(toObject, ['tokenCount'], fromTokenCount);\n    }\n    const fromFinishReason = getValueByPath(fromObject, ['finishReason']);\n    if (fromFinishReason != null) {\n        setValueByPath(toObject, ['finishReason'], fromFinishReason);\n    }\n    const fromAvgLogprobs = getValueByPath(fromObject, ['avgLogprobs']);\n    if (fromAvgLogprobs != null) {\n        setValueByPath(toObject, ['avgLogprobs'], fromAvgLogprobs);\n    }\n    const fromGroundingMetadata = getValueByPath(fromObject, [\n        'groundingMetadata',\n    ]);\n    if (fromGroundingMetadata != null) {\n        setValueByPath(toObject, ['groundingMetadata'], fromGroundingMetadata);\n    }\n    const fromIndex = getValueByPath(fromObject, ['index']);\n    if (fromIndex != null) {\n        setValueByPath(toObject, ['index'], fromIndex);\n    }\n    const fromLogprobsResult = getValueByPath(fromObject, [\n        'logprobsResult',\n    ]);\n    if (fromLogprobsResult != null) {\n        setValueByPath(toObject, ['logprobsResult'], fromLogprobsResult);\n    }\n    const fromSafetyRatings = getValueByPath(fromObject, [\n        'safetyRatings',\n    ]);\n    if (fromSafetyRatings != null) {\n        let transformedList = fromSafetyRatings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['safetyRatings'], transformedList);\n    }\n    const fromUrlContextMetadata = getValueByPath(fromObject, [\n        'urlContextMetadata',\n    ]);\n    if (fromUrlContextMetadata != null) {\n        setValueByPath(toObject, ['urlContextMetadata'], fromUrlContextMetadata);\n    }\n    return toObject;\n}\nfunction citationMetadataFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromCitations = getValueByPath(fromObject, ['citationSources']);\n    if (fromCitations != null) {\n        let transformedList = fromCitations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['citations'], transformedList);\n    }\n    return toObject;\n}\nfunction contentToMldev$4(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, ['parts']);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return partToMldev$4(item);\n            });\n        }\n        setValueByPath(toObject, ['parts'], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, ['role']);\n    if (fromRole != null) {\n        setValueByPath(toObject, ['role'], fromRole);\n    }\n    return toObject;\n}\nfunction createBatchJobConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, ['displayName']);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, ['batch', 'displayName'], fromDisplayName);\n    }\n    if (getValueByPath(fromObject, ['dest']) !== undefined) {\n        throw new Error('dest parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction createBatchJobConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, ['displayName']);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, ['displayName'], fromDisplayName);\n    }\n    const fromDest = getValueByPath(fromObject, ['dest']);\n    if (parentObject !== undefined && fromDest != null) {\n        setValueByPath(parentObject, ['outputConfig'], batchJobDestinationToVertex(tBatchJobDestination(fromDest)));\n    }\n    return toObject;\n}\nfunction createBatchJobParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromSrc = getValueByPath(fromObject, ['src']);\n    if (fromSrc != null) {\n        setValueByPath(toObject, ['batch', 'inputConfig'], batchJobSourceToMldev(apiClient, tBatchJobSource(apiClient, fromSrc)));\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        createBatchJobConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction createBatchJobParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['model'], tModel(apiClient, fromModel));\n    }\n    const fromSrc = getValueByPath(fromObject, ['src']);\n    if (fromSrc != null) {\n        setValueByPath(toObject, ['inputConfig'], batchJobSourceToVertex(tBatchJobSource(apiClient, fromSrc)));\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        createBatchJobConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction createEmbeddingsBatchJobConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, ['displayName']);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, ['batch', 'displayName'], fromDisplayName);\n    }\n    return toObject;\n}\nfunction createEmbeddingsBatchJobParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromSrc = getValueByPath(fromObject, ['src']);\n    if (fromSrc != null) {\n        setValueByPath(toObject, ['batch', 'inputConfig'], embeddingsBatchJobSourceToMldev(apiClient, fromSrc));\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        createEmbeddingsBatchJobConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction deleteBatchJobParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], tBatchJobName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction deleteBatchJobParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], tBatchJobName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction deleteResourceJobFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromDone = getValueByPath(fromObject, ['done']);\n    if (fromDone != null) {\n        setValueByPath(toObject, ['done'], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, ['error']);\n    if (fromError != null) {\n        setValueByPath(toObject, ['error'], fromError);\n    }\n    return toObject;\n}\nfunction deleteResourceJobFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromDone = getValueByPath(fromObject, ['done']);\n    if (fromDone != null) {\n        setValueByPath(toObject, ['done'], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, ['error']);\n    if (fromError != null) {\n        setValueByPath(toObject, ['error'], fromError);\n    }\n    return toObject;\n}\nfunction embedContentBatchToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromContents = getValueByPath(fromObject, ['contents']);\n    if (fromContents != null) {\n        let transformedList = tContentsForEmbed(apiClient, fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['requests[]', 'request', 'content'], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        setValueByPath(toObject, ['_self'], embedContentConfigToMldev$1(fromConfig, toObject));\n        moveValueByPath(toObject, { 'requests[].*': 'requests[].request.*' });\n    }\n    return toObject;\n}\nfunction embedContentConfigToMldev$1(fromObject, parentObject) {\n    const toObject = {};\n    const fromTaskType = getValueByPath(fromObject, ['taskType']);\n    if (parentObject !== undefined && fromTaskType != null) {\n        setValueByPath(parentObject, ['requests[]', 'taskType'], fromTaskType);\n    }\n    const fromTitle = getValueByPath(fromObject, ['title']);\n    if (parentObject !== undefined && fromTitle != null) {\n        setValueByPath(parentObject, ['requests[]', 'title'], fromTitle);\n    }\n    const fromOutputDimensionality = getValueByPath(fromObject, [\n        'outputDimensionality',\n    ]);\n    if (parentObject !== undefined && fromOutputDimensionality != null) {\n        setValueByPath(parentObject, ['requests[]', 'outputDimensionality'], fromOutputDimensionality);\n    }\n    if (getValueByPath(fromObject, ['mimeType']) !== undefined) {\n        throw new Error('mimeType parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['autoTruncate']) !== undefined) {\n        throw new Error('autoTruncate parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction embeddingsBatchJobSourceToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromFileName = getValueByPath(fromObject, ['fileName']);\n    if (fromFileName != null) {\n        setValueByPath(toObject, ['file_name'], fromFileName);\n    }\n    const fromInlinedRequests = getValueByPath(fromObject, [\n        'inlinedRequests',\n    ]);\n    if (fromInlinedRequests != null) {\n        setValueByPath(toObject, ['requests'], embedContentBatchToMldev(apiClient, fromInlinedRequests));\n    }\n    return toObject;\n}\nfunction fileDataToMldev$4(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['displayName']) !== undefined) {\n        throw new Error('displayName parameter is not supported in Gemini API.');\n    }\n    const fromFileUri = getValueByPath(fromObject, ['fileUri']);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, ['fileUri'], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction functionCallToMldev$4(fromObject) {\n    const toObject = {};\n    const fromId = getValueByPath(fromObject, ['id']);\n    if (fromId != null) {\n        setValueByPath(toObject, ['id'], fromId);\n    }\n    const fromArgs = getValueByPath(fromObject, ['args']);\n    if (fromArgs != null) {\n        setValueByPath(toObject, ['args'], fromArgs);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    if (getValueByPath(fromObject, ['partialArgs']) !== undefined) {\n        throw new Error('partialArgs parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['willContinue']) !== undefined) {\n        throw new Error('willContinue parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction functionCallingConfigToMldev$2(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, ['mode']);\n    if (fromMode != null) {\n        setValueByPath(toObject, ['mode'], fromMode);\n    }\n    const fromAllowedFunctionNames = getValueByPath(fromObject, [\n        'allowedFunctionNames',\n    ]);\n    if (fromAllowedFunctionNames != null) {\n        setValueByPath(toObject, ['allowedFunctionNames'], fromAllowedFunctionNames);\n    }\n    if (getValueByPath(fromObject, ['streamFunctionCallArguments']) !==\n        undefined) {\n        throw new Error('streamFunctionCallArguments parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction generateContentConfigToMldev$1(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        'systemInstruction',\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, ['systemInstruction'], contentToMldev$4(tContent(fromSystemInstruction)));\n    }\n    const fromTemperature = getValueByPath(fromObject, ['temperature']);\n    if (fromTemperature != null) {\n        setValueByPath(toObject, ['temperature'], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, ['topP']);\n    if (fromTopP != null) {\n        setValueByPath(toObject, ['topP'], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, ['topK']);\n    if (fromTopK != null) {\n        setValueByPath(toObject, ['topK'], fromTopK);\n    }\n    const fromCandidateCount = getValueByPath(fromObject, [\n        'candidateCount',\n    ]);\n    if (fromCandidateCount != null) {\n        setValueByPath(toObject, ['candidateCount'], fromCandidateCount);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        'maxOutputTokens',\n    ]);\n    if (fromMaxOutputTokens != null) {\n        setValueByPath(toObject, ['maxOutputTokens'], fromMaxOutputTokens);\n    }\n    const fromStopSequences = getValueByPath(fromObject, [\n        'stopSequences',\n    ]);\n    if (fromStopSequences != null) {\n        setValueByPath(toObject, ['stopSequences'], fromStopSequences);\n    }\n    const fromResponseLogprobs = getValueByPath(fromObject, [\n        'responseLogprobs',\n    ]);\n    if (fromResponseLogprobs != null) {\n        setValueByPath(toObject, ['responseLogprobs'], fromResponseLogprobs);\n    }\n    const fromLogprobs = getValueByPath(fromObject, ['logprobs']);\n    if (fromLogprobs != null) {\n        setValueByPath(toObject, ['logprobs'], fromLogprobs);\n    }\n    const fromPresencePenalty = getValueByPath(fromObject, [\n        'presencePenalty',\n    ]);\n    if (fromPresencePenalty != null) {\n        setValueByPath(toObject, ['presencePenalty'], fromPresencePenalty);\n    }\n    const fromFrequencyPenalty = getValueByPath(fromObject, [\n        'frequencyPenalty',\n    ]);\n    if (fromFrequencyPenalty != null) {\n        setValueByPath(toObject, ['frequencyPenalty'], fromFrequencyPenalty);\n    }\n    const fromSeed = getValueByPath(fromObject, ['seed']);\n    if (fromSeed != null) {\n        setValueByPath(toObject, ['seed'], fromSeed);\n    }\n    const fromResponseMimeType = getValueByPath(fromObject, [\n        'responseMimeType',\n    ]);\n    if (fromResponseMimeType != null) {\n        setValueByPath(toObject, ['responseMimeType'], fromResponseMimeType);\n    }\n    const fromResponseSchema = getValueByPath(fromObject, [\n        'responseSchema',\n    ]);\n    if (fromResponseSchema != null) {\n        setValueByPath(toObject, ['responseSchema'], tSchema(fromResponseSchema));\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        'responseJsonSchema',\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, ['responseJsonSchema'], fromResponseJsonSchema);\n    }\n    if (getValueByPath(fromObject, ['routingConfig']) !== undefined) {\n        throw new Error('routingConfig parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['modelSelectionConfig']) !== undefined) {\n        throw new Error('modelSelectionConfig parameter is not supported in Gemini API.');\n    }\n    const fromSafetySettings = getValueByPath(fromObject, [\n        'safetySettings',\n    ]);\n    if (parentObject !== undefined && fromSafetySettings != null) {\n        let transformedList = fromSafetySettings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return safetySettingToMldev$1(item);\n            });\n        }\n        setValueByPath(parentObject, ['safetySettings'], transformedList);\n    }\n    const fromTools = getValueByPath(fromObject, ['tools']);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return toolToMldev$4(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, ['tools'], transformedList);\n    }\n    const fromToolConfig = getValueByPath(fromObject, ['toolConfig']);\n    if (parentObject !== undefined && fromToolConfig != null) {\n        setValueByPath(parentObject, ['toolConfig'], toolConfigToMldev$2(fromToolConfig));\n    }\n    if (getValueByPath(fromObject, ['labels']) !== undefined) {\n        throw new Error('labels parameter is not supported in Gemini API.');\n    }\n    const fromCachedContent = getValueByPath(fromObject, [\n        'cachedContent',\n    ]);\n    if (parentObject !== undefined && fromCachedContent != null) {\n        setValueByPath(parentObject, ['cachedContent'], tCachedContentName(apiClient, fromCachedContent));\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        'responseModalities',\n    ]);\n    if (fromResponseModalities != null) {\n        setValueByPath(toObject, ['responseModalities'], fromResponseModalities);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        'mediaResolution',\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, ['mediaResolution'], fromMediaResolution);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, ['speechConfig']);\n    if (fromSpeechConfig != null) {\n        setValueByPath(toObject, ['speechConfig'], tSpeechConfig(fromSpeechConfig));\n    }\n    if (getValueByPath(fromObject, ['audioTimestamp']) !== undefined) {\n        throw new Error('audioTimestamp parameter is not supported in Gemini API.');\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        'thinkingConfig',\n    ]);\n    if (fromThinkingConfig != null) {\n        setValueByPath(toObject, ['thinkingConfig'], fromThinkingConfig);\n    }\n    const fromImageConfig = getValueByPath(fromObject, ['imageConfig']);\n    if (fromImageConfig != null) {\n        setValueByPath(toObject, ['imageConfig'], imageConfigToMldev$1(fromImageConfig));\n    }\n    return toObject;\n}\nfunction generateContentResponseFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromCandidates = getValueByPath(fromObject, ['candidates']);\n    if (fromCandidates != null) {\n        let transformedList = fromCandidates;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return candidateFromMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, ['candidates'], transformedList);\n    }\n    const fromModelVersion = getValueByPath(fromObject, ['modelVersion']);\n    if (fromModelVersion != null) {\n        setValueByPath(toObject, ['modelVersion'], fromModelVersion);\n    }\n    const fromPromptFeedback = getValueByPath(fromObject, [\n        'promptFeedback',\n    ]);\n    if (fromPromptFeedback != null) {\n        setValueByPath(toObject, ['promptFeedback'], fromPromptFeedback);\n    }\n    const fromResponseId = getValueByPath(fromObject, ['responseId']);\n    if (fromResponseId != null) {\n        setValueByPath(toObject, ['responseId'], fromResponseId);\n    }\n    const fromUsageMetadata = getValueByPath(fromObject, [\n        'usageMetadata',\n    ]);\n    if (fromUsageMetadata != null) {\n        setValueByPath(toObject, ['usageMetadata'], fromUsageMetadata);\n    }\n    return toObject;\n}\nfunction getBatchJobParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], tBatchJobName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction getBatchJobParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], tBatchJobName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction googleMapsToMldev$4(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['authConfig']) !== undefined) {\n        throw new Error('authConfig parameter is not supported in Gemini API.');\n    }\n    const fromEnableWidget = getValueByPath(fromObject, ['enableWidget']);\n    if (fromEnableWidget != null) {\n        setValueByPath(toObject, ['enableWidget'], fromEnableWidget);\n    }\n    return toObject;\n}\nfunction googleSearchToMldev$4(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['excludeDomains']) !== undefined) {\n        throw new Error('excludeDomains parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['blockingConfidence']) !== undefined) {\n        throw new Error('blockingConfidence parameter is not supported in Gemini API.');\n    }\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        'timeRangeFilter',\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, ['timeRangeFilter'], fromTimeRangeFilter);\n    }\n    return toObject;\n}\nfunction imageConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromAspectRatio = getValueByPath(fromObject, ['aspectRatio']);\n    if (fromAspectRatio != null) {\n        setValueByPath(toObject, ['aspectRatio'], fromAspectRatio);\n    }\n    const fromImageSize = getValueByPath(fromObject, ['imageSize']);\n    if (fromImageSize != null) {\n        setValueByPath(toObject, ['imageSize'], fromImageSize);\n    }\n    if (getValueByPath(fromObject, ['outputMimeType']) !== undefined) {\n        throw new Error('outputMimeType parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['outputCompressionQuality']) !==\n        undefined) {\n        throw new Error('outputCompressionQuality parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction inlinedRequestToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['request', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, ['contents']);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return contentToMldev$4(item);\n            });\n        }\n        setValueByPath(toObject, ['request', 'contents'], transformedList);\n    }\n    const fromMetadata = getValueByPath(fromObject, ['metadata']);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, ['metadata'], fromMetadata);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        setValueByPath(toObject, ['request', 'generationConfig'], generateContentConfigToMldev$1(apiClient, fromConfig, getValueByPath(toObject, ['request'], {})));\n    }\n    return toObject;\n}\nfunction inlinedResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromResponse = getValueByPath(fromObject, ['response']);\n    if (fromResponse != null) {\n        setValueByPath(toObject, ['response'], generateContentResponseFromMldev$1(fromResponse));\n    }\n    const fromError = getValueByPath(fromObject, ['error']);\n    if (fromError != null) {\n        setValueByPath(toObject, ['error'], fromError);\n    }\n    return toObject;\n}\nfunction listBatchJobsConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, ['pageSize']);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, ['_query', 'pageSize'], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, ['pageToken']);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, ['_query', 'pageToken'], fromPageToken);\n    }\n    if (getValueByPath(fromObject, ['filter']) !== undefined) {\n        throw new Error('filter parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction listBatchJobsConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, ['pageSize']);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, ['_query', 'pageSize'], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, ['pageToken']);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, ['_query', 'pageToken'], fromPageToken);\n    }\n    const fromFilter = getValueByPath(fromObject, ['filter']);\n    if (parentObject !== undefined && fromFilter != null) {\n        setValueByPath(parentObject, ['_query', 'filter'], fromFilter);\n    }\n    return toObject;\n}\nfunction listBatchJobsParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        listBatchJobsConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listBatchJobsParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        listBatchJobsConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listBatchJobsResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        'nextPageToken',\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, ['nextPageToken'], fromNextPageToken);\n    }\n    const fromBatchJobs = getValueByPath(fromObject, ['operations']);\n    if (fromBatchJobs != null) {\n        let transformedList = fromBatchJobs;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return batchJobFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, ['batchJobs'], transformedList);\n    }\n    return toObject;\n}\nfunction listBatchJobsResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        'nextPageToken',\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, ['nextPageToken'], fromNextPageToken);\n    }\n    const fromBatchJobs = getValueByPath(fromObject, [\n        'batchPredictionJobs',\n    ]);\n    if (fromBatchJobs != null) {\n        let transformedList = fromBatchJobs;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return batchJobFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['batchJobs'], transformedList);\n    }\n    return toObject;\n}\nfunction partToMldev$4(fromObject) {\n    const toObject = {};\n    const fromMediaResolution = getValueByPath(fromObject, [\n        'mediaResolution',\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, ['mediaResolution'], fromMediaResolution);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        'codeExecutionResult',\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, ['codeExecutionResult'], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        'executableCode',\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, ['executableCode'], fromExecutableCode);\n    }\n    const fromFileData = getValueByPath(fromObject, ['fileData']);\n    if (fromFileData != null) {\n        setValueByPath(toObject, ['fileData'], fileDataToMldev$4(fromFileData));\n    }\n    const fromFunctionCall = getValueByPath(fromObject, ['functionCall']);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, ['functionCall'], functionCallToMldev$4(fromFunctionCall));\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        'functionResponse',\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, ['functionResponse'], fromFunctionResponse);\n    }\n    const fromInlineData = getValueByPath(fromObject, ['inlineData']);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, ['inlineData'], blobToMldev$4(fromInlineData));\n    }\n    const fromText = getValueByPath(fromObject, ['text']);\n    if (fromText != null) {\n        setValueByPath(toObject, ['text'], fromText);\n    }\n    const fromThought = getValueByPath(fromObject, ['thought']);\n    if (fromThought != null) {\n        setValueByPath(toObject, ['thought'], fromThought);\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        'thoughtSignature',\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, ['thoughtSignature'], fromThoughtSignature);\n    }\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        'videoMetadata',\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, ['videoMetadata'], fromVideoMetadata);\n    }\n    return toObject;\n}\nfunction safetySettingToMldev$1(fromObject) {\n    const toObject = {};\n    const fromCategory = getValueByPath(fromObject, ['category']);\n    if (fromCategory != null) {\n        setValueByPath(toObject, ['category'], fromCategory);\n    }\n    if (getValueByPath(fromObject, ['method']) !== undefined) {\n        throw new Error('method parameter is not supported in Gemini API.');\n    }\n    const fromThreshold = getValueByPath(fromObject, ['threshold']);\n    if (fromThreshold != null) {\n        setValueByPath(toObject, ['threshold'], fromThreshold);\n    }\n    return toObject;\n}\nfunction toolConfigToMldev$2(fromObject) {\n    const toObject = {};\n    const fromFunctionCallingConfig = getValueByPath(fromObject, [\n        'functionCallingConfig',\n    ]);\n    if (fromFunctionCallingConfig != null) {\n        setValueByPath(toObject, ['functionCallingConfig'], functionCallingConfigToMldev$2(fromFunctionCallingConfig));\n    }\n    const fromRetrievalConfig = getValueByPath(fromObject, [\n        'retrievalConfig',\n    ]);\n    if (fromRetrievalConfig != null) {\n        setValueByPath(toObject, ['retrievalConfig'], fromRetrievalConfig);\n    }\n    return toObject;\n}\nfunction toolToMldev$4(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        'functionDeclarations',\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['functionDeclarations'], transformedList);\n    }\n    if (getValueByPath(fromObject, ['retrieval']) !== undefined) {\n        throw new Error('retrieval parameter is not supported in Gemini API.');\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        'googleSearchRetrieval',\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, ['googleSearchRetrieval'], fromGoogleSearchRetrieval);\n    }\n    const fromComputerUse = getValueByPath(fromObject, ['computerUse']);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, ['computerUse'], fromComputerUse);\n    }\n    const fromFileSearch = getValueByPath(fromObject, ['fileSearch']);\n    if (fromFileSearch != null) {\n        setValueByPath(toObject, ['fileSearch'], fromFileSearch);\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        'codeExecution',\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, ['codeExecution'], fromCodeExecution);\n    }\n    if (getValueByPath(fromObject, ['enterpriseWebSearch']) !== undefined) {\n        throw new Error('enterpriseWebSearch parameter is not supported in Gemini API.');\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, ['googleMaps']);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, ['googleMaps'], googleMapsToMldev$4(fromGoogleMaps));\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, ['googleSearch']);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, ['googleSearch'], googleSearchToMldev$4(fromGoogleSearch));\n    }\n    const fromUrlContext = getValueByPath(fromObject, ['urlContext']);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, ['urlContext'], fromUrlContext);\n    }\n    return toObject;\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nvar PagedItem;\n(function (PagedItem) {\n    PagedItem[\"PAGED_ITEM_BATCH_JOBS\"] = \"batchJobs\";\n    PagedItem[\"PAGED_ITEM_MODELS\"] = \"models\";\n    PagedItem[\"PAGED_ITEM_TUNING_JOBS\"] = \"tuningJobs\";\n    PagedItem[\"PAGED_ITEM_FILES\"] = \"files\";\n    PagedItem[\"PAGED_ITEM_CACHED_CONTENTS\"] = \"cachedContents\";\n    PagedItem[\"PAGED_ITEM_FILE_SEARCH_STORES\"] = \"fileSearchStores\";\n    PagedItem[\"PAGED_ITEM_DOCUMENTS\"] = \"documents\";\n})(PagedItem || (PagedItem = {}));\n/**\n * Pager class for iterating through paginated results.\n */\nclass Pager {\n    constructor(name, request, response, params) {\n        this.pageInternal = [];\n        this.paramsInternal = {};\n        this.requestInternal = request;\n        this.init(name, response, params);\n    }\n    init(name, response, params) {\n        var _a, _b;\n        this.nameInternal = name;\n        this.pageInternal = response[this.nameInternal] || [];\n        this.sdkHttpResponseInternal = response === null || response === void 0 ? void 0 : response.sdkHttpResponse;\n        this.idxInternal = 0;\n        let requestParams = { config: {} };\n        if (!params || Object.keys(params).length === 0) {\n            requestParams = { config: {} };\n        }\n        else if (typeof params === 'object') {\n            requestParams = Object.assign({}, params);\n        }\n        else {\n            requestParams = params;\n        }\n        if (requestParams['config']) {\n            requestParams['config']['pageToken'] = response['nextPageToken'];\n        }\n        this.paramsInternal = requestParams;\n        this.pageInternalSize =\n            (_b = (_a = requestParams['config']) === null || _a === void 0 ? void 0 : _a['pageSize']) !== null && _b !== void 0 ? _b : this.pageInternal.length;\n    }\n    initNextPage(response) {\n        this.init(this.nameInternal, response, this.paramsInternal);\n    }\n    /**\n     * Returns the current page, which is a list of items.\n     *\n     * @remarks\n     * The first page is retrieved when the pager is created. The returned list of\n     * items could be a subset of the entire list.\n     */\n    get page() {\n        return this.pageInternal;\n    }\n    /**\n     * Returns the type of paged item (for example, ``batch_jobs``).\n     */\n    get name() {\n        return this.nameInternal;\n    }\n    /**\n     * Returns the length of the page fetched each time by this pager.\n     *\n     * @remarks\n     * The number of items in the page is less than or equal to the page length.\n     */\n    get pageSize() {\n        return this.pageInternalSize;\n    }\n    /**\n     * Returns the headers of the API response.\n     */\n    get sdkHttpResponse() {\n        return this.sdkHttpResponseInternal;\n    }\n    /**\n     * Returns the parameters when making the API request for the next page.\n     *\n     * @remarks\n     * Parameters contain a set of optional configs that can be\n     * used to customize the API request. For example, the `pageToken` parameter\n     * contains the token to request the next page.\n     */\n    get params() {\n        return this.paramsInternal;\n    }\n    /**\n     * Returns the total number of items in the current page.\n     */\n    get pageLength() {\n        return this.pageInternal.length;\n    }\n    /**\n     * Returns the item at the given index.\n     */\n    getItem(index) {\n        return this.pageInternal[index];\n    }\n    /**\n     * Returns an async iterator that support iterating through all items\n     * retrieved from the API.\n     *\n     * @remarks\n     * The iterator will automatically fetch the next page if there are more items\n     * to fetch from the API.\n     *\n     * @example\n     *\n     * ```ts\n     * const pager = await ai.files.list({config: {pageSize: 10}});\n     * for await (const file of pager) {\n     *   console.log(file.name);\n     * }\n     * ```\n     */\n    [Symbol.asyncIterator]() {\n        return {\n            next: async () => {\n                if (this.idxInternal >= this.pageLength) {\n                    if (this.hasNextPage()) {\n                        await this.nextPage();\n                    }\n                    else {\n                        return { value: undefined, done: true };\n                    }\n                }\n                const item = this.getItem(this.idxInternal);\n                this.idxInternal += 1;\n                return { value: item, done: false };\n            },\n            return: async () => {\n                return { value: undefined, done: true };\n            },\n        };\n    }\n    /**\n     * Fetches the next page of items. This makes a new API request.\n     *\n     * @throws {Error} If there are no more pages to fetch.\n     *\n     * @example\n     *\n     * ```ts\n     * const pager = await ai.files.list({config: {pageSize: 10}});\n     * let page = pager.page;\n     * while (true) {\n     *   for (const file of page) {\n     *     console.log(file.name);\n     *   }\n     *   if (!pager.hasNextPage()) {\n     *     break;\n     *   }\n     *   page = await pager.nextPage();\n     * }\n     * ```\n     */\n    async nextPage() {\n        if (!this.hasNextPage()) {\n            throw new Error('No more pages to fetch.');\n        }\n        const response = await this.requestInternal(this.params);\n        this.initNextPage(response);\n        return this.page;\n    }\n    /**\n     * Returns true if there are more pages to fetch from the API.\n     */\n    hasNextPage() {\n        var _a;\n        if (((_a = this.params['config']) === null || _a === void 0 ? void 0 : _a['pageToken']) !== undefined) {\n            return true;\n        }\n        return false;\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nclass Batches extends BaseModule {\n    constructor(apiClient) {\n        super();\n        this.apiClient = apiClient;\n        /**\n         * Create batch job.\n         *\n         * @param params - The parameters for create batch job request.\n         * @return The created batch job.\n         *\n         * @example\n         * ```ts\n         * const response = await ai.batches.create({\n         *   model: 'gemini-2.0-flash',\n         *   src: {gcsUri: 'gs://bucket/path/to/file.jsonl', format: 'jsonl'},\n         *   config: {\n         *     dest: {gcsUri: 'gs://bucket/path/output/directory', format: 'jsonl'},\n         *   }\n         * });\n         * console.log(response);\n         * ```\n         */\n        this.create = async (params) => {\n            if (this.apiClient.isVertexAI()) {\n                // Format destination if not provided\n                // Cast params.src as Vertex AI path does not handle InlinedRequest[]\n                params.config = this.formatDestination(params.src, params.config);\n            }\n            return this.createInternal(params);\n        };\n        /**\n         * **Experimental** Creates an embedding batch job.\n         *\n         * @param params - The parameters for create embedding batch job request.\n         * @return The created batch job.\n         *\n         * @example\n         * ```ts\n         * const response = await ai.batches.createEmbeddings({\n         *   model: 'text-embedding-004',\n         *   src: {fileName: 'files/my_embedding_input'},\n         * });\n         * console.log(response);\n         * ```\n         */\n        this.createEmbeddings = async (params) => {\n            console.warn('batches.createEmbeddings() is experimental and may change without notice.');\n            if (this.apiClient.isVertexAI()) {\n                throw new Error('Vertex AI does not support batches.createEmbeddings.');\n            }\n            return this.createEmbeddingsInternal(params);\n        };\n        /**\n         * Lists batch job configurations.\n         *\n         * @param params - The parameters for the list request.\n         * @return The paginated results of the list of batch jobs.\n         *\n         * @example\n         * ```ts\n         * const batchJobs = await ai.batches.list({config: {'pageSize': 2}});\n         * for await (const batchJob of batchJobs) {\n         *   console.log(batchJob);\n         * }\n         * ```\n         */\n        this.list = async (params = {}) => {\n            return new Pager(PagedItem.PAGED_ITEM_BATCH_JOBS, (x) => this.listInternal(x), await this.listInternal(params), params);\n        };\n    }\n    // Helper function to handle inlined generate content requests\n    createInlinedGenerateContentRequest(params) {\n        const body = createBatchJobParametersToMldev(this.apiClient, // Use instance apiClient\n        params);\n        const urlParams = body['_url'];\n        const path = formatMap('{model}:batchGenerateContent', urlParams);\n        const batch = body['batch'];\n        const inputConfig = batch['inputConfig'];\n        const requestsWrapper = inputConfig['requests'];\n        const requests = requestsWrapper['requests'];\n        const newRequests = [];\n        for (const request of requests) {\n            const requestDict = Object.assign({}, request); // Clone\n            if (requestDict['systemInstruction']) {\n                const systemInstructionValue = requestDict['systemInstruction'];\n                delete requestDict['systemInstruction'];\n                const requestContent = requestDict['request'];\n                requestContent['systemInstruction'] = systemInstructionValue;\n                requestDict['request'] = requestContent;\n            }\n            newRequests.push(requestDict);\n        }\n        requestsWrapper['requests'] = newRequests;\n        delete body['config'];\n        delete body['_url'];\n        delete body['_query'];\n        return { path, body };\n    }\n    // Helper function to get the first GCS URI\n    getGcsUri(src) {\n        if (typeof src === 'string') {\n            return src.startsWith('gs://') ? src : undefined;\n        }\n        if (!Array.isArray(src) && src.gcsUri && src.gcsUri.length > 0) {\n            return src.gcsUri[0];\n        }\n        return undefined;\n    }\n    // Helper function to get the BigQuery URI\n    getBigqueryUri(src) {\n        if (typeof src === 'string') {\n            return src.startsWith('bq://') ? src : undefined;\n        }\n        if (!Array.isArray(src)) {\n            return src.bigqueryUri;\n        }\n        return undefined;\n    }\n    // Function to format the destination configuration for Vertex AI\n    formatDestination(src, config) {\n        const newConfig = config ? Object.assign({}, config) : {};\n        const timestampStr = Date.now().toString();\n        if (!newConfig.displayName) {\n            newConfig.displayName = `genaiBatchJob_${timestampStr}`;\n        }\n        if (newConfig.dest === undefined) {\n            const gcsUri = this.getGcsUri(src);\n            const bigqueryUri = this.getBigqueryUri(src);\n            if (gcsUri) {\n                if (gcsUri.endsWith('.jsonl')) {\n                    // For .jsonl files, remove suffix and add /dest\n                    newConfig.dest = `${gcsUri.slice(0, -6)}/dest`;\n                }\n                else {\n                    // Fallback for other GCS URIs\n                    newConfig.dest = `${gcsUri}_dest_${timestampStr}`;\n                }\n            }\n            else if (bigqueryUri) {\n                newConfig.dest = `${bigqueryUri}_dest_${timestampStr}`;\n            }\n            else {\n                throw new Error('Unsupported source for Vertex AI: No GCS or BigQuery URI found.');\n            }\n        }\n        return newConfig;\n    }\n    /**\n     * Internal method to create batch job.\n     *\n     * @param params - The parameters for create batch job request.\n     * @return The created batch job.\n     *\n     */\n    async createInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = createBatchJobParametersToVertex(this.apiClient, params);\n            path = formatMap('batchPredictionJobs', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = batchJobFromVertex(apiResponse);\n                return resp;\n            });\n        }\n        else {\n            const body = createBatchJobParametersToMldev(this.apiClient, params);\n            path = formatMap('{model}:batchGenerateContent', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = batchJobFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    /**\n     * Internal method to create batch job.\n     *\n     * @param params - The parameters for create batch job request.\n     * @return The created batch job.\n     *\n     */\n    async createEmbeddingsInternal(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error('This method is only supported by the Gemini Developer API.');\n        }\n        else {\n            const body = createEmbeddingsBatchJobParametersToMldev(this.apiClient, params);\n            path = formatMap('{model}:asyncBatchEmbedContent', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = batchJobFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    /**\n     * Gets batch job configurations.\n     *\n     * @param params - The parameters for the get request.\n     * @return The batch job.\n     *\n     * @example\n     * ```ts\n     * await ai.batches.get({name: '...'}); // The server-generated resource name.\n     * ```\n     */\n    async get(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = getBatchJobParametersToVertex(this.apiClient, params);\n            path = formatMap('batchPredictionJobs/{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = batchJobFromVertex(apiResponse);\n                return resp;\n            });\n        }\n        else {\n            const body = getBatchJobParametersToMldev(this.apiClient, params);\n            path = formatMap('batches/{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = batchJobFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    /**\n     * Cancels a batch job.\n     *\n     * @param params - The parameters for the cancel request.\n     * @return The empty response returned by the API.\n     *\n     * @example\n     * ```ts\n     * await ai.batches.cancel({name: '...'}); // The server-generated resource name.\n     * ```\n     */\n    async cancel(params) {\n        var _a, _b, _c, _d;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = cancelBatchJobParametersToVertex(this.apiClient, params);\n            path = formatMap('batchPredictionJobs/{name}:cancel', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            await this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            });\n        }\n        else {\n            const body = cancelBatchJobParametersToMldev(this.apiClient, params);\n            path = formatMap('batches/{name}:cancel', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            await this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            });\n        }\n    }\n    async listInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = listBatchJobsParametersToVertex(params);\n            path = formatMap('batchPredictionJobs', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = listBatchJobsResponseFromVertex(apiResponse);\n                const typedResp = new ListBatchJobsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            const body = listBatchJobsParametersToMldev(params);\n            path = formatMap('batches', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = listBatchJobsResponseFromMldev(apiResponse);\n                const typedResp = new ListBatchJobsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Deletes a batch job.\n     *\n     * @param params - The parameters for the delete request.\n     * @return The empty response returned by the API.\n     *\n     * @example\n     * ```ts\n     * await ai.batches.delete({name: '...'}); // The server-generated resource name.\n     * ```\n     */\n    async delete(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = deleteBatchJobParametersToVertex(this.apiClient, params);\n            path = formatMap('batchPredictionJobs/{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'DELETE',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = deleteResourceJobFromVertex(apiResponse);\n                return resp;\n            });\n        }\n        else {\n            const body = deleteBatchJobParametersToMldev(this.apiClient, params);\n            path = formatMap('batches/{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'DELETE',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = deleteResourceJobFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nfunction blobToMldev$3(fromObject) {\n    const toObject = {};\n    const fromData = getValueByPath(fromObject, ['data']);\n    if (fromData != null) {\n        setValueByPath(toObject, ['data'], fromData);\n    }\n    if (getValueByPath(fromObject, ['displayName']) !== undefined) {\n        throw new Error('displayName parameter is not supported in Gemini API.');\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction contentToMldev$3(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, ['parts']);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return partToMldev$3(item);\n            });\n        }\n        setValueByPath(toObject, ['parts'], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, ['role']);\n    if (fromRole != null) {\n        setValueByPath(toObject, ['role'], fromRole);\n    }\n    return toObject;\n}\nfunction createCachedContentConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromTtl = getValueByPath(fromObject, ['ttl']);\n    if (parentObject !== undefined && fromTtl != null) {\n        setValueByPath(parentObject, ['ttl'], fromTtl);\n    }\n    const fromExpireTime = getValueByPath(fromObject, ['expireTime']);\n    if (parentObject !== undefined && fromExpireTime != null) {\n        setValueByPath(parentObject, ['expireTime'], fromExpireTime);\n    }\n    const fromDisplayName = getValueByPath(fromObject, ['displayName']);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, ['displayName'], fromDisplayName);\n    }\n    const fromContents = getValueByPath(fromObject, ['contents']);\n    if (parentObject !== undefined && fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return contentToMldev$3(item);\n            });\n        }\n        setValueByPath(parentObject, ['contents'], transformedList);\n    }\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        'systemInstruction',\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, ['systemInstruction'], contentToMldev$3(tContent(fromSystemInstruction)));\n    }\n    const fromTools = getValueByPath(fromObject, ['tools']);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = fromTools;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return toolToMldev$3(item);\n            });\n        }\n        setValueByPath(parentObject, ['tools'], transformedList);\n    }\n    const fromToolConfig = getValueByPath(fromObject, ['toolConfig']);\n    if (parentObject !== undefined && fromToolConfig != null) {\n        setValueByPath(parentObject, ['toolConfig'], toolConfigToMldev$1(fromToolConfig));\n    }\n    if (getValueByPath(fromObject, ['kmsKeyName']) !== undefined) {\n        throw new Error('kmsKeyName parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction createCachedContentConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromTtl = getValueByPath(fromObject, ['ttl']);\n    if (parentObject !== undefined && fromTtl != null) {\n        setValueByPath(parentObject, ['ttl'], fromTtl);\n    }\n    const fromExpireTime = getValueByPath(fromObject, ['expireTime']);\n    if (parentObject !== undefined && fromExpireTime != null) {\n        setValueByPath(parentObject, ['expireTime'], fromExpireTime);\n    }\n    const fromDisplayName = getValueByPath(fromObject, ['displayName']);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, ['displayName'], fromDisplayName);\n    }\n    const fromContents = getValueByPath(fromObject, ['contents']);\n    if (parentObject !== undefined && fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(parentObject, ['contents'], transformedList);\n    }\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        'systemInstruction',\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, ['systemInstruction'], tContent(fromSystemInstruction));\n    }\n    const fromTools = getValueByPath(fromObject, ['tools']);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = fromTools;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return toolToVertex$2(item);\n            });\n        }\n        setValueByPath(parentObject, ['tools'], transformedList);\n    }\n    const fromToolConfig = getValueByPath(fromObject, ['toolConfig']);\n    if (parentObject !== undefined && fromToolConfig != null) {\n        setValueByPath(parentObject, ['toolConfig'], fromToolConfig);\n    }\n    const fromKmsKeyName = getValueByPath(fromObject, ['kmsKeyName']);\n    if (parentObject !== undefined && fromKmsKeyName != null) {\n        setValueByPath(parentObject, ['encryption_spec', 'kmsKeyName'], fromKmsKeyName);\n    }\n    return toObject;\n}\nfunction createCachedContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['model'], tCachesModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        createCachedContentConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction createCachedContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['model'], tCachesModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        createCachedContentConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction deleteCachedContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], tCachedContentName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction deleteCachedContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], tCachedContentName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction deleteCachedContentResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    return toObject;\n}\nfunction deleteCachedContentResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    return toObject;\n}\nfunction fileDataToMldev$3(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['displayName']) !== undefined) {\n        throw new Error('displayName parameter is not supported in Gemini API.');\n    }\n    const fromFileUri = getValueByPath(fromObject, ['fileUri']);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, ['fileUri'], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction functionCallToMldev$3(fromObject) {\n    const toObject = {};\n    const fromId = getValueByPath(fromObject, ['id']);\n    if (fromId != null) {\n        setValueByPath(toObject, ['id'], fromId);\n    }\n    const fromArgs = getValueByPath(fromObject, ['args']);\n    if (fromArgs != null) {\n        setValueByPath(toObject, ['args'], fromArgs);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    if (getValueByPath(fromObject, ['partialArgs']) !== undefined) {\n        throw new Error('partialArgs parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['willContinue']) !== undefined) {\n        throw new Error('willContinue parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction functionCallingConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, ['mode']);\n    if (fromMode != null) {\n        setValueByPath(toObject, ['mode'], fromMode);\n    }\n    const fromAllowedFunctionNames = getValueByPath(fromObject, [\n        'allowedFunctionNames',\n    ]);\n    if (fromAllowedFunctionNames != null) {\n        setValueByPath(toObject, ['allowedFunctionNames'], fromAllowedFunctionNames);\n    }\n    if (getValueByPath(fromObject, ['streamFunctionCallArguments']) !==\n        undefined) {\n        throw new Error('streamFunctionCallArguments parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction functionDeclarationToVertex$2(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['behavior']) !== undefined) {\n        throw new Error('behavior parameter is not supported in Vertex AI.');\n    }\n    const fromDescription = getValueByPath(fromObject, ['description']);\n    if (fromDescription != null) {\n        setValueByPath(toObject, ['description'], fromDescription);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromParameters = getValueByPath(fromObject, ['parameters']);\n    if (fromParameters != null) {\n        setValueByPath(toObject, ['parameters'], fromParameters);\n    }\n    const fromParametersJsonSchema = getValueByPath(fromObject, [\n        'parametersJsonSchema',\n    ]);\n    if (fromParametersJsonSchema != null) {\n        setValueByPath(toObject, ['parametersJsonSchema'], fromParametersJsonSchema);\n    }\n    const fromResponse = getValueByPath(fromObject, ['response']);\n    if (fromResponse != null) {\n        setValueByPath(toObject, ['response'], fromResponse);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        'responseJsonSchema',\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, ['responseJsonSchema'], fromResponseJsonSchema);\n    }\n    return toObject;\n}\nfunction getCachedContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], tCachedContentName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction getCachedContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], tCachedContentName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction googleMapsToMldev$3(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['authConfig']) !== undefined) {\n        throw new Error('authConfig parameter is not supported in Gemini API.');\n    }\n    const fromEnableWidget = getValueByPath(fromObject, ['enableWidget']);\n    if (fromEnableWidget != null) {\n        setValueByPath(toObject, ['enableWidget'], fromEnableWidget);\n    }\n    return toObject;\n}\nfunction googleSearchToMldev$3(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['excludeDomains']) !== undefined) {\n        throw new Error('excludeDomains parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['blockingConfidence']) !== undefined) {\n        throw new Error('blockingConfidence parameter is not supported in Gemini API.');\n    }\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        'timeRangeFilter',\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, ['timeRangeFilter'], fromTimeRangeFilter);\n    }\n    return toObject;\n}\nfunction listCachedContentsConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, ['pageSize']);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, ['_query', 'pageSize'], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, ['pageToken']);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, ['_query', 'pageToken'], fromPageToken);\n    }\n    return toObject;\n}\nfunction listCachedContentsConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, ['pageSize']);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, ['_query', 'pageSize'], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, ['pageToken']);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, ['_query', 'pageToken'], fromPageToken);\n    }\n    return toObject;\n}\nfunction listCachedContentsParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        listCachedContentsConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listCachedContentsParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        listCachedContentsConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listCachedContentsResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        'nextPageToken',\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, ['nextPageToken'], fromNextPageToken);\n    }\n    const fromCachedContents = getValueByPath(fromObject, [\n        'cachedContents',\n    ]);\n    if (fromCachedContents != null) {\n        let transformedList = fromCachedContents;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['cachedContents'], transformedList);\n    }\n    return toObject;\n}\nfunction listCachedContentsResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        'nextPageToken',\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, ['nextPageToken'], fromNextPageToken);\n    }\n    const fromCachedContents = getValueByPath(fromObject, [\n        'cachedContents',\n    ]);\n    if (fromCachedContents != null) {\n        let transformedList = fromCachedContents;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['cachedContents'], transformedList);\n    }\n    return toObject;\n}\nfunction partToMldev$3(fromObject) {\n    const toObject = {};\n    const fromMediaResolution = getValueByPath(fromObject, [\n        'mediaResolution',\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, ['mediaResolution'], fromMediaResolution);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        'codeExecutionResult',\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, ['codeExecutionResult'], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        'executableCode',\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, ['executableCode'], fromExecutableCode);\n    }\n    const fromFileData = getValueByPath(fromObject, ['fileData']);\n    if (fromFileData != null) {\n        setValueByPath(toObject, ['fileData'], fileDataToMldev$3(fromFileData));\n    }\n    const fromFunctionCall = getValueByPath(fromObject, ['functionCall']);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, ['functionCall'], functionCallToMldev$3(fromFunctionCall));\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        'functionResponse',\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, ['functionResponse'], fromFunctionResponse);\n    }\n    const fromInlineData = getValueByPath(fromObject, ['inlineData']);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, ['inlineData'], blobToMldev$3(fromInlineData));\n    }\n    const fromText = getValueByPath(fromObject, ['text']);\n    if (fromText != null) {\n        setValueByPath(toObject, ['text'], fromText);\n    }\n    const fromThought = getValueByPath(fromObject, ['thought']);\n    if (fromThought != null) {\n        setValueByPath(toObject, ['thought'], fromThought);\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        'thoughtSignature',\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, ['thoughtSignature'], fromThoughtSignature);\n    }\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        'videoMetadata',\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, ['videoMetadata'], fromVideoMetadata);\n    }\n    return toObject;\n}\nfunction toolConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromFunctionCallingConfig = getValueByPath(fromObject, [\n        'functionCallingConfig',\n    ]);\n    if (fromFunctionCallingConfig != null) {\n        setValueByPath(toObject, ['functionCallingConfig'], functionCallingConfigToMldev$1(fromFunctionCallingConfig));\n    }\n    const fromRetrievalConfig = getValueByPath(fromObject, [\n        'retrievalConfig',\n    ]);\n    if (fromRetrievalConfig != null) {\n        setValueByPath(toObject, ['retrievalConfig'], fromRetrievalConfig);\n    }\n    return toObject;\n}\nfunction toolToMldev$3(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        'functionDeclarations',\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['functionDeclarations'], transformedList);\n    }\n    if (getValueByPath(fromObject, ['retrieval']) !== undefined) {\n        throw new Error('retrieval parameter is not supported in Gemini API.');\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        'googleSearchRetrieval',\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, ['googleSearchRetrieval'], fromGoogleSearchRetrieval);\n    }\n    const fromComputerUse = getValueByPath(fromObject, ['computerUse']);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, ['computerUse'], fromComputerUse);\n    }\n    const fromFileSearch = getValueByPath(fromObject, ['fileSearch']);\n    if (fromFileSearch != null) {\n        setValueByPath(toObject, ['fileSearch'], fromFileSearch);\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        'codeExecution',\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, ['codeExecution'], fromCodeExecution);\n    }\n    if (getValueByPath(fromObject, ['enterpriseWebSearch']) !== undefined) {\n        throw new Error('enterpriseWebSearch parameter is not supported in Gemini API.');\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, ['googleMaps']);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, ['googleMaps'], googleMapsToMldev$3(fromGoogleMaps));\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, ['googleSearch']);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, ['googleSearch'], googleSearchToMldev$3(fromGoogleSearch));\n    }\n    const fromUrlContext = getValueByPath(fromObject, ['urlContext']);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, ['urlContext'], fromUrlContext);\n    }\n    return toObject;\n}\nfunction toolToVertex$2(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        'functionDeclarations',\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return functionDeclarationToVertex$2(item);\n            });\n        }\n        setValueByPath(toObject, ['functionDeclarations'], transformedList);\n    }\n    const fromRetrieval = getValueByPath(fromObject, ['retrieval']);\n    if (fromRetrieval != null) {\n        setValueByPath(toObject, ['retrieval'], fromRetrieval);\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        'googleSearchRetrieval',\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, ['googleSearchRetrieval'], fromGoogleSearchRetrieval);\n    }\n    const fromComputerUse = getValueByPath(fromObject, ['computerUse']);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, ['computerUse'], fromComputerUse);\n    }\n    if (getValueByPath(fromObject, ['fileSearch']) !== undefined) {\n        throw new Error('fileSearch parameter is not supported in Vertex AI.');\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        'codeExecution',\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, ['codeExecution'], fromCodeExecution);\n    }\n    const fromEnterpriseWebSearch = getValueByPath(fromObject, [\n        'enterpriseWebSearch',\n    ]);\n    if (fromEnterpriseWebSearch != null) {\n        setValueByPath(toObject, ['enterpriseWebSearch'], fromEnterpriseWebSearch);\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, ['googleMaps']);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, ['googleMaps'], fromGoogleMaps);\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, ['googleSearch']);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, ['googleSearch'], fromGoogleSearch);\n    }\n    const fromUrlContext = getValueByPath(fromObject, ['urlContext']);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, ['urlContext'], fromUrlContext);\n    }\n    return toObject;\n}\nfunction updateCachedContentConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromTtl = getValueByPath(fromObject, ['ttl']);\n    if (parentObject !== undefined && fromTtl != null) {\n        setValueByPath(parentObject, ['ttl'], fromTtl);\n    }\n    const fromExpireTime = getValueByPath(fromObject, ['expireTime']);\n    if (parentObject !== undefined && fromExpireTime != null) {\n        setValueByPath(parentObject, ['expireTime'], fromExpireTime);\n    }\n    return toObject;\n}\nfunction updateCachedContentConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromTtl = getValueByPath(fromObject, ['ttl']);\n    if (parentObject !== undefined && fromTtl != null) {\n        setValueByPath(parentObject, ['ttl'], fromTtl);\n    }\n    const fromExpireTime = getValueByPath(fromObject, ['expireTime']);\n    if (parentObject !== undefined && fromExpireTime != null) {\n        setValueByPath(parentObject, ['expireTime'], fromExpireTime);\n    }\n    return toObject;\n}\nfunction updateCachedContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], tCachedContentName(apiClient, fromName));\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        updateCachedContentConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction updateCachedContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], tCachedContentName(apiClient, fromName));\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        updateCachedContentConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nclass Caches extends BaseModule {\n    constructor(apiClient) {\n        super();\n        this.apiClient = apiClient;\n        /**\n         * Lists cached content configurations.\n         *\n         * @param params - The parameters for the list request.\n         * @return The paginated results of the list of cached contents.\n         *\n         * @example\n         * ```ts\n         * const cachedContents = await ai.caches.list({config: {'pageSize': 2}});\n         * for await (const cachedContent of cachedContents) {\n         *   console.log(cachedContent);\n         * }\n         * ```\n         */\n        this.list = async (params = {}) => {\n            return new Pager(PagedItem.PAGED_ITEM_CACHED_CONTENTS, (x) => this.listInternal(x), await this.listInternal(params), params);\n        };\n    }\n    /**\n     * Creates a cached contents resource.\n     *\n     * @remarks\n     * Context caching is only supported for specific models. See [Gemini\n     * Developer API reference](https://ai.google.dev/gemini-api/docs/caching?lang=node/context-cac)\n     * and [Vertex AI reference](https://cloud.google.com/vertex-ai/generative-ai/docs/context-cache/context-cache-overview#supported_models)\n     * for more information.\n     *\n     * @param params - The parameters for the create request.\n     * @return The created cached content.\n     *\n     * @example\n     * ```ts\n     * const contents = ...; // Initialize the content to cache.\n     * const response = await ai.caches.create({\n     *   model: 'gemini-2.0-flash-001',\n     *   config: {\n     *    'contents': contents,\n     *    'displayName': 'test cache',\n     *    'systemInstruction': 'What is the sum of the two pdfs?',\n     *    'ttl': '86400s',\n     *  }\n     * });\n     * ```\n     */\n    async create(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = createCachedContentParametersToVertex(this.apiClient, params);\n            path = formatMap('cachedContents', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((resp) => {\n                return resp;\n            });\n        }\n        else {\n            const body = createCachedContentParametersToMldev(this.apiClient, params);\n            path = formatMap('cachedContents', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((resp) => {\n                return resp;\n            });\n        }\n    }\n    /**\n     * Gets cached content configurations.\n     *\n     * @param params - The parameters for the get request.\n     * @return The cached content.\n     *\n     * @example\n     * ```ts\n     * await ai.caches.get({name: '...'}); // The server-generated resource name.\n     * ```\n     */\n    async get(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = getCachedContentParametersToVertex(this.apiClient, params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((resp) => {\n                return resp;\n            });\n        }\n        else {\n            const body = getCachedContentParametersToMldev(this.apiClient, params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((resp) => {\n                return resp;\n            });\n        }\n    }\n    /**\n     * Deletes cached content.\n     *\n     * @param params - The parameters for the delete request.\n     * @return The empty response returned by the API.\n     *\n     * @example\n     * ```ts\n     * await ai.caches.delete({name: '...'}); // The server-generated resource name.\n     * ```\n     */\n    async delete(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = deleteCachedContentParametersToVertex(this.apiClient, params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'DELETE',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = deleteCachedContentResponseFromVertex(apiResponse);\n                const typedResp = new DeleteCachedContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            const body = deleteCachedContentParametersToMldev(this.apiClient, params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'DELETE',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = deleteCachedContentResponseFromMldev(apiResponse);\n                const typedResp = new DeleteCachedContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Updates cached content configurations.\n     *\n     * @param params - The parameters for the update request.\n     * @return The updated cached content.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.caches.update({\n     *   name: '...',  // The server-generated resource name.\n     *   config: {'ttl': '7600s'}\n     * });\n     * ```\n     */\n    async update(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = updateCachedContentParametersToVertex(this.apiClient, params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'PATCH',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((resp) => {\n                return resp;\n            });\n        }\n        else {\n            const body = updateCachedContentParametersToMldev(this.apiClient, params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'PATCH',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((resp) => {\n                return resp;\n            });\n        }\n    }\n    async listInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = listCachedContentsParametersToVertex(params);\n            path = formatMap('cachedContents', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = listCachedContentsResponseFromVertex(apiResponse);\n                const typedResp = new ListCachedContentsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            const body = listCachedContentsParametersToMldev(params);\n            path = formatMap('cachedContents', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = listCachedContentsResponseFromMldev(apiResponse);\n                const typedResp = new ListCachedContentsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n}\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\r\n\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\r\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * Returns true if the response is valid, false otherwise.\n */\nfunction isValidResponse(response) {\n    var _a;\n    if (response.candidates == undefined || response.candidates.length === 0) {\n        return false;\n    }\n    const content = (_a = response.candidates[0]) === null || _a === void 0 ? void 0 : _a.content;\n    if (content === undefined) {\n        return false;\n    }\n    return isValidContent(content);\n}\nfunction isValidContent(content) {\n    if (content.parts === undefined || content.parts.length === 0) {\n        return false;\n    }\n    for (const part of content.parts) {\n        if (part === undefined || Object.keys(part).length === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Validates the history contains the correct roles.\n *\n * @throws Error if the history does not start with a user turn.\n * @throws Error if the history contains an invalid role.\n */\nfunction validateHistory(history) {\n    // Empty history is valid.\n    if (history.length === 0) {\n        return;\n    }\n    for (const content of history) {\n        if (content.role !== 'user' && content.role !== 'model') {\n            throw new Error(`Role must be user or model, but got ${content.role}.`);\n        }\n    }\n}\n/**\n * Extracts the curated (valid) history from a comprehensive history.\n *\n * @remarks\n * The model may sometimes generate invalid or empty contents(e.g., due to safty\n * filters or recitation). Extracting valid turns from the history\n * ensures that subsequent requests could be accpeted by the model.\n */\nfunction extractCuratedHistory(comprehensiveHistory) {\n    if (comprehensiveHistory === undefined || comprehensiveHistory.length === 0) {\n        return [];\n    }\n    const curatedHistory = [];\n    const length = comprehensiveHistory.length;\n    let i = 0;\n    while (i < length) {\n        if (comprehensiveHistory[i].role === 'user') {\n            curatedHistory.push(comprehensiveHistory[i]);\n            i++;\n        }\n        else {\n            const modelOutput = [];\n            let isValid = true;\n            while (i < length && comprehensiveHistory[i].role === 'model') {\n                modelOutput.push(comprehensiveHistory[i]);\n                if (isValid && !isValidContent(comprehensiveHistory[i])) {\n                    isValid = false;\n                }\n                i++;\n            }\n            if (isValid) {\n                curatedHistory.push(...modelOutput);\n            }\n            else {\n                // Remove the last user input when model content is invalid.\n                curatedHistory.pop();\n            }\n        }\n    }\n    return curatedHistory;\n}\n/**\n * A utility class to create a chat session.\n */\nclass Chats {\n    constructor(modelsModule, apiClient) {\n        this.modelsModule = modelsModule;\n        this.apiClient = apiClient;\n    }\n    /**\n     * Creates a new chat session.\n     *\n     * @remarks\n     * The config in the params will be used for all requests within the chat\n     * session unless overridden by a per-request `config` in\n     * @see {@link types.SendMessageParameters#config}.\n     *\n     * @param params - Parameters for creating a chat session.\n     * @returns A new chat session.\n     *\n     * @example\n     * ```ts\n     * const chat = ai.chats.create({\n     *   model: 'gemini-2.0-flash'\n     *   config: {\n     *     temperature: 0.5,\n     *     maxOutputTokens: 1024,\n     *   }\n     * });\n     * ```\n     */\n    create(params) {\n        return new Chat(this.apiClient, this.modelsModule, params.model, params.config, \n        // Deep copy the history to avoid mutating the history outside of the\n        // chat session.\n        structuredClone(params.history));\n    }\n}\n/**\n * Chat session that enables sending messages to the model with previous\n * conversation context.\n *\n * @remarks\n * The session maintains all the turns between user and model.\n */\nclass Chat {\n    constructor(apiClient, modelsModule, model, config = {}, history = []) {\n        this.apiClient = apiClient;\n        this.modelsModule = modelsModule;\n        this.model = model;\n        this.config = config;\n        this.history = history;\n        // A promise to represent the current state of the message being sent to the\n        // model.\n        this.sendPromise = Promise.resolve();\n        validateHistory(history);\n    }\n    /**\n     * Sends a message to the model and returns the response.\n     *\n     * @remarks\n     * This method will wait for the previous message to be processed before\n     * sending the next message.\n     *\n     * @see {@link Chat#sendMessageStream} for streaming method.\n     * @param params - parameters for sending messages within a chat session.\n     * @returns The model's response.\n     *\n     * @example\n     * ```ts\n     * const chat = ai.chats.create({model: 'gemini-2.0-flash'});\n     * const response = await chat.sendMessage({\n     *   message: 'Why is the sky blue?'\n     * });\n     * console.log(response.text);\n     * ```\n     */\n    async sendMessage(params) {\n        var _a;\n        await this.sendPromise;\n        const inputContent = tContent(params.message);\n        const responsePromise = this.modelsModule.generateContent({\n            model: this.model,\n            contents: this.getHistory(true).concat(inputContent),\n            config: (_a = params.config) !== null && _a !== void 0 ? _a : this.config,\n        });\n        this.sendPromise = (async () => {\n            var _a, _b, _c;\n            const response = await responsePromise;\n            const outputContent = (_b = (_a = response.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content;\n            // Because the AFC input contains the entire curated chat history in\n            // addition to the new user input, we need to truncate the AFC history\n            // to deduplicate the existing chat history.\n            const fullAutomaticFunctionCallingHistory = response.automaticFunctionCallingHistory;\n            const index = this.getHistory(true).length;\n            let automaticFunctionCallingHistory = [];\n            if (fullAutomaticFunctionCallingHistory != null) {\n                automaticFunctionCallingHistory =\n                    (_c = fullAutomaticFunctionCallingHistory.slice(index)) !== null && _c !== void 0 ? _c : [];\n            }\n            const modelOutput = outputContent ? [outputContent] : [];\n            this.recordHistory(inputContent, modelOutput, automaticFunctionCallingHistory);\n            return;\n        })();\n        await this.sendPromise.catch(() => {\n            // Resets sendPromise to avoid subsequent calls failing\n            this.sendPromise = Promise.resolve();\n        });\n        return responsePromise;\n    }\n    /**\n     * Sends a message to the model and returns the response in chunks.\n     *\n     * @remarks\n     * This method will wait for the previous message to be processed before\n     * sending the next message.\n     *\n     * @see {@link Chat#sendMessage} for non-streaming method.\n     * @param params - parameters for sending the message.\n     * @return The model's response.\n     *\n     * @example\n     * ```ts\n     * const chat = ai.chats.create({model: 'gemini-2.0-flash'});\n     * const response = await chat.sendMessageStream({\n     *   message: 'Why is the sky blue?'\n     * });\n     * for await (const chunk of response) {\n     *   console.log(chunk.text);\n     * }\n     * ```\n     */\n    async sendMessageStream(params) {\n        var _a;\n        await this.sendPromise;\n        const inputContent = tContent(params.message);\n        const streamResponse = this.modelsModule.generateContentStream({\n            model: this.model,\n            contents: this.getHistory(true).concat(inputContent),\n            config: (_a = params.config) !== null && _a !== void 0 ? _a : this.config,\n        });\n        // Resolve the internal tracking of send completion promise - `sendPromise`\n        // for both success and failure response. The actual failure is still\n        // propagated by the `await streamResponse`.\n        this.sendPromise = streamResponse\n            .then(() => undefined)\n            .catch(() => undefined);\n        const response = await streamResponse;\n        const result = this.processStreamResponse(response, inputContent);\n        return result;\n    }\n    /**\n     * Returns the chat history.\n     *\n     * @remarks\n     * The history is a list of contents alternating between user and model.\n     *\n     * There are two types of history:\n     * - The `curated history` contains only the valid turns between user and\n     * model, which will be included in the subsequent requests sent to the model.\n     * - The `comprehensive history` contains all turns, including invalid or\n     *   empty model outputs, providing a complete record of the history.\n     *\n     * The history is updated after receiving the response from the model,\n     * for streaming response, it means receiving the last chunk of the response.\n     *\n     * The `comprehensive history` is returned by default. To get the `curated\n     * history`, set the `curated` parameter to `true`.\n     *\n     * @param curated - whether to return the curated history or the comprehensive\n     *     history.\n     * @return History contents alternating between user and model for the entire\n     *     chat session.\n     */\n    getHistory(curated = false) {\n        const history = curated\n            ? extractCuratedHistory(this.history)\n            : this.history;\n        // Deep copy the history to avoid mutating the history outside of the\n        // chat session.\n        return structuredClone(history);\n    }\n    processStreamResponse(streamResponse, inputContent) {\n        var _a, _b;\n        return __asyncGenerator(this, arguments, function* processStreamResponse_1() {\n            var _c, e_1, _d, _e;\n            const outputContent = [];\n            try {\n                for (var _f = true, streamResponse_1 = __asyncValues(streamResponse), streamResponse_1_1; streamResponse_1_1 = yield __await(streamResponse_1.next()), _c = streamResponse_1_1.done, !_c; _f = true) {\n                    _e = streamResponse_1_1.value;\n                    _f = false;\n                    const chunk = _e;\n                    if (isValidResponse(chunk)) {\n                        const content = (_b = (_a = chunk.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content;\n                        if (content !== undefined) {\n                            outputContent.push(content);\n                        }\n                    }\n                    yield yield __await(chunk);\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (!_f && !_c && (_d = streamResponse_1.return)) yield __await(_d.call(streamResponse_1));\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            this.recordHistory(inputContent, outputContent);\n        });\n    }\n    recordHistory(userInput, modelOutput, automaticFunctionCallingHistory) {\n        let outputContents = [];\n        if (modelOutput.length > 0 &&\n            modelOutput.every((content) => content.role !== undefined)) {\n            outputContents = modelOutput;\n        }\n        else {\n            // Appends an empty content when model returns empty response, so that the\n            // history is always alternating between user and model.\n            outputContents.push({\n                role: 'model',\n                parts: [],\n            });\n        }\n        if (automaticFunctionCallingHistory &&\n            automaticFunctionCallingHistory.length > 0) {\n            this.history.push(...extractCuratedHistory(automaticFunctionCallingHistory));\n        }\n        else {\n            this.history.push(userInput);\n        }\n        this.history.push(...outputContents);\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * API errors raised by the GenAI API.\n */\nclass ApiError extends Error {\n    constructor(options) {\n        super(options.message);\n        this.name = 'ApiError';\n        this.status = options.status;\n        Object.setPrototypeOf(this, ApiError.prototype);\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n// Code generated by the Google Gen AI SDK generator DO NOT EDIT.\nfunction createFileParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromFile = getValueByPath(fromObject, ['file']);\n    if (fromFile != null) {\n        setValueByPath(toObject, ['file'], fromFile);\n    }\n    return toObject;\n}\nfunction createFileResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    return toObject;\n}\nfunction deleteFileParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'file'], tFileName(fromName));\n    }\n    return toObject;\n}\nfunction deleteFileResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    return toObject;\n}\nfunction getFileParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'file'], tFileName(fromName));\n    }\n    return toObject;\n}\nfunction listFilesConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, ['pageSize']);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, ['_query', 'pageSize'], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, ['pageToken']);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, ['_query', 'pageToken'], fromPageToken);\n    }\n    return toObject;\n}\nfunction listFilesParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        listFilesConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listFilesResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        'nextPageToken',\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, ['nextPageToken'], fromNextPageToken);\n    }\n    const fromFiles = getValueByPath(fromObject, ['files']);\n    if (fromFiles != null) {\n        let transformedList = fromFiles;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['files'], transformedList);\n    }\n    return toObject;\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nclass Files extends BaseModule {\n    constructor(apiClient) {\n        super();\n        this.apiClient = apiClient;\n        /**\n         * Lists all current project files from the service.\n         *\n         * @param params - The parameters for the list request\n         * @return The paginated results of the list of files\n         *\n         * @example\n         * The following code prints the names of all files from the service, the\n         * size of each page is 10.\n         *\n         * ```ts\n         * const listResponse = await ai.files.list({config: {'pageSize': 10}});\n         * for await (const file of listResponse) {\n         *   console.log(file.name);\n         * }\n         * ```\n         */\n        this.list = async (params = {}) => {\n            return new Pager(PagedItem.PAGED_ITEM_FILES, (x) => this.listInternal(x), await this.listInternal(params), params);\n        };\n    }\n    /**\n     * Uploads a file asynchronously to the Gemini API.\n     * This method is not available in Vertex AI.\n     * Supported upload sources:\n     * - Node.js: File path (string) or Blob object.\n     * - Browser: Blob object (e.g., File).\n     *\n     * @remarks\n     * The `mimeType` can be specified in the `config` parameter. If omitted:\n     *  - For file path (string) inputs, the `mimeType` will be inferred from the\n     *     file extension.\n     *  - For Blob object inputs, the `mimeType` will be set to the Blob's `type`\n     *     property.\n     * Somex eamples for file extension to mimeType mapping:\n     * .txt -> text/plain\n     * .json -> application/json\n     * .jpg  -> image/jpeg\n     * .png -> image/png\n     * .mp3 -> audio/mpeg\n     * .mp4 -> video/mp4\n     *\n     * This section can contain multiple paragraphs and code examples.\n     *\n     * @param params - Optional parameters specified in the\n     *        `types.UploadFileParameters` interface.\n     *         @see {@link types.UploadFileParameters#config} for the optional\n     *         config in the parameters.\n     * @return A promise that resolves to a `types.File` object.\n     * @throws An error if called on a Vertex AI client.\n     * @throws An error if the `mimeType` is not provided and can not be inferred,\n     * the `mimeType` can be provided in the `params.config` parameter.\n     * @throws An error occurs if a suitable upload location cannot be established.\n     *\n     * @example\n     * The following code uploads a file to Gemini API.\n     *\n     * ```ts\n     * const file = await ai.files.upload({file: 'file.txt', config: {\n     *   mimeType: 'text/plain',\n     * }});\n     * console.log(file.name);\n     * ```\n     */\n    async upload(params) {\n        if (this.apiClient.isVertexAI()) {\n            throw new Error('Vertex AI does not support uploading files. You can share files through a GCS bucket.');\n        }\n        return this.apiClient\n            .uploadFile(params.file, params.config)\n            .then((resp) => {\n            return resp;\n        });\n    }\n    /**\n     * Downloads a remotely stored file asynchronously to a location specified in\n     * the `params` object. This method only works on Node environment, to\n     * download files in the browser, use a browser compliant method like an <a>\n     * tag.\n     *\n     * @param params - The parameters for the download request.\n     *\n     * @example\n     * The following code downloads an example file named \"files/mehozpxf877d\" as\n     * \"file.txt\".\n     *\n     * ```ts\n     * await ai.files.download({file: file.name, downloadPath: 'file.txt'});\n     * ```\n     */\n    async download(params) {\n        await this.apiClient.downloadFile(params);\n    }\n    async listInternal(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error('This method is only supported by the Gemini Developer API.');\n        }\n        else {\n            const body = listFilesParametersToMldev(params);\n            path = formatMap('files', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = listFilesResponseFromMldev(apiResponse);\n                const typedResp = new ListFilesResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    async createInternal(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error('This method is only supported by the Gemini Developer API.');\n        }\n        else {\n            const body = createFileParametersToMldev(params);\n            path = formatMap('upload/v1beta/files', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = createFileResponseFromMldev(apiResponse);\n                const typedResp = new CreateFileResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Retrieves the file information from the service.\n     *\n     * @param params - The parameters for the get request\n     * @return The Promise that resolves to the types.File object requested.\n     *\n     * @example\n     * ```ts\n     * const config: GetFileParameters = {\n     *   name: fileName,\n     * };\n     * file = await ai.files.get(config);\n     * console.log(file.name);\n     * ```\n     */\n    async get(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error('This method is only supported by the Gemini Developer API.');\n        }\n        else {\n            const body = getFileParametersToMldev(params);\n            path = formatMap('files/{file}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((resp) => {\n                return resp;\n            });\n        }\n    }\n    /**\n     * Deletes a remotely stored file.\n     *\n     * @param params - The parameters for the delete request.\n     * @return The DeleteFileResponse, the response for the delete method.\n     *\n     * @example\n     * The following code deletes an example file named \"files/mehozpxf877d\".\n     *\n     * ```ts\n     * await ai.files.delete({name: file.name});\n     * ```\n     */\n    async delete(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error('This method is only supported by the Gemini Developer API.');\n        }\n        else {\n            const body = deleteFileParametersToMldev(params);\n            path = formatMap('files/{file}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'DELETE',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = deleteFileResponseFromMldev(apiResponse);\n                const typedResp = new DeleteFileResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nfunction blobToMldev$2(fromObject) {\n    const toObject = {};\n    const fromData = getValueByPath(fromObject, ['data']);\n    if (fromData != null) {\n        setValueByPath(toObject, ['data'], fromData);\n    }\n    if (getValueByPath(fromObject, ['displayName']) !== undefined) {\n        throw new Error('displayName parameter is not supported in Gemini API.');\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction contentToMldev$2(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, ['parts']);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return partToMldev$2(item);\n            });\n        }\n        setValueByPath(toObject, ['parts'], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, ['role']);\n    if (fromRole != null) {\n        setValueByPath(toObject, ['role'], fromRole);\n    }\n    return toObject;\n}\nfunction fileDataToMldev$2(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['displayName']) !== undefined) {\n        throw new Error('displayName parameter is not supported in Gemini API.');\n    }\n    const fromFileUri = getValueByPath(fromObject, ['fileUri']);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, ['fileUri'], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction functionCallToMldev$2(fromObject) {\n    const toObject = {};\n    const fromId = getValueByPath(fromObject, ['id']);\n    if (fromId != null) {\n        setValueByPath(toObject, ['id'], fromId);\n    }\n    const fromArgs = getValueByPath(fromObject, ['args']);\n    if (fromArgs != null) {\n        setValueByPath(toObject, ['args'], fromArgs);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    if (getValueByPath(fromObject, ['partialArgs']) !== undefined) {\n        throw new Error('partialArgs parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['willContinue']) !== undefined) {\n        throw new Error('willContinue parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction functionDeclarationToVertex$1(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['behavior']) !== undefined) {\n        throw new Error('behavior parameter is not supported in Vertex AI.');\n    }\n    const fromDescription = getValueByPath(fromObject, ['description']);\n    if (fromDescription != null) {\n        setValueByPath(toObject, ['description'], fromDescription);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromParameters = getValueByPath(fromObject, ['parameters']);\n    if (fromParameters != null) {\n        setValueByPath(toObject, ['parameters'], fromParameters);\n    }\n    const fromParametersJsonSchema = getValueByPath(fromObject, [\n        'parametersJsonSchema',\n    ]);\n    if (fromParametersJsonSchema != null) {\n        setValueByPath(toObject, ['parametersJsonSchema'], fromParametersJsonSchema);\n    }\n    const fromResponse = getValueByPath(fromObject, ['response']);\n    if (fromResponse != null) {\n        setValueByPath(toObject, ['response'], fromResponse);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        'responseJsonSchema',\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, ['responseJsonSchema'], fromResponseJsonSchema);\n    }\n    return toObject;\n}\nfunction generationConfigToVertex$1(fromObject) {\n    const toObject = {};\n    const fromModelSelectionConfig = getValueByPath(fromObject, [\n        'modelSelectionConfig',\n    ]);\n    if (fromModelSelectionConfig != null) {\n        setValueByPath(toObject, ['modelConfig'], fromModelSelectionConfig);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        'responseJsonSchema',\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, ['responseJsonSchema'], fromResponseJsonSchema);\n    }\n    const fromAudioTimestamp = getValueByPath(fromObject, [\n        'audioTimestamp',\n    ]);\n    if (fromAudioTimestamp != null) {\n        setValueByPath(toObject, ['audioTimestamp'], fromAudioTimestamp);\n    }\n    const fromCandidateCount = getValueByPath(fromObject, [\n        'candidateCount',\n    ]);\n    if (fromCandidateCount != null) {\n        setValueByPath(toObject, ['candidateCount'], fromCandidateCount);\n    }\n    const fromEnableAffectiveDialog = getValueByPath(fromObject, [\n        'enableAffectiveDialog',\n    ]);\n    if (fromEnableAffectiveDialog != null) {\n        setValueByPath(toObject, ['enableAffectiveDialog'], fromEnableAffectiveDialog);\n    }\n    const fromFrequencyPenalty = getValueByPath(fromObject, [\n        'frequencyPenalty',\n    ]);\n    if (fromFrequencyPenalty != null) {\n        setValueByPath(toObject, ['frequencyPenalty'], fromFrequencyPenalty);\n    }\n    const fromLogprobs = getValueByPath(fromObject, ['logprobs']);\n    if (fromLogprobs != null) {\n        setValueByPath(toObject, ['logprobs'], fromLogprobs);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        'maxOutputTokens',\n    ]);\n    if (fromMaxOutputTokens != null) {\n        setValueByPath(toObject, ['maxOutputTokens'], fromMaxOutputTokens);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        'mediaResolution',\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, ['mediaResolution'], fromMediaResolution);\n    }\n    const fromPresencePenalty = getValueByPath(fromObject, [\n        'presencePenalty',\n    ]);\n    if (fromPresencePenalty != null) {\n        setValueByPath(toObject, ['presencePenalty'], fromPresencePenalty);\n    }\n    const fromResponseLogprobs = getValueByPath(fromObject, [\n        'responseLogprobs',\n    ]);\n    if (fromResponseLogprobs != null) {\n        setValueByPath(toObject, ['responseLogprobs'], fromResponseLogprobs);\n    }\n    const fromResponseMimeType = getValueByPath(fromObject, [\n        'responseMimeType',\n    ]);\n    if (fromResponseMimeType != null) {\n        setValueByPath(toObject, ['responseMimeType'], fromResponseMimeType);\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        'responseModalities',\n    ]);\n    if (fromResponseModalities != null) {\n        setValueByPath(toObject, ['responseModalities'], fromResponseModalities);\n    }\n    const fromResponseSchema = getValueByPath(fromObject, [\n        'responseSchema',\n    ]);\n    if (fromResponseSchema != null) {\n        setValueByPath(toObject, ['responseSchema'], fromResponseSchema);\n    }\n    const fromRoutingConfig = getValueByPath(fromObject, [\n        'routingConfig',\n    ]);\n    if (fromRoutingConfig != null) {\n        setValueByPath(toObject, ['routingConfig'], fromRoutingConfig);\n    }\n    const fromSeed = getValueByPath(fromObject, ['seed']);\n    if (fromSeed != null) {\n        setValueByPath(toObject, ['seed'], fromSeed);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, ['speechConfig']);\n    if (fromSpeechConfig != null) {\n        setValueByPath(toObject, ['speechConfig'], speechConfigToVertex$1(fromSpeechConfig));\n    }\n    const fromStopSequences = getValueByPath(fromObject, [\n        'stopSequences',\n    ]);\n    if (fromStopSequences != null) {\n        setValueByPath(toObject, ['stopSequences'], fromStopSequences);\n    }\n    const fromTemperature = getValueByPath(fromObject, ['temperature']);\n    if (fromTemperature != null) {\n        setValueByPath(toObject, ['temperature'], fromTemperature);\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        'thinkingConfig',\n    ]);\n    if (fromThinkingConfig != null) {\n        setValueByPath(toObject, ['thinkingConfig'], fromThinkingConfig);\n    }\n    const fromTopK = getValueByPath(fromObject, ['topK']);\n    if (fromTopK != null) {\n        setValueByPath(toObject, ['topK'], fromTopK);\n    }\n    const fromTopP = getValueByPath(fromObject, ['topP']);\n    if (fromTopP != null) {\n        setValueByPath(toObject, ['topP'], fromTopP);\n    }\n    if (getValueByPath(fromObject, ['enableEnhancedCivicAnswers']) !==\n        undefined) {\n        throw new Error('enableEnhancedCivicAnswers parameter is not supported in Vertex AI.');\n    }\n    return toObject;\n}\nfunction googleMapsToMldev$2(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['authConfig']) !== undefined) {\n        throw new Error('authConfig parameter is not supported in Gemini API.');\n    }\n    const fromEnableWidget = getValueByPath(fromObject, ['enableWidget']);\n    if (fromEnableWidget != null) {\n        setValueByPath(toObject, ['enableWidget'], fromEnableWidget);\n    }\n    return toObject;\n}\nfunction googleSearchToMldev$2(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['excludeDomains']) !== undefined) {\n        throw new Error('excludeDomains parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['blockingConfidence']) !== undefined) {\n        throw new Error('blockingConfidence parameter is not supported in Gemini API.');\n    }\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        'timeRangeFilter',\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, ['timeRangeFilter'], fromTimeRangeFilter);\n    }\n    return toObject;\n}\nfunction liveConnectConfigToMldev$1(fromObject, parentObject) {\n    const toObject = {};\n    const fromGenerationConfig = getValueByPath(fromObject, [\n        'generationConfig',\n    ]);\n    if (parentObject !== undefined && fromGenerationConfig != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig'], fromGenerationConfig);\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        'responseModalities',\n    ]);\n    if (parentObject !== undefined && fromResponseModalities != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'responseModalities'], fromResponseModalities);\n    }\n    const fromTemperature = getValueByPath(fromObject, ['temperature']);\n    if (parentObject !== undefined && fromTemperature != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'temperature'], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, ['topP']);\n    if (parentObject !== undefined && fromTopP != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'topP'], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, ['topK']);\n    if (parentObject !== undefined && fromTopK != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'topK'], fromTopK);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        'maxOutputTokens',\n    ]);\n    if (parentObject !== undefined && fromMaxOutputTokens != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'maxOutputTokens'], fromMaxOutputTokens);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        'mediaResolution',\n    ]);\n    if (parentObject !== undefined && fromMediaResolution != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'mediaResolution'], fromMediaResolution);\n    }\n    const fromSeed = getValueByPath(fromObject, ['seed']);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'seed'], fromSeed);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, ['speechConfig']);\n    if (parentObject !== undefined && fromSpeechConfig != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'speechConfig'], tLiveSpeechConfig(fromSpeechConfig));\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        'thinkingConfig',\n    ]);\n    if (parentObject !== undefined && fromThinkingConfig != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'thinkingConfig'], fromThinkingConfig);\n    }\n    const fromEnableAffectiveDialog = getValueByPath(fromObject, [\n        'enableAffectiveDialog',\n    ]);\n    if (parentObject !== undefined && fromEnableAffectiveDialog != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'enableAffectiveDialog'], fromEnableAffectiveDialog);\n    }\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        'systemInstruction',\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, ['setup', 'systemInstruction'], contentToMldev$2(tContent(fromSystemInstruction)));\n    }\n    const fromTools = getValueByPath(fromObject, ['tools']);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return toolToMldev$2(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, ['setup', 'tools'], transformedList);\n    }\n    const fromSessionResumption = getValueByPath(fromObject, [\n        'sessionResumption',\n    ]);\n    if (parentObject !== undefined && fromSessionResumption != null) {\n        setValueByPath(parentObject, ['setup', 'sessionResumption'], sessionResumptionConfigToMldev$1(fromSessionResumption));\n    }\n    const fromInputAudioTranscription = getValueByPath(fromObject, [\n        'inputAudioTranscription',\n    ]);\n    if (parentObject !== undefined && fromInputAudioTranscription != null) {\n        setValueByPath(parentObject, ['setup', 'inputAudioTranscription'], fromInputAudioTranscription);\n    }\n    const fromOutputAudioTranscription = getValueByPath(fromObject, [\n        'outputAudioTranscription',\n    ]);\n    if (parentObject !== undefined && fromOutputAudioTranscription != null) {\n        setValueByPath(parentObject, ['setup', 'outputAudioTranscription'], fromOutputAudioTranscription);\n    }\n    const fromRealtimeInputConfig = getValueByPath(fromObject, [\n        'realtimeInputConfig',\n    ]);\n    if (parentObject !== undefined && fromRealtimeInputConfig != null) {\n        setValueByPath(parentObject, ['setup', 'realtimeInputConfig'], fromRealtimeInputConfig);\n    }\n    const fromContextWindowCompression = getValueByPath(fromObject, [\n        'contextWindowCompression',\n    ]);\n    if (parentObject !== undefined && fromContextWindowCompression != null) {\n        setValueByPath(parentObject, ['setup', 'contextWindowCompression'], fromContextWindowCompression);\n    }\n    const fromProactivity = getValueByPath(fromObject, ['proactivity']);\n    if (parentObject !== undefined && fromProactivity != null) {\n        setValueByPath(parentObject, ['setup', 'proactivity'], fromProactivity);\n    }\n    return toObject;\n}\nfunction liveConnectConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromGenerationConfig = getValueByPath(fromObject, [\n        'generationConfig',\n    ]);\n    if (parentObject !== undefined && fromGenerationConfig != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig'], generationConfigToVertex$1(fromGenerationConfig));\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        'responseModalities',\n    ]);\n    if (parentObject !== undefined && fromResponseModalities != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'responseModalities'], fromResponseModalities);\n    }\n    const fromTemperature = getValueByPath(fromObject, ['temperature']);\n    if (parentObject !== undefined && fromTemperature != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'temperature'], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, ['topP']);\n    if (parentObject !== undefined && fromTopP != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'topP'], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, ['topK']);\n    if (parentObject !== undefined && fromTopK != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'topK'], fromTopK);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        'maxOutputTokens',\n    ]);\n    if (parentObject !== undefined && fromMaxOutputTokens != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'maxOutputTokens'], fromMaxOutputTokens);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        'mediaResolution',\n    ]);\n    if (parentObject !== undefined && fromMediaResolution != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'mediaResolution'], fromMediaResolution);\n    }\n    const fromSeed = getValueByPath(fromObject, ['seed']);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'seed'], fromSeed);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, ['speechConfig']);\n    if (parentObject !== undefined && fromSpeechConfig != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'speechConfig'], speechConfigToVertex$1(tLiveSpeechConfig(fromSpeechConfig)));\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        'thinkingConfig',\n    ]);\n    if (parentObject !== undefined && fromThinkingConfig != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'thinkingConfig'], fromThinkingConfig);\n    }\n    const fromEnableAffectiveDialog = getValueByPath(fromObject, [\n        'enableAffectiveDialog',\n    ]);\n    if (parentObject !== undefined && fromEnableAffectiveDialog != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'enableAffectiveDialog'], fromEnableAffectiveDialog);\n    }\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        'systemInstruction',\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, ['setup', 'systemInstruction'], tContent(fromSystemInstruction));\n    }\n    const fromTools = getValueByPath(fromObject, ['tools']);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return toolToVertex$1(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, ['setup', 'tools'], transformedList);\n    }\n    const fromSessionResumption = getValueByPath(fromObject, [\n        'sessionResumption',\n    ]);\n    if (parentObject !== undefined && fromSessionResumption != null) {\n        setValueByPath(parentObject, ['setup', 'sessionResumption'], fromSessionResumption);\n    }\n    const fromInputAudioTranscription = getValueByPath(fromObject, [\n        'inputAudioTranscription',\n    ]);\n    if (parentObject !== undefined && fromInputAudioTranscription != null) {\n        setValueByPath(parentObject, ['setup', 'inputAudioTranscription'], fromInputAudioTranscription);\n    }\n    const fromOutputAudioTranscription = getValueByPath(fromObject, [\n        'outputAudioTranscription',\n    ]);\n    if (parentObject !== undefined && fromOutputAudioTranscription != null) {\n        setValueByPath(parentObject, ['setup', 'outputAudioTranscription'], fromOutputAudioTranscription);\n    }\n    const fromRealtimeInputConfig = getValueByPath(fromObject, [\n        'realtimeInputConfig',\n    ]);\n    if (parentObject !== undefined && fromRealtimeInputConfig != null) {\n        setValueByPath(parentObject, ['setup', 'realtimeInputConfig'], fromRealtimeInputConfig);\n    }\n    const fromContextWindowCompression = getValueByPath(fromObject, [\n        'contextWindowCompression',\n    ]);\n    if (parentObject !== undefined && fromContextWindowCompression != null) {\n        setValueByPath(parentObject, ['setup', 'contextWindowCompression'], fromContextWindowCompression);\n    }\n    const fromProactivity = getValueByPath(fromObject, ['proactivity']);\n    if (parentObject !== undefined && fromProactivity != null) {\n        setValueByPath(parentObject, ['setup', 'proactivity'], fromProactivity);\n    }\n    return toObject;\n}\nfunction liveConnectParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['setup', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        setValueByPath(toObject, ['config'], liveConnectConfigToMldev$1(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction liveConnectParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['setup', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        setValueByPath(toObject, ['config'], liveConnectConfigToVertex(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction liveMusicSetConfigParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromMusicGenerationConfig = getValueByPath(fromObject, [\n        'musicGenerationConfig',\n    ]);\n    if (fromMusicGenerationConfig != null) {\n        setValueByPath(toObject, ['musicGenerationConfig'], fromMusicGenerationConfig);\n    }\n    return toObject;\n}\nfunction liveMusicSetWeightedPromptsParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromWeightedPrompts = getValueByPath(fromObject, [\n        'weightedPrompts',\n    ]);\n    if (fromWeightedPrompts != null) {\n        let transformedList = fromWeightedPrompts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['weightedPrompts'], transformedList);\n    }\n    return toObject;\n}\nfunction liveSendRealtimeInputParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromMedia = getValueByPath(fromObject, ['media']);\n    if (fromMedia != null) {\n        let transformedList = tBlobs(fromMedia);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return blobToMldev$2(item);\n            });\n        }\n        setValueByPath(toObject, ['mediaChunks'], transformedList);\n    }\n    const fromAudio = getValueByPath(fromObject, ['audio']);\n    if (fromAudio != null) {\n        setValueByPath(toObject, ['audio'], blobToMldev$2(tAudioBlob(fromAudio)));\n    }\n    const fromAudioStreamEnd = getValueByPath(fromObject, [\n        'audioStreamEnd',\n    ]);\n    if (fromAudioStreamEnd != null) {\n        setValueByPath(toObject, ['audioStreamEnd'], fromAudioStreamEnd);\n    }\n    const fromVideo = getValueByPath(fromObject, ['video']);\n    if (fromVideo != null) {\n        setValueByPath(toObject, ['video'], blobToMldev$2(tImageBlob(fromVideo)));\n    }\n    const fromText = getValueByPath(fromObject, ['text']);\n    if (fromText != null) {\n        setValueByPath(toObject, ['text'], fromText);\n    }\n    const fromActivityStart = getValueByPath(fromObject, [\n        'activityStart',\n    ]);\n    if (fromActivityStart != null) {\n        setValueByPath(toObject, ['activityStart'], fromActivityStart);\n    }\n    const fromActivityEnd = getValueByPath(fromObject, ['activityEnd']);\n    if (fromActivityEnd != null) {\n        setValueByPath(toObject, ['activityEnd'], fromActivityEnd);\n    }\n    return toObject;\n}\nfunction liveSendRealtimeInputParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromMedia = getValueByPath(fromObject, ['media']);\n    if (fromMedia != null) {\n        let transformedList = tBlobs(fromMedia);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['mediaChunks'], transformedList);\n    }\n    const fromAudio = getValueByPath(fromObject, ['audio']);\n    if (fromAudio != null) {\n        setValueByPath(toObject, ['audio'], tAudioBlob(fromAudio));\n    }\n    const fromAudioStreamEnd = getValueByPath(fromObject, [\n        'audioStreamEnd',\n    ]);\n    if (fromAudioStreamEnd != null) {\n        setValueByPath(toObject, ['audioStreamEnd'], fromAudioStreamEnd);\n    }\n    const fromVideo = getValueByPath(fromObject, ['video']);\n    if (fromVideo != null) {\n        setValueByPath(toObject, ['video'], tImageBlob(fromVideo));\n    }\n    const fromText = getValueByPath(fromObject, ['text']);\n    if (fromText != null) {\n        setValueByPath(toObject, ['text'], fromText);\n    }\n    const fromActivityStart = getValueByPath(fromObject, [\n        'activityStart',\n    ]);\n    if (fromActivityStart != null) {\n        setValueByPath(toObject, ['activityStart'], fromActivityStart);\n    }\n    const fromActivityEnd = getValueByPath(fromObject, ['activityEnd']);\n    if (fromActivityEnd != null) {\n        setValueByPath(toObject, ['activityEnd'], fromActivityEnd);\n    }\n    return toObject;\n}\nfunction liveServerMessageFromVertex(fromObject) {\n    const toObject = {};\n    const fromSetupComplete = getValueByPath(fromObject, [\n        'setupComplete',\n    ]);\n    if (fromSetupComplete != null) {\n        setValueByPath(toObject, ['setupComplete'], fromSetupComplete);\n    }\n    const fromServerContent = getValueByPath(fromObject, [\n        'serverContent',\n    ]);\n    if (fromServerContent != null) {\n        setValueByPath(toObject, ['serverContent'], fromServerContent);\n    }\n    const fromToolCall = getValueByPath(fromObject, ['toolCall']);\n    if (fromToolCall != null) {\n        setValueByPath(toObject, ['toolCall'], fromToolCall);\n    }\n    const fromToolCallCancellation = getValueByPath(fromObject, [\n        'toolCallCancellation',\n    ]);\n    if (fromToolCallCancellation != null) {\n        setValueByPath(toObject, ['toolCallCancellation'], fromToolCallCancellation);\n    }\n    const fromUsageMetadata = getValueByPath(fromObject, [\n        'usageMetadata',\n    ]);\n    if (fromUsageMetadata != null) {\n        setValueByPath(toObject, ['usageMetadata'], usageMetadataFromVertex(fromUsageMetadata));\n    }\n    const fromGoAway = getValueByPath(fromObject, ['goAway']);\n    if (fromGoAway != null) {\n        setValueByPath(toObject, ['goAway'], fromGoAway);\n    }\n    const fromSessionResumptionUpdate = getValueByPath(fromObject, [\n        'sessionResumptionUpdate',\n    ]);\n    if (fromSessionResumptionUpdate != null) {\n        setValueByPath(toObject, ['sessionResumptionUpdate'], fromSessionResumptionUpdate);\n    }\n    return toObject;\n}\nfunction partToMldev$2(fromObject) {\n    const toObject = {};\n    const fromMediaResolution = getValueByPath(fromObject, [\n        'mediaResolution',\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, ['mediaResolution'], fromMediaResolution);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        'codeExecutionResult',\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, ['codeExecutionResult'], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        'executableCode',\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, ['executableCode'], fromExecutableCode);\n    }\n    const fromFileData = getValueByPath(fromObject, ['fileData']);\n    if (fromFileData != null) {\n        setValueByPath(toObject, ['fileData'], fileDataToMldev$2(fromFileData));\n    }\n    const fromFunctionCall = getValueByPath(fromObject, ['functionCall']);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, ['functionCall'], functionCallToMldev$2(fromFunctionCall));\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        'functionResponse',\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, ['functionResponse'], fromFunctionResponse);\n    }\n    const fromInlineData = getValueByPath(fromObject, ['inlineData']);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, ['inlineData'], blobToMldev$2(fromInlineData));\n    }\n    const fromText = getValueByPath(fromObject, ['text']);\n    if (fromText != null) {\n        setValueByPath(toObject, ['text'], fromText);\n    }\n    const fromThought = getValueByPath(fromObject, ['thought']);\n    if (fromThought != null) {\n        setValueByPath(toObject, ['thought'], fromThought);\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        'thoughtSignature',\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, ['thoughtSignature'], fromThoughtSignature);\n    }\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        'videoMetadata',\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, ['videoMetadata'], fromVideoMetadata);\n    }\n    return toObject;\n}\nfunction sessionResumptionConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromHandle = getValueByPath(fromObject, ['handle']);\n    if (fromHandle != null) {\n        setValueByPath(toObject, ['handle'], fromHandle);\n    }\n    if (getValueByPath(fromObject, ['transparent']) !== undefined) {\n        throw new Error('transparent parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction speechConfigToVertex$1(fromObject) {\n    const toObject = {};\n    const fromLanguageCode = getValueByPath(fromObject, ['languageCode']);\n    if (fromLanguageCode != null) {\n        setValueByPath(toObject, ['languageCode'], fromLanguageCode);\n    }\n    const fromVoiceConfig = getValueByPath(fromObject, ['voiceConfig']);\n    if (fromVoiceConfig != null) {\n        setValueByPath(toObject, ['voiceConfig'], fromVoiceConfig);\n    }\n    if (getValueByPath(fromObject, ['multiSpeakerVoiceConfig']) !== undefined) {\n        throw new Error('multiSpeakerVoiceConfig parameter is not supported in Vertex AI.');\n    }\n    return toObject;\n}\nfunction toolToMldev$2(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        'functionDeclarations',\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['functionDeclarations'], transformedList);\n    }\n    if (getValueByPath(fromObject, ['retrieval']) !== undefined) {\n        throw new Error('retrieval parameter is not supported in Gemini API.');\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        'googleSearchRetrieval',\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, ['googleSearchRetrieval'], fromGoogleSearchRetrieval);\n    }\n    const fromComputerUse = getValueByPath(fromObject, ['computerUse']);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, ['computerUse'], fromComputerUse);\n    }\n    const fromFileSearch = getValueByPath(fromObject, ['fileSearch']);\n    if (fromFileSearch != null) {\n        setValueByPath(toObject, ['fileSearch'], fromFileSearch);\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        'codeExecution',\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, ['codeExecution'], fromCodeExecution);\n    }\n    if (getValueByPath(fromObject, ['enterpriseWebSearch']) !== undefined) {\n        throw new Error('enterpriseWebSearch parameter is not supported in Gemini API.');\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, ['googleMaps']);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, ['googleMaps'], googleMapsToMldev$2(fromGoogleMaps));\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, ['googleSearch']);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, ['googleSearch'], googleSearchToMldev$2(fromGoogleSearch));\n    }\n    const fromUrlContext = getValueByPath(fromObject, ['urlContext']);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, ['urlContext'], fromUrlContext);\n    }\n    return toObject;\n}\nfunction toolToVertex$1(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        'functionDeclarations',\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return functionDeclarationToVertex$1(item);\n            });\n        }\n        setValueByPath(toObject, ['functionDeclarations'], transformedList);\n    }\n    const fromRetrieval = getValueByPath(fromObject, ['retrieval']);\n    if (fromRetrieval != null) {\n        setValueByPath(toObject, ['retrieval'], fromRetrieval);\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        'googleSearchRetrieval',\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, ['googleSearchRetrieval'], fromGoogleSearchRetrieval);\n    }\n    const fromComputerUse = getValueByPath(fromObject, ['computerUse']);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, ['computerUse'], fromComputerUse);\n    }\n    if (getValueByPath(fromObject, ['fileSearch']) !== undefined) {\n        throw new Error('fileSearch parameter is not supported in Vertex AI.');\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        'codeExecution',\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, ['codeExecution'], fromCodeExecution);\n    }\n    const fromEnterpriseWebSearch = getValueByPath(fromObject, [\n        'enterpriseWebSearch',\n    ]);\n    if (fromEnterpriseWebSearch != null) {\n        setValueByPath(toObject, ['enterpriseWebSearch'], fromEnterpriseWebSearch);\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, ['googleMaps']);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, ['googleMaps'], fromGoogleMaps);\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, ['googleSearch']);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, ['googleSearch'], fromGoogleSearch);\n    }\n    const fromUrlContext = getValueByPath(fromObject, ['urlContext']);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, ['urlContext'], fromUrlContext);\n    }\n    return toObject;\n}\nfunction usageMetadataFromVertex(fromObject) {\n    const toObject = {};\n    const fromPromptTokenCount = getValueByPath(fromObject, [\n        'promptTokenCount',\n    ]);\n    if (fromPromptTokenCount != null) {\n        setValueByPath(toObject, ['promptTokenCount'], fromPromptTokenCount);\n    }\n    const fromCachedContentTokenCount = getValueByPath(fromObject, [\n        'cachedContentTokenCount',\n    ]);\n    if (fromCachedContentTokenCount != null) {\n        setValueByPath(toObject, ['cachedContentTokenCount'], fromCachedContentTokenCount);\n    }\n    const fromResponseTokenCount = getValueByPath(fromObject, [\n        'candidatesTokenCount',\n    ]);\n    if (fromResponseTokenCount != null) {\n        setValueByPath(toObject, ['responseTokenCount'], fromResponseTokenCount);\n    }\n    const fromToolUsePromptTokenCount = getValueByPath(fromObject, [\n        'toolUsePromptTokenCount',\n    ]);\n    if (fromToolUsePromptTokenCount != null) {\n        setValueByPath(toObject, ['toolUsePromptTokenCount'], fromToolUsePromptTokenCount);\n    }\n    const fromThoughtsTokenCount = getValueByPath(fromObject, [\n        'thoughtsTokenCount',\n    ]);\n    if (fromThoughtsTokenCount != null) {\n        setValueByPath(toObject, ['thoughtsTokenCount'], fromThoughtsTokenCount);\n    }\n    const fromTotalTokenCount = getValueByPath(fromObject, [\n        'totalTokenCount',\n    ]);\n    if (fromTotalTokenCount != null) {\n        setValueByPath(toObject, ['totalTokenCount'], fromTotalTokenCount);\n    }\n    const fromPromptTokensDetails = getValueByPath(fromObject, [\n        'promptTokensDetails',\n    ]);\n    if (fromPromptTokensDetails != null) {\n        let transformedList = fromPromptTokensDetails;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['promptTokensDetails'], transformedList);\n    }\n    const fromCacheTokensDetails = getValueByPath(fromObject, [\n        'cacheTokensDetails',\n    ]);\n    if (fromCacheTokensDetails != null) {\n        let transformedList = fromCacheTokensDetails;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['cacheTokensDetails'], transformedList);\n    }\n    const fromResponseTokensDetails = getValueByPath(fromObject, [\n        'candidatesTokensDetails',\n    ]);\n    if (fromResponseTokensDetails != null) {\n        let transformedList = fromResponseTokensDetails;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['responseTokensDetails'], transformedList);\n    }\n    const fromToolUsePromptTokensDetails = getValueByPath(fromObject, [\n        'toolUsePromptTokensDetails',\n    ]);\n    if (fromToolUsePromptTokensDetails != null) {\n        let transformedList = fromToolUsePromptTokensDetails;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['toolUsePromptTokensDetails'], transformedList);\n    }\n    const fromTrafficType = getValueByPath(fromObject, ['trafficType']);\n    if (fromTrafficType != null) {\n        setValueByPath(toObject, ['trafficType'], fromTrafficType);\n    }\n    return toObject;\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nfunction blobToMldev$1(fromObject) {\n    const toObject = {};\n    const fromData = getValueByPath(fromObject, ['data']);\n    if (fromData != null) {\n        setValueByPath(toObject, ['data'], fromData);\n    }\n    if (getValueByPath(fromObject, ['displayName']) !== undefined) {\n        throw new Error('displayName parameter is not supported in Gemini API.');\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction candidateFromMldev(fromObject) {\n    const toObject = {};\n    const fromContent = getValueByPath(fromObject, ['content']);\n    if (fromContent != null) {\n        setValueByPath(toObject, ['content'], fromContent);\n    }\n    const fromCitationMetadata = getValueByPath(fromObject, [\n        'citationMetadata',\n    ]);\n    if (fromCitationMetadata != null) {\n        setValueByPath(toObject, ['citationMetadata'], citationMetadataFromMldev(fromCitationMetadata));\n    }\n    const fromTokenCount = getValueByPath(fromObject, ['tokenCount']);\n    if (fromTokenCount != null) {\n        setValueByPath(toObject, ['tokenCount'], fromTokenCount);\n    }\n    const fromFinishReason = getValueByPath(fromObject, ['finishReason']);\n    if (fromFinishReason != null) {\n        setValueByPath(toObject, ['finishReason'], fromFinishReason);\n    }\n    const fromAvgLogprobs = getValueByPath(fromObject, ['avgLogprobs']);\n    if (fromAvgLogprobs != null) {\n        setValueByPath(toObject, ['avgLogprobs'], fromAvgLogprobs);\n    }\n    const fromGroundingMetadata = getValueByPath(fromObject, [\n        'groundingMetadata',\n    ]);\n    if (fromGroundingMetadata != null) {\n        setValueByPath(toObject, ['groundingMetadata'], fromGroundingMetadata);\n    }\n    const fromIndex = getValueByPath(fromObject, ['index']);\n    if (fromIndex != null) {\n        setValueByPath(toObject, ['index'], fromIndex);\n    }\n    const fromLogprobsResult = getValueByPath(fromObject, [\n        'logprobsResult',\n    ]);\n    if (fromLogprobsResult != null) {\n        setValueByPath(toObject, ['logprobsResult'], fromLogprobsResult);\n    }\n    const fromSafetyRatings = getValueByPath(fromObject, [\n        'safetyRatings',\n    ]);\n    if (fromSafetyRatings != null) {\n        let transformedList = fromSafetyRatings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['safetyRatings'], transformedList);\n    }\n    const fromUrlContextMetadata = getValueByPath(fromObject, [\n        'urlContextMetadata',\n    ]);\n    if (fromUrlContextMetadata != null) {\n        setValueByPath(toObject, ['urlContextMetadata'], fromUrlContextMetadata);\n    }\n    return toObject;\n}\nfunction citationMetadataFromMldev(fromObject) {\n    const toObject = {};\n    const fromCitations = getValueByPath(fromObject, ['citationSources']);\n    if (fromCitations != null) {\n        let transformedList = fromCitations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['citations'], transformedList);\n    }\n    return toObject;\n}\nfunction computeTokensParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, ['contents']);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['contents'], transformedList);\n    }\n    return toObject;\n}\nfunction computeTokensResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromTokensInfo = getValueByPath(fromObject, ['tokensInfo']);\n    if (fromTokensInfo != null) {\n        let transformedList = fromTokensInfo;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['tokensInfo'], transformedList);\n    }\n    return toObject;\n}\nfunction contentEmbeddingFromVertex(fromObject) {\n    const toObject = {};\n    const fromValues = getValueByPath(fromObject, ['values']);\n    if (fromValues != null) {\n        setValueByPath(toObject, ['values'], fromValues);\n    }\n    const fromStatistics = getValueByPath(fromObject, ['statistics']);\n    if (fromStatistics != null) {\n        setValueByPath(toObject, ['statistics'], contentEmbeddingStatisticsFromVertex(fromStatistics));\n    }\n    return toObject;\n}\nfunction contentEmbeddingStatisticsFromVertex(fromObject) {\n    const toObject = {};\n    const fromTruncated = getValueByPath(fromObject, ['truncated']);\n    if (fromTruncated != null) {\n        setValueByPath(toObject, ['truncated'], fromTruncated);\n    }\n    const fromTokenCount = getValueByPath(fromObject, ['token_count']);\n    if (fromTokenCount != null) {\n        setValueByPath(toObject, ['tokenCount'], fromTokenCount);\n    }\n    return toObject;\n}\nfunction contentToMldev$1(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, ['parts']);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return partToMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, ['parts'], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, ['role']);\n    if (fromRole != null) {\n        setValueByPath(toObject, ['role'], fromRole);\n    }\n    return toObject;\n}\nfunction controlReferenceConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromControlType = getValueByPath(fromObject, ['controlType']);\n    if (fromControlType != null) {\n        setValueByPath(toObject, ['controlType'], fromControlType);\n    }\n    const fromEnableControlImageComputation = getValueByPath(fromObject, [\n        'enableControlImageComputation',\n    ]);\n    if (fromEnableControlImageComputation != null) {\n        setValueByPath(toObject, ['computeControl'], fromEnableControlImageComputation);\n    }\n    return toObject;\n}\nfunction countTokensConfigToMldev(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['systemInstruction']) !== undefined) {\n        throw new Error('systemInstruction parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['tools']) !== undefined) {\n        throw new Error('tools parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['generationConfig']) !== undefined) {\n        throw new Error('generationConfig parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction countTokensConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        'systemInstruction',\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, ['systemInstruction'], tContent(fromSystemInstruction));\n    }\n    const fromTools = getValueByPath(fromObject, ['tools']);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = fromTools;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return toolToVertex(item);\n            });\n        }\n        setValueByPath(parentObject, ['tools'], transformedList);\n    }\n    const fromGenerationConfig = getValueByPath(fromObject, [\n        'generationConfig',\n    ]);\n    if (parentObject !== undefined && fromGenerationConfig != null) {\n        setValueByPath(parentObject, ['generationConfig'], generationConfigToVertex(fromGenerationConfig));\n    }\n    return toObject;\n}\nfunction countTokensParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, ['contents']);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return contentToMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, ['contents'], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        countTokensConfigToMldev(fromConfig);\n    }\n    return toObject;\n}\nfunction countTokensParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, ['contents']);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['contents'], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        countTokensConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction countTokensResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromTotalTokens = getValueByPath(fromObject, ['totalTokens']);\n    if (fromTotalTokens != null) {\n        setValueByPath(toObject, ['totalTokens'], fromTotalTokens);\n    }\n    const fromCachedContentTokenCount = getValueByPath(fromObject, [\n        'cachedContentTokenCount',\n    ]);\n    if (fromCachedContentTokenCount != null) {\n        setValueByPath(toObject, ['cachedContentTokenCount'], fromCachedContentTokenCount);\n    }\n    return toObject;\n}\nfunction countTokensResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromTotalTokens = getValueByPath(fromObject, ['totalTokens']);\n    if (fromTotalTokens != null) {\n        setValueByPath(toObject, ['totalTokens'], fromTotalTokens);\n    }\n    return toObject;\n}\nfunction deleteModelParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'name'], tModel(apiClient, fromModel));\n    }\n    return toObject;\n}\nfunction deleteModelParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'name'], tModel(apiClient, fromModel));\n    }\n    return toObject;\n}\nfunction deleteModelResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    return toObject;\n}\nfunction deleteModelResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    return toObject;\n}\nfunction editImageConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromOutputGcsUri = getValueByPath(fromObject, ['outputGcsUri']);\n    if (parentObject !== undefined && fromOutputGcsUri != null) {\n        setValueByPath(parentObject, ['parameters', 'storageUri'], fromOutputGcsUri);\n    }\n    const fromNegativePrompt = getValueByPath(fromObject, [\n        'negativePrompt',\n    ]);\n    if (parentObject !== undefined && fromNegativePrompt != null) {\n        setValueByPath(parentObject, ['parameters', 'negativePrompt'], fromNegativePrompt);\n    }\n    const fromNumberOfImages = getValueByPath(fromObject, [\n        'numberOfImages',\n    ]);\n    if (parentObject !== undefined && fromNumberOfImages != null) {\n        setValueByPath(parentObject, ['parameters', 'sampleCount'], fromNumberOfImages);\n    }\n    const fromAspectRatio = getValueByPath(fromObject, ['aspectRatio']);\n    if (parentObject !== undefined && fromAspectRatio != null) {\n        setValueByPath(parentObject, ['parameters', 'aspectRatio'], fromAspectRatio);\n    }\n    const fromGuidanceScale = getValueByPath(fromObject, [\n        'guidanceScale',\n    ]);\n    if (parentObject !== undefined && fromGuidanceScale != null) {\n        setValueByPath(parentObject, ['parameters', 'guidanceScale'], fromGuidanceScale);\n    }\n    const fromSeed = getValueByPath(fromObject, ['seed']);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, ['parameters', 'seed'], fromSeed);\n    }\n    const fromSafetyFilterLevel = getValueByPath(fromObject, [\n        'safetyFilterLevel',\n    ]);\n    if (parentObject !== undefined && fromSafetyFilterLevel != null) {\n        setValueByPath(parentObject, ['parameters', 'safetySetting'], fromSafetyFilterLevel);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        'personGeneration',\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, ['parameters', 'personGeneration'], fromPersonGeneration);\n    }\n    const fromIncludeSafetyAttributes = getValueByPath(fromObject, [\n        'includeSafetyAttributes',\n    ]);\n    if (parentObject !== undefined && fromIncludeSafetyAttributes != null) {\n        setValueByPath(parentObject, ['parameters', 'includeSafetyAttributes'], fromIncludeSafetyAttributes);\n    }\n    const fromIncludeRaiReason = getValueByPath(fromObject, [\n        'includeRaiReason',\n    ]);\n    if (parentObject !== undefined && fromIncludeRaiReason != null) {\n        setValueByPath(parentObject, ['parameters', 'includeRaiReason'], fromIncludeRaiReason);\n    }\n    const fromLanguage = getValueByPath(fromObject, ['language']);\n    if (parentObject !== undefined && fromLanguage != null) {\n        setValueByPath(parentObject, ['parameters', 'language'], fromLanguage);\n    }\n    const fromOutputMimeType = getValueByPath(fromObject, [\n        'outputMimeType',\n    ]);\n    if (parentObject !== undefined && fromOutputMimeType != null) {\n        setValueByPath(parentObject, ['parameters', 'outputOptions', 'mimeType'], fromOutputMimeType);\n    }\n    const fromOutputCompressionQuality = getValueByPath(fromObject, [\n        'outputCompressionQuality',\n    ]);\n    if (parentObject !== undefined && fromOutputCompressionQuality != null) {\n        setValueByPath(parentObject, ['parameters', 'outputOptions', 'compressionQuality'], fromOutputCompressionQuality);\n    }\n    const fromAddWatermark = getValueByPath(fromObject, ['addWatermark']);\n    if (parentObject !== undefined && fromAddWatermark != null) {\n        setValueByPath(parentObject, ['parameters', 'addWatermark'], fromAddWatermark);\n    }\n    const fromLabels = getValueByPath(fromObject, ['labels']);\n    if (parentObject !== undefined && fromLabels != null) {\n        setValueByPath(parentObject, ['labels'], fromLabels);\n    }\n    const fromEditMode = getValueByPath(fromObject, ['editMode']);\n    if (parentObject !== undefined && fromEditMode != null) {\n        setValueByPath(parentObject, ['parameters', 'editMode'], fromEditMode);\n    }\n    const fromBaseSteps = getValueByPath(fromObject, ['baseSteps']);\n    if (parentObject !== undefined && fromBaseSteps != null) {\n        setValueByPath(parentObject, ['parameters', 'editConfig', 'baseSteps'], fromBaseSteps);\n    }\n    return toObject;\n}\nfunction editImageParametersInternalToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromPrompt = getValueByPath(fromObject, ['prompt']);\n    if (fromPrompt != null) {\n        setValueByPath(toObject, ['instances[0]', 'prompt'], fromPrompt);\n    }\n    const fromReferenceImages = getValueByPath(fromObject, [\n        'referenceImages',\n    ]);\n    if (fromReferenceImages != null) {\n        let transformedList = fromReferenceImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return referenceImageAPIInternalToVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['instances[0]', 'referenceImages'], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        editImageConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction editImageResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromGeneratedImages = getValueByPath(fromObject, [\n        'predictions',\n    ]);\n    if (fromGeneratedImages != null) {\n        let transformedList = fromGeneratedImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return generatedImageFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['generatedImages'], transformedList);\n    }\n    return toObject;\n}\nfunction embedContentConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromTaskType = getValueByPath(fromObject, ['taskType']);\n    if (parentObject !== undefined && fromTaskType != null) {\n        setValueByPath(parentObject, ['requests[]', 'taskType'], fromTaskType);\n    }\n    const fromTitle = getValueByPath(fromObject, ['title']);\n    if (parentObject !== undefined && fromTitle != null) {\n        setValueByPath(parentObject, ['requests[]', 'title'], fromTitle);\n    }\n    const fromOutputDimensionality = getValueByPath(fromObject, [\n        'outputDimensionality',\n    ]);\n    if (parentObject !== undefined && fromOutputDimensionality != null) {\n        setValueByPath(parentObject, ['requests[]', 'outputDimensionality'], fromOutputDimensionality);\n    }\n    if (getValueByPath(fromObject, ['mimeType']) !== undefined) {\n        throw new Error('mimeType parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['autoTruncate']) !== undefined) {\n        throw new Error('autoTruncate parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction embedContentConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromTaskType = getValueByPath(fromObject, ['taskType']);\n    if (parentObject !== undefined && fromTaskType != null) {\n        setValueByPath(parentObject, ['instances[]', 'task_type'], fromTaskType);\n    }\n    const fromTitle = getValueByPath(fromObject, ['title']);\n    if (parentObject !== undefined && fromTitle != null) {\n        setValueByPath(parentObject, ['instances[]', 'title'], fromTitle);\n    }\n    const fromOutputDimensionality = getValueByPath(fromObject, [\n        'outputDimensionality',\n    ]);\n    if (parentObject !== undefined && fromOutputDimensionality != null) {\n        setValueByPath(parentObject, ['parameters', 'outputDimensionality'], fromOutputDimensionality);\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (parentObject !== undefined && fromMimeType != null) {\n        setValueByPath(parentObject, ['instances[]', 'mimeType'], fromMimeType);\n    }\n    const fromAutoTruncate = getValueByPath(fromObject, ['autoTruncate']);\n    if (parentObject !== undefined && fromAutoTruncate != null) {\n        setValueByPath(parentObject, ['parameters', 'autoTruncate'], fromAutoTruncate);\n    }\n    return toObject;\n}\nfunction embedContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, ['contents']);\n    if (fromContents != null) {\n        let transformedList = tContentsForEmbed(apiClient, fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['requests[]', 'content'], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        embedContentConfigToMldev(fromConfig, toObject);\n    }\n    const fromModelForEmbedContent = getValueByPath(fromObject, ['model']);\n    if (fromModelForEmbedContent !== undefined) {\n        setValueByPath(toObject, ['requests[]', 'model'], tModel(apiClient, fromModelForEmbedContent));\n    }\n    return toObject;\n}\nfunction embedContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, ['contents']);\n    if (fromContents != null) {\n        let transformedList = tContentsForEmbed(apiClient, fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['instances[]', 'content'], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        embedContentConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction embedContentResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromEmbeddings = getValueByPath(fromObject, ['embeddings']);\n    if (fromEmbeddings != null) {\n        let transformedList = fromEmbeddings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['embeddings'], transformedList);\n    }\n    const fromMetadata = getValueByPath(fromObject, ['metadata']);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, ['metadata'], fromMetadata);\n    }\n    return toObject;\n}\nfunction embedContentResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromEmbeddings = getValueByPath(fromObject, [\n        'predictions[]',\n        'embeddings',\n    ]);\n    if (fromEmbeddings != null) {\n        let transformedList = fromEmbeddings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return contentEmbeddingFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['embeddings'], transformedList);\n    }\n    const fromMetadata = getValueByPath(fromObject, ['metadata']);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, ['metadata'], fromMetadata);\n    }\n    return toObject;\n}\nfunction endpointFromVertex(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['endpoint']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromDeployedModelId = getValueByPath(fromObject, [\n        'deployedModelId',\n    ]);\n    if (fromDeployedModelId != null) {\n        setValueByPath(toObject, ['deployedModelId'], fromDeployedModelId);\n    }\n    return toObject;\n}\nfunction fileDataToMldev$1(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['displayName']) !== undefined) {\n        throw new Error('displayName parameter is not supported in Gemini API.');\n    }\n    const fromFileUri = getValueByPath(fromObject, ['fileUri']);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, ['fileUri'], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction functionCallToMldev$1(fromObject) {\n    const toObject = {};\n    const fromId = getValueByPath(fromObject, ['id']);\n    if (fromId != null) {\n        setValueByPath(toObject, ['id'], fromId);\n    }\n    const fromArgs = getValueByPath(fromObject, ['args']);\n    if (fromArgs != null) {\n        setValueByPath(toObject, ['args'], fromArgs);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    if (getValueByPath(fromObject, ['partialArgs']) !== undefined) {\n        throw new Error('partialArgs parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['willContinue']) !== undefined) {\n        throw new Error('willContinue parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction functionCallingConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, ['mode']);\n    if (fromMode != null) {\n        setValueByPath(toObject, ['mode'], fromMode);\n    }\n    const fromAllowedFunctionNames = getValueByPath(fromObject, [\n        'allowedFunctionNames',\n    ]);\n    if (fromAllowedFunctionNames != null) {\n        setValueByPath(toObject, ['allowedFunctionNames'], fromAllowedFunctionNames);\n    }\n    if (getValueByPath(fromObject, ['streamFunctionCallArguments']) !==\n        undefined) {\n        throw new Error('streamFunctionCallArguments parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction functionDeclarationToVertex(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['behavior']) !== undefined) {\n        throw new Error('behavior parameter is not supported in Vertex AI.');\n    }\n    const fromDescription = getValueByPath(fromObject, ['description']);\n    if (fromDescription != null) {\n        setValueByPath(toObject, ['description'], fromDescription);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromParameters = getValueByPath(fromObject, ['parameters']);\n    if (fromParameters != null) {\n        setValueByPath(toObject, ['parameters'], fromParameters);\n    }\n    const fromParametersJsonSchema = getValueByPath(fromObject, [\n        'parametersJsonSchema',\n    ]);\n    if (fromParametersJsonSchema != null) {\n        setValueByPath(toObject, ['parametersJsonSchema'], fromParametersJsonSchema);\n    }\n    const fromResponse = getValueByPath(fromObject, ['response']);\n    if (fromResponse != null) {\n        setValueByPath(toObject, ['response'], fromResponse);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        'responseJsonSchema',\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, ['responseJsonSchema'], fromResponseJsonSchema);\n    }\n    return toObject;\n}\nfunction generateContentConfigToMldev(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        'systemInstruction',\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, ['systemInstruction'], contentToMldev$1(tContent(fromSystemInstruction)));\n    }\n    const fromTemperature = getValueByPath(fromObject, ['temperature']);\n    if (fromTemperature != null) {\n        setValueByPath(toObject, ['temperature'], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, ['topP']);\n    if (fromTopP != null) {\n        setValueByPath(toObject, ['topP'], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, ['topK']);\n    if (fromTopK != null) {\n        setValueByPath(toObject, ['topK'], fromTopK);\n    }\n    const fromCandidateCount = getValueByPath(fromObject, [\n        'candidateCount',\n    ]);\n    if (fromCandidateCount != null) {\n        setValueByPath(toObject, ['candidateCount'], fromCandidateCount);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        'maxOutputTokens',\n    ]);\n    if (fromMaxOutputTokens != null) {\n        setValueByPath(toObject, ['maxOutputTokens'], fromMaxOutputTokens);\n    }\n    const fromStopSequences = getValueByPath(fromObject, [\n        'stopSequences',\n    ]);\n    if (fromStopSequences != null) {\n        setValueByPath(toObject, ['stopSequences'], fromStopSequences);\n    }\n    const fromResponseLogprobs = getValueByPath(fromObject, [\n        'responseLogprobs',\n    ]);\n    if (fromResponseLogprobs != null) {\n        setValueByPath(toObject, ['responseLogprobs'], fromResponseLogprobs);\n    }\n    const fromLogprobs = getValueByPath(fromObject, ['logprobs']);\n    if (fromLogprobs != null) {\n        setValueByPath(toObject, ['logprobs'], fromLogprobs);\n    }\n    const fromPresencePenalty = getValueByPath(fromObject, [\n        'presencePenalty',\n    ]);\n    if (fromPresencePenalty != null) {\n        setValueByPath(toObject, ['presencePenalty'], fromPresencePenalty);\n    }\n    const fromFrequencyPenalty = getValueByPath(fromObject, [\n        'frequencyPenalty',\n    ]);\n    if (fromFrequencyPenalty != null) {\n        setValueByPath(toObject, ['frequencyPenalty'], fromFrequencyPenalty);\n    }\n    const fromSeed = getValueByPath(fromObject, ['seed']);\n    if (fromSeed != null) {\n        setValueByPath(toObject, ['seed'], fromSeed);\n    }\n    const fromResponseMimeType = getValueByPath(fromObject, [\n        'responseMimeType',\n    ]);\n    if (fromResponseMimeType != null) {\n        setValueByPath(toObject, ['responseMimeType'], fromResponseMimeType);\n    }\n    const fromResponseSchema = getValueByPath(fromObject, [\n        'responseSchema',\n    ]);\n    if (fromResponseSchema != null) {\n        setValueByPath(toObject, ['responseSchema'], tSchema(fromResponseSchema));\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        'responseJsonSchema',\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, ['responseJsonSchema'], fromResponseJsonSchema);\n    }\n    if (getValueByPath(fromObject, ['routingConfig']) !== undefined) {\n        throw new Error('routingConfig parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['modelSelectionConfig']) !== undefined) {\n        throw new Error('modelSelectionConfig parameter is not supported in Gemini API.');\n    }\n    const fromSafetySettings = getValueByPath(fromObject, [\n        'safetySettings',\n    ]);\n    if (parentObject !== undefined && fromSafetySettings != null) {\n        let transformedList = fromSafetySettings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return safetySettingToMldev(item);\n            });\n        }\n        setValueByPath(parentObject, ['safetySettings'], transformedList);\n    }\n    const fromTools = getValueByPath(fromObject, ['tools']);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return toolToMldev$1(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, ['tools'], transformedList);\n    }\n    const fromToolConfig = getValueByPath(fromObject, ['toolConfig']);\n    if (parentObject !== undefined && fromToolConfig != null) {\n        setValueByPath(parentObject, ['toolConfig'], toolConfigToMldev(fromToolConfig));\n    }\n    if (getValueByPath(fromObject, ['labels']) !== undefined) {\n        throw new Error('labels parameter is not supported in Gemini API.');\n    }\n    const fromCachedContent = getValueByPath(fromObject, [\n        'cachedContent',\n    ]);\n    if (parentObject !== undefined && fromCachedContent != null) {\n        setValueByPath(parentObject, ['cachedContent'], tCachedContentName(apiClient, fromCachedContent));\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        'responseModalities',\n    ]);\n    if (fromResponseModalities != null) {\n        setValueByPath(toObject, ['responseModalities'], fromResponseModalities);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        'mediaResolution',\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, ['mediaResolution'], fromMediaResolution);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, ['speechConfig']);\n    if (fromSpeechConfig != null) {\n        setValueByPath(toObject, ['speechConfig'], tSpeechConfig(fromSpeechConfig));\n    }\n    if (getValueByPath(fromObject, ['audioTimestamp']) !== undefined) {\n        throw new Error('audioTimestamp parameter is not supported in Gemini API.');\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        'thinkingConfig',\n    ]);\n    if (fromThinkingConfig != null) {\n        setValueByPath(toObject, ['thinkingConfig'], fromThinkingConfig);\n    }\n    const fromImageConfig = getValueByPath(fromObject, ['imageConfig']);\n    if (fromImageConfig != null) {\n        setValueByPath(toObject, ['imageConfig'], imageConfigToMldev(fromImageConfig));\n    }\n    return toObject;\n}\nfunction generateContentConfigToVertex(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        'systemInstruction',\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, ['systemInstruction'], tContent(fromSystemInstruction));\n    }\n    const fromTemperature = getValueByPath(fromObject, ['temperature']);\n    if (fromTemperature != null) {\n        setValueByPath(toObject, ['temperature'], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, ['topP']);\n    if (fromTopP != null) {\n        setValueByPath(toObject, ['topP'], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, ['topK']);\n    if (fromTopK != null) {\n        setValueByPath(toObject, ['topK'], fromTopK);\n    }\n    const fromCandidateCount = getValueByPath(fromObject, [\n        'candidateCount',\n    ]);\n    if (fromCandidateCount != null) {\n        setValueByPath(toObject, ['candidateCount'], fromCandidateCount);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        'maxOutputTokens',\n    ]);\n    if (fromMaxOutputTokens != null) {\n        setValueByPath(toObject, ['maxOutputTokens'], fromMaxOutputTokens);\n    }\n    const fromStopSequences = getValueByPath(fromObject, [\n        'stopSequences',\n    ]);\n    if (fromStopSequences != null) {\n        setValueByPath(toObject, ['stopSequences'], fromStopSequences);\n    }\n    const fromResponseLogprobs = getValueByPath(fromObject, [\n        'responseLogprobs',\n    ]);\n    if (fromResponseLogprobs != null) {\n        setValueByPath(toObject, ['responseLogprobs'], fromResponseLogprobs);\n    }\n    const fromLogprobs = getValueByPath(fromObject, ['logprobs']);\n    if (fromLogprobs != null) {\n        setValueByPath(toObject, ['logprobs'], fromLogprobs);\n    }\n    const fromPresencePenalty = getValueByPath(fromObject, [\n        'presencePenalty',\n    ]);\n    if (fromPresencePenalty != null) {\n        setValueByPath(toObject, ['presencePenalty'], fromPresencePenalty);\n    }\n    const fromFrequencyPenalty = getValueByPath(fromObject, [\n        'frequencyPenalty',\n    ]);\n    if (fromFrequencyPenalty != null) {\n        setValueByPath(toObject, ['frequencyPenalty'], fromFrequencyPenalty);\n    }\n    const fromSeed = getValueByPath(fromObject, ['seed']);\n    if (fromSeed != null) {\n        setValueByPath(toObject, ['seed'], fromSeed);\n    }\n    const fromResponseMimeType = getValueByPath(fromObject, [\n        'responseMimeType',\n    ]);\n    if (fromResponseMimeType != null) {\n        setValueByPath(toObject, ['responseMimeType'], fromResponseMimeType);\n    }\n    const fromResponseSchema = getValueByPath(fromObject, [\n        'responseSchema',\n    ]);\n    if (fromResponseSchema != null) {\n        setValueByPath(toObject, ['responseSchema'], tSchema(fromResponseSchema));\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        'responseJsonSchema',\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, ['responseJsonSchema'], fromResponseJsonSchema);\n    }\n    const fromRoutingConfig = getValueByPath(fromObject, [\n        'routingConfig',\n    ]);\n    if (fromRoutingConfig != null) {\n        setValueByPath(toObject, ['routingConfig'], fromRoutingConfig);\n    }\n    const fromModelSelectionConfig = getValueByPath(fromObject, [\n        'modelSelectionConfig',\n    ]);\n    if (fromModelSelectionConfig != null) {\n        setValueByPath(toObject, ['modelConfig'], fromModelSelectionConfig);\n    }\n    const fromSafetySettings = getValueByPath(fromObject, [\n        'safetySettings',\n    ]);\n    if (parentObject !== undefined && fromSafetySettings != null) {\n        let transformedList = fromSafetySettings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(parentObject, ['safetySettings'], transformedList);\n    }\n    const fromTools = getValueByPath(fromObject, ['tools']);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return toolToVertex(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, ['tools'], transformedList);\n    }\n    const fromToolConfig = getValueByPath(fromObject, ['toolConfig']);\n    if (parentObject !== undefined && fromToolConfig != null) {\n        setValueByPath(parentObject, ['toolConfig'], fromToolConfig);\n    }\n    const fromLabels = getValueByPath(fromObject, ['labels']);\n    if (parentObject !== undefined && fromLabels != null) {\n        setValueByPath(parentObject, ['labels'], fromLabels);\n    }\n    const fromCachedContent = getValueByPath(fromObject, [\n        'cachedContent',\n    ]);\n    if (parentObject !== undefined && fromCachedContent != null) {\n        setValueByPath(parentObject, ['cachedContent'], tCachedContentName(apiClient, fromCachedContent));\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        'responseModalities',\n    ]);\n    if (fromResponseModalities != null) {\n        setValueByPath(toObject, ['responseModalities'], fromResponseModalities);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        'mediaResolution',\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, ['mediaResolution'], fromMediaResolution);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, ['speechConfig']);\n    if (fromSpeechConfig != null) {\n        setValueByPath(toObject, ['speechConfig'], speechConfigToVertex(tSpeechConfig(fromSpeechConfig)));\n    }\n    const fromAudioTimestamp = getValueByPath(fromObject, [\n        'audioTimestamp',\n    ]);\n    if (fromAudioTimestamp != null) {\n        setValueByPath(toObject, ['audioTimestamp'], fromAudioTimestamp);\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        'thinkingConfig',\n    ]);\n    if (fromThinkingConfig != null) {\n        setValueByPath(toObject, ['thinkingConfig'], fromThinkingConfig);\n    }\n    const fromImageConfig = getValueByPath(fromObject, ['imageConfig']);\n    if (fromImageConfig != null) {\n        setValueByPath(toObject, ['imageConfig'], imageConfigToVertex(fromImageConfig));\n    }\n    return toObject;\n}\nfunction generateContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, ['contents']);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return contentToMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, ['contents'], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        setValueByPath(toObject, ['generationConfig'], generateContentConfigToMldev(apiClient, fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction generateContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, ['contents']);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['contents'], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        setValueByPath(toObject, ['generationConfig'], generateContentConfigToVertex(apiClient, fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction generateContentResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromCandidates = getValueByPath(fromObject, ['candidates']);\n    if (fromCandidates != null) {\n        let transformedList = fromCandidates;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return candidateFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, ['candidates'], transformedList);\n    }\n    const fromModelVersion = getValueByPath(fromObject, ['modelVersion']);\n    if (fromModelVersion != null) {\n        setValueByPath(toObject, ['modelVersion'], fromModelVersion);\n    }\n    const fromPromptFeedback = getValueByPath(fromObject, [\n        'promptFeedback',\n    ]);\n    if (fromPromptFeedback != null) {\n        setValueByPath(toObject, ['promptFeedback'], fromPromptFeedback);\n    }\n    const fromResponseId = getValueByPath(fromObject, ['responseId']);\n    if (fromResponseId != null) {\n        setValueByPath(toObject, ['responseId'], fromResponseId);\n    }\n    const fromUsageMetadata = getValueByPath(fromObject, [\n        'usageMetadata',\n    ]);\n    if (fromUsageMetadata != null) {\n        setValueByPath(toObject, ['usageMetadata'], fromUsageMetadata);\n    }\n    return toObject;\n}\nfunction generateContentResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromCandidates = getValueByPath(fromObject, ['candidates']);\n    if (fromCandidates != null) {\n        let transformedList = fromCandidates;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['candidates'], transformedList);\n    }\n    const fromCreateTime = getValueByPath(fromObject, ['createTime']);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, ['createTime'], fromCreateTime);\n    }\n    const fromModelVersion = getValueByPath(fromObject, ['modelVersion']);\n    if (fromModelVersion != null) {\n        setValueByPath(toObject, ['modelVersion'], fromModelVersion);\n    }\n    const fromPromptFeedback = getValueByPath(fromObject, [\n        'promptFeedback',\n    ]);\n    if (fromPromptFeedback != null) {\n        setValueByPath(toObject, ['promptFeedback'], fromPromptFeedback);\n    }\n    const fromResponseId = getValueByPath(fromObject, ['responseId']);\n    if (fromResponseId != null) {\n        setValueByPath(toObject, ['responseId'], fromResponseId);\n    }\n    const fromUsageMetadata = getValueByPath(fromObject, [\n        'usageMetadata',\n    ]);\n    if (fromUsageMetadata != null) {\n        setValueByPath(toObject, ['usageMetadata'], fromUsageMetadata);\n    }\n    return toObject;\n}\nfunction generateImagesConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['outputGcsUri']) !== undefined) {\n        throw new Error('outputGcsUri parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['negativePrompt']) !== undefined) {\n        throw new Error('negativePrompt parameter is not supported in Gemini API.');\n    }\n    const fromNumberOfImages = getValueByPath(fromObject, [\n        'numberOfImages',\n    ]);\n    if (parentObject !== undefined && fromNumberOfImages != null) {\n        setValueByPath(parentObject, ['parameters', 'sampleCount'], fromNumberOfImages);\n    }\n    const fromAspectRatio = getValueByPath(fromObject, ['aspectRatio']);\n    if (parentObject !== undefined && fromAspectRatio != null) {\n        setValueByPath(parentObject, ['parameters', 'aspectRatio'], fromAspectRatio);\n    }\n    const fromGuidanceScale = getValueByPath(fromObject, [\n        'guidanceScale',\n    ]);\n    if (parentObject !== undefined && fromGuidanceScale != null) {\n        setValueByPath(parentObject, ['parameters', 'guidanceScale'], fromGuidanceScale);\n    }\n    if (getValueByPath(fromObject, ['seed']) !== undefined) {\n        throw new Error('seed parameter is not supported in Gemini API.');\n    }\n    const fromSafetyFilterLevel = getValueByPath(fromObject, [\n        'safetyFilterLevel',\n    ]);\n    if (parentObject !== undefined && fromSafetyFilterLevel != null) {\n        setValueByPath(parentObject, ['parameters', 'safetySetting'], fromSafetyFilterLevel);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        'personGeneration',\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, ['parameters', 'personGeneration'], fromPersonGeneration);\n    }\n    const fromIncludeSafetyAttributes = getValueByPath(fromObject, [\n        'includeSafetyAttributes',\n    ]);\n    if (parentObject !== undefined && fromIncludeSafetyAttributes != null) {\n        setValueByPath(parentObject, ['parameters', 'includeSafetyAttributes'], fromIncludeSafetyAttributes);\n    }\n    const fromIncludeRaiReason = getValueByPath(fromObject, [\n        'includeRaiReason',\n    ]);\n    if (parentObject !== undefined && fromIncludeRaiReason != null) {\n        setValueByPath(parentObject, ['parameters', 'includeRaiReason'], fromIncludeRaiReason);\n    }\n    const fromLanguage = getValueByPath(fromObject, ['language']);\n    if (parentObject !== undefined && fromLanguage != null) {\n        setValueByPath(parentObject, ['parameters', 'language'], fromLanguage);\n    }\n    const fromOutputMimeType = getValueByPath(fromObject, [\n        'outputMimeType',\n    ]);\n    if (parentObject !== undefined && fromOutputMimeType != null) {\n        setValueByPath(parentObject, ['parameters', 'outputOptions', 'mimeType'], fromOutputMimeType);\n    }\n    const fromOutputCompressionQuality = getValueByPath(fromObject, [\n        'outputCompressionQuality',\n    ]);\n    if (parentObject !== undefined && fromOutputCompressionQuality != null) {\n        setValueByPath(parentObject, ['parameters', 'outputOptions', 'compressionQuality'], fromOutputCompressionQuality);\n    }\n    if (getValueByPath(fromObject, ['addWatermark']) !== undefined) {\n        throw new Error('addWatermark parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['labels']) !== undefined) {\n        throw new Error('labels parameter is not supported in Gemini API.');\n    }\n    const fromImageSize = getValueByPath(fromObject, ['imageSize']);\n    if (parentObject !== undefined && fromImageSize != null) {\n        setValueByPath(parentObject, ['parameters', 'sampleImageSize'], fromImageSize);\n    }\n    if (getValueByPath(fromObject, ['enhancePrompt']) !== undefined) {\n        throw new Error('enhancePrompt parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction generateImagesConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromOutputGcsUri = getValueByPath(fromObject, ['outputGcsUri']);\n    if (parentObject !== undefined && fromOutputGcsUri != null) {\n        setValueByPath(parentObject, ['parameters', 'storageUri'], fromOutputGcsUri);\n    }\n    const fromNegativePrompt = getValueByPath(fromObject, [\n        'negativePrompt',\n    ]);\n    if (parentObject !== undefined && fromNegativePrompt != null) {\n        setValueByPath(parentObject, ['parameters', 'negativePrompt'], fromNegativePrompt);\n    }\n    const fromNumberOfImages = getValueByPath(fromObject, [\n        'numberOfImages',\n    ]);\n    if (parentObject !== undefined && fromNumberOfImages != null) {\n        setValueByPath(parentObject, ['parameters', 'sampleCount'], fromNumberOfImages);\n    }\n    const fromAspectRatio = getValueByPath(fromObject, ['aspectRatio']);\n    if (parentObject !== undefined && fromAspectRatio != null) {\n        setValueByPath(parentObject, ['parameters', 'aspectRatio'], fromAspectRatio);\n    }\n    const fromGuidanceScale = getValueByPath(fromObject, [\n        'guidanceScale',\n    ]);\n    if (parentObject !== undefined && fromGuidanceScale != null) {\n        setValueByPath(parentObject, ['parameters', 'guidanceScale'], fromGuidanceScale);\n    }\n    const fromSeed = getValueByPath(fromObject, ['seed']);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, ['parameters', 'seed'], fromSeed);\n    }\n    const fromSafetyFilterLevel = getValueByPath(fromObject, [\n        'safetyFilterLevel',\n    ]);\n    if (parentObject !== undefined && fromSafetyFilterLevel != null) {\n        setValueByPath(parentObject, ['parameters', 'safetySetting'], fromSafetyFilterLevel);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        'personGeneration',\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, ['parameters', 'personGeneration'], fromPersonGeneration);\n    }\n    const fromIncludeSafetyAttributes = getValueByPath(fromObject, [\n        'includeSafetyAttributes',\n    ]);\n    if (parentObject !== undefined && fromIncludeSafetyAttributes != null) {\n        setValueByPath(parentObject, ['parameters', 'includeSafetyAttributes'], fromIncludeSafetyAttributes);\n    }\n    const fromIncludeRaiReason = getValueByPath(fromObject, [\n        'includeRaiReason',\n    ]);\n    if (parentObject !== undefined && fromIncludeRaiReason != null) {\n        setValueByPath(parentObject, ['parameters', 'includeRaiReason'], fromIncludeRaiReason);\n    }\n    const fromLanguage = getValueByPath(fromObject, ['language']);\n    if (parentObject !== undefined && fromLanguage != null) {\n        setValueByPath(parentObject, ['parameters', 'language'], fromLanguage);\n    }\n    const fromOutputMimeType = getValueByPath(fromObject, [\n        'outputMimeType',\n    ]);\n    if (parentObject !== undefined && fromOutputMimeType != null) {\n        setValueByPath(parentObject, ['parameters', 'outputOptions', 'mimeType'], fromOutputMimeType);\n    }\n    const fromOutputCompressionQuality = getValueByPath(fromObject, [\n        'outputCompressionQuality',\n    ]);\n    if (parentObject !== undefined && fromOutputCompressionQuality != null) {\n        setValueByPath(parentObject, ['parameters', 'outputOptions', 'compressionQuality'], fromOutputCompressionQuality);\n    }\n    const fromAddWatermark = getValueByPath(fromObject, ['addWatermark']);\n    if (parentObject !== undefined && fromAddWatermark != null) {\n        setValueByPath(parentObject, ['parameters', 'addWatermark'], fromAddWatermark);\n    }\n    const fromLabels = getValueByPath(fromObject, ['labels']);\n    if (parentObject !== undefined && fromLabels != null) {\n        setValueByPath(parentObject, ['labels'], fromLabels);\n    }\n    const fromImageSize = getValueByPath(fromObject, ['imageSize']);\n    if (parentObject !== undefined && fromImageSize != null) {\n        setValueByPath(parentObject, ['parameters', 'sampleImageSize'], fromImageSize);\n    }\n    const fromEnhancePrompt = getValueByPath(fromObject, [\n        'enhancePrompt',\n    ]);\n    if (parentObject !== undefined && fromEnhancePrompt != null) {\n        setValueByPath(parentObject, ['parameters', 'enhancePrompt'], fromEnhancePrompt);\n    }\n    return toObject;\n}\nfunction generateImagesParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromPrompt = getValueByPath(fromObject, ['prompt']);\n    if (fromPrompt != null) {\n        setValueByPath(toObject, ['instances[0]', 'prompt'], fromPrompt);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        generateImagesConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction generateImagesParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromPrompt = getValueByPath(fromObject, ['prompt']);\n    if (fromPrompt != null) {\n        setValueByPath(toObject, ['instances[0]', 'prompt'], fromPrompt);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        generateImagesConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction generateImagesResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromGeneratedImages = getValueByPath(fromObject, [\n        'predictions',\n    ]);\n    if (fromGeneratedImages != null) {\n        let transformedList = fromGeneratedImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return generatedImageFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, ['generatedImages'], transformedList);\n    }\n    const fromPositivePromptSafetyAttributes = getValueByPath(fromObject, [\n        'positivePromptSafetyAttributes',\n    ]);\n    if (fromPositivePromptSafetyAttributes != null) {\n        setValueByPath(toObject, ['positivePromptSafetyAttributes'], safetyAttributesFromMldev(fromPositivePromptSafetyAttributes));\n    }\n    return toObject;\n}\nfunction generateImagesResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromGeneratedImages = getValueByPath(fromObject, [\n        'predictions',\n    ]);\n    if (fromGeneratedImages != null) {\n        let transformedList = fromGeneratedImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return generatedImageFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['generatedImages'], transformedList);\n    }\n    const fromPositivePromptSafetyAttributes = getValueByPath(fromObject, [\n        'positivePromptSafetyAttributes',\n    ]);\n    if (fromPositivePromptSafetyAttributes != null) {\n        setValueByPath(toObject, ['positivePromptSafetyAttributes'], safetyAttributesFromVertex(fromPositivePromptSafetyAttributes));\n    }\n    return toObject;\n}\nfunction generateVideosConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromNumberOfVideos = getValueByPath(fromObject, [\n        'numberOfVideos',\n    ]);\n    if (parentObject !== undefined && fromNumberOfVideos != null) {\n        setValueByPath(parentObject, ['parameters', 'sampleCount'], fromNumberOfVideos);\n    }\n    if (getValueByPath(fromObject, ['outputGcsUri']) !== undefined) {\n        throw new Error('outputGcsUri parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['fps']) !== undefined) {\n        throw new Error('fps parameter is not supported in Gemini API.');\n    }\n    const fromDurationSeconds = getValueByPath(fromObject, [\n        'durationSeconds',\n    ]);\n    if (parentObject !== undefined && fromDurationSeconds != null) {\n        setValueByPath(parentObject, ['parameters', 'durationSeconds'], fromDurationSeconds);\n    }\n    if (getValueByPath(fromObject, ['seed']) !== undefined) {\n        throw new Error('seed parameter is not supported in Gemini API.');\n    }\n    const fromAspectRatio = getValueByPath(fromObject, ['aspectRatio']);\n    if (parentObject !== undefined && fromAspectRatio != null) {\n        setValueByPath(parentObject, ['parameters', 'aspectRatio'], fromAspectRatio);\n    }\n    const fromResolution = getValueByPath(fromObject, ['resolution']);\n    if (parentObject !== undefined && fromResolution != null) {\n        setValueByPath(parentObject, ['parameters', 'resolution'], fromResolution);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        'personGeneration',\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, ['parameters', 'personGeneration'], fromPersonGeneration);\n    }\n    if (getValueByPath(fromObject, ['pubsubTopic']) !== undefined) {\n        throw new Error('pubsubTopic parameter is not supported in Gemini API.');\n    }\n    const fromNegativePrompt = getValueByPath(fromObject, [\n        'negativePrompt',\n    ]);\n    if (parentObject !== undefined && fromNegativePrompt != null) {\n        setValueByPath(parentObject, ['parameters', 'negativePrompt'], fromNegativePrompt);\n    }\n    const fromEnhancePrompt = getValueByPath(fromObject, [\n        'enhancePrompt',\n    ]);\n    if (parentObject !== undefined && fromEnhancePrompt != null) {\n        setValueByPath(parentObject, ['parameters', 'enhancePrompt'], fromEnhancePrompt);\n    }\n    if (getValueByPath(fromObject, ['generateAudio']) !== undefined) {\n        throw new Error('generateAudio parameter is not supported in Gemini API.');\n    }\n    const fromLastFrame = getValueByPath(fromObject, ['lastFrame']);\n    if (parentObject !== undefined && fromLastFrame != null) {\n        setValueByPath(parentObject, ['instances[0]', 'lastFrame'], imageToMldev(fromLastFrame));\n    }\n    const fromReferenceImages = getValueByPath(fromObject, [\n        'referenceImages',\n    ]);\n    if (parentObject !== undefined && fromReferenceImages != null) {\n        let transformedList = fromReferenceImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return videoGenerationReferenceImageToMldev(item);\n            });\n        }\n        setValueByPath(parentObject, ['instances[0]', 'referenceImages'], transformedList);\n    }\n    if (getValueByPath(fromObject, ['mask']) !== undefined) {\n        throw new Error('mask parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['compressionQuality']) !== undefined) {\n        throw new Error('compressionQuality parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction generateVideosConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromNumberOfVideos = getValueByPath(fromObject, [\n        'numberOfVideos',\n    ]);\n    if (parentObject !== undefined && fromNumberOfVideos != null) {\n        setValueByPath(parentObject, ['parameters', 'sampleCount'], fromNumberOfVideos);\n    }\n    const fromOutputGcsUri = getValueByPath(fromObject, ['outputGcsUri']);\n    if (parentObject !== undefined && fromOutputGcsUri != null) {\n        setValueByPath(parentObject, ['parameters', 'storageUri'], fromOutputGcsUri);\n    }\n    const fromFps = getValueByPath(fromObject, ['fps']);\n    if (parentObject !== undefined && fromFps != null) {\n        setValueByPath(parentObject, ['parameters', 'fps'], fromFps);\n    }\n    const fromDurationSeconds = getValueByPath(fromObject, [\n        'durationSeconds',\n    ]);\n    if (parentObject !== undefined && fromDurationSeconds != null) {\n        setValueByPath(parentObject, ['parameters', 'durationSeconds'], fromDurationSeconds);\n    }\n    const fromSeed = getValueByPath(fromObject, ['seed']);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, ['parameters', 'seed'], fromSeed);\n    }\n    const fromAspectRatio = getValueByPath(fromObject, ['aspectRatio']);\n    if (parentObject !== undefined && fromAspectRatio != null) {\n        setValueByPath(parentObject, ['parameters', 'aspectRatio'], fromAspectRatio);\n    }\n    const fromResolution = getValueByPath(fromObject, ['resolution']);\n    if (parentObject !== undefined && fromResolution != null) {\n        setValueByPath(parentObject, ['parameters', 'resolution'], fromResolution);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        'personGeneration',\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, ['parameters', 'personGeneration'], fromPersonGeneration);\n    }\n    const fromPubsubTopic = getValueByPath(fromObject, ['pubsubTopic']);\n    if (parentObject !== undefined && fromPubsubTopic != null) {\n        setValueByPath(parentObject, ['parameters', 'pubsubTopic'], fromPubsubTopic);\n    }\n    const fromNegativePrompt = getValueByPath(fromObject, [\n        'negativePrompt',\n    ]);\n    if (parentObject !== undefined && fromNegativePrompt != null) {\n        setValueByPath(parentObject, ['parameters', 'negativePrompt'], fromNegativePrompt);\n    }\n    const fromEnhancePrompt = getValueByPath(fromObject, [\n        'enhancePrompt',\n    ]);\n    if (parentObject !== undefined && fromEnhancePrompt != null) {\n        setValueByPath(parentObject, ['parameters', 'enhancePrompt'], fromEnhancePrompt);\n    }\n    const fromGenerateAudio = getValueByPath(fromObject, [\n        'generateAudio',\n    ]);\n    if (parentObject !== undefined && fromGenerateAudio != null) {\n        setValueByPath(parentObject, ['parameters', 'generateAudio'], fromGenerateAudio);\n    }\n    const fromLastFrame = getValueByPath(fromObject, ['lastFrame']);\n    if (parentObject !== undefined && fromLastFrame != null) {\n        setValueByPath(parentObject, ['instances[0]', 'lastFrame'], imageToVertex(fromLastFrame));\n    }\n    const fromReferenceImages = getValueByPath(fromObject, [\n        'referenceImages',\n    ]);\n    if (parentObject !== undefined && fromReferenceImages != null) {\n        let transformedList = fromReferenceImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return videoGenerationReferenceImageToVertex(item);\n            });\n        }\n        setValueByPath(parentObject, ['instances[0]', 'referenceImages'], transformedList);\n    }\n    const fromMask = getValueByPath(fromObject, ['mask']);\n    if (parentObject !== undefined && fromMask != null) {\n        setValueByPath(parentObject, ['instances[0]', 'mask'], videoGenerationMaskToVertex(fromMask));\n    }\n    const fromCompressionQuality = getValueByPath(fromObject, [\n        'compressionQuality',\n    ]);\n    if (parentObject !== undefined && fromCompressionQuality != null) {\n        setValueByPath(parentObject, ['parameters', 'compressionQuality'], fromCompressionQuality);\n    }\n    return toObject;\n}\nfunction generateVideosOperationFromMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, ['metadata']);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, ['metadata'], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, ['done']);\n    if (fromDone != null) {\n        setValueByPath(toObject, ['done'], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, ['error']);\n    if (fromError != null) {\n        setValueByPath(toObject, ['error'], fromError);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        'response',\n        'generateVideoResponse',\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, ['response'], generateVideosResponseFromMldev(fromResponse));\n    }\n    return toObject;\n}\nfunction generateVideosOperationFromVertex(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, ['metadata']);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, ['metadata'], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, ['done']);\n    if (fromDone != null) {\n        setValueByPath(toObject, ['done'], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, ['error']);\n    if (fromError != null) {\n        setValueByPath(toObject, ['error'], fromError);\n    }\n    const fromResponse = getValueByPath(fromObject, ['response']);\n    if (fromResponse != null) {\n        setValueByPath(toObject, ['response'], generateVideosResponseFromVertex(fromResponse));\n    }\n    return toObject;\n}\nfunction generateVideosParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromPrompt = getValueByPath(fromObject, ['prompt']);\n    if (fromPrompt != null) {\n        setValueByPath(toObject, ['instances[0]', 'prompt'], fromPrompt);\n    }\n    const fromImage = getValueByPath(fromObject, ['image']);\n    if (fromImage != null) {\n        setValueByPath(toObject, ['instances[0]', 'image'], imageToMldev(fromImage));\n    }\n    const fromVideo = getValueByPath(fromObject, ['video']);\n    if (fromVideo != null) {\n        setValueByPath(toObject, ['instances[0]', 'video'], videoToMldev(fromVideo));\n    }\n    const fromSource = getValueByPath(fromObject, ['source']);\n    if (fromSource != null) {\n        generateVideosSourceToMldev(fromSource, toObject);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        generateVideosConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction generateVideosParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromPrompt = getValueByPath(fromObject, ['prompt']);\n    if (fromPrompt != null) {\n        setValueByPath(toObject, ['instances[0]', 'prompt'], fromPrompt);\n    }\n    const fromImage = getValueByPath(fromObject, ['image']);\n    if (fromImage != null) {\n        setValueByPath(toObject, ['instances[0]', 'image'], imageToVertex(fromImage));\n    }\n    const fromVideo = getValueByPath(fromObject, ['video']);\n    if (fromVideo != null) {\n        setValueByPath(toObject, ['instances[0]', 'video'], videoToVertex(fromVideo));\n    }\n    const fromSource = getValueByPath(fromObject, ['source']);\n    if (fromSource != null) {\n        generateVideosSourceToVertex(fromSource, toObject);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        generateVideosConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction generateVideosResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromGeneratedVideos = getValueByPath(fromObject, [\n        'generatedSamples',\n    ]);\n    if (fromGeneratedVideos != null) {\n        let transformedList = fromGeneratedVideos;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return generatedVideoFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, ['generatedVideos'], transformedList);\n    }\n    const fromRaiMediaFilteredCount = getValueByPath(fromObject, [\n        'raiMediaFilteredCount',\n    ]);\n    if (fromRaiMediaFilteredCount != null) {\n        setValueByPath(toObject, ['raiMediaFilteredCount'], fromRaiMediaFilteredCount);\n    }\n    const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [\n        'raiMediaFilteredReasons',\n    ]);\n    if (fromRaiMediaFilteredReasons != null) {\n        setValueByPath(toObject, ['raiMediaFilteredReasons'], fromRaiMediaFilteredReasons);\n    }\n    return toObject;\n}\nfunction generateVideosResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromGeneratedVideos = getValueByPath(fromObject, ['videos']);\n    if (fromGeneratedVideos != null) {\n        let transformedList = fromGeneratedVideos;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return generatedVideoFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['generatedVideos'], transformedList);\n    }\n    const fromRaiMediaFilteredCount = getValueByPath(fromObject, [\n        'raiMediaFilteredCount',\n    ]);\n    if (fromRaiMediaFilteredCount != null) {\n        setValueByPath(toObject, ['raiMediaFilteredCount'], fromRaiMediaFilteredCount);\n    }\n    const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [\n        'raiMediaFilteredReasons',\n    ]);\n    if (fromRaiMediaFilteredReasons != null) {\n        setValueByPath(toObject, ['raiMediaFilteredReasons'], fromRaiMediaFilteredReasons);\n    }\n    return toObject;\n}\nfunction generateVideosSourceToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromPrompt = getValueByPath(fromObject, ['prompt']);\n    if (parentObject !== undefined && fromPrompt != null) {\n        setValueByPath(parentObject, ['instances[0]', 'prompt'], fromPrompt);\n    }\n    const fromImage = getValueByPath(fromObject, ['image']);\n    if (parentObject !== undefined && fromImage != null) {\n        setValueByPath(parentObject, ['instances[0]', 'image'], imageToMldev(fromImage));\n    }\n    const fromVideo = getValueByPath(fromObject, ['video']);\n    if (parentObject !== undefined && fromVideo != null) {\n        setValueByPath(parentObject, ['instances[0]', 'video'], videoToMldev(fromVideo));\n    }\n    return toObject;\n}\nfunction generateVideosSourceToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromPrompt = getValueByPath(fromObject, ['prompt']);\n    if (parentObject !== undefined && fromPrompt != null) {\n        setValueByPath(parentObject, ['instances[0]', 'prompt'], fromPrompt);\n    }\n    const fromImage = getValueByPath(fromObject, ['image']);\n    if (parentObject !== undefined && fromImage != null) {\n        setValueByPath(parentObject, ['instances[0]', 'image'], imageToVertex(fromImage));\n    }\n    const fromVideo = getValueByPath(fromObject, ['video']);\n    if (parentObject !== undefined && fromVideo != null) {\n        setValueByPath(parentObject, ['instances[0]', 'video'], videoToVertex(fromVideo));\n    }\n    return toObject;\n}\nfunction generatedImageFromMldev(fromObject) {\n    const toObject = {};\n    const fromImage = getValueByPath(fromObject, ['_self']);\n    if (fromImage != null) {\n        setValueByPath(toObject, ['image'], imageFromMldev(fromImage));\n    }\n    const fromRaiFilteredReason = getValueByPath(fromObject, [\n        'raiFilteredReason',\n    ]);\n    if (fromRaiFilteredReason != null) {\n        setValueByPath(toObject, ['raiFilteredReason'], fromRaiFilteredReason);\n    }\n    const fromSafetyAttributes = getValueByPath(fromObject, ['_self']);\n    if (fromSafetyAttributes != null) {\n        setValueByPath(toObject, ['safetyAttributes'], safetyAttributesFromMldev(fromSafetyAttributes));\n    }\n    return toObject;\n}\nfunction generatedImageFromVertex(fromObject) {\n    const toObject = {};\n    const fromImage = getValueByPath(fromObject, ['_self']);\n    if (fromImage != null) {\n        setValueByPath(toObject, ['image'], imageFromVertex(fromImage));\n    }\n    const fromRaiFilteredReason = getValueByPath(fromObject, [\n        'raiFilteredReason',\n    ]);\n    if (fromRaiFilteredReason != null) {\n        setValueByPath(toObject, ['raiFilteredReason'], fromRaiFilteredReason);\n    }\n    const fromSafetyAttributes = getValueByPath(fromObject, ['_self']);\n    if (fromSafetyAttributes != null) {\n        setValueByPath(toObject, ['safetyAttributes'], safetyAttributesFromVertex(fromSafetyAttributes));\n    }\n    const fromEnhancedPrompt = getValueByPath(fromObject, ['prompt']);\n    if (fromEnhancedPrompt != null) {\n        setValueByPath(toObject, ['enhancedPrompt'], fromEnhancedPrompt);\n    }\n    return toObject;\n}\nfunction generatedImageMaskFromVertex(fromObject) {\n    const toObject = {};\n    const fromMask = getValueByPath(fromObject, ['_self']);\n    if (fromMask != null) {\n        setValueByPath(toObject, ['mask'], imageFromVertex(fromMask));\n    }\n    const fromLabels = getValueByPath(fromObject, ['labels']);\n    if (fromLabels != null) {\n        let transformedList = fromLabels;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['labels'], transformedList);\n    }\n    return toObject;\n}\nfunction generatedVideoFromMldev(fromObject) {\n    const toObject = {};\n    const fromVideo = getValueByPath(fromObject, ['video']);\n    if (fromVideo != null) {\n        setValueByPath(toObject, ['video'], videoFromMldev(fromVideo));\n    }\n    return toObject;\n}\nfunction generatedVideoFromVertex(fromObject) {\n    const toObject = {};\n    const fromVideo = getValueByPath(fromObject, ['_self']);\n    if (fromVideo != null) {\n        setValueByPath(toObject, ['video'], videoFromVertex(fromVideo));\n    }\n    return toObject;\n}\nfunction generationConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromModelSelectionConfig = getValueByPath(fromObject, [\n        'modelSelectionConfig',\n    ]);\n    if (fromModelSelectionConfig != null) {\n        setValueByPath(toObject, ['modelConfig'], fromModelSelectionConfig);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        'responseJsonSchema',\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, ['responseJsonSchema'], fromResponseJsonSchema);\n    }\n    const fromAudioTimestamp = getValueByPath(fromObject, [\n        'audioTimestamp',\n    ]);\n    if (fromAudioTimestamp != null) {\n        setValueByPath(toObject, ['audioTimestamp'], fromAudioTimestamp);\n    }\n    const fromCandidateCount = getValueByPath(fromObject, [\n        'candidateCount',\n    ]);\n    if (fromCandidateCount != null) {\n        setValueByPath(toObject, ['candidateCount'], fromCandidateCount);\n    }\n    const fromEnableAffectiveDialog = getValueByPath(fromObject, [\n        'enableAffectiveDialog',\n    ]);\n    if (fromEnableAffectiveDialog != null) {\n        setValueByPath(toObject, ['enableAffectiveDialog'], fromEnableAffectiveDialog);\n    }\n    const fromFrequencyPenalty = getValueByPath(fromObject, [\n        'frequencyPenalty',\n    ]);\n    if (fromFrequencyPenalty != null) {\n        setValueByPath(toObject, ['frequencyPenalty'], fromFrequencyPenalty);\n    }\n    const fromLogprobs = getValueByPath(fromObject, ['logprobs']);\n    if (fromLogprobs != null) {\n        setValueByPath(toObject, ['logprobs'], fromLogprobs);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        'maxOutputTokens',\n    ]);\n    if (fromMaxOutputTokens != null) {\n        setValueByPath(toObject, ['maxOutputTokens'], fromMaxOutputTokens);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        'mediaResolution',\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, ['mediaResolution'], fromMediaResolution);\n    }\n    const fromPresencePenalty = getValueByPath(fromObject, [\n        'presencePenalty',\n    ]);\n    if (fromPresencePenalty != null) {\n        setValueByPath(toObject, ['presencePenalty'], fromPresencePenalty);\n    }\n    const fromResponseLogprobs = getValueByPath(fromObject, [\n        'responseLogprobs',\n    ]);\n    if (fromResponseLogprobs != null) {\n        setValueByPath(toObject, ['responseLogprobs'], fromResponseLogprobs);\n    }\n    const fromResponseMimeType = getValueByPath(fromObject, [\n        'responseMimeType',\n    ]);\n    if (fromResponseMimeType != null) {\n        setValueByPath(toObject, ['responseMimeType'], fromResponseMimeType);\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        'responseModalities',\n    ]);\n    if (fromResponseModalities != null) {\n        setValueByPath(toObject, ['responseModalities'], fromResponseModalities);\n    }\n    const fromResponseSchema = getValueByPath(fromObject, [\n        'responseSchema',\n    ]);\n    if (fromResponseSchema != null) {\n        setValueByPath(toObject, ['responseSchema'], fromResponseSchema);\n    }\n    const fromRoutingConfig = getValueByPath(fromObject, [\n        'routingConfig',\n    ]);\n    if (fromRoutingConfig != null) {\n        setValueByPath(toObject, ['routingConfig'], fromRoutingConfig);\n    }\n    const fromSeed = getValueByPath(fromObject, ['seed']);\n    if (fromSeed != null) {\n        setValueByPath(toObject, ['seed'], fromSeed);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, ['speechConfig']);\n    if (fromSpeechConfig != null) {\n        setValueByPath(toObject, ['speechConfig'], speechConfigToVertex(fromSpeechConfig));\n    }\n    const fromStopSequences = getValueByPath(fromObject, [\n        'stopSequences',\n    ]);\n    if (fromStopSequences != null) {\n        setValueByPath(toObject, ['stopSequences'], fromStopSequences);\n    }\n    const fromTemperature = getValueByPath(fromObject, ['temperature']);\n    if (fromTemperature != null) {\n        setValueByPath(toObject, ['temperature'], fromTemperature);\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        'thinkingConfig',\n    ]);\n    if (fromThinkingConfig != null) {\n        setValueByPath(toObject, ['thinkingConfig'], fromThinkingConfig);\n    }\n    const fromTopK = getValueByPath(fromObject, ['topK']);\n    if (fromTopK != null) {\n        setValueByPath(toObject, ['topK'], fromTopK);\n    }\n    const fromTopP = getValueByPath(fromObject, ['topP']);\n    if (fromTopP != null) {\n        setValueByPath(toObject, ['topP'], fromTopP);\n    }\n    if (getValueByPath(fromObject, ['enableEnhancedCivicAnswers']) !==\n        undefined) {\n        throw new Error('enableEnhancedCivicAnswers parameter is not supported in Vertex AI.');\n    }\n    return toObject;\n}\nfunction getModelParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'name'], tModel(apiClient, fromModel));\n    }\n    return toObject;\n}\nfunction getModelParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'name'], tModel(apiClient, fromModel));\n    }\n    return toObject;\n}\nfunction googleMapsToMldev$1(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['authConfig']) !== undefined) {\n        throw new Error('authConfig parameter is not supported in Gemini API.');\n    }\n    const fromEnableWidget = getValueByPath(fromObject, ['enableWidget']);\n    if (fromEnableWidget != null) {\n        setValueByPath(toObject, ['enableWidget'], fromEnableWidget);\n    }\n    return toObject;\n}\nfunction googleSearchToMldev$1(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['excludeDomains']) !== undefined) {\n        throw new Error('excludeDomains parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['blockingConfidence']) !== undefined) {\n        throw new Error('blockingConfidence parameter is not supported in Gemini API.');\n    }\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        'timeRangeFilter',\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, ['timeRangeFilter'], fromTimeRangeFilter);\n    }\n    return toObject;\n}\nfunction imageConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromAspectRatio = getValueByPath(fromObject, ['aspectRatio']);\n    if (fromAspectRatio != null) {\n        setValueByPath(toObject, ['aspectRatio'], fromAspectRatio);\n    }\n    const fromImageSize = getValueByPath(fromObject, ['imageSize']);\n    if (fromImageSize != null) {\n        setValueByPath(toObject, ['imageSize'], fromImageSize);\n    }\n    if (getValueByPath(fromObject, ['outputMimeType']) !== undefined) {\n        throw new Error('outputMimeType parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['outputCompressionQuality']) !==\n        undefined) {\n        throw new Error('outputCompressionQuality parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction imageConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromAspectRatio = getValueByPath(fromObject, ['aspectRatio']);\n    if (fromAspectRatio != null) {\n        setValueByPath(toObject, ['aspectRatio'], fromAspectRatio);\n    }\n    const fromImageSize = getValueByPath(fromObject, ['imageSize']);\n    if (fromImageSize != null) {\n        setValueByPath(toObject, ['imageSize'], fromImageSize);\n    }\n    const fromOutputMimeType = getValueByPath(fromObject, [\n        'outputMimeType',\n    ]);\n    if (fromOutputMimeType != null) {\n        setValueByPath(toObject, ['imageOutputOptions', 'mimeType'], fromOutputMimeType);\n    }\n    const fromOutputCompressionQuality = getValueByPath(fromObject, [\n        'outputCompressionQuality',\n    ]);\n    if (fromOutputCompressionQuality != null) {\n        setValueByPath(toObject, ['imageOutputOptions', 'compressionQuality'], fromOutputCompressionQuality);\n    }\n    return toObject;\n}\nfunction imageFromMldev(fromObject) {\n    const toObject = {};\n    const fromImageBytes = getValueByPath(fromObject, [\n        'bytesBase64Encoded',\n    ]);\n    if (fromImageBytes != null) {\n        setValueByPath(toObject, ['imageBytes'], tBytes(fromImageBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction imageFromVertex(fromObject) {\n    const toObject = {};\n    const fromGcsUri = getValueByPath(fromObject, ['gcsUri']);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, ['gcsUri'], fromGcsUri);\n    }\n    const fromImageBytes = getValueByPath(fromObject, [\n        'bytesBase64Encoded',\n    ]);\n    if (fromImageBytes != null) {\n        setValueByPath(toObject, ['imageBytes'], tBytes(fromImageBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction imageToMldev(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['gcsUri']) !== undefined) {\n        throw new Error('gcsUri parameter is not supported in Gemini API.');\n    }\n    const fromImageBytes = getValueByPath(fromObject, ['imageBytes']);\n    if (fromImageBytes != null) {\n        setValueByPath(toObject, ['bytesBase64Encoded'], tBytes(fromImageBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction imageToVertex(fromObject) {\n    const toObject = {};\n    const fromGcsUri = getValueByPath(fromObject, ['gcsUri']);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, ['gcsUri'], fromGcsUri);\n    }\n    const fromImageBytes = getValueByPath(fromObject, ['imageBytes']);\n    if (fromImageBytes != null) {\n        setValueByPath(toObject, ['bytesBase64Encoded'], tBytes(fromImageBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction listModelsConfigToMldev(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, ['pageSize']);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, ['_query', 'pageSize'], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, ['pageToken']);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, ['_query', 'pageToken'], fromPageToken);\n    }\n    const fromFilter = getValueByPath(fromObject, ['filter']);\n    if (parentObject !== undefined && fromFilter != null) {\n        setValueByPath(parentObject, ['_query', 'filter'], fromFilter);\n    }\n    const fromQueryBase = getValueByPath(fromObject, ['queryBase']);\n    if (parentObject !== undefined && fromQueryBase != null) {\n        setValueByPath(parentObject, ['_url', 'models_url'], tModelsUrl(apiClient, fromQueryBase));\n    }\n    return toObject;\n}\nfunction listModelsConfigToVertex(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, ['pageSize']);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, ['_query', 'pageSize'], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, ['pageToken']);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, ['_query', 'pageToken'], fromPageToken);\n    }\n    const fromFilter = getValueByPath(fromObject, ['filter']);\n    if (parentObject !== undefined && fromFilter != null) {\n        setValueByPath(parentObject, ['_query', 'filter'], fromFilter);\n    }\n    const fromQueryBase = getValueByPath(fromObject, ['queryBase']);\n    if (parentObject !== undefined && fromQueryBase != null) {\n        setValueByPath(parentObject, ['_url', 'models_url'], tModelsUrl(apiClient, fromQueryBase));\n    }\n    return toObject;\n}\nfunction listModelsParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        listModelsConfigToMldev(apiClient, fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listModelsParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        listModelsConfigToVertex(apiClient, fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listModelsResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        'nextPageToken',\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, ['nextPageToken'], fromNextPageToken);\n    }\n    const fromModels = getValueByPath(fromObject, ['_self']);\n    if (fromModels != null) {\n        let transformedList = tExtractModels(fromModels);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return modelFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, ['models'], transformedList);\n    }\n    return toObject;\n}\nfunction listModelsResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        'nextPageToken',\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, ['nextPageToken'], fromNextPageToken);\n    }\n    const fromModels = getValueByPath(fromObject, ['_self']);\n    if (fromModels != null) {\n        let transformedList = tExtractModels(fromModels);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return modelFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['models'], transformedList);\n    }\n    return toObject;\n}\nfunction maskReferenceConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromMaskMode = getValueByPath(fromObject, ['maskMode']);\n    if (fromMaskMode != null) {\n        setValueByPath(toObject, ['maskMode'], fromMaskMode);\n    }\n    const fromSegmentationClasses = getValueByPath(fromObject, [\n        'segmentationClasses',\n    ]);\n    if (fromSegmentationClasses != null) {\n        setValueByPath(toObject, ['maskClasses'], fromSegmentationClasses);\n    }\n    const fromMaskDilation = getValueByPath(fromObject, ['maskDilation']);\n    if (fromMaskDilation != null) {\n        setValueByPath(toObject, ['dilation'], fromMaskDilation);\n    }\n    return toObject;\n}\nfunction modelFromMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, ['displayName']);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, ['displayName'], fromDisplayName);\n    }\n    const fromDescription = getValueByPath(fromObject, ['description']);\n    if (fromDescription != null) {\n        setValueByPath(toObject, ['description'], fromDescription);\n    }\n    const fromVersion = getValueByPath(fromObject, ['version']);\n    if (fromVersion != null) {\n        setValueByPath(toObject, ['version'], fromVersion);\n    }\n    const fromTunedModelInfo = getValueByPath(fromObject, ['_self']);\n    if (fromTunedModelInfo != null) {\n        setValueByPath(toObject, ['tunedModelInfo'], tunedModelInfoFromMldev(fromTunedModelInfo));\n    }\n    const fromInputTokenLimit = getValueByPath(fromObject, [\n        'inputTokenLimit',\n    ]);\n    if (fromInputTokenLimit != null) {\n        setValueByPath(toObject, ['inputTokenLimit'], fromInputTokenLimit);\n    }\n    const fromOutputTokenLimit = getValueByPath(fromObject, [\n        'outputTokenLimit',\n    ]);\n    if (fromOutputTokenLimit != null) {\n        setValueByPath(toObject, ['outputTokenLimit'], fromOutputTokenLimit);\n    }\n    const fromSupportedActions = getValueByPath(fromObject, [\n        'supportedGenerationMethods',\n    ]);\n    if (fromSupportedActions != null) {\n        setValueByPath(toObject, ['supportedActions'], fromSupportedActions);\n    }\n    const fromTemperature = getValueByPath(fromObject, ['temperature']);\n    if (fromTemperature != null) {\n        setValueByPath(toObject, ['temperature'], fromTemperature);\n    }\n    const fromMaxTemperature = getValueByPath(fromObject, [\n        'maxTemperature',\n    ]);\n    if (fromMaxTemperature != null) {\n        setValueByPath(toObject, ['maxTemperature'], fromMaxTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, ['topP']);\n    if (fromTopP != null) {\n        setValueByPath(toObject, ['topP'], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, ['topK']);\n    if (fromTopK != null) {\n        setValueByPath(toObject, ['topK'], fromTopK);\n    }\n    const fromThinking = getValueByPath(fromObject, ['thinking']);\n    if (fromThinking != null) {\n        setValueByPath(toObject, ['thinking'], fromThinking);\n    }\n    return toObject;\n}\nfunction modelFromVertex(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, ['displayName']);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, ['displayName'], fromDisplayName);\n    }\n    const fromDescription = getValueByPath(fromObject, ['description']);\n    if (fromDescription != null) {\n        setValueByPath(toObject, ['description'], fromDescription);\n    }\n    const fromVersion = getValueByPath(fromObject, ['versionId']);\n    if (fromVersion != null) {\n        setValueByPath(toObject, ['version'], fromVersion);\n    }\n    const fromEndpoints = getValueByPath(fromObject, ['deployedModels']);\n    if (fromEndpoints != null) {\n        let transformedList = fromEndpoints;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return endpointFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['endpoints'], transformedList);\n    }\n    const fromLabels = getValueByPath(fromObject, ['labels']);\n    if (fromLabels != null) {\n        setValueByPath(toObject, ['labels'], fromLabels);\n    }\n    const fromTunedModelInfo = getValueByPath(fromObject, ['_self']);\n    if (fromTunedModelInfo != null) {\n        setValueByPath(toObject, ['tunedModelInfo'], tunedModelInfoFromVertex(fromTunedModelInfo));\n    }\n    const fromDefaultCheckpointId = getValueByPath(fromObject, [\n        'defaultCheckpointId',\n    ]);\n    if (fromDefaultCheckpointId != null) {\n        setValueByPath(toObject, ['defaultCheckpointId'], fromDefaultCheckpointId);\n    }\n    const fromCheckpoints = getValueByPath(fromObject, ['checkpoints']);\n    if (fromCheckpoints != null) {\n        let transformedList = fromCheckpoints;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['checkpoints'], transformedList);\n    }\n    return toObject;\n}\nfunction partToMldev$1(fromObject) {\n    const toObject = {};\n    const fromMediaResolution = getValueByPath(fromObject, [\n        'mediaResolution',\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, ['mediaResolution'], fromMediaResolution);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        'codeExecutionResult',\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, ['codeExecutionResult'], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        'executableCode',\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, ['executableCode'], fromExecutableCode);\n    }\n    const fromFileData = getValueByPath(fromObject, ['fileData']);\n    if (fromFileData != null) {\n        setValueByPath(toObject, ['fileData'], fileDataToMldev$1(fromFileData));\n    }\n    const fromFunctionCall = getValueByPath(fromObject, ['functionCall']);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, ['functionCall'], functionCallToMldev$1(fromFunctionCall));\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        'functionResponse',\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, ['functionResponse'], fromFunctionResponse);\n    }\n    const fromInlineData = getValueByPath(fromObject, ['inlineData']);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, ['inlineData'], blobToMldev$1(fromInlineData));\n    }\n    const fromText = getValueByPath(fromObject, ['text']);\n    if (fromText != null) {\n        setValueByPath(toObject, ['text'], fromText);\n    }\n    const fromThought = getValueByPath(fromObject, ['thought']);\n    if (fromThought != null) {\n        setValueByPath(toObject, ['thought'], fromThought);\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        'thoughtSignature',\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, ['thoughtSignature'], fromThoughtSignature);\n    }\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        'videoMetadata',\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, ['videoMetadata'], fromVideoMetadata);\n    }\n    return toObject;\n}\nfunction productImageToVertex(fromObject) {\n    const toObject = {};\n    const fromProductImage = getValueByPath(fromObject, ['productImage']);\n    if (fromProductImage != null) {\n        setValueByPath(toObject, ['image'], imageToVertex(fromProductImage));\n    }\n    return toObject;\n}\nfunction recontextImageConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromNumberOfImages = getValueByPath(fromObject, [\n        'numberOfImages',\n    ]);\n    if (parentObject !== undefined && fromNumberOfImages != null) {\n        setValueByPath(parentObject, ['parameters', 'sampleCount'], fromNumberOfImages);\n    }\n    const fromBaseSteps = getValueByPath(fromObject, ['baseSteps']);\n    if (parentObject !== undefined && fromBaseSteps != null) {\n        setValueByPath(parentObject, ['parameters', 'baseSteps'], fromBaseSteps);\n    }\n    const fromOutputGcsUri = getValueByPath(fromObject, ['outputGcsUri']);\n    if (parentObject !== undefined && fromOutputGcsUri != null) {\n        setValueByPath(parentObject, ['parameters', 'storageUri'], fromOutputGcsUri);\n    }\n    const fromSeed = getValueByPath(fromObject, ['seed']);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, ['parameters', 'seed'], fromSeed);\n    }\n    const fromSafetyFilterLevel = getValueByPath(fromObject, [\n        'safetyFilterLevel',\n    ]);\n    if (parentObject !== undefined && fromSafetyFilterLevel != null) {\n        setValueByPath(parentObject, ['parameters', 'safetySetting'], fromSafetyFilterLevel);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        'personGeneration',\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, ['parameters', 'personGeneration'], fromPersonGeneration);\n    }\n    const fromAddWatermark = getValueByPath(fromObject, ['addWatermark']);\n    if (parentObject !== undefined && fromAddWatermark != null) {\n        setValueByPath(parentObject, ['parameters', 'addWatermark'], fromAddWatermark);\n    }\n    const fromOutputMimeType = getValueByPath(fromObject, [\n        'outputMimeType',\n    ]);\n    if (parentObject !== undefined && fromOutputMimeType != null) {\n        setValueByPath(parentObject, ['parameters', 'outputOptions', 'mimeType'], fromOutputMimeType);\n    }\n    const fromOutputCompressionQuality = getValueByPath(fromObject, [\n        'outputCompressionQuality',\n    ]);\n    if (parentObject !== undefined && fromOutputCompressionQuality != null) {\n        setValueByPath(parentObject, ['parameters', 'outputOptions', 'compressionQuality'], fromOutputCompressionQuality);\n    }\n    const fromEnhancePrompt = getValueByPath(fromObject, [\n        'enhancePrompt',\n    ]);\n    if (parentObject !== undefined && fromEnhancePrompt != null) {\n        setValueByPath(parentObject, ['parameters', 'enhancePrompt'], fromEnhancePrompt);\n    }\n    const fromLabels = getValueByPath(fromObject, ['labels']);\n    if (parentObject !== undefined && fromLabels != null) {\n        setValueByPath(parentObject, ['labels'], fromLabels);\n    }\n    return toObject;\n}\nfunction recontextImageParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromSource = getValueByPath(fromObject, ['source']);\n    if (fromSource != null) {\n        recontextImageSourceToVertex(fromSource, toObject);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        recontextImageConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction recontextImageResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromGeneratedImages = getValueByPath(fromObject, [\n        'predictions',\n    ]);\n    if (fromGeneratedImages != null) {\n        let transformedList = fromGeneratedImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return generatedImageFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['generatedImages'], transformedList);\n    }\n    return toObject;\n}\nfunction recontextImageSourceToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromPrompt = getValueByPath(fromObject, ['prompt']);\n    if (parentObject !== undefined && fromPrompt != null) {\n        setValueByPath(parentObject, ['instances[0]', 'prompt'], fromPrompt);\n    }\n    const fromPersonImage = getValueByPath(fromObject, ['personImage']);\n    if (parentObject !== undefined && fromPersonImage != null) {\n        setValueByPath(parentObject, ['instances[0]', 'personImage', 'image'], imageToVertex(fromPersonImage));\n    }\n    const fromProductImages = getValueByPath(fromObject, [\n        'productImages',\n    ]);\n    if (parentObject !== undefined && fromProductImages != null) {\n        let transformedList = fromProductImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return productImageToVertex(item);\n            });\n        }\n        setValueByPath(parentObject, ['instances[0]', 'productImages'], transformedList);\n    }\n    return toObject;\n}\nfunction referenceImageAPIInternalToVertex(fromObject) {\n    const toObject = {};\n    const fromReferenceImage = getValueByPath(fromObject, [\n        'referenceImage',\n    ]);\n    if (fromReferenceImage != null) {\n        setValueByPath(toObject, ['referenceImage'], imageToVertex(fromReferenceImage));\n    }\n    const fromReferenceId = getValueByPath(fromObject, ['referenceId']);\n    if (fromReferenceId != null) {\n        setValueByPath(toObject, ['referenceId'], fromReferenceId);\n    }\n    const fromReferenceType = getValueByPath(fromObject, [\n        'referenceType',\n    ]);\n    if (fromReferenceType != null) {\n        setValueByPath(toObject, ['referenceType'], fromReferenceType);\n    }\n    const fromMaskImageConfig = getValueByPath(fromObject, [\n        'maskImageConfig',\n    ]);\n    if (fromMaskImageConfig != null) {\n        setValueByPath(toObject, ['maskImageConfig'], maskReferenceConfigToVertex(fromMaskImageConfig));\n    }\n    const fromControlImageConfig = getValueByPath(fromObject, [\n        'controlImageConfig',\n    ]);\n    if (fromControlImageConfig != null) {\n        setValueByPath(toObject, ['controlImageConfig'], controlReferenceConfigToVertex(fromControlImageConfig));\n    }\n    const fromStyleImageConfig = getValueByPath(fromObject, [\n        'styleImageConfig',\n    ]);\n    if (fromStyleImageConfig != null) {\n        setValueByPath(toObject, ['styleImageConfig'], fromStyleImageConfig);\n    }\n    const fromSubjectImageConfig = getValueByPath(fromObject, [\n        'subjectImageConfig',\n    ]);\n    if (fromSubjectImageConfig != null) {\n        setValueByPath(toObject, ['subjectImageConfig'], fromSubjectImageConfig);\n    }\n    return toObject;\n}\nfunction safetyAttributesFromMldev(fromObject) {\n    const toObject = {};\n    const fromCategories = getValueByPath(fromObject, [\n        'safetyAttributes',\n        'categories',\n    ]);\n    if (fromCategories != null) {\n        setValueByPath(toObject, ['categories'], fromCategories);\n    }\n    const fromScores = getValueByPath(fromObject, [\n        'safetyAttributes',\n        'scores',\n    ]);\n    if (fromScores != null) {\n        setValueByPath(toObject, ['scores'], fromScores);\n    }\n    const fromContentType = getValueByPath(fromObject, ['contentType']);\n    if (fromContentType != null) {\n        setValueByPath(toObject, ['contentType'], fromContentType);\n    }\n    return toObject;\n}\nfunction safetyAttributesFromVertex(fromObject) {\n    const toObject = {};\n    const fromCategories = getValueByPath(fromObject, [\n        'safetyAttributes',\n        'categories',\n    ]);\n    if (fromCategories != null) {\n        setValueByPath(toObject, ['categories'], fromCategories);\n    }\n    const fromScores = getValueByPath(fromObject, [\n        'safetyAttributes',\n        'scores',\n    ]);\n    if (fromScores != null) {\n        setValueByPath(toObject, ['scores'], fromScores);\n    }\n    const fromContentType = getValueByPath(fromObject, ['contentType']);\n    if (fromContentType != null) {\n        setValueByPath(toObject, ['contentType'], fromContentType);\n    }\n    return toObject;\n}\nfunction safetySettingToMldev(fromObject) {\n    const toObject = {};\n    const fromCategory = getValueByPath(fromObject, ['category']);\n    if (fromCategory != null) {\n        setValueByPath(toObject, ['category'], fromCategory);\n    }\n    if (getValueByPath(fromObject, ['method']) !== undefined) {\n        throw new Error('method parameter is not supported in Gemini API.');\n    }\n    const fromThreshold = getValueByPath(fromObject, ['threshold']);\n    if (fromThreshold != null) {\n        setValueByPath(toObject, ['threshold'], fromThreshold);\n    }\n    return toObject;\n}\nfunction scribbleImageToVertex(fromObject) {\n    const toObject = {};\n    const fromImage = getValueByPath(fromObject, ['image']);\n    if (fromImage != null) {\n        setValueByPath(toObject, ['image'], imageToVertex(fromImage));\n    }\n    return toObject;\n}\nfunction segmentImageConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, ['mode']);\n    if (parentObject !== undefined && fromMode != null) {\n        setValueByPath(parentObject, ['parameters', 'mode'], fromMode);\n    }\n    const fromMaxPredictions = getValueByPath(fromObject, [\n        'maxPredictions',\n    ]);\n    if (parentObject !== undefined && fromMaxPredictions != null) {\n        setValueByPath(parentObject, ['parameters', 'maxPredictions'], fromMaxPredictions);\n    }\n    const fromConfidenceThreshold = getValueByPath(fromObject, [\n        'confidenceThreshold',\n    ]);\n    if (parentObject !== undefined && fromConfidenceThreshold != null) {\n        setValueByPath(parentObject, ['parameters', 'confidenceThreshold'], fromConfidenceThreshold);\n    }\n    const fromMaskDilation = getValueByPath(fromObject, ['maskDilation']);\n    if (parentObject !== undefined && fromMaskDilation != null) {\n        setValueByPath(parentObject, ['parameters', 'maskDilation'], fromMaskDilation);\n    }\n    const fromBinaryColorThreshold = getValueByPath(fromObject, [\n        'binaryColorThreshold',\n    ]);\n    if (parentObject !== undefined && fromBinaryColorThreshold != null) {\n        setValueByPath(parentObject, ['parameters', 'binaryColorThreshold'], fromBinaryColorThreshold);\n    }\n    const fromLabels = getValueByPath(fromObject, ['labels']);\n    if (parentObject !== undefined && fromLabels != null) {\n        setValueByPath(parentObject, ['labels'], fromLabels);\n    }\n    return toObject;\n}\nfunction segmentImageParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromSource = getValueByPath(fromObject, ['source']);\n    if (fromSource != null) {\n        segmentImageSourceToVertex(fromSource, toObject);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        segmentImageConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction segmentImageResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromGeneratedMasks = getValueByPath(fromObject, ['predictions']);\n    if (fromGeneratedMasks != null) {\n        let transformedList = fromGeneratedMasks;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return generatedImageMaskFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['generatedMasks'], transformedList);\n    }\n    return toObject;\n}\nfunction segmentImageSourceToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromPrompt = getValueByPath(fromObject, ['prompt']);\n    if (parentObject !== undefined && fromPrompt != null) {\n        setValueByPath(parentObject, ['instances[0]', 'prompt'], fromPrompt);\n    }\n    const fromImage = getValueByPath(fromObject, ['image']);\n    if (parentObject !== undefined && fromImage != null) {\n        setValueByPath(parentObject, ['instances[0]', 'image'], imageToVertex(fromImage));\n    }\n    const fromScribbleImage = getValueByPath(fromObject, [\n        'scribbleImage',\n    ]);\n    if (parentObject !== undefined && fromScribbleImage != null) {\n        setValueByPath(parentObject, ['instances[0]', 'scribble'], scribbleImageToVertex(fromScribbleImage));\n    }\n    return toObject;\n}\nfunction speechConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromLanguageCode = getValueByPath(fromObject, ['languageCode']);\n    if (fromLanguageCode != null) {\n        setValueByPath(toObject, ['languageCode'], fromLanguageCode);\n    }\n    const fromVoiceConfig = getValueByPath(fromObject, ['voiceConfig']);\n    if (fromVoiceConfig != null) {\n        setValueByPath(toObject, ['voiceConfig'], fromVoiceConfig);\n    }\n    if (getValueByPath(fromObject, ['multiSpeakerVoiceConfig']) !== undefined) {\n        throw new Error('multiSpeakerVoiceConfig parameter is not supported in Vertex AI.');\n    }\n    return toObject;\n}\nfunction toolConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromFunctionCallingConfig = getValueByPath(fromObject, [\n        'functionCallingConfig',\n    ]);\n    if (fromFunctionCallingConfig != null) {\n        setValueByPath(toObject, ['functionCallingConfig'], functionCallingConfigToMldev(fromFunctionCallingConfig));\n    }\n    const fromRetrievalConfig = getValueByPath(fromObject, [\n        'retrievalConfig',\n    ]);\n    if (fromRetrievalConfig != null) {\n        setValueByPath(toObject, ['retrievalConfig'], fromRetrievalConfig);\n    }\n    return toObject;\n}\nfunction toolToMldev$1(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        'functionDeclarations',\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['functionDeclarations'], transformedList);\n    }\n    if (getValueByPath(fromObject, ['retrieval']) !== undefined) {\n        throw new Error('retrieval parameter is not supported in Gemini API.');\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        'googleSearchRetrieval',\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, ['googleSearchRetrieval'], fromGoogleSearchRetrieval);\n    }\n    const fromComputerUse = getValueByPath(fromObject, ['computerUse']);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, ['computerUse'], fromComputerUse);\n    }\n    const fromFileSearch = getValueByPath(fromObject, ['fileSearch']);\n    if (fromFileSearch != null) {\n        setValueByPath(toObject, ['fileSearch'], fromFileSearch);\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        'codeExecution',\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, ['codeExecution'], fromCodeExecution);\n    }\n    if (getValueByPath(fromObject, ['enterpriseWebSearch']) !== undefined) {\n        throw new Error('enterpriseWebSearch parameter is not supported in Gemini API.');\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, ['googleMaps']);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, ['googleMaps'], googleMapsToMldev$1(fromGoogleMaps));\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, ['googleSearch']);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, ['googleSearch'], googleSearchToMldev$1(fromGoogleSearch));\n    }\n    const fromUrlContext = getValueByPath(fromObject, ['urlContext']);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, ['urlContext'], fromUrlContext);\n    }\n    return toObject;\n}\nfunction toolToVertex(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        'functionDeclarations',\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return functionDeclarationToVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['functionDeclarations'], transformedList);\n    }\n    const fromRetrieval = getValueByPath(fromObject, ['retrieval']);\n    if (fromRetrieval != null) {\n        setValueByPath(toObject, ['retrieval'], fromRetrieval);\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        'googleSearchRetrieval',\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, ['googleSearchRetrieval'], fromGoogleSearchRetrieval);\n    }\n    const fromComputerUse = getValueByPath(fromObject, ['computerUse']);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, ['computerUse'], fromComputerUse);\n    }\n    if (getValueByPath(fromObject, ['fileSearch']) !== undefined) {\n        throw new Error('fileSearch parameter is not supported in Vertex AI.');\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        'codeExecution',\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, ['codeExecution'], fromCodeExecution);\n    }\n    const fromEnterpriseWebSearch = getValueByPath(fromObject, [\n        'enterpriseWebSearch',\n    ]);\n    if (fromEnterpriseWebSearch != null) {\n        setValueByPath(toObject, ['enterpriseWebSearch'], fromEnterpriseWebSearch);\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, ['googleMaps']);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, ['googleMaps'], fromGoogleMaps);\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, ['googleSearch']);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, ['googleSearch'], fromGoogleSearch);\n    }\n    const fromUrlContext = getValueByPath(fromObject, ['urlContext']);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, ['urlContext'], fromUrlContext);\n    }\n    return toObject;\n}\nfunction tunedModelInfoFromMldev(fromObject) {\n    const toObject = {};\n    const fromBaseModel = getValueByPath(fromObject, ['baseModel']);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, ['baseModel'], fromBaseModel);\n    }\n    const fromCreateTime = getValueByPath(fromObject, ['createTime']);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, ['createTime'], fromCreateTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, ['updateTime']);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, ['updateTime'], fromUpdateTime);\n    }\n    return toObject;\n}\nfunction tunedModelInfoFromVertex(fromObject) {\n    const toObject = {};\n    const fromBaseModel = getValueByPath(fromObject, [\n        'labels',\n        'google-vertex-llm-tuning-base-model-id',\n    ]);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, ['baseModel'], fromBaseModel);\n    }\n    const fromCreateTime = getValueByPath(fromObject, ['createTime']);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, ['createTime'], fromCreateTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, ['updateTime']);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, ['updateTime'], fromUpdateTime);\n    }\n    return toObject;\n}\nfunction updateModelConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, ['displayName']);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, ['displayName'], fromDisplayName);\n    }\n    const fromDescription = getValueByPath(fromObject, ['description']);\n    if (parentObject !== undefined && fromDescription != null) {\n        setValueByPath(parentObject, ['description'], fromDescription);\n    }\n    const fromDefaultCheckpointId = getValueByPath(fromObject, [\n        'defaultCheckpointId',\n    ]);\n    if (parentObject !== undefined && fromDefaultCheckpointId != null) {\n        setValueByPath(parentObject, ['defaultCheckpointId'], fromDefaultCheckpointId);\n    }\n    return toObject;\n}\nfunction updateModelConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, ['displayName']);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, ['displayName'], fromDisplayName);\n    }\n    const fromDescription = getValueByPath(fromObject, ['description']);\n    if (parentObject !== undefined && fromDescription != null) {\n        setValueByPath(parentObject, ['description'], fromDescription);\n    }\n    const fromDefaultCheckpointId = getValueByPath(fromObject, [\n        'defaultCheckpointId',\n    ]);\n    if (parentObject !== undefined && fromDefaultCheckpointId != null) {\n        setValueByPath(parentObject, ['defaultCheckpointId'], fromDefaultCheckpointId);\n    }\n    return toObject;\n}\nfunction updateModelParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'name'], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        updateModelConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction updateModelParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        updateModelConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction upscaleImageAPIConfigInternalToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromOutputGcsUri = getValueByPath(fromObject, ['outputGcsUri']);\n    if (parentObject !== undefined && fromOutputGcsUri != null) {\n        setValueByPath(parentObject, ['parameters', 'storageUri'], fromOutputGcsUri);\n    }\n    const fromSafetyFilterLevel = getValueByPath(fromObject, [\n        'safetyFilterLevel',\n    ]);\n    if (parentObject !== undefined && fromSafetyFilterLevel != null) {\n        setValueByPath(parentObject, ['parameters', 'safetySetting'], fromSafetyFilterLevel);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        'personGeneration',\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, ['parameters', 'personGeneration'], fromPersonGeneration);\n    }\n    const fromIncludeRaiReason = getValueByPath(fromObject, [\n        'includeRaiReason',\n    ]);\n    if (parentObject !== undefined && fromIncludeRaiReason != null) {\n        setValueByPath(parentObject, ['parameters', 'includeRaiReason'], fromIncludeRaiReason);\n    }\n    const fromOutputMimeType = getValueByPath(fromObject, [\n        'outputMimeType',\n    ]);\n    if (parentObject !== undefined && fromOutputMimeType != null) {\n        setValueByPath(parentObject, ['parameters', 'outputOptions', 'mimeType'], fromOutputMimeType);\n    }\n    const fromOutputCompressionQuality = getValueByPath(fromObject, [\n        'outputCompressionQuality',\n    ]);\n    if (parentObject !== undefined && fromOutputCompressionQuality != null) {\n        setValueByPath(parentObject, ['parameters', 'outputOptions', 'compressionQuality'], fromOutputCompressionQuality);\n    }\n    const fromEnhanceInputImage = getValueByPath(fromObject, [\n        'enhanceInputImage',\n    ]);\n    if (parentObject !== undefined && fromEnhanceInputImage != null) {\n        setValueByPath(parentObject, ['parameters', 'upscaleConfig', 'enhanceInputImage'], fromEnhanceInputImage);\n    }\n    const fromImagePreservationFactor = getValueByPath(fromObject, [\n        'imagePreservationFactor',\n    ]);\n    if (parentObject !== undefined && fromImagePreservationFactor != null) {\n        setValueByPath(parentObject, ['parameters', 'upscaleConfig', 'imagePreservationFactor'], fromImagePreservationFactor);\n    }\n    const fromLabels = getValueByPath(fromObject, ['labels']);\n    if (parentObject !== undefined && fromLabels != null) {\n        setValueByPath(parentObject, ['labels'], fromLabels);\n    }\n    const fromNumberOfImages = getValueByPath(fromObject, [\n        'numberOfImages',\n    ]);\n    if (parentObject !== undefined && fromNumberOfImages != null) {\n        setValueByPath(parentObject, ['parameters', 'sampleCount'], fromNumberOfImages);\n    }\n    const fromMode = getValueByPath(fromObject, ['mode']);\n    if (parentObject !== undefined && fromMode != null) {\n        setValueByPath(parentObject, ['parameters', 'mode'], fromMode);\n    }\n    return toObject;\n}\nfunction upscaleImageAPIParametersInternalToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromImage = getValueByPath(fromObject, ['image']);\n    if (fromImage != null) {\n        setValueByPath(toObject, ['instances[0]', 'image'], imageToVertex(fromImage));\n    }\n    const fromUpscaleFactor = getValueByPath(fromObject, [\n        'upscaleFactor',\n    ]);\n    if (fromUpscaleFactor != null) {\n        setValueByPath(toObject, ['parameters', 'upscaleConfig', 'upscaleFactor'], fromUpscaleFactor);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        upscaleImageAPIConfigInternalToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction upscaleImageResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromGeneratedImages = getValueByPath(fromObject, [\n        'predictions',\n    ]);\n    if (fromGeneratedImages != null) {\n        let transformedList = fromGeneratedImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return generatedImageFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['generatedImages'], transformedList);\n    }\n    return toObject;\n}\nfunction videoFromMldev(fromObject) {\n    const toObject = {};\n    const fromUri = getValueByPath(fromObject, ['uri']);\n    if (fromUri != null) {\n        setValueByPath(toObject, ['uri'], fromUri);\n    }\n    const fromVideoBytes = getValueByPath(fromObject, ['encodedVideo']);\n    if (fromVideoBytes != null) {\n        setValueByPath(toObject, ['videoBytes'], tBytes(fromVideoBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, ['encoding']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction videoFromVertex(fromObject) {\n    const toObject = {};\n    const fromUri = getValueByPath(fromObject, ['gcsUri']);\n    if (fromUri != null) {\n        setValueByPath(toObject, ['uri'], fromUri);\n    }\n    const fromVideoBytes = getValueByPath(fromObject, [\n        'bytesBase64Encoded',\n    ]);\n    if (fromVideoBytes != null) {\n        setValueByPath(toObject, ['videoBytes'], tBytes(fromVideoBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction videoGenerationMaskToVertex(fromObject) {\n    const toObject = {};\n    const fromImage = getValueByPath(fromObject, ['image']);\n    if (fromImage != null) {\n        setValueByPath(toObject, ['_self'], imageToVertex(fromImage));\n    }\n    const fromMaskMode = getValueByPath(fromObject, ['maskMode']);\n    if (fromMaskMode != null) {\n        setValueByPath(toObject, ['maskMode'], fromMaskMode);\n    }\n    return toObject;\n}\nfunction videoGenerationReferenceImageToMldev(fromObject) {\n    const toObject = {};\n    const fromImage = getValueByPath(fromObject, ['image']);\n    if (fromImage != null) {\n        setValueByPath(toObject, ['image'], imageToMldev(fromImage));\n    }\n    const fromReferenceType = getValueByPath(fromObject, [\n        'referenceType',\n    ]);\n    if (fromReferenceType != null) {\n        setValueByPath(toObject, ['referenceType'], fromReferenceType);\n    }\n    return toObject;\n}\nfunction videoGenerationReferenceImageToVertex(fromObject) {\n    const toObject = {};\n    const fromImage = getValueByPath(fromObject, ['image']);\n    if (fromImage != null) {\n        setValueByPath(toObject, ['image'], imageToVertex(fromImage));\n    }\n    const fromReferenceType = getValueByPath(fromObject, [\n        'referenceType',\n    ]);\n    if (fromReferenceType != null) {\n        setValueByPath(toObject, ['referenceType'], fromReferenceType);\n    }\n    return toObject;\n}\nfunction videoToMldev(fromObject) {\n    const toObject = {};\n    const fromUri = getValueByPath(fromObject, ['uri']);\n    if (fromUri != null) {\n        setValueByPath(toObject, ['uri'], fromUri);\n    }\n    const fromVideoBytes = getValueByPath(fromObject, ['videoBytes']);\n    if (fromVideoBytes != null) {\n        setValueByPath(toObject, ['encodedVideo'], tBytes(fromVideoBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['encoding'], fromMimeType);\n    }\n    return toObject;\n}\nfunction videoToVertex(fromObject) {\n    const toObject = {};\n    const fromUri = getValueByPath(fromObject, ['uri']);\n    if (fromUri != null) {\n        setValueByPath(toObject, ['gcsUri'], fromUri);\n    }\n    const fromVideoBytes = getValueByPath(fromObject, ['videoBytes']);\n    if (fromVideoBytes != null) {\n        setValueByPath(toObject, ['bytesBase64Encoded'], tBytes(fromVideoBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst CONTENT_TYPE_HEADER = 'Content-Type';\nconst SERVER_TIMEOUT_HEADER = 'X-Server-Timeout';\nconst USER_AGENT_HEADER = 'User-Agent';\nconst GOOGLE_API_CLIENT_HEADER = 'x-goog-api-client';\nconst SDK_VERSION = '1.30.0'; // x-release-please-version\nconst LIBRARY_LABEL = `google-genai-sdk/${SDK_VERSION}`;\nconst VERTEX_AI_API_DEFAULT_VERSION = 'v1beta1';\nconst GOOGLE_AI_API_DEFAULT_VERSION = 'v1beta';\nconst responseLineRE = /^\\s*data: (.*)(?:\\n\\n|\\r\\r|\\r\\n\\r\\n)/;\n/**\n * The ApiClient class is used to send requests to the Gemini API or Vertex AI\n * endpoints.\n */\nclass ApiClient {\n    constructor(opts) {\n        var _a, _b;\n        this.clientOptions = Object.assign(Object.assign({}, opts), { project: opts.project, location: opts.location, apiKey: opts.apiKey, vertexai: opts.vertexai });\n        const initHttpOptions = {};\n        if (this.clientOptions.vertexai) {\n            initHttpOptions.apiVersion =\n                (_a = this.clientOptions.apiVersion) !== null && _a !== void 0 ? _a : VERTEX_AI_API_DEFAULT_VERSION;\n            initHttpOptions.baseUrl = this.baseUrlFromProjectLocation();\n            this.normalizeAuthParameters();\n        }\n        else {\n            // Gemini API\n            initHttpOptions.apiVersion =\n                (_b = this.clientOptions.apiVersion) !== null && _b !== void 0 ? _b : GOOGLE_AI_API_DEFAULT_VERSION;\n            initHttpOptions.baseUrl = `https://generativelanguage.googleapis.com/`;\n        }\n        initHttpOptions.headers = this.getDefaultHeaders();\n        this.clientOptions.httpOptions = initHttpOptions;\n        if (opts.httpOptions) {\n            this.clientOptions.httpOptions = this.patchHttpOptions(initHttpOptions, opts.httpOptions);\n        }\n    }\n    /**\n     * Determines the base URL for Vertex AI based on project and location.\n     * Uses the global endpoint if location is 'global' or if project/location\n     * are not specified (implying API key usage).\n     * @private\n     */\n    baseUrlFromProjectLocation() {\n        if (this.clientOptions.project &&\n            this.clientOptions.location &&\n            this.clientOptions.location !== 'global') {\n            // Regional endpoint\n            return `https://${this.clientOptions.location}-aiplatform.googleapis.com/`;\n        }\n        // Global endpoint (covers 'global' location and API key usage)\n        return `https://aiplatform.googleapis.com/`;\n    }\n    /**\n     * Normalizes authentication parameters for Vertex AI.\n     * If project and location are provided, API key is cleared.\n     * If project and location are not provided (implying API key usage),\n     * project and location are cleared.\n     * @private\n     */\n    normalizeAuthParameters() {\n        if (this.clientOptions.project && this.clientOptions.location) {\n            // Using project/location for auth, clear potential API key\n            this.clientOptions.apiKey = undefined;\n            return;\n        }\n        // Using API key for auth (or no auth provided yet), clear project/location\n        this.clientOptions.project = undefined;\n        this.clientOptions.location = undefined;\n    }\n    isVertexAI() {\n        var _a;\n        return (_a = this.clientOptions.vertexai) !== null && _a !== void 0 ? _a : false;\n    }\n    getProject() {\n        return this.clientOptions.project;\n    }\n    getLocation() {\n        return this.clientOptions.location;\n    }\n    getApiVersion() {\n        if (this.clientOptions.httpOptions &&\n            this.clientOptions.httpOptions.apiVersion !== undefined) {\n            return this.clientOptions.httpOptions.apiVersion;\n        }\n        throw new Error('API version is not set.');\n    }\n    getBaseUrl() {\n        if (this.clientOptions.httpOptions &&\n            this.clientOptions.httpOptions.baseUrl !== undefined) {\n            return this.clientOptions.httpOptions.baseUrl;\n        }\n        throw new Error('Base URL is not set.');\n    }\n    getRequestUrl() {\n        return this.getRequestUrlInternal(this.clientOptions.httpOptions);\n    }\n    getHeaders() {\n        if (this.clientOptions.httpOptions &&\n            this.clientOptions.httpOptions.headers !== undefined) {\n            return this.clientOptions.httpOptions.headers;\n        }\n        else {\n            throw new Error('Headers are not set.');\n        }\n    }\n    getRequestUrlInternal(httpOptions) {\n        if (!httpOptions ||\n            httpOptions.baseUrl === undefined ||\n            httpOptions.apiVersion === undefined) {\n            throw new Error('HTTP options are not correctly set.');\n        }\n        const baseUrl = httpOptions.baseUrl.endsWith('/')\n            ? httpOptions.baseUrl.slice(0, -1)\n            : httpOptions.baseUrl;\n        const urlElement = [baseUrl];\n        if (httpOptions.apiVersion && httpOptions.apiVersion !== '') {\n            urlElement.push(httpOptions.apiVersion);\n        }\n        return urlElement.join('/');\n    }\n    getBaseResourcePath() {\n        return `projects/${this.clientOptions.project}/locations/${this.clientOptions.location}`;\n    }\n    getApiKey() {\n        return this.clientOptions.apiKey;\n    }\n    getWebsocketBaseUrl() {\n        const baseUrl = this.getBaseUrl();\n        const urlParts = new URL(baseUrl);\n        urlParts.protocol = urlParts.protocol == 'http:' ? 'ws' : 'wss';\n        return urlParts.toString();\n    }\n    setBaseUrl(url) {\n        if (this.clientOptions.httpOptions) {\n            this.clientOptions.httpOptions.baseUrl = url;\n        }\n        else {\n            throw new Error('HTTP options are not correctly set.');\n        }\n    }\n    constructUrl(path, httpOptions, prependProjectLocation) {\n        const urlElement = [this.getRequestUrlInternal(httpOptions)];\n        if (prependProjectLocation) {\n            urlElement.push(this.getBaseResourcePath());\n        }\n        if (path !== '') {\n            urlElement.push(path);\n        }\n        const url = new URL(`${urlElement.join('/')}`);\n        return url;\n    }\n    shouldPrependVertexProjectPath(request) {\n        if (this.clientOptions.apiKey) {\n            return false;\n        }\n        if (!this.clientOptions.vertexai) {\n            return false;\n        }\n        if (request.path.startsWith('projects/')) {\n            // Assume the path already starts with\n            // `projects/<project>/location/<location>`.\n            return false;\n        }\n        if (request.httpMethod === 'GET' &&\n            request.path.startsWith('publishers/google/models')) {\n            // These paths are used by Vertex's models.get and models.list\n            // calls. For base models Vertex does not accept a project/location\n            // prefix (for tuned model the prefix is required).\n            return false;\n        }\n        return true;\n    }\n    async request(request) {\n        let patchedHttpOptions = this.clientOptions.httpOptions;\n        if (request.httpOptions) {\n            patchedHttpOptions = this.patchHttpOptions(this.clientOptions.httpOptions, request.httpOptions);\n        }\n        const prependProjectLocation = this.shouldPrependVertexProjectPath(request);\n        const url = this.constructUrl(request.path, patchedHttpOptions, prependProjectLocation);\n        if (request.queryParams) {\n            for (const [key, value] of Object.entries(request.queryParams)) {\n                url.searchParams.append(key, String(value));\n            }\n        }\n        let requestInit = {};\n        if (request.httpMethod === 'GET') {\n            if (request.body && request.body !== '{}') {\n                throw new Error('Request body should be empty for GET request, but got non empty request body');\n            }\n        }\n        else {\n            requestInit.body = request.body;\n        }\n        requestInit = await this.includeExtraHttpOptionsToRequestInit(requestInit, patchedHttpOptions, url.toString(), request.abortSignal);\n        return this.unaryApiCall(url, requestInit, request.httpMethod);\n    }\n    patchHttpOptions(baseHttpOptions, requestHttpOptions) {\n        const patchedHttpOptions = JSON.parse(JSON.stringify(baseHttpOptions));\n        for (const [key, value] of Object.entries(requestHttpOptions)) {\n            // Records compile to objects.\n            if (typeof value === 'object') {\n                // @ts-expect-error TS2345TS7053: Element implicitly has an 'any' type\n                // because expression of type 'string' can't be used to index type\n                // 'HttpOptions'.\n                patchedHttpOptions[key] = Object.assign(Object.assign({}, patchedHttpOptions[key]), value);\n            }\n            else if (value !== undefined) {\n                // @ts-expect-error TS2345TS7053: Element implicitly has an 'any' type\n                // because expression of type 'string' can't be used to index type\n                // 'HttpOptions'.\n                patchedHttpOptions[key] = value;\n            }\n        }\n        return patchedHttpOptions;\n    }\n    async requestStream(request) {\n        let patchedHttpOptions = this.clientOptions.httpOptions;\n        if (request.httpOptions) {\n            patchedHttpOptions = this.patchHttpOptions(this.clientOptions.httpOptions, request.httpOptions);\n        }\n        const prependProjectLocation = this.shouldPrependVertexProjectPath(request);\n        const url = this.constructUrl(request.path, patchedHttpOptions, prependProjectLocation);\n        if (!url.searchParams.has('alt') || url.searchParams.get('alt') !== 'sse') {\n            url.searchParams.set('alt', 'sse');\n        }\n        let requestInit = {};\n        requestInit.body = request.body;\n        requestInit = await this.includeExtraHttpOptionsToRequestInit(requestInit, patchedHttpOptions, url.toString(), request.abortSignal);\n        return this.streamApiCall(url, requestInit, request.httpMethod);\n    }\n    async includeExtraHttpOptionsToRequestInit(requestInit, httpOptions, url, abortSignal) {\n        if ((httpOptions && httpOptions.timeout) || abortSignal) {\n            const abortController = new AbortController();\n            const signal = abortController.signal;\n            if (httpOptions.timeout && (httpOptions === null || httpOptions === void 0 ? void 0 : httpOptions.timeout) > 0) {\n                const timeoutHandle = setTimeout(() => abortController.abort(), httpOptions.timeout);\n                if (timeoutHandle &&\n                    typeof timeoutHandle.unref ===\n                        'function') {\n                    // call unref to prevent nodejs process from hanging, see\n                    // https://nodejs.org/api/timers.html#timeoutunref\n                    timeoutHandle.unref();\n                }\n            }\n            if (abortSignal) {\n                abortSignal.addEventListener('abort', () => {\n                    abortController.abort();\n                });\n            }\n            requestInit.signal = signal;\n        }\n        if (httpOptions && httpOptions.extraBody !== null) {\n            includeExtraBodyToRequestInit(requestInit, httpOptions.extraBody);\n        }\n        requestInit.headers = await this.getHeadersInternal(httpOptions, url);\n        return requestInit;\n    }\n    async unaryApiCall(url, requestInit, httpMethod) {\n        return this.apiCall(url.toString(), Object.assign(Object.assign({}, requestInit), { method: httpMethod }))\n            .then(async (response) => {\n            await throwErrorIfNotOK(response);\n            return new HttpResponse(response);\n        })\n            .catch((e) => {\n            if (e instanceof Error) {\n                throw e;\n            }\n            else {\n                throw new Error(JSON.stringify(e));\n            }\n        });\n    }\n    async streamApiCall(url, requestInit, httpMethod) {\n        return this.apiCall(url.toString(), Object.assign(Object.assign({}, requestInit), { method: httpMethod }))\n            .then(async (response) => {\n            await throwErrorIfNotOK(response);\n            return this.processStreamResponse(response);\n        })\n            .catch((e) => {\n            if (e instanceof Error) {\n                throw e;\n            }\n            else {\n                throw new Error(JSON.stringify(e));\n            }\n        });\n    }\n    processStreamResponse(response) {\n        var _a;\n        return __asyncGenerator(this, arguments, function* processStreamResponse_1() {\n            const reader = (_a = response === null || response === void 0 ? void 0 : response.body) === null || _a === void 0 ? void 0 : _a.getReader();\n            const decoder = new TextDecoder('utf-8');\n            if (!reader) {\n                throw new Error('Response body is empty');\n            }\n            try {\n                let buffer = '';\n                while (true) {\n                    const { done, value } = yield __await(reader.read());\n                    if (done) {\n                        if (buffer.trim().length > 0) {\n                            throw new Error('Incomplete JSON segment at the end');\n                        }\n                        break;\n                    }\n                    const chunkString = decoder.decode(value, { stream: true });\n                    // Parse and throw an error if the chunk contains an error.\n                    try {\n                        const chunkJson = JSON.parse(chunkString);\n                        if ('error' in chunkJson) {\n                            const errorJson = JSON.parse(JSON.stringify(chunkJson['error']));\n                            const status = errorJson['status'];\n                            const code = errorJson['code'];\n                            const errorMessage = `got status: ${status}. ${JSON.stringify(chunkJson)}`;\n                            if (code >= 400 && code < 600) {\n                                const apiError = new ApiError({\n                                    message: errorMessage,\n                                    status: code,\n                                });\n                                throw apiError;\n                            }\n                        }\n                    }\n                    catch (e) {\n                        const error = e;\n                        if (error.name === 'ApiError') {\n                            throw e;\n                        }\n                    }\n                    buffer += chunkString;\n                    let match = buffer.match(responseLineRE);\n                    while (match) {\n                        const processedChunkString = match[1];\n                        try {\n                            const partialResponse = new Response(processedChunkString, {\n                                headers: response === null || response === void 0 ? void 0 : response.headers,\n                                status: response === null || response === void 0 ? void 0 : response.status,\n                                statusText: response === null || response === void 0 ? void 0 : response.statusText,\n                            });\n                            yield yield __await(new HttpResponse(partialResponse));\n                            buffer = buffer.slice(match[0].length);\n                            match = buffer.match(responseLineRE);\n                        }\n                        catch (e) {\n                            throw new Error(`exception parsing stream chunk ${processedChunkString}. ${e}`);\n                        }\n                    }\n                }\n            }\n            finally {\n                reader.releaseLock();\n            }\n        });\n    }\n    async apiCall(url, requestInit) {\n        return fetch(url, requestInit).catch((e) => {\n            throw new Error(`exception ${e} sending request`);\n        });\n    }\n    getDefaultHeaders() {\n        const headers = {};\n        const versionHeaderValue = LIBRARY_LABEL + ' ' + this.clientOptions.userAgentExtra;\n        headers[USER_AGENT_HEADER] = versionHeaderValue;\n        headers[GOOGLE_API_CLIENT_HEADER] = versionHeaderValue;\n        headers[CONTENT_TYPE_HEADER] = 'application/json';\n        return headers;\n    }\n    async getHeadersInternal(httpOptions, url) {\n        const headers = new Headers();\n        if (httpOptions && httpOptions.headers) {\n            for (const [key, value] of Object.entries(httpOptions.headers)) {\n                headers.append(key, value);\n            }\n            // Append a timeout header if it is set, note that the timeout option is\n            // in milliseconds but the header is in seconds.\n            if (httpOptions.timeout && httpOptions.timeout > 0) {\n                headers.append(SERVER_TIMEOUT_HEADER, String(Math.ceil(httpOptions.timeout / 1000)));\n            }\n        }\n        await this.clientOptions.auth.addAuthHeaders(headers, url);\n        return headers;\n    }\n    getFileName(file) {\n        var _a;\n        let fileName = '';\n        if (typeof file === 'string') {\n            fileName = file.replace(/[/\\\\]+$/, '');\n            fileName = (_a = fileName.split(/[/\\\\]/).pop()) !== null && _a !== void 0 ? _a : '';\n        }\n        return fileName;\n    }\n    /**\n     * Uploads a file asynchronously using Gemini API only, this is not supported\n     * in Vertex AI.\n     *\n     * @param file The string path to the file to be uploaded or a Blob object.\n     * @param config Optional parameters specified in the `UploadFileConfig`\n     *     interface. @see {@link types.UploadFileConfig}\n     * @return A promise that resolves to a `File` object.\n     * @throws An error if called on a Vertex AI client.\n     * @throws An error if the `mimeType` is not provided and can not be inferred,\n     */\n    async uploadFile(file, config) {\n        var _a;\n        const fileToUpload = {};\n        if (config != null) {\n            fileToUpload.mimeType = config.mimeType;\n            fileToUpload.name = config.name;\n            fileToUpload.displayName = config.displayName;\n        }\n        if (fileToUpload.name && !fileToUpload.name.startsWith('files/')) {\n            fileToUpload.name = `files/${fileToUpload.name}`;\n        }\n        const uploader = this.clientOptions.uploader;\n        const fileStat = await uploader.stat(file);\n        fileToUpload.sizeBytes = String(fileStat.size);\n        const mimeType = (_a = config === null || config === void 0 ? void 0 : config.mimeType) !== null && _a !== void 0 ? _a : fileStat.type;\n        if (mimeType === undefined || mimeType === '') {\n            throw new Error('Can not determine mimeType. Please provide mimeType in the config.');\n        }\n        fileToUpload.mimeType = mimeType;\n        const body = {\n            file: fileToUpload,\n        };\n        const fileName = this.getFileName(file);\n        const path = formatMap('upload/v1beta/files', body['_url']);\n        const uploadUrl = await this.fetchUploadUrl(path, fileToUpload.sizeBytes, fileToUpload.mimeType, fileName, body, config === null || config === void 0 ? void 0 : config.httpOptions);\n        return uploader.upload(file, uploadUrl, this);\n    }\n    /**\n     * Uploads a file to a given file search store asynchronously using Gemini API only, this is not supported\n     * in Vertex AI.\n     *\n     * @param fileSearchStoreName The name of the file search store to upload the file to.\n     * @param file The string path to the file to be uploaded or a Blob object.\n     * @param config Optional parameters specified in the `UploadFileConfig`\n     *     interface. @see {@link UploadFileConfig}\n     * @return A promise that resolves to a `File` object.\n     * @throws An error if called on a Vertex AI client.\n     * @throws An error if the `mimeType` is not provided and can not be inferred,\n     */\n    async uploadFileToFileSearchStore(fileSearchStoreName, file, config) {\n        var _a;\n        const uploader = this.clientOptions.uploader;\n        const fileStat = await uploader.stat(file);\n        const sizeBytes = String(fileStat.size);\n        const mimeType = (_a = config === null || config === void 0 ? void 0 : config.mimeType) !== null && _a !== void 0 ? _a : fileStat.type;\n        if (mimeType === undefined || mimeType === '') {\n            throw new Error('Can not determine mimeType. Please provide mimeType in the config.');\n        }\n        const path = `upload/v1beta/${fileSearchStoreName}:uploadToFileSearchStore`;\n        const fileName = this.getFileName(file);\n        const body = {};\n        if (config === null || config === void 0 ? void 0 : config.customMetadata) {\n            body['customMetadata'] = config.customMetadata;\n        }\n        if (config === null || config === void 0 ? void 0 : config.chunkingConfig) {\n            body['chunkingConfig'] = config.chunkingConfig;\n        }\n        const uploadUrl = await this.fetchUploadUrl(path, sizeBytes, mimeType, fileName, body, config === null || config === void 0 ? void 0 : config.httpOptions);\n        return uploader.uploadToFileSearchStore(file, uploadUrl, this);\n    }\n    /**\n     * Downloads a file asynchronously to the specified path.\n     *\n     * @params params - The parameters for the download request, see {@link\n     * types.DownloadFileParameters}\n     */\n    async downloadFile(params) {\n        const downloader = this.clientOptions.downloader;\n        await downloader.download(params, this);\n    }\n    async fetchUploadUrl(path, sizeBytes, mimeType, fileName, body, configHttpOptions) {\n        var _a;\n        let httpOptions = {};\n        if (configHttpOptions) {\n            httpOptions = configHttpOptions;\n        }\n        else {\n            httpOptions = {\n                apiVersion: '',\n                headers: Object.assign({ 'Content-Type': 'application/json', 'X-Goog-Upload-Protocol': 'resumable', 'X-Goog-Upload-Command': 'start', 'X-Goog-Upload-Header-Content-Length': `${sizeBytes}`, 'X-Goog-Upload-Header-Content-Type': `${mimeType}` }, (fileName ? { 'X-Goog-Upload-File-Name': fileName } : {})),\n            };\n        }\n        const httpResponse = await this.request({\n            path,\n            body: JSON.stringify(body),\n            httpMethod: 'POST',\n            httpOptions,\n        });\n        if (!httpResponse || !(httpResponse === null || httpResponse === void 0 ? void 0 : httpResponse.headers)) {\n            throw new Error('Server did not return an HttpResponse or the returned HttpResponse did not have headers.');\n        }\n        const uploadUrl = (_a = httpResponse === null || httpResponse === void 0 ? void 0 : httpResponse.headers) === null || _a === void 0 ? void 0 : _a['x-goog-upload-url'];\n        if (uploadUrl === undefined) {\n            throw new Error('Failed to get upload url. Server did not return the x-google-upload-url in the headers');\n        }\n        return uploadUrl;\n    }\n}\nasync function throwErrorIfNotOK(response) {\n    var _a;\n    if (response === undefined) {\n        throw new Error('response is undefined');\n    }\n    if (!response.ok) {\n        const status = response.status;\n        let errorBody;\n        if ((_a = response.headers.get('content-type')) === null || _a === void 0 ? void 0 : _a.includes('application/json')) {\n            errorBody = await response.json();\n        }\n        else {\n            errorBody = {\n                error: {\n                    message: await response.text(),\n                    code: response.status,\n                    status: response.statusText,\n                },\n            };\n        }\n        const errorMessage = JSON.stringify(errorBody);\n        if (status >= 400 && status < 600) {\n            const apiError = new ApiError({\n                message: errorMessage,\n                status: status,\n            });\n            throw apiError;\n        }\n        throw new Error(errorMessage);\n    }\n}\n/**\n * Recursively updates the `requestInit.body` with values from an `extraBody` object.\n *\n * If `requestInit.body` is a string, it's assumed to be JSON and will be parsed.\n * The `extraBody` is then deeply merged into this parsed object.\n * If `requestInit.body` is a Blob, `extraBody` will be ignored, and a warning logged,\n * as merging structured data into an opaque Blob is not supported.\n *\n * The function does not enforce that updated values from `extraBody` have the\n * same type as existing values in `requestInit.body`. Type mismatches during\n * the merge will result in a warning, but the value from `extraBody` will overwrite\n * the original. `extraBody` users are responsible for ensuring `extraBody` has the correct structure.\n *\n * @param requestInit The RequestInit object whose body will be updated.\n * @param extraBody The object containing updates to be merged into `requestInit.body`.\n */\nfunction includeExtraBodyToRequestInit(requestInit, extraBody) {\n    if (!extraBody || Object.keys(extraBody).length === 0) {\n        return;\n    }\n    if (requestInit.body instanceof Blob) {\n        console.warn('includeExtraBodyToRequestInit: extraBody provided but current request body is a Blob. extraBody will be ignored as merging is not supported for Blob bodies.');\n        return;\n    }\n    let currentBodyObject = {};\n    // If adding new type to HttpRequest.body, please check the code below to\n    // see if we need to update the logic.\n    if (typeof requestInit.body === 'string' && requestInit.body.length > 0) {\n        try {\n            const parsedBody = JSON.parse(requestInit.body);\n            if (typeof parsedBody === 'object' &&\n                parsedBody !== null &&\n                !Array.isArray(parsedBody)) {\n                currentBodyObject = parsedBody;\n            }\n            else {\n                console.warn('includeExtraBodyToRequestInit: Original request body is valid JSON but not a non-array object. Skip applying extraBody to the request body.');\n                return;\n            }\n            /*  eslint-disable-next-line @typescript-eslint/no-unused-vars */\n        }\n        catch (e) {\n            console.warn('includeExtraBodyToRequestInit: Original request body is not valid JSON. Skip applying extraBody to the request body.');\n            return;\n        }\n    }\n    function deepMerge(target, source) {\n        const output = Object.assign({}, target);\n        for (const key in source) {\n            if (Object.prototype.hasOwnProperty.call(source, key)) {\n                const sourceValue = source[key];\n                const targetValue = output[key];\n                if (sourceValue &&\n                    typeof sourceValue === 'object' &&\n                    !Array.isArray(sourceValue) &&\n                    targetValue &&\n                    typeof targetValue === 'object' &&\n                    !Array.isArray(targetValue)) {\n                    output[key] = deepMerge(targetValue, sourceValue);\n                }\n                else {\n                    if (targetValue &&\n                        sourceValue &&\n                        typeof targetValue !== typeof sourceValue) {\n                        console.warn(`includeExtraBodyToRequestInit:deepMerge: Type mismatch for key \"${key}\". Original type: ${typeof targetValue}, New type: ${typeof sourceValue}. Overwriting.`);\n                    }\n                    output[key] = sourceValue;\n                }\n            }\n        }\n        return output;\n    }\n    const mergedBody = deepMerge(currentBodyObject, extraBody);\n    requestInit.body = JSON.stringify(mergedBody);\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n// TODO: b/416041229 - Determine how to retrieve the MCP package version.\nconst MCP_LABEL = 'mcp_used/unknown';\n// Whether MCP tool usage is detected from mcpToTool. This is used for\n// telemetry.\nlet hasMcpToolUsageFromMcpToTool = false;\n// Checks whether the list of tools contains any MCP tools.\nfunction hasMcpToolUsage(tools) {\n    for (const tool of tools) {\n        if (isMcpCallableTool(tool)) {\n            return true;\n        }\n        if (typeof tool === 'object' && 'inputSchema' in tool) {\n            return true;\n        }\n    }\n    return hasMcpToolUsageFromMcpToTool;\n}\n// Sets the MCP version label in the Google API client header.\nfunction setMcpUsageHeader(headers) {\n    var _a;\n    const existingHeader = (_a = headers[GOOGLE_API_CLIENT_HEADER]) !== null && _a !== void 0 ? _a : '';\n    headers[GOOGLE_API_CLIENT_HEADER] = (existingHeader + ` ${MCP_LABEL}`).trimStart();\n}\n// Returns true if the object is a MCP CallableTool, otherwise false.\nfunction isMcpCallableTool(object) {\n    return (object !== null &&\n        typeof object === 'object' &&\n        object instanceof McpCallableTool);\n}\n// List all tools from the MCP client.\nfunction listAllTools(mcpClient, maxTools = 100) {\n    return __asyncGenerator(this, arguments, function* listAllTools_1() {\n        let cursor = undefined;\n        let numTools = 0;\n        while (numTools < maxTools) {\n            const t = yield __await(mcpClient.listTools({ cursor }));\n            for (const tool of t.tools) {\n                yield yield __await(tool);\n                numTools++;\n            }\n            if (!t.nextCursor) {\n                break;\n            }\n            cursor = t.nextCursor;\n        }\n    });\n}\n/**\n * McpCallableTool can be used for model inference and invoking MCP clients with\n * given function call arguments.\n *\n * @experimental Built-in MCP support is an experimental feature, may change in future\n * versions.\n */\nclass McpCallableTool {\n    constructor(mcpClients = [], config) {\n        this.mcpTools = [];\n        this.functionNameToMcpClient = {};\n        this.mcpClients = mcpClients;\n        this.config = config;\n    }\n    /**\n     * Creates a McpCallableTool.\n     */\n    static create(mcpClients, config) {\n        return new McpCallableTool(mcpClients, config);\n    }\n    /**\n     * Validates the function names are not duplicate and initialize the function\n     * name to MCP client mapping.\n     *\n     * @throws {Error} if the MCP tools from the MCP clients have duplicate tool\n     *     names.\n     */\n    async initialize() {\n        var _a, e_1, _b, _c;\n        if (this.mcpTools.length > 0) {\n            return;\n        }\n        const functionMap = {};\n        const mcpTools = [];\n        for (const mcpClient of this.mcpClients) {\n            try {\n                for (var _d = true, _e = (e_1 = void 0, __asyncValues(listAllTools(mcpClient))), _f; _f = await _e.next(), _a = _f.done, !_a; _d = true) {\n                    _c = _f.value;\n                    _d = false;\n                    const mcpTool = _c;\n                    mcpTools.push(mcpTool);\n                    const mcpToolName = mcpTool.name;\n                    if (functionMap[mcpToolName]) {\n                        throw new Error(`Duplicate function name ${mcpToolName} found in MCP tools. Please ensure function names are unique.`);\n                    }\n                    functionMap[mcpToolName] = mcpClient;\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (!_d && !_a && (_b = _e.return)) await _b.call(_e);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n        }\n        this.mcpTools = mcpTools;\n        this.functionNameToMcpClient = functionMap;\n    }\n    async tool() {\n        await this.initialize();\n        return mcpToolsToGeminiTool(this.mcpTools, this.config);\n    }\n    async callTool(functionCalls) {\n        await this.initialize();\n        const functionCallResponseParts = [];\n        for (const functionCall of functionCalls) {\n            if (functionCall.name in this.functionNameToMcpClient) {\n                const mcpClient = this.functionNameToMcpClient[functionCall.name];\n                let requestOptions = undefined;\n                // TODO: b/424238654 - Add support for finer grained timeout control.\n                if (this.config.timeout) {\n                    requestOptions = {\n                        timeout: this.config.timeout,\n                    };\n                }\n                const callToolResponse = await mcpClient.callTool({\n                    name: functionCall.name,\n                    arguments: functionCall.args,\n                }, \n                // Set the result schema to undefined to allow MCP to rely on the\n                // default schema.\n                undefined, requestOptions);\n                functionCallResponseParts.push({\n                    functionResponse: {\n                        name: functionCall.name,\n                        response: callToolResponse.isError\n                            ? { error: callToolResponse }\n                            : callToolResponse,\n                    },\n                });\n            }\n        }\n        return functionCallResponseParts;\n    }\n}\nfunction isMcpClient(client) {\n    return (client !== null &&\n        typeof client === 'object' &&\n        'listTools' in client &&\n        typeof client.listTools === 'function');\n}\n/**\n * Creates a McpCallableTool from MCP clients and an optional config.\n *\n * The callable tool can invoke the MCP clients with given function call\n * arguments. (often for automatic function calling).\n * Use the config to modify tool parameters such as behavior.\n *\n * @experimental Built-in MCP support is an experimental feature, may change in future\n * versions.\n */\nfunction mcpToTool(...args) {\n    // Set MCP usage for telemetry.\n    hasMcpToolUsageFromMcpToTool = true;\n    if (args.length === 0) {\n        throw new Error('No MCP clients provided');\n    }\n    const maybeConfig = args[args.length - 1];\n    if (isMcpClient(maybeConfig)) {\n        return McpCallableTool.create(args, {});\n    }\n    return McpCallableTool.create(args.slice(0, args.length - 1), maybeConfig);\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * Handles incoming messages from the WebSocket.\n *\n * @remarks\n * This function is responsible for parsing incoming messages, transforming them\n * into LiveMusicServerMessage, and then calling the onmessage callback.\n * Note that the first message which is received from the server is a\n * setupComplete message.\n *\n * @param apiClient The ApiClient instance.\n * @param onmessage The user-provided onmessage callback (if any).\n * @param event The MessageEvent from the WebSocket.\n */\nasync function handleWebSocketMessage$1(apiClient, onmessage, event) {\n    const serverMessage = new LiveMusicServerMessage();\n    let data;\n    if (event.data instanceof Blob) {\n        data = JSON.parse(await event.data.text());\n    }\n    else {\n        data = JSON.parse(event.data);\n    }\n    Object.assign(serverMessage, data);\n    onmessage(serverMessage);\n}\n/**\n   LiveMusic class encapsulates the configuration for live music\n   generation via Lyria Live models.\n\n   @experimental\n  */\nclass LiveMusic {\n    constructor(apiClient, auth, webSocketFactory) {\n        this.apiClient = apiClient;\n        this.auth = auth;\n        this.webSocketFactory = webSocketFactory;\n    }\n    /**\n       Establishes a connection to the specified model and returns a\n       LiveMusicSession object representing that connection.\n  \n       @experimental\n  \n       @remarks\n  \n       @param params - The parameters for establishing a connection to the model.\n       @return A live session.\n  \n       @example\n       ```ts\n       let model = 'models/lyria-realtime-exp';\n       const session = await ai.live.music.connect({\n         model: model,\n         callbacks: {\n           onmessage: (e: MessageEvent) => {\n             console.log('Received message from the server: %s\\n', debug(e.data));\n           },\n           onerror: (e: ErrorEvent) => {\n             console.log('Error occurred: %s\\n', debug(e.error));\n           },\n           onclose: (e: CloseEvent) => {\n             console.log('Connection closed.');\n           },\n         },\n       });\n       ```\n      */\n    async connect(params) {\n        var _a, _b;\n        if (this.apiClient.isVertexAI()) {\n            throw new Error('Live music is not supported for Vertex AI.');\n        }\n        console.warn('Live music generation is experimental and may change in future versions.');\n        const websocketBaseUrl = this.apiClient.getWebsocketBaseUrl();\n        const apiVersion = this.apiClient.getApiVersion();\n        const headers = mapToHeaders$1(this.apiClient.getDefaultHeaders());\n        const apiKey = this.apiClient.getApiKey();\n        const url = `${websocketBaseUrl}/ws/google.ai.generativelanguage.${apiVersion}.GenerativeService.BidiGenerateMusic?key=${apiKey}`;\n        let onopenResolve = () => { };\n        const onopenPromise = new Promise((resolve) => {\n            onopenResolve = resolve;\n        });\n        const callbacks = params.callbacks;\n        const onopenAwaitedCallback = function () {\n            onopenResolve({});\n        };\n        const apiClient = this.apiClient;\n        const websocketCallbacks = {\n            onopen: onopenAwaitedCallback,\n            onmessage: (event) => {\n                void handleWebSocketMessage$1(apiClient, callbacks.onmessage, event);\n            },\n            onerror: (_a = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onerror) !== null && _a !== void 0 ? _a : function (e) {\n            },\n            onclose: (_b = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onclose) !== null && _b !== void 0 ? _b : function (e) {\n            },\n        };\n        const conn = this.webSocketFactory.create(url, headersToMap$1(headers), websocketCallbacks);\n        conn.connect();\n        // Wait for the websocket to open before sending requests.\n        await onopenPromise;\n        const model = tModel(this.apiClient, params.model);\n        const setup = { model };\n        const clientMessage = { setup };\n        conn.send(JSON.stringify(clientMessage));\n        return new LiveMusicSession(conn, this.apiClient);\n    }\n}\n/**\n   Represents a connection to the API.\n\n   @experimental\n  */\nclass LiveMusicSession {\n    constructor(conn, apiClient) {\n        this.conn = conn;\n        this.apiClient = apiClient;\n    }\n    /**\n      Sets inputs to steer music generation. Updates the session's current\n      weighted prompts.\n  \n      @param params - Contains one property, `weightedPrompts`.\n  \n        - `weightedPrompts` to send to the model; weights are normalized to\n          sum to 1.0.\n  \n      @experimental\n     */\n    async setWeightedPrompts(params) {\n        if (!params.weightedPrompts ||\n            Object.keys(params.weightedPrompts).length === 0) {\n            throw new Error('Weighted prompts must be set and contain at least one entry.');\n        }\n        const clientContent = liveMusicSetWeightedPromptsParametersToMldev(params);\n        this.conn.send(JSON.stringify({ clientContent }));\n    }\n    /**\n      Sets a configuration to the model. Updates the session's current\n      music generation config.\n  \n      @param params - Contains one property, `musicGenerationConfig`.\n  \n        - `musicGenerationConfig` to set in the model. Passing an empty or\n      undefined config to the model will reset the config to defaults.\n  \n      @experimental\n     */\n    async setMusicGenerationConfig(params) {\n        if (!params.musicGenerationConfig) {\n            params.musicGenerationConfig = {};\n        }\n        const setConfigParameters = liveMusicSetConfigParametersToMldev(params);\n        this.conn.send(JSON.stringify(setConfigParameters));\n    }\n    sendPlaybackControl(playbackControl) {\n        const clientMessage = { playbackControl };\n        this.conn.send(JSON.stringify(clientMessage));\n    }\n    /**\n     * Start the music stream.\n     *\n     * @experimental\n     */\n    play() {\n        this.sendPlaybackControl(LiveMusicPlaybackControl.PLAY);\n    }\n    /**\n     * Temporarily halt the music stream. Use `play` to resume from the current\n     * position.\n     *\n     * @experimental\n     */\n    pause() {\n        this.sendPlaybackControl(LiveMusicPlaybackControl.PAUSE);\n    }\n    /**\n     * Stop the music stream and reset the state. Retains the current prompts\n     * and config.\n     *\n     * @experimental\n     */\n    stop() {\n        this.sendPlaybackControl(LiveMusicPlaybackControl.STOP);\n    }\n    /**\n     * Resets the context of the music generation without stopping it.\n     * Retains the current prompts and config.\n     *\n     * @experimental\n     */\n    resetContext() {\n        this.sendPlaybackControl(LiveMusicPlaybackControl.RESET_CONTEXT);\n    }\n    /**\n       Terminates the WebSocket connection.\n  \n       @experimental\n     */\n    close() {\n        this.conn.close();\n    }\n}\n// Converts an headers object to a \"map\" object as expected by the WebSocket\n// constructor. We use this as the Auth interface works with Headers objects\n// while the WebSocket constructor takes a map.\nfunction headersToMap$1(headers) {\n    const headerMap = {};\n    headers.forEach((value, key) => {\n        headerMap[key] = value;\n    });\n    return headerMap;\n}\n// Converts a \"map\" object to a headers object. We use this as the Auth\n// interface works with Headers objects while the API client default headers\n// returns a map.\nfunction mapToHeaders$1(map) {\n    const headers = new Headers();\n    for (const [key, value] of Object.entries(map)) {\n        headers.append(key, value);\n    }\n    return headers;\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst FUNCTION_RESPONSE_REQUIRES_ID = 'FunctionResponse request must have an `id` field from the response of a ToolCall.FunctionalCalls in Google AI.';\n/**\n * Handles incoming messages from the WebSocket.\n *\n * @remarks\n * This function is responsible for parsing incoming messages, transforming them\n * into LiveServerMessages, and then calling the onmessage callback. Note that\n * the first message which is received from the server is a setupComplete\n * message.\n *\n * @param apiClient The ApiClient instance.\n * @param onmessage The user-provided onmessage callback (if any).\n * @param event The MessageEvent from the WebSocket.\n */\nasync function handleWebSocketMessage(apiClient, onmessage, event) {\n    const serverMessage = new LiveServerMessage();\n    let jsonData;\n    if (event.data instanceof Blob) {\n        jsonData = await event.data.text();\n    }\n    else if (event.data instanceof ArrayBuffer) {\n        jsonData = new TextDecoder().decode(event.data);\n    }\n    else {\n        jsonData = event.data;\n    }\n    const data = JSON.parse(jsonData);\n    if (apiClient.isVertexAI()) {\n        const resp = liveServerMessageFromVertex(data);\n        Object.assign(serverMessage, resp);\n    }\n    else {\n        const resp = data;\n        Object.assign(serverMessage, resp);\n    }\n    onmessage(serverMessage);\n}\n/**\n   Live class encapsulates the configuration for live interaction with the\n   Generative Language API. It embeds ApiClient for general API settings.\n\n   @experimental\n  */\nclass Live {\n    constructor(apiClient, auth, webSocketFactory) {\n        this.apiClient = apiClient;\n        this.auth = auth;\n        this.webSocketFactory = webSocketFactory;\n        this.music = new LiveMusic(this.apiClient, this.auth, this.webSocketFactory);\n    }\n    /**\n       Establishes a connection to the specified model with the given\n       configuration and returns a Session object representing that connection.\n  \n       @experimental Built-in MCP support is an experimental feature, may change in\n       future versions.\n  \n       @remarks\n  \n       @param params - The parameters for establishing a connection to the model.\n       @return A live session.\n  \n       @example\n       ```ts\n       let model: string;\n       if (GOOGLE_GENAI_USE_VERTEXAI) {\n         model = 'gemini-2.0-flash-live-preview-04-09';\n       } else {\n         model = 'gemini-live-2.5-flash-preview';\n       }\n       const session = await ai.live.connect({\n         model: model,\n         config: {\n           responseModalities: [Modality.AUDIO],\n         },\n         callbacks: {\n           onopen: () => {\n             console.log('Connected to the socket.');\n           },\n           onmessage: (e: MessageEvent) => {\n             console.log('Received message from the server: %s\\n', debug(e.data));\n           },\n           onerror: (e: ErrorEvent) => {\n             console.log('Error occurred: %s\\n', debug(e.error));\n           },\n           onclose: (e: CloseEvent) => {\n             console.log('Connection closed.');\n           },\n         },\n       });\n       ```\n      */\n    async connect(params) {\n        var _a, _b, _c, _d, _e, _f;\n        // TODO: b/404946746 - Support per request HTTP options.\n        if (params.config && params.config.httpOptions) {\n            throw new Error('The Live module does not support httpOptions at request-level in' +\n                ' LiveConnectConfig yet. Please use the client-level httpOptions' +\n                ' configuration instead.');\n        }\n        const websocketBaseUrl = this.apiClient.getWebsocketBaseUrl();\n        const apiVersion = this.apiClient.getApiVersion();\n        let url;\n        const clientHeaders = this.apiClient.getHeaders();\n        if (params.config &&\n            params.config.tools &&\n            hasMcpToolUsage(params.config.tools)) {\n            setMcpUsageHeader(clientHeaders);\n        }\n        const headers = mapToHeaders(clientHeaders);\n        if (this.apiClient.isVertexAI()) {\n            url = `${websocketBaseUrl}/ws/google.cloud.aiplatform.${apiVersion}.LlmBidiService/BidiGenerateContent`;\n            await this.auth.addAuthHeaders(headers, url);\n        }\n        else {\n            const apiKey = this.apiClient.getApiKey();\n            let method = 'BidiGenerateContent';\n            let keyName = 'key';\n            if (apiKey === null || apiKey === void 0 ? void 0 : apiKey.startsWith('auth_tokens/')) {\n                console.warn('Warning: Ephemeral token support is experimental and may change in future versions.');\n                if (apiVersion !== 'v1alpha') {\n                    console.warn(\"Warning: The SDK's ephemeral token support is in v1alpha only. Please use const ai = new GoogleGenAI({apiKey: token.name, httpOptions: { apiVersion: 'v1alpha' }}); before session connection.\");\n                }\n                method = 'BidiGenerateContentConstrained';\n                keyName = 'access_token';\n            }\n            url = `${websocketBaseUrl}/ws/google.ai.generativelanguage.${apiVersion}.GenerativeService.${method}?${keyName}=${apiKey}`;\n        }\n        let onopenResolve = () => { };\n        const onopenPromise = new Promise((resolve) => {\n            onopenResolve = resolve;\n        });\n        const callbacks = params.callbacks;\n        const onopenAwaitedCallback = function () {\n            var _a;\n            (_a = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onopen) === null || _a === void 0 ? void 0 : _a.call(callbacks);\n            onopenResolve({});\n        };\n        const apiClient = this.apiClient;\n        const websocketCallbacks = {\n            onopen: onopenAwaitedCallback,\n            onmessage: (event) => {\n                void handleWebSocketMessage(apiClient, callbacks.onmessage, event);\n            },\n            onerror: (_a = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onerror) !== null && _a !== void 0 ? _a : function (e) {\n            },\n            onclose: (_b = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onclose) !== null && _b !== void 0 ? _b : function (e) {\n            },\n        };\n        const conn = this.webSocketFactory.create(url, headersToMap(headers), websocketCallbacks);\n        conn.connect();\n        // Wait for the websocket to open before sending requests.\n        await onopenPromise;\n        let transformedModel = tModel(this.apiClient, params.model);\n        if (this.apiClient.isVertexAI() &&\n            transformedModel.startsWith('publishers/')) {\n            const project = this.apiClient.getProject();\n            const location = this.apiClient.getLocation();\n            transformedModel =\n                `projects/${project}/locations/${location}/` + transformedModel;\n        }\n        let clientMessage = {};\n        if (this.apiClient.isVertexAI() &&\n            ((_c = params.config) === null || _c === void 0 ? void 0 : _c.responseModalities) === undefined) {\n            // Set default to AUDIO to align with MLDev API.\n            if (params.config === undefined) {\n                params.config = { responseModalities: [Modality.AUDIO] };\n            }\n            else {\n                params.config.responseModalities = [Modality.AUDIO];\n            }\n        }\n        if ((_d = params.config) === null || _d === void 0 ? void 0 : _d.generationConfig) {\n            // Raise deprecation warning for generationConfig.\n            console.warn('Setting `LiveConnectConfig.generation_config` is deprecated, please set the fields on `LiveConnectConfig` directly. This will become an error in a future version (not before Q3 2025).');\n        }\n        const inputTools = (_f = (_e = params.config) === null || _e === void 0 ? void 0 : _e.tools) !== null && _f !== void 0 ? _f : [];\n        const convertedTools = [];\n        for (const tool of inputTools) {\n            if (this.isCallableTool(tool)) {\n                const callableTool = tool;\n                convertedTools.push(await callableTool.tool());\n            }\n            else {\n                convertedTools.push(tool);\n            }\n        }\n        if (convertedTools.length > 0) {\n            params.config.tools = convertedTools;\n        }\n        const liveConnectParameters = {\n            model: transformedModel,\n            config: params.config,\n            callbacks: params.callbacks,\n        };\n        if (this.apiClient.isVertexAI()) {\n            clientMessage = liveConnectParametersToVertex(this.apiClient, liveConnectParameters);\n        }\n        else {\n            clientMessage = liveConnectParametersToMldev(this.apiClient, liveConnectParameters);\n        }\n        delete clientMessage['config'];\n        conn.send(JSON.stringify(clientMessage));\n        return new Session(conn, this.apiClient);\n    }\n    // TODO: b/416041229 - Abstract this method to a common place.\n    isCallableTool(tool) {\n        return 'callTool' in tool && typeof tool.callTool === 'function';\n    }\n}\nconst defaultLiveSendClientContentParamerters = {\n    turnComplete: true,\n};\n/**\n   Represents a connection to the API.\n\n   @experimental\n  */\nclass Session {\n    constructor(conn, apiClient) {\n        this.conn = conn;\n        this.apiClient = apiClient;\n    }\n    tLiveClientContent(apiClient, params) {\n        if (params.turns !== null && params.turns !== undefined) {\n            let contents = [];\n            try {\n                contents = tContents(params.turns);\n                if (!apiClient.isVertexAI()) {\n                    contents = contents.map((item) => contentToMldev$1(item));\n                }\n            }\n            catch (_a) {\n                throw new Error(`Failed to parse client content \"turns\", type: '${typeof params.turns}'`);\n            }\n            return {\n                clientContent: { turns: contents, turnComplete: params.turnComplete },\n            };\n        }\n        return {\n            clientContent: { turnComplete: params.turnComplete },\n        };\n    }\n    tLiveClienttToolResponse(apiClient, params) {\n        let functionResponses = [];\n        if (params.functionResponses == null) {\n            throw new Error('functionResponses is required.');\n        }\n        if (!Array.isArray(params.functionResponses)) {\n            functionResponses = [params.functionResponses];\n        }\n        else {\n            functionResponses = params.functionResponses;\n        }\n        if (functionResponses.length === 0) {\n            throw new Error('functionResponses is required.');\n        }\n        for (const functionResponse of functionResponses) {\n            if (typeof functionResponse !== 'object' ||\n                functionResponse === null ||\n                !('name' in functionResponse) ||\n                !('response' in functionResponse)) {\n                throw new Error(`Could not parse function response, type '${typeof functionResponse}'.`);\n            }\n            if (!apiClient.isVertexAI() && !('id' in functionResponse)) {\n                throw new Error(FUNCTION_RESPONSE_REQUIRES_ID);\n            }\n        }\n        const clientMessage = {\n            toolResponse: { functionResponses: functionResponses },\n        };\n        return clientMessage;\n    }\n    /**\n      Send a message over the established connection.\n  \n      @param params - Contains two **optional** properties, `turns` and\n          `turnComplete`.\n  \n        - `turns` will be converted to a `Content[]`\n        - `turnComplete: true` [default] indicates that you are done sending\n          content and expect a response. If `turnComplete: false`, the server\n          will wait for additional messages before starting generation.\n  \n      @experimental\n  \n      @remarks\n      There are two ways to send messages to the live API:\n      `sendClientContent` and `sendRealtimeInput`.\n  \n      `sendClientContent` messages are added to the model context **in order**.\n      Having a conversation using `sendClientContent` messages is roughly\n      equivalent to using the `Chat.sendMessageStream`, except that the state of\n      the `chat` history is stored on the API server instead of locally.\n  \n      Because of `sendClientContent`'s order guarantee, the model cannot respons\n      as quickly to `sendClientContent` messages as to `sendRealtimeInput`\n      messages. This makes the biggest difference when sending objects that have\n      significant preprocessing time (typically images).\n  \n      The `sendClientContent` message sends a `Content[]`\n      which has more options than the `Blob` sent by `sendRealtimeInput`.\n  \n      So the main use-cases for `sendClientContent` over `sendRealtimeInput` are:\n  \n      - Sending anything that can't be represented as a `Blob` (text,\n      `sendClientContent({turns=\"Hello?\"}`)).\n      - Managing turns when not using audio input and voice activity detection.\n        (`sendClientContent({turnComplete:true})` or the short form\n      `sendClientContent()`)\n      - Prefilling a conversation context\n        ```\n        sendClientContent({\n            turns: [\n              Content({role:user, parts:...}),\n              Content({role:user, parts:...}),\n              ...\n            ]\n        })\n        ```\n      @experimental\n     */\n    sendClientContent(params) {\n        params = Object.assign(Object.assign({}, defaultLiveSendClientContentParamerters), params);\n        const clientMessage = this.tLiveClientContent(this.apiClient, params);\n        this.conn.send(JSON.stringify(clientMessage));\n    }\n    /**\n      Send a realtime message over the established connection.\n  \n      @param params - Contains one property, `media`.\n  \n        - `media` will be converted to a `Blob`\n  \n      @experimental\n  \n      @remarks\n      Use `sendRealtimeInput` for realtime audio chunks and video frames (images).\n  \n      With `sendRealtimeInput` the api will respond to audio automatically\n      based on voice activity detection (VAD).\n  \n      `sendRealtimeInput` is optimized for responsivness at the expense of\n      deterministic ordering guarantees. Audio and video tokens are to the\n      context when they become available.\n  \n      Note: The Call signature expects a `Blob` object, but only a subset\n      of audio and image mimetypes are allowed.\n     */\n    sendRealtimeInput(params) {\n        let clientMessage = {};\n        if (this.apiClient.isVertexAI()) {\n            clientMessage = {\n                'realtimeInput': liveSendRealtimeInputParametersToVertex(params),\n            };\n        }\n        else {\n            clientMessage = {\n                'realtimeInput': liveSendRealtimeInputParametersToMldev(params),\n            };\n        }\n        this.conn.send(JSON.stringify(clientMessage));\n    }\n    /**\n      Send a function response message over the established connection.\n  \n      @param params - Contains property `functionResponses`.\n  \n        - `functionResponses` will be converted to a `functionResponses[]`\n  \n      @remarks\n      Use `sendFunctionResponse` to reply to `LiveServerToolCall` from the server.\n  \n      Use {@link types.LiveConnectConfig#tools} to configure the callable functions.\n  \n      @experimental\n     */\n    sendToolResponse(params) {\n        if (params.functionResponses == null) {\n            throw new Error('Tool response parameters are required.');\n        }\n        const clientMessage = this.tLiveClienttToolResponse(this.apiClient, params);\n        this.conn.send(JSON.stringify(clientMessage));\n    }\n    /**\n       Terminates the WebSocket connection.\n  \n       @experimental\n  \n       @example\n       ```ts\n       let model: string;\n       if (GOOGLE_GENAI_USE_VERTEXAI) {\n         model = 'gemini-2.0-flash-live-preview-04-09';\n       } else {\n         model = 'gemini-live-2.5-flash-preview';\n       }\n       const session = await ai.live.connect({\n         model: model,\n         config: {\n           responseModalities: [Modality.AUDIO],\n         }\n       });\n  \n       session.close();\n       ```\n     */\n    close() {\n        this.conn.close();\n    }\n}\n// Converts an headers object to a \"map\" object as expected by the WebSocket\n// constructor. We use this as the Auth interface works with Headers objects\n// while the WebSocket constructor takes a map.\nfunction headersToMap(headers) {\n    const headerMap = {};\n    headers.forEach((value, key) => {\n        headerMap[key] = value;\n    });\n    return headerMap;\n}\n// Converts a \"map\" object to a headers object. We use this as the Auth\n// interface works with Headers objects while the API client default headers\n// returns a map.\nfunction mapToHeaders(map) {\n    const headers = new Headers();\n    for (const [key, value] of Object.entries(map)) {\n        headers.append(key, value);\n    }\n    return headers;\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst DEFAULT_MAX_REMOTE_CALLS = 10;\n/** Returns whether automatic function calling is disabled. */\nfunction shouldDisableAfc(config) {\n    var _a, _b, _c;\n    if ((_a = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _a === void 0 ? void 0 : _a.disable) {\n        return true;\n    }\n    let callableToolsPresent = false;\n    for (const tool of (_b = config === null || config === void 0 ? void 0 : config.tools) !== null && _b !== void 0 ? _b : []) {\n        if (isCallableTool(tool)) {\n            callableToolsPresent = true;\n            break;\n        }\n    }\n    if (!callableToolsPresent) {\n        return true;\n    }\n    const maxCalls = (_c = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _c === void 0 ? void 0 : _c.maximumRemoteCalls;\n    if ((maxCalls && (maxCalls < 0 || !Number.isInteger(maxCalls))) ||\n        maxCalls == 0) {\n        console.warn('Invalid maximumRemoteCalls value provided for automatic function calling. Disabled automatic function calling. Please provide a valid integer value greater than 0. maximumRemoteCalls provided:', maxCalls);\n        return true;\n    }\n    return false;\n}\nfunction isCallableTool(tool) {\n    return 'callTool' in tool && typeof tool.callTool === 'function';\n}\n// Checks whether the list of tools contains any CallableTools. Will return true\n// if there is at least one CallableTool.\nfunction hasCallableTools(params) {\n    var _a, _b, _c;\n    return (_c = (_b = (_a = params.config) === null || _a === void 0 ? void 0 : _a.tools) === null || _b === void 0 ? void 0 : _b.some((tool) => isCallableTool(tool))) !== null && _c !== void 0 ? _c : false;\n}\n/**\n * Returns the indexes of the tools that are not compatible with AFC.\n */\nfunction findAfcIncompatibleToolIndexes(params) {\n    var _a;\n    // Use number[] for an array of numbers in TypeScript\n    const afcIncompatibleToolIndexes = [];\n    if (!((_a = params === null || params === void 0 ? void 0 : params.config) === null || _a === void 0 ? void 0 : _a.tools)) {\n        return afcIncompatibleToolIndexes;\n    }\n    params.config.tools.forEach((tool, index) => {\n        if (isCallableTool(tool)) {\n            return;\n        }\n        const geminiTool = tool;\n        if (geminiTool.functionDeclarations &&\n            geminiTool.functionDeclarations.length > 0) {\n            afcIncompatibleToolIndexes.push(index);\n        }\n    });\n    return afcIncompatibleToolIndexes;\n}\n/**\n * Returns whether to append automatic function calling history to the\n * response.\n */\nfunction shouldAppendAfcHistory(config) {\n    var _a;\n    return !((_a = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _a === void 0 ? void 0 : _a.ignoreCallHistory);\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nclass Models extends BaseModule {\n    constructor(apiClient) {\n        super();\n        this.apiClient = apiClient;\n        /**\n         * Makes an API request to generate content with a given model.\n         *\n         * For the `model` parameter, supported formats for Vertex AI API include:\n         * - The Gemini model ID, for example: 'gemini-2.0-flash'\n         * - The full resource name starts with 'projects/', for example:\n         *  'projects/my-project-id/locations/us-central1/publishers/google/models/gemini-2.0-flash'\n         * - The partial resource name with 'publishers/', for example:\n         *  'publishers/google/models/gemini-2.0-flash' or\n         *  'publishers/meta/models/llama-3.1-405b-instruct-maas'\n         * - `/` separated publisher and model name, for example:\n         * 'google/gemini-2.0-flash' or 'meta/llama-3.1-405b-instruct-maas'\n         *\n         * For the `model` parameter, supported formats for Gemini API include:\n         * - The Gemini model ID, for example: 'gemini-2.0-flash'\n         * - The model name starts with 'models/', for example:\n         *  'models/gemini-2.0-flash'\n         * - For tuned models, the model name starts with 'tunedModels/',\n         * for example:\n         * 'tunedModels/1234567890123456789'\n         *\n         * Some models support multimodal input and output.\n         *\n         * @param params - The parameters for generating content.\n         * @return The response from generating content.\n         *\n         * @example\n         * ```ts\n         * const response = await ai.models.generateContent({\n         *   model: 'gemini-2.0-flash',\n         *   contents: 'why is the sky blue?',\n         *   config: {\n         *     candidateCount: 2,\n         *   }\n         * });\n         * console.log(response);\n         * ```\n         */\n        this.generateContent = async (params) => {\n            var _a, _b, _c, _d, _e;\n            const transformedParams = await this.processParamsMaybeAddMcpUsage(params);\n            this.maybeMoveToResponseJsonSchem(params);\n            if (!hasCallableTools(params) || shouldDisableAfc(params.config)) {\n                return await this.generateContentInternal(transformedParams);\n            }\n            const incompatibleToolIndexes = findAfcIncompatibleToolIndexes(params);\n            if (incompatibleToolIndexes.length > 0) {\n                const formattedIndexes = incompatibleToolIndexes\n                    .map((index) => `tools[${index}]`)\n                    .join(', ');\n                throw new Error(`Automatic function calling with CallableTools (or MCP objects) and basic FunctionDeclarations is not yet supported. Incompatible tools found at ${formattedIndexes}.`);\n            }\n            let response;\n            let functionResponseContent;\n            const automaticFunctionCallingHistory = tContents(transformedParams.contents);\n            const maxRemoteCalls = (_c = (_b = (_a = transformedParams.config) === null || _a === void 0 ? void 0 : _a.automaticFunctionCalling) === null || _b === void 0 ? void 0 : _b.maximumRemoteCalls) !== null && _c !== void 0 ? _c : DEFAULT_MAX_REMOTE_CALLS;\n            let remoteCalls = 0;\n            while (remoteCalls < maxRemoteCalls) {\n                response = await this.generateContentInternal(transformedParams);\n                if (!response.functionCalls || response.functionCalls.length === 0) {\n                    break;\n                }\n                const responseContent = response.candidates[0].content;\n                const functionResponseParts = [];\n                for (const tool of (_e = (_d = params.config) === null || _d === void 0 ? void 0 : _d.tools) !== null && _e !== void 0 ? _e : []) {\n                    if (isCallableTool(tool)) {\n                        const callableTool = tool;\n                        const parts = await callableTool.callTool(response.functionCalls);\n                        functionResponseParts.push(...parts);\n                    }\n                }\n                remoteCalls++;\n                functionResponseContent = {\n                    role: 'user',\n                    parts: functionResponseParts,\n                };\n                transformedParams.contents = tContents(transformedParams.contents);\n                transformedParams.contents.push(responseContent);\n                transformedParams.contents.push(functionResponseContent);\n                if (shouldAppendAfcHistory(transformedParams.config)) {\n                    automaticFunctionCallingHistory.push(responseContent);\n                    automaticFunctionCallingHistory.push(functionResponseContent);\n                }\n            }\n            if (shouldAppendAfcHistory(transformedParams.config)) {\n                response.automaticFunctionCallingHistory =\n                    automaticFunctionCallingHistory;\n            }\n            return response;\n        };\n        /**\n         * Makes an API request to generate content with a given model and yields the\n         * response in chunks.\n         *\n         * For the `model` parameter, supported formats for Vertex AI API include:\n         * - The Gemini model ID, for example: 'gemini-2.0-flash'\n         * - The full resource name starts with 'projects/', for example:\n         *  'projects/my-project-id/locations/us-central1/publishers/google/models/gemini-2.0-flash'\n         * - The partial resource name with 'publishers/', for example:\n         *  'publishers/google/models/gemini-2.0-flash' or\n         *  'publishers/meta/models/llama-3.1-405b-instruct-maas'\n         * - `/` separated publisher and model name, for example:\n         * 'google/gemini-2.0-flash' or 'meta/llama-3.1-405b-instruct-maas'\n         *\n         * For the `model` parameter, supported formats for Gemini API include:\n         * - The Gemini model ID, for example: 'gemini-2.0-flash'\n         * - The model name starts with 'models/', for example:\n         *  'models/gemini-2.0-flash'\n         * - For tuned models, the model name starts with 'tunedModels/',\n         * for example:\n         *  'tunedModels/1234567890123456789'\n         *\n         * Some models support multimodal input and output.\n         *\n         * @param params - The parameters for generating content with streaming response.\n         * @return The response from generating content.\n         *\n         * @example\n         * ```ts\n         * const response = await ai.models.generateContentStream({\n         *   model: 'gemini-2.0-flash',\n         *   contents: 'why is the sky blue?',\n         *   config: {\n         *     maxOutputTokens: 200,\n         *   }\n         * });\n         * for await (const chunk of response) {\n         *   console.log(chunk);\n         * }\n         * ```\n         */\n        this.generateContentStream = async (params) => {\n            var _a, _b, _c, _d, _e;\n            this.maybeMoveToResponseJsonSchem(params);\n            if (shouldDisableAfc(params.config)) {\n                const transformedParams = await this.processParamsMaybeAddMcpUsage(params);\n                return await this.generateContentStreamInternal(transformedParams);\n            }\n            const incompatibleToolIndexes = findAfcIncompatibleToolIndexes(params);\n            if (incompatibleToolIndexes.length > 0) {\n                const formattedIndexes = incompatibleToolIndexes\n                    .map((index) => `tools[${index}]`)\n                    .join(', ');\n                throw new Error(`Incompatible tools found at ${formattedIndexes}. Automatic function calling with CallableTools (or MCP objects) and basic FunctionDeclarations\" is not yet supported.`);\n            }\n            // With tool compatibility confirmed, validate that the configuration are\n            // compatible with each other and raise an error if invalid.\n            const streamFunctionCall = (_c = (_b = (_a = params === null || params === void 0 ? void 0 : params.config) === null || _a === void 0 ? void 0 : _a.toolConfig) === null || _b === void 0 ? void 0 : _b.functionCallingConfig) === null || _c === void 0 ? void 0 : _c.streamFunctionCallArguments;\n            const disableAfc = (_e = (_d = params === null || params === void 0 ? void 0 : params.config) === null || _d === void 0 ? void 0 : _d.automaticFunctionCalling) === null || _e === void 0 ? void 0 : _e.disable;\n            if (streamFunctionCall && !disableAfc) {\n                throw new Error(\"Running in streaming mode with 'streamFunctionCallArguments' enabled, \" +\n                    'this feature is not compatible with automatic function calling (AFC). ' +\n                    \"Please set 'config.automaticFunctionCalling.disable' to true to disable AFC \" +\n                    \"or leave 'config.toolConfig.functionCallingConfig.streamFunctionCallArguments' \" +\n                    'to be undefined or set to false to disable streaming function call arguments feature.');\n            }\n            return await this.processAfcStream(params);\n        };\n        /**\n         * Generates an image based on a text description and configuration.\n         *\n         * @param params - The parameters for generating images.\n         * @return The response from the API.\n         *\n         * @example\n         * ```ts\n         * const response = await client.models.generateImages({\n         *  model: 'imagen-3.0-generate-002',\n         *  prompt: 'Robot holding a red skateboard',\n         *  config: {\n         *    numberOfImages: 1,\n         *    includeRaiReason: true,\n         *  },\n         * });\n         * console.log(response?.generatedImages?.[0]?.image?.imageBytes);\n         * ```\n         */\n        this.generateImages = async (params) => {\n            return await this.generateImagesInternal(params).then((apiResponse) => {\n                var _a;\n                let positivePromptSafetyAttributes;\n                const generatedImages = [];\n                if (apiResponse === null || apiResponse === void 0 ? void 0 : apiResponse.generatedImages) {\n                    for (const generatedImage of apiResponse.generatedImages) {\n                        if (generatedImage &&\n                            (generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes) &&\n                            ((_a = generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes) === null || _a === void 0 ? void 0 : _a.contentType) === 'Positive Prompt') {\n                            positivePromptSafetyAttributes = generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes;\n                        }\n                        else {\n                            generatedImages.push(generatedImage);\n                        }\n                    }\n                }\n                let response;\n                if (positivePromptSafetyAttributes) {\n                    response = {\n                        generatedImages: generatedImages,\n                        positivePromptSafetyAttributes: positivePromptSafetyAttributes,\n                        sdkHttpResponse: apiResponse.sdkHttpResponse,\n                    };\n                }\n                else {\n                    response = {\n                        generatedImages: generatedImages,\n                        sdkHttpResponse: apiResponse.sdkHttpResponse,\n                    };\n                }\n                return response;\n            });\n        };\n        this.list = async (params) => {\n            var _a;\n            const defaultConfig = {\n                queryBase: true,\n            };\n            const actualConfig = Object.assign(Object.assign({}, defaultConfig), params === null || params === void 0 ? void 0 : params.config);\n            const actualParams = {\n                config: actualConfig,\n            };\n            if (this.apiClient.isVertexAI()) {\n                if (!actualParams.config.queryBase) {\n                    if ((_a = actualParams.config) === null || _a === void 0 ? void 0 : _a.filter) {\n                        throw new Error('Filtering tuned models list for Vertex AI is not currently supported');\n                    }\n                    else {\n                        actualParams.config.filter = 'labels.tune-type:*';\n                    }\n                }\n            }\n            return new Pager(PagedItem.PAGED_ITEM_MODELS, (x) => this.listInternal(x), await this.listInternal(actualParams), actualParams);\n        };\n        /**\n         * Edits an image based on a prompt, list of reference images, and configuration.\n         *\n         * @param params - The parameters for editing an image.\n         * @return The response from the API.\n         *\n         * @example\n         * ```ts\n         * const response = await client.models.editImage({\n         *  model: 'imagen-3.0-capability-001',\n         *  prompt: 'Generate an image containing a mug with the product logo [1] visible on the side of the mug.',\n         *  referenceImages: [subjectReferenceImage]\n         *  config: {\n         *    numberOfImages: 1,\n         *    includeRaiReason: true,\n         *  },\n         * });\n         * console.log(response?.generatedImages?.[0]?.image?.imageBytes);\n         * ```\n         */\n        this.editImage = async (params) => {\n            const paramsInternal = {\n                model: params.model,\n                prompt: params.prompt,\n                referenceImages: [],\n                config: params.config,\n            };\n            if (params.referenceImages) {\n                if (params.referenceImages) {\n                    paramsInternal.referenceImages = params.referenceImages.map((img) => img.toReferenceImageAPI());\n                }\n            }\n            return await this.editImageInternal(paramsInternal);\n        };\n        /**\n         * Upscales an image based on an image, upscale factor, and configuration.\n         * Only supported in Vertex AI currently.\n         *\n         * @param params - The parameters for upscaling an image.\n         * @return The response from the API.\n         *\n         * @example\n         * ```ts\n         * const response = await client.models.upscaleImage({\n         *  model: 'imagen-3.0-generate-002',\n         *  image: image,\n         *  upscaleFactor: 'x2',\n         *  config: {\n         *    includeRaiReason: true,\n         *  },\n         * });\n         * console.log(response?.generatedImages?.[0]?.image?.imageBytes);\n         * ```\n         */\n        this.upscaleImage = async (params) => {\n            let apiConfig = {\n                numberOfImages: 1,\n                mode: 'upscale',\n            };\n            if (params.config) {\n                apiConfig = Object.assign(Object.assign({}, apiConfig), params.config);\n            }\n            const apiParams = {\n                model: params.model,\n                image: params.image,\n                upscaleFactor: params.upscaleFactor,\n                config: apiConfig,\n            };\n            return await this.upscaleImageInternal(apiParams);\n        };\n        /**\n         *  Generates videos based on a text description and configuration.\n         *\n         * @param params - The parameters for generating videos.\n         * @return A Promise<GenerateVideosOperation> which allows you to track the progress and eventually retrieve the generated videos using the operations.get method.\n         *\n         * @example\n         * ```ts\n         * const operation = await ai.models.generateVideos({\n         *  model: 'veo-2.0-generate-001',\n         *  source: {\n         *    prompt: 'A neon hologram of a cat driving at top speed',\n         *  },\n         *  config: {\n         *    numberOfVideos: 1\n         * });\n         *\n         * while (!operation.done) {\n         *   await new Promise(resolve => setTimeout(resolve, 10000));\n         *   operation = await ai.operations.getVideosOperation({operation: operation});\n         * }\n         *\n         * console.log(operation.response?.generatedVideos?.[0]?.video?.uri);\n         * ```\n         */\n        this.generateVideos = async (params) => {\n            var _a, _b, _c, _d, _e, _f;\n            if ((params.prompt || params.image || params.video) && params.source) {\n                throw new Error('Source and prompt/image/video are mutually exclusive. Please only use source.');\n            }\n            // Gemini API does not support video bytes.\n            if (!this.apiClient.isVertexAI()) {\n                if (((_a = params.video) === null || _a === void 0 ? void 0 : _a.uri) && ((_b = params.video) === null || _b === void 0 ? void 0 : _b.videoBytes)) {\n                    params.video = {\n                        uri: params.video.uri,\n                        mimeType: params.video.mimeType,\n                    };\n                }\n                else if (((_d = (_c = params.source) === null || _c === void 0 ? void 0 : _c.video) === null || _d === void 0 ? void 0 : _d.uri) &&\n                    ((_f = (_e = params.source) === null || _e === void 0 ? void 0 : _e.video) === null || _f === void 0 ? void 0 : _f.videoBytes)) {\n                    params.source.video = {\n                        uri: params.source.video.uri,\n                        mimeType: params.source.video.mimeType,\n                    };\n                }\n            }\n            return await this.generateVideosInternal(params);\n        };\n    }\n    /**\n     * This logic is needed for GenerateContentConfig only.\n     * Previously we made GenerateContentConfig.responseSchema field to accept\n     * unknown. Since v1.9.0, we switch to use backend JSON schema support.\n     * To maintain backward compatibility, we move the data that was treated as\n     * JSON schema from the responseSchema field to the responseJsonSchema field.\n     */\n    maybeMoveToResponseJsonSchem(params) {\n        if (params.config && params.config.responseSchema) {\n            if (!params.config.responseJsonSchema) {\n                if (Object.keys(params.config.responseSchema).includes('$schema')) {\n                    params.config.responseJsonSchema = params.config.responseSchema;\n                    delete params.config.responseSchema;\n                }\n            }\n        }\n        return;\n    }\n    /**\n     * Transforms the CallableTools in the parameters to be simply Tools, it\n     * copies the params into a new object and replaces the tools, it does not\n     * modify the original params. Also sets the MCP usage header if there are\n     * MCP tools in the parameters.\n     */\n    async processParamsMaybeAddMcpUsage(params) {\n        var _a, _b, _c;\n        const tools = (_a = params.config) === null || _a === void 0 ? void 0 : _a.tools;\n        if (!tools) {\n            return params;\n        }\n        const transformedTools = await Promise.all(tools.map(async (tool) => {\n            if (isCallableTool(tool)) {\n                const callableTool = tool;\n                return await callableTool.tool();\n            }\n            return tool;\n        }));\n        const newParams = {\n            model: params.model,\n            contents: params.contents,\n            config: Object.assign(Object.assign({}, params.config), { tools: transformedTools }),\n        };\n        newParams.config.tools = transformedTools;\n        if (params.config &&\n            params.config.tools &&\n            hasMcpToolUsage(params.config.tools)) {\n            const headers = (_c = (_b = params.config.httpOptions) === null || _b === void 0 ? void 0 : _b.headers) !== null && _c !== void 0 ? _c : {};\n            let newHeaders = Object.assign({}, headers);\n            if (Object.keys(newHeaders).length === 0) {\n                newHeaders = this.apiClient.getDefaultHeaders();\n            }\n            setMcpUsageHeader(newHeaders);\n            newParams.config.httpOptions = Object.assign(Object.assign({}, params.config.httpOptions), { headers: newHeaders });\n        }\n        return newParams;\n    }\n    async initAfcToolsMap(params) {\n        var _a, _b, _c;\n        const afcTools = new Map();\n        for (const tool of (_b = (_a = params.config) === null || _a === void 0 ? void 0 : _a.tools) !== null && _b !== void 0 ? _b : []) {\n            if (isCallableTool(tool)) {\n                const callableTool = tool;\n                const toolDeclaration = await callableTool.tool();\n                for (const declaration of (_c = toolDeclaration.functionDeclarations) !== null && _c !== void 0 ? _c : []) {\n                    if (!declaration.name) {\n                        throw new Error('Function declaration name is required.');\n                    }\n                    if (afcTools.has(declaration.name)) {\n                        throw new Error(`Duplicate tool declaration name: ${declaration.name}`);\n                    }\n                    afcTools.set(declaration.name, callableTool);\n                }\n            }\n        }\n        return afcTools;\n    }\n    async processAfcStream(params) {\n        var _a, _b, _c;\n        const maxRemoteCalls = (_c = (_b = (_a = params.config) === null || _a === void 0 ? void 0 : _a.automaticFunctionCalling) === null || _b === void 0 ? void 0 : _b.maximumRemoteCalls) !== null && _c !== void 0 ? _c : DEFAULT_MAX_REMOTE_CALLS;\n        let wereFunctionsCalled = false;\n        let remoteCallCount = 0;\n        const afcToolsMap = await this.initAfcToolsMap(params);\n        return (function (models, afcTools, params) {\n            var _a, _b;\n            return __asyncGenerator(this, arguments, function* () {\n                var _c, e_1, _d, _e;\n                while (remoteCallCount < maxRemoteCalls) {\n                    if (wereFunctionsCalled) {\n                        remoteCallCount++;\n                        wereFunctionsCalled = false;\n                    }\n                    const transformedParams = yield __await(models.processParamsMaybeAddMcpUsage(params));\n                    const response = yield __await(models.generateContentStreamInternal(transformedParams));\n                    const functionResponses = [];\n                    const responseContents = [];\n                    try {\n                        for (var _f = true, response_1 = (e_1 = void 0, __asyncValues(response)), response_1_1; response_1_1 = yield __await(response_1.next()), _c = response_1_1.done, !_c; _f = true) {\n                            _e = response_1_1.value;\n                            _f = false;\n                            const chunk = _e;\n                            yield yield __await(chunk);\n                            if (chunk.candidates && ((_a = chunk.candidates[0]) === null || _a === void 0 ? void 0 : _a.content)) {\n                                responseContents.push(chunk.candidates[0].content);\n                                for (const part of (_b = chunk.candidates[0].content.parts) !== null && _b !== void 0 ? _b : []) {\n                                    if (remoteCallCount < maxRemoteCalls && part.functionCall) {\n                                        if (!part.functionCall.name) {\n                                            throw new Error('Function call name was not returned by the model.');\n                                        }\n                                        if (!afcTools.has(part.functionCall.name)) {\n                                            throw new Error(`Automatic function calling was requested, but not all the tools the model used implement the CallableTool interface. Available tools: ${afcTools.keys()}, mising tool: ${part.functionCall.name}`);\n                                        }\n                                        else {\n                                            const responseParts = yield __await(afcTools\n                                                .get(part.functionCall.name)\n                                                .callTool([part.functionCall]));\n                                            functionResponses.push(...responseParts);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                    finally {\n                        try {\n                            if (!_f && !_c && (_d = response_1.return)) yield __await(_d.call(response_1));\n                        }\n                        finally { if (e_1) throw e_1.error; }\n                    }\n                    if (functionResponses.length > 0) {\n                        wereFunctionsCalled = true;\n                        const typedResponseChunk = new GenerateContentResponse();\n                        typedResponseChunk.candidates = [\n                            {\n                                content: {\n                                    role: 'user',\n                                    parts: functionResponses,\n                                },\n                            },\n                        ];\n                        yield yield __await(typedResponseChunk);\n                        const newContents = [];\n                        newContents.push(...responseContents);\n                        newContents.push({\n                            role: 'user',\n                            parts: functionResponses,\n                        });\n                        const updatedContents = tContents(params.contents).concat(newContents);\n                        params.contents = updatedContents;\n                    }\n                    else {\n                        break;\n                    }\n                }\n            });\n        })(this, afcToolsMap, params);\n    }\n    async generateContentInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = generateContentParametersToVertex(this.apiClient, params);\n            path = formatMap('{model}:generateContent', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = generateContentResponseFromVertex(apiResponse);\n                const typedResp = new GenerateContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            const body = generateContentParametersToMldev(this.apiClient, params);\n            path = formatMap('{model}:generateContent', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = generateContentResponseFromMldev(apiResponse);\n                const typedResp = new GenerateContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    async generateContentStreamInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = generateContentParametersToVertex(this.apiClient, params);\n            path = formatMap('{model}:streamGenerateContent?alt=sse', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            const apiClient = this.apiClient;\n            response = apiClient.requestStream({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            });\n            return response.then(function (apiResponse) {\n                return __asyncGenerator(this, arguments, function* () {\n                    var _a, e_2, _b, _c;\n                    try {\n                        for (var _d = true, apiResponse_1 = __asyncValues(apiResponse), apiResponse_1_1; apiResponse_1_1 = yield __await(apiResponse_1.next()), _a = apiResponse_1_1.done, !_a; _d = true) {\n                            _c = apiResponse_1_1.value;\n                            _d = false;\n                            const chunk = _c;\n                            const resp = generateContentResponseFromVertex((yield __await(chunk.json())));\n                            resp['sdkHttpResponse'] = {\n                                headers: chunk.headers,\n                            };\n                            const typedResp = new GenerateContentResponse();\n                            Object.assign(typedResp, resp);\n                            yield yield __await(typedResp);\n                        }\n                    }\n                    catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                    finally {\n                        try {\n                            if (!_d && !_a && (_b = apiResponse_1.return)) yield __await(_b.call(apiResponse_1));\n                        }\n                        finally { if (e_2) throw e_2.error; }\n                    }\n                });\n            });\n        }\n        else {\n            const body = generateContentParametersToMldev(this.apiClient, params);\n            path = formatMap('{model}:streamGenerateContent?alt=sse', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            const apiClient = this.apiClient;\n            response = apiClient.requestStream({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            });\n            return response.then(function (apiResponse) {\n                return __asyncGenerator(this, arguments, function* () {\n                    var _a, e_3, _b, _c;\n                    try {\n                        for (var _d = true, apiResponse_2 = __asyncValues(apiResponse), apiResponse_2_1; apiResponse_2_1 = yield __await(apiResponse_2.next()), _a = apiResponse_2_1.done, !_a; _d = true) {\n                            _c = apiResponse_2_1.value;\n                            _d = false;\n                            const chunk = _c;\n                            const resp = generateContentResponseFromMldev((yield __await(chunk.json())));\n                            resp['sdkHttpResponse'] = {\n                                headers: chunk.headers,\n                            };\n                            const typedResp = new GenerateContentResponse();\n                            Object.assign(typedResp, resp);\n                            yield yield __await(typedResp);\n                        }\n                    }\n                    catch (e_3_1) { e_3 = { error: e_3_1 }; }\n                    finally {\n                        try {\n                            if (!_d && !_a && (_b = apiResponse_2.return)) yield __await(_b.call(apiResponse_2));\n                        }\n                        finally { if (e_3) throw e_3.error; }\n                    }\n                });\n            });\n        }\n    }\n    /**\n     * Calculates embeddings for the given contents. Only text is supported.\n     *\n     * @param params - The parameters for embedding contents.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.embedContent({\n     *  model: 'text-embedding-004',\n     *  contents: [\n     *    'What is your name?',\n     *    'What is your favorite color?',\n     *  ],\n     *  config: {\n     *    outputDimensionality: 64,\n     *  },\n     * });\n     * console.log(response);\n     * ```\n     */\n    async embedContent(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = embedContentParametersToVertex(this.apiClient, params);\n            path = formatMap('{model}:predict', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = embedContentResponseFromVertex(apiResponse);\n                const typedResp = new EmbedContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            const body = embedContentParametersToMldev(this.apiClient, params);\n            path = formatMap('{model}:batchEmbedContents', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = embedContentResponseFromMldev(apiResponse);\n                const typedResp = new EmbedContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Private method for generating images.\n     */\n    async generateImagesInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = generateImagesParametersToVertex(this.apiClient, params);\n            path = formatMap('{model}:predict', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = generateImagesResponseFromVertex(apiResponse);\n                const typedResp = new GenerateImagesResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            const body = generateImagesParametersToMldev(this.apiClient, params);\n            path = formatMap('{model}:predict', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = generateImagesResponseFromMldev(apiResponse);\n                const typedResp = new GenerateImagesResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Private method for editing an image.\n     */\n    async editImageInternal(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = editImageParametersInternalToVertex(this.apiClient, params);\n            path = formatMap('{model}:predict', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = editImageResponseFromVertex(apiResponse);\n                const typedResp = new EditImageResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            throw new Error('This method is only supported by the Vertex AI.');\n        }\n    }\n    /**\n     * Private method for upscaling an image.\n     */\n    async upscaleImageInternal(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = upscaleImageAPIParametersInternalToVertex(this.apiClient, params);\n            path = formatMap('{model}:predict', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = upscaleImageResponseFromVertex(apiResponse);\n                const typedResp = new UpscaleImageResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            throw new Error('This method is only supported by the Vertex AI.');\n        }\n    }\n    /**\n     * Recontextualizes an image.\n     *\n     * There are two types of recontextualization currently supported:\n     * 1) Imagen Product Recontext - Generate images of products in new scenes\n     *    and contexts.\n     * 2) Virtual Try-On: Generate images of persons modeling fashion products.\n     *\n     * @param params - The parameters for recontextualizing an image.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response1 = await ai.models.recontextImage({\n     *  model: 'imagen-product-recontext-preview-06-30',\n     *  source: {\n     *    prompt: 'In a modern kitchen setting.',\n     *    productImages: [productImage],\n     *  },\n     *  config: {\n     *    numberOfImages: 1,\n     *  },\n     * });\n     * console.log(response1?.generatedImages?.[0]?.image?.imageBytes);\n     *\n     * const response2 = await ai.models.recontextImage({\n     *  model: 'virtual-try-on-preview-08-04',\n     *  source: {\n     *    personImage: personImage,\n     *    productImages: [productImage],\n     *  },\n     *  config: {\n     *    numberOfImages: 1,\n     *  },\n     * });\n     * console.log(response2?.generatedImages?.[0]?.image?.imageBytes);\n     * ```\n     */\n    async recontextImage(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = recontextImageParametersToVertex(this.apiClient, params);\n            path = formatMap('{model}:predict', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = recontextImageResponseFromVertex(apiResponse);\n                const typedResp = new RecontextImageResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            throw new Error('This method is only supported by the Vertex AI.');\n        }\n    }\n    /**\n     * Segments an image, creating a mask of a specified area.\n     *\n     * @param params - The parameters for segmenting an image.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.segmentImage({\n     *  model: 'image-segmentation-001',\n     *  source: {\n     *    image: image,\n     *  },\n     *  config: {\n     *    mode: 'foreground',\n     *  },\n     * });\n     * console.log(response?.generatedMasks?.[0]?.mask?.imageBytes);\n     * ```\n     */\n    async segmentImage(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = segmentImageParametersToVertex(this.apiClient, params);\n            path = formatMap('{model}:predict', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = segmentImageResponseFromVertex(apiResponse);\n                const typedResp = new SegmentImageResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            throw new Error('This method is only supported by the Vertex AI.');\n        }\n    }\n    /**\n     * Fetches information about a model by name.\n     *\n     * @example\n     * ```ts\n     * const modelInfo = await ai.models.get({model: 'gemini-2.0-flash'});\n     * ```\n     */\n    async get(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = getModelParametersToVertex(this.apiClient, params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = modelFromVertex(apiResponse);\n                return resp;\n            });\n        }\n        else {\n            const body = getModelParametersToMldev(this.apiClient, params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = modelFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    async listInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = listModelsParametersToVertex(this.apiClient, params);\n            path = formatMap('{models_url}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = listModelsResponseFromVertex(apiResponse);\n                const typedResp = new ListModelsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            const body = listModelsParametersToMldev(this.apiClient, params);\n            path = formatMap('{models_url}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = listModelsResponseFromMldev(apiResponse);\n                const typedResp = new ListModelsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Updates a tuned model by its name.\n     *\n     * @param params - The parameters for updating the model.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.update({\n     *   model: 'tuned-model-name',\n     *   config: {\n     *     displayName: 'New display name',\n     *     description: 'New description',\n     *   },\n     * });\n     * ```\n     */\n    async update(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = updateModelParametersToVertex(this.apiClient, params);\n            path = formatMap('{model}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'PATCH',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = modelFromVertex(apiResponse);\n                return resp;\n            });\n        }\n        else {\n            const body = updateModelParametersToMldev(this.apiClient, params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'PATCH',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = modelFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    /**\n     * Deletes a tuned model by its name.\n     *\n     * @param params - The parameters for deleting the model.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.delete({model: 'tuned-model-name'});\n     * ```\n     */\n    async delete(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = deleteModelParametersToVertex(this.apiClient, params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'DELETE',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = deleteModelResponseFromVertex(apiResponse);\n                const typedResp = new DeleteModelResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            const body = deleteModelParametersToMldev(this.apiClient, params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'DELETE',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = deleteModelResponseFromMldev(apiResponse);\n                const typedResp = new DeleteModelResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Counts the number of tokens in the given contents. Multimodal input is\n     * supported for Gemini models.\n     *\n     * @param params - The parameters for counting tokens.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.countTokens({\n     *  model: 'gemini-2.0-flash',\n     *  contents: 'The quick brown fox jumps over the lazy dog.'\n     * });\n     * console.log(response);\n     * ```\n     */\n    async countTokens(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = countTokensParametersToVertex(this.apiClient, params);\n            path = formatMap('{model}:countTokens', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = countTokensResponseFromVertex(apiResponse);\n                const typedResp = new CountTokensResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            const body = countTokensParametersToMldev(this.apiClient, params);\n            path = formatMap('{model}:countTokens', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = countTokensResponseFromMldev(apiResponse);\n                const typedResp = new CountTokensResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Given a list of contents, returns a corresponding TokensInfo containing\n     * the list of tokens and list of token ids.\n     *\n     * This method is not supported by the Gemini Developer API.\n     *\n     * @param params - The parameters for computing tokens.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.computeTokens({\n     *  model: 'gemini-2.0-flash',\n     *  contents: 'What is your name?'\n     * });\n     * console.log(response);\n     * ```\n     */\n    async computeTokens(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = computeTokensParametersToVertex(this.apiClient, params);\n            path = formatMap('{model}:computeTokens', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = computeTokensResponseFromVertex(apiResponse);\n                const typedResp = new ComputeTokensResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            throw new Error('This method is only supported by the Vertex AI.');\n        }\n    }\n    /**\n     * Private method for generating videos.\n     */\n    async generateVideosInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = generateVideosParametersToVertex(this.apiClient, params);\n            path = formatMap('{model}:predictLongRunning', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = generateVideosOperationFromVertex(apiResponse);\n                const typedResp = new GenerateVideosOperation();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            const body = generateVideosParametersToMldev(this.apiClient, params);\n            path = formatMap('{model}:predictLongRunning', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = generateVideosOperationFromMldev(apiResponse);\n                const typedResp = new GenerateVideosOperation();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nclass Operations extends BaseModule {\n    constructor(apiClient) {\n        super();\n        this.apiClient = apiClient;\n    }\n    /**\n     * Gets the status of a long-running operation.\n     *\n     * @param parameters The parameters for the get operation request.\n     * @return The updated Operation object, with the latest status or result.\n     */\n    async getVideosOperation(parameters) {\n        const operation = parameters.operation;\n        const config = parameters.config;\n        if (operation.name === undefined || operation.name === '') {\n            throw new Error('Operation name is required.');\n        }\n        if (this.apiClient.isVertexAI()) {\n            const resourceName = operation.name.split('/operations/')[0];\n            let httpOptions = undefined;\n            if (config && 'httpOptions' in config) {\n                httpOptions = config.httpOptions;\n            }\n            const rawOperation = await this.fetchPredictVideosOperationInternal({\n                operationName: operation.name,\n                resourceName: resourceName,\n                config: { httpOptions: httpOptions },\n            });\n            return operation._fromAPIResponse({\n                apiResponse: rawOperation,\n                _isVertexAI: true,\n            });\n        }\n        else {\n            const rawOperation = await this.getVideosOperationInternal({\n                operationName: operation.name,\n                config: config,\n            });\n            return operation._fromAPIResponse({\n                apiResponse: rawOperation,\n                _isVertexAI: false,\n            });\n        }\n    }\n    /**\n     * Gets the status of a long-running operation.\n     *\n     * @param parameters The parameters for the get operation request.\n     * @return The updated Operation object, with the latest status or result.\n     */\n    async get(parameters) {\n        const operation = parameters.operation;\n        const config = parameters.config;\n        if (operation.name === undefined || operation.name === '') {\n            throw new Error('Operation name is required.');\n        }\n        if (this.apiClient.isVertexAI()) {\n            const resourceName = operation.name.split('/operations/')[0];\n            let httpOptions = undefined;\n            if (config && 'httpOptions' in config) {\n                httpOptions = config.httpOptions;\n            }\n            const rawOperation = await this.fetchPredictVideosOperationInternal({\n                operationName: operation.name,\n                resourceName: resourceName,\n                config: { httpOptions: httpOptions },\n            });\n            return operation._fromAPIResponse({\n                apiResponse: rawOperation,\n                _isVertexAI: true,\n            });\n        }\n        else {\n            const rawOperation = await this.getVideosOperationInternal({\n                operationName: operation.name,\n                config: config,\n            });\n            return operation._fromAPIResponse({\n                apiResponse: rawOperation,\n                _isVertexAI: false,\n            });\n        }\n    }\n    async getVideosOperationInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = getOperationParametersToVertex(params);\n            path = formatMap('{operationName}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response;\n        }\n        else {\n            const body = getOperationParametersToMldev(params);\n            path = formatMap('{operationName}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response;\n        }\n    }\n    async fetchPredictVideosOperationInternal(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = fetchPredictOperationParametersToVertex(params);\n            path = formatMap('{resourceName}:fetchPredictOperation', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response;\n        }\n        else {\n            throw new Error('This method is only supported by the Vertex AI.');\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nfunction blobToMldev(fromObject) {\n    const toObject = {};\n    const fromData = getValueByPath(fromObject, ['data']);\n    if (fromData != null) {\n        setValueByPath(toObject, ['data'], fromData);\n    }\n    if (getValueByPath(fromObject, ['displayName']) !== undefined) {\n        throw new Error('displayName parameter is not supported in Gemini API.');\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction contentToMldev(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, ['parts']);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return partToMldev(item);\n            });\n        }\n        setValueByPath(toObject, ['parts'], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, ['role']);\n    if (fromRole != null) {\n        setValueByPath(toObject, ['role'], fromRole);\n    }\n    return toObject;\n}\nfunction createAuthTokenConfigToMldev(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromExpireTime = getValueByPath(fromObject, ['expireTime']);\n    if (parentObject !== undefined && fromExpireTime != null) {\n        setValueByPath(parentObject, ['expireTime'], fromExpireTime);\n    }\n    const fromNewSessionExpireTime = getValueByPath(fromObject, [\n        'newSessionExpireTime',\n    ]);\n    if (parentObject !== undefined && fromNewSessionExpireTime != null) {\n        setValueByPath(parentObject, ['newSessionExpireTime'], fromNewSessionExpireTime);\n    }\n    const fromUses = getValueByPath(fromObject, ['uses']);\n    if (parentObject !== undefined && fromUses != null) {\n        setValueByPath(parentObject, ['uses'], fromUses);\n    }\n    const fromLiveConnectConstraints = getValueByPath(fromObject, [\n        'liveConnectConstraints',\n    ]);\n    if (parentObject !== undefined && fromLiveConnectConstraints != null) {\n        setValueByPath(parentObject, ['bidiGenerateContentSetup'], liveConnectConstraintsToMldev(apiClient, fromLiveConnectConstraints));\n    }\n    const fromLockAdditionalFields = getValueByPath(fromObject, [\n        'lockAdditionalFields',\n    ]);\n    if (parentObject !== undefined && fromLockAdditionalFields != null) {\n        setValueByPath(parentObject, ['fieldMask'], fromLockAdditionalFields);\n    }\n    return toObject;\n}\nfunction createAuthTokenParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        setValueByPath(toObject, ['config'], createAuthTokenConfigToMldev(apiClient, fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction fileDataToMldev(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['displayName']) !== undefined) {\n        throw new Error('displayName parameter is not supported in Gemini API.');\n    }\n    const fromFileUri = getValueByPath(fromObject, ['fileUri']);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, ['fileUri'], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction functionCallToMldev(fromObject) {\n    const toObject = {};\n    const fromId = getValueByPath(fromObject, ['id']);\n    if (fromId != null) {\n        setValueByPath(toObject, ['id'], fromId);\n    }\n    const fromArgs = getValueByPath(fromObject, ['args']);\n    if (fromArgs != null) {\n        setValueByPath(toObject, ['args'], fromArgs);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    if (getValueByPath(fromObject, ['partialArgs']) !== undefined) {\n        throw new Error('partialArgs parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['willContinue']) !== undefined) {\n        throw new Error('willContinue parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction googleMapsToMldev(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['authConfig']) !== undefined) {\n        throw new Error('authConfig parameter is not supported in Gemini API.');\n    }\n    const fromEnableWidget = getValueByPath(fromObject, ['enableWidget']);\n    if (fromEnableWidget != null) {\n        setValueByPath(toObject, ['enableWidget'], fromEnableWidget);\n    }\n    return toObject;\n}\nfunction googleSearchToMldev(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['excludeDomains']) !== undefined) {\n        throw new Error('excludeDomains parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['blockingConfidence']) !== undefined) {\n        throw new Error('blockingConfidence parameter is not supported in Gemini API.');\n    }\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        'timeRangeFilter',\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, ['timeRangeFilter'], fromTimeRangeFilter);\n    }\n    return toObject;\n}\nfunction liveConnectConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromGenerationConfig = getValueByPath(fromObject, [\n        'generationConfig',\n    ]);\n    if (parentObject !== undefined && fromGenerationConfig != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig'], fromGenerationConfig);\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        'responseModalities',\n    ]);\n    if (parentObject !== undefined && fromResponseModalities != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'responseModalities'], fromResponseModalities);\n    }\n    const fromTemperature = getValueByPath(fromObject, ['temperature']);\n    if (parentObject !== undefined && fromTemperature != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'temperature'], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, ['topP']);\n    if (parentObject !== undefined && fromTopP != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'topP'], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, ['topK']);\n    if (parentObject !== undefined && fromTopK != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'topK'], fromTopK);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        'maxOutputTokens',\n    ]);\n    if (parentObject !== undefined && fromMaxOutputTokens != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'maxOutputTokens'], fromMaxOutputTokens);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        'mediaResolution',\n    ]);\n    if (parentObject !== undefined && fromMediaResolution != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'mediaResolution'], fromMediaResolution);\n    }\n    const fromSeed = getValueByPath(fromObject, ['seed']);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'seed'], fromSeed);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, ['speechConfig']);\n    if (parentObject !== undefined && fromSpeechConfig != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'speechConfig'], tLiveSpeechConfig(fromSpeechConfig));\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        'thinkingConfig',\n    ]);\n    if (parentObject !== undefined && fromThinkingConfig != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'thinkingConfig'], fromThinkingConfig);\n    }\n    const fromEnableAffectiveDialog = getValueByPath(fromObject, [\n        'enableAffectiveDialog',\n    ]);\n    if (parentObject !== undefined && fromEnableAffectiveDialog != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'enableAffectiveDialog'], fromEnableAffectiveDialog);\n    }\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        'systemInstruction',\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, ['setup', 'systemInstruction'], contentToMldev(tContent(fromSystemInstruction)));\n    }\n    const fromTools = getValueByPath(fromObject, ['tools']);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return toolToMldev(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, ['setup', 'tools'], transformedList);\n    }\n    const fromSessionResumption = getValueByPath(fromObject, [\n        'sessionResumption',\n    ]);\n    if (parentObject !== undefined && fromSessionResumption != null) {\n        setValueByPath(parentObject, ['setup', 'sessionResumption'], sessionResumptionConfigToMldev(fromSessionResumption));\n    }\n    const fromInputAudioTranscription = getValueByPath(fromObject, [\n        'inputAudioTranscription',\n    ]);\n    if (parentObject !== undefined && fromInputAudioTranscription != null) {\n        setValueByPath(parentObject, ['setup', 'inputAudioTranscription'], fromInputAudioTranscription);\n    }\n    const fromOutputAudioTranscription = getValueByPath(fromObject, [\n        'outputAudioTranscription',\n    ]);\n    if (parentObject !== undefined && fromOutputAudioTranscription != null) {\n        setValueByPath(parentObject, ['setup', 'outputAudioTranscription'], fromOutputAudioTranscription);\n    }\n    const fromRealtimeInputConfig = getValueByPath(fromObject, [\n        'realtimeInputConfig',\n    ]);\n    if (parentObject !== undefined && fromRealtimeInputConfig != null) {\n        setValueByPath(parentObject, ['setup', 'realtimeInputConfig'], fromRealtimeInputConfig);\n    }\n    const fromContextWindowCompression = getValueByPath(fromObject, [\n        'contextWindowCompression',\n    ]);\n    if (parentObject !== undefined && fromContextWindowCompression != null) {\n        setValueByPath(parentObject, ['setup', 'contextWindowCompression'], fromContextWindowCompression);\n    }\n    const fromProactivity = getValueByPath(fromObject, ['proactivity']);\n    if (parentObject !== undefined && fromProactivity != null) {\n        setValueByPath(parentObject, ['setup', 'proactivity'], fromProactivity);\n    }\n    return toObject;\n}\nfunction liveConnectConstraintsToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['setup', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        setValueByPath(toObject, ['config'], liveConnectConfigToMldev(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction partToMldev(fromObject) {\n    const toObject = {};\n    const fromMediaResolution = getValueByPath(fromObject, [\n        'mediaResolution',\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, ['mediaResolution'], fromMediaResolution);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        'codeExecutionResult',\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, ['codeExecutionResult'], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        'executableCode',\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, ['executableCode'], fromExecutableCode);\n    }\n    const fromFileData = getValueByPath(fromObject, ['fileData']);\n    if (fromFileData != null) {\n        setValueByPath(toObject, ['fileData'], fileDataToMldev(fromFileData));\n    }\n    const fromFunctionCall = getValueByPath(fromObject, ['functionCall']);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, ['functionCall'], functionCallToMldev(fromFunctionCall));\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        'functionResponse',\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, ['functionResponse'], fromFunctionResponse);\n    }\n    const fromInlineData = getValueByPath(fromObject, ['inlineData']);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, ['inlineData'], blobToMldev(fromInlineData));\n    }\n    const fromText = getValueByPath(fromObject, ['text']);\n    if (fromText != null) {\n        setValueByPath(toObject, ['text'], fromText);\n    }\n    const fromThought = getValueByPath(fromObject, ['thought']);\n    if (fromThought != null) {\n        setValueByPath(toObject, ['thought'], fromThought);\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        'thoughtSignature',\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, ['thoughtSignature'], fromThoughtSignature);\n    }\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        'videoMetadata',\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, ['videoMetadata'], fromVideoMetadata);\n    }\n    return toObject;\n}\nfunction sessionResumptionConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromHandle = getValueByPath(fromObject, ['handle']);\n    if (fromHandle != null) {\n        setValueByPath(toObject, ['handle'], fromHandle);\n    }\n    if (getValueByPath(fromObject, ['transparent']) !== undefined) {\n        throw new Error('transparent parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction toolToMldev(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        'functionDeclarations',\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['functionDeclarations'], transformedList);\n    }\n    if (getValueByPath(fromObject, ['retrieval']) !== undefined) {\n        throw new Error('retrieval parameter is not supported in Gemini API.');\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        'googleSearchRetrieval',\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, ['googleSearchRetrieval'], fromGoogleSearchRetrieval);\n    }\n    const fromComputerUse = getValueByPath(fromObject, ['computerUse']);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, ['computerUse'], fromComputerUse);\n    }\n    const fromFileSearch = getValueByPath(fromObject, ['fileSearch']);\n    if (fromFileSearch != null) {\n        setValueByPath(toObject, ['fileSearch'], fromFileSearch);\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        'codeExecution',\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, ['codeExecution'], fromCodeExecution);\n    }\n    if (getValueByPath(fromObject, ['enterpriseWebSearch']) !== undefined) {\n        throw new Error('enterpriseWebSearch parameter is not supported in Gemini API.');\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, ['googleMaps']);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, ['googleMaps'], googleMapsToMldev(fromGoogleMaps));\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, ['googleSearch']);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, ['googleSearch'], googleSearchToMldev(fromGoogleSearch));\n    }\n    const fromUrlContext = getValueByPath(fromObject, ['urlContext']);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, ['urlContext'], fromUrlContext);\n    }\n    return toObject;\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * Returns a comma-separated list of field masks from a given object.\n *\n * @param setup The object to extract field masks from.\n * @return A comma-separated list of field masks.\n */\nfunction getFieldMasks(setup) {\n    const fields = [];\n    for (const key in setup) {\n        if (Object.prototype.hasOwnProperty.call(setup, key)) {\n            const value = setup[key];\n            // 2nd layer, recursively get field masks see TODO(b/418290100)\n            if (typeof value === 'object' &&\n                value != null &&\n                Object.keys(value).length > 0) {\n                const field = Object.keys(value).map((kk) => `${key}.${kk}`);\n                fields.push(...field);\n            }\n            else {\n                fields.push(key); // 1st layer\n            }\n        }\n    }\n    return fields.join(',');\n}\n/**\n * Converts bidiGenerateContentSetup.\n * @param requestDict - The request dictionary.\n * @param config - The configuration object.\n * @return - The modified request dictionary.\n */\nfunction convertBidiSetupToTokenSetup(requestDict, config) {\n    // Convert bidiGenerateContentSetup from bidiGenerateContentSetup.setup.\n    let setupForMaskGeneration = null;\n    const bidiGenerateContentSetupValue = requestDict['bidiGenerateContentSetup'];\n    if (typeof bidiGenerateContentSetupValue === 'object' &&\n        bidiGenerateContentSetupValue !== null &&\n        'setup' in bidiGenerateContentSetupValue) {\n        // Now we know bidiGenerateContentSetupValue is an object and has a 'setup'\n        // property.\n        const innerSetup = bidiGenerateContentSetupValue\n            .setup;\n        if (typeof innerSetup === 'object' && innerSetup !== null) {\n            // Valid inner setup found.\n            requestDict['bidiGenerateContentSetup'] = innerSetup;\n            setupForMaskGeneration = innerSetup;\n        }\n        else {\n            // `bidiGenerateContentSetupValue.setup` is not a valid object; treat as\n            // if bidiGenerateContentSetup is invalid.\n            delete requestDict['bidiGenerateContentSetup'];\n        }\n    }\n    else if (bidiGenerateContentSetupValue !== undefined) {\n        // `bidiGenerateContentSetup` exists but not in the expected\n        // shape {setup: {...}}; treat as invalid.\n        delete requestDict['bidiGenerateContentSetup'];\n    }\n    const preExistingFieldMask = requestDict['fieldMask'];\n    // Handle mask generation setup.\n    if (setupForMaskGeneration) {\n        const generatedMaskFromBidi = getFieldMasks(setupForMaskGeneration);\n        if (Array.isArray(config === null || config === void 0 ? void 0 : config.lockAdditionalFields) &&\n            (config === null || config === void 0 ? void 0 : config.lockAdditionalFields.length) === 0) {\n            // Case 1: lockAdditionalFields is an empty array. Lock only fields from\n            // bidi setup.\n            if (generatedMaskFromBidi) {\n                // Only assign if mask is not empty\n                requestDict['fieldMask'] = generatedMaskFromBidi;\n            }\n            else {\n                delete requestDict['fieldMask']; // If mask is empty, effectively no\n                // specific fields locked by bidi\n            }\n        }\n        else if ((config === null || config === void 0 ? void 0 : config.lockAdditionalFields) &&\n            config.lockAdditionalFields.length > 0 &&\n            preExistingFieldMask !== null &&\n            Array.isArray(preExistingFieldMask) &&\n            preExistingFieldMask.length > 0) {\n            // Case 2: Lock fields from bidi setup + additional fields\n            // (preExistingFieldMask).\n            const generationConfigFields = [\n                'temperature',\n                'topK',\n                'topP',\n                'maxOutputTokens',\n                'responseModalities',\n                'seed',\n                'speechConfig',\n            ];\n            let mappedFieldsFromPreExisting = [];\n            if (preExistingFieldMask.length > 0) {\n                mappedFieldsFromPreExisting = preExistingFieldMask.map((field) => {\n                    if (generationConfigFields.includes(field)) {\n                        return `generationConfig.${field}`;\n                    }\n                    return field; // Keep original field name if not in\n                    // generationConfigFields\n                });\n            }\n            const finalMaskParts = [];\n            if (generatedMaskFromBidi) {\n                finalMaskParts.push(generatedMaskFromBidi);\n            }\n            if (mappedFieldsFromPreExisting.length > 0) {\n                finalMaskParts.push(...mappedFieldsFromPreExisting);\n            }\n            if (finalMaskParts.length > 0) {\n                requestDict['fieldMask'] = finalMaskParts.join(',');\n            }\n            else {\n                // If no fields from bidi and no valid additional fields from\n                // pre-existing mask.\n                delete requestDict['fieldMask'];\n            }\n        }\n        else {\n            // Case 3: \"Lock all fields\" (meaning, don't send a field_mask, let server\n            // defaults apply or all are mutable). This is hit if:\n            //  - `config.lockAdditionalFields` is undefined.\n            //  - `config.lockAdditionalFields` is non-empty, BUT\n            //  `preExistingFieldMask` is null, not a string, or an empty string.\n            delete requestDict['fieldMask'];\n        }\n    }\n    else {\n        // No valid `bidiGenerateContentSetup` was found or extracted.\n        // \"Lock additional null fields if any\".\n        if (preExistingFieldMask !== null &&\n            Array.isArray(preExistingFieldMask) &&\n            preExistingFieldMask.length > 0) {\n            // If there's a pre-existing field mask, it's a string, and it's not\n            // empty, then we should lock all fields.\n            requestDict['fieldMask'] = preExistingFieldMask.join(',');\n        }\n        else {\n            delete requestDict['fieldMask'];\n        }\n    }\n    return requestDict;\n}\nclass Tokens extends BaseModule {\n    constructor(apiClient) {\n        super();\n        this.apiClient = apiClient;\n    }\n    /**\n     * Creates an ephemeral auth token resource.\n     *\n     * @experimental\n     *\n     * @remarks\n     * Ephemeral auth tokens is only supported in the Gemini Developer API.\n     * It can be used for the session connection to the Live constrained API.\n     * Support in v1alpha only.\n     *\n     * @param params - The parameters for the create request.\n     * @return The created auth token.\n     *\n     * @example\n     * ```ts\n     * const ai = new GoogleGenAI({\n     *     apiKey: token.name,\n     *     httpOptions: { apiVersion: 'v1alpha' }  // Support in v1alpha only.\n     * });\n     *\n     * // Case 1: If LiveEphemeralParameters is unset, unlock LiveConnectConfig\n     * // when using the token in Live API sessions. Each session connection can\n     * // use a different configuration.\n     * const config: CreateAuthTokenConfig = {\n     *     uses: 3,\n     *     expireTime: '2025-05-01T00:00:00Z',\n     * }\n     * const token = await ai.tokens.create(config);\n     *\n     * // Case 2: If LiveEphemeralParameters is set, lock all fields in\n     * // LiveConnectConfig when using the token in Live API sessions. For\n     * // example, changing `outputAudioTranscription` in the Live API\n     * // connection will be ignored by the API.\n     * const config: CreateAuthTokenConfig =\n     *     uses: 3,\n     *     expireTime: '2025-05-01T00:00:00Z',\n     *     LiveEphemeralParameters: {\n     *        model: 'gemini-2.0-flash-001',\n     *        config: {\n     *           'responseModalities': ['AUDIO'],\n     *           'systemInstruction': 'Always answer in English.',\n     *        }\n     *     }\n     * }\n     * const token = await ai.tokens.create(config);\n     *\n     * // Case 3: If LiveEphemeralParameters is set and lockAdditionalFields is\n     * // set, lock LiveConnectConfig with set and additional fields (e.g.\n     * // responseModalities, systemInstruction, temperature in this example) when\n     * // using the token in Live API sessions.\n     * const config: CreateAuthTokenConfig =\n     *     uses: 3,\n     *     expireTime: '2025-05-01T00:00:00Z',\n     *     LiveEphemeralParameters: {\n     *        model: 'gemini-2.0-flash-001',\n     *        config: {\n     *           'responseModalities': ['AUDIO'],\n     *           'systemInstruction': 'Always answer in English.',\n     *        }\n     *     },\n     *     lockAdditionalFields: ['temperature'],\n     * }\n     * const token = await ai.tokens.create(config);\n     *\n     * // Case 4: If LiveEphemeralParameters is set and lockAdditionalFields is\n     * // empty array, lock LiveConnectConfig with set fields (e.g.\n     * // responseModalities, systemInstruction in this example) when using the\n     * // token in Live API sessions.\n     * const config: CreateAuthTokenConfig =\n     *     uses: 3,\n     *     expireTime: '2025-05-01T00:00:00Z',\n     *     LiveEphemeralParameters: {\n     *        model: 'gemini-2.0-flash-001',\n     *        config: {\n     *           'responseModalities': ['AUDIO'],\n     *           'systemInstruction': 'Always answer in English.',\n     *        }\n     *     },\n     *     lockAdditionalFields: [],\n     * }\n     * const token = await ai.tokens.create(config);\n     * ```\n     */\n    async create(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error('The client.tokens.create method is only supported by the Gemini Developer API.');\n        }\n        else {\n            const body = createAuthTokenParametersToMldev(this.apiClient, params);\n            path = formatMap('auth_tokens', body['_url']);\n            queryParams = body['_query'];\n            delete body['config'];\n            delete body['_url'];\n            delete body['_query'];\n            const transformedBody = convertBidiSetupToTokenSetup(body, params.config);\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(transformedBody),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((resp) => {\n                return resp;\n            });\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n// Code generated by the Google Gen AI SDK generator DO NOT EDIT.\nfunction createFileSearchStoreConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, ['displayName']);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, ['displayName'], fromDisplayName);\n    }\n    return toObject;\n}\nfunction createFileSearchStoreParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        createFileSearchStoreConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction deleteFileSearchStoreConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromForce = getValueByPath(fromObject, ['force']);\n    if (parentObject !== undefined && fromForce != null) {\n        setValueByPath(parentObject, ['_query', 'force'], fromForce);\n    }\n    return toObject;\n}\nfunction deleteFileSearchStoreParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], fromName);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        deleteFileSearchStoreConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction getFileSearchStoreParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], fromName);\n    }\n    return toObject;\n}\nfunction importFileConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromCustomMetadata = getValueByPath(fromObject, [\n        'customMetadata',\n    ]);\n    if (parentObject !== undefined && fromCustomMetadata != null) {\n        let transformedList = fromCustomMetadata;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(parentObject, ['customMetadata'], transformedList);\n    }\n    const fromChunkingConfig = getValueByPath(fromObject, [\n        'chunkingConfig',\n    ]);\n    if (parentObject !== undefined && fromChunkingConfig != null) {\n        setValueByPath(parentObject, ['chunkingConfig'], fromChunkingConfig);\n    }\n    return toObject;\n}\nfunction importFileOperationFromMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, ['metadata']);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, ['metadata'], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, ['done']);\n    if (fromDone != null) {\n        setValueByPath(toObject, ['done'], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, ['error']);\n    if (fromError != null) {\n        setValueByPath(toObject, ['error'], fromError);\n    }\n    const fromResponse = getValueByPath(fromObject, ['response']);\n    if (fromResponse != null) {\n        setValueByPath(toObject, ['response'], importFileResponseFromMldev(fromResponse));\n    }\n    return toObject;\n}\nfunction importFileParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromFileSearchStoreName = getValueByPath(fromObject, [\n        'fileSearchStoreName',\n    ]);\n    if (fromFileSearchStoreName != null) {\n        setValueByPath(toObject, ['_url', 'file_search_store_name'], fromFileSearchStoreName);\n    }\n    const fromFileName = getValueByPath(fromObject, ['fileName']);\n    if (fromFileName != null) {\n        setValueByPath(toObject, ['fileName'], fromFileName);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        importFileConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction importFileResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromParent = getValueByPath(fromObject, ['parent']);\n    if (fromParent != null) {\n        setValueByPath(toObject, ['parent'], fromParent);\n    }\n    const fromDocumentName = getValueByPath(fromObject, ['documentName']);\n    if (fromDocumentName != null) {\n        setValueByPath(toObject, ['documentName'], fromDocumentName);\n    }\n    return toObject;\n}\nfunction listFileSearchStoresConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, ['pageSize']);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, ['_query', 'pageSize'], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, ['pageToken']);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, ['_query', 'pageToken'], fromPageToken);\n    }\n    return toObject;\n}\nfunction listFileSearchStoresParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        listFileSearchStoresConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listFileSearchStoresResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        'nextPageToken',\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, ['nextPageToken'], fromNextPageToken);\n    }\n    const fromFileSearchStores = getValueByPath(fromObject, [\n        'fileSearchStores',\n    ]);\n    if (fromFileSearchStores != null) {\n        let transformedList = fromFileSearchStores;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['fileSearchStores'], transformedList);\n    }\n    return toObject;\n}\nfunction uploadToFileSearchStoreConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (parentObject !== undefined && fromMimeType != null) {\n        setValueByPath(parentObject, ['mimeType'], fromMimeType);\n    }\n    const fromDisplayName = getValueByPath(fromObject, ['displayName']);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, ['displayName'], fromDisplayName);\n    }\n    const fromCustomMetadata = getValueByPath(fromObject, [\n        'customMetadata',\n    ]);\n    if (parentObject !== undefined && fromCustomMetadata != null) {\n        let transformedList = fromCustomMetadata;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(parentObject, ['customMetadata'], transformedList);\n    }\n    const fromChunkingConfig = getValueByPath(fromObject, [\n        'chunkingConfig',\n    ]);\n    if (parentObject !== undefined && fromChunkingConfig != null) {\n        setValueByPath(parentObject, ['chunkingConfig'], fromChunkingConfig);\n    }\n    return toObject;\n}\nfunction uploadToFileSearchStoreParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromFileSearchStoreName = getValueByPath(fromObject, [\n        'fileSearchStoreName',\n    ]);\n    if (fromFileSearchStoreName != null) {\n        setValueByPath(toObject, ['_url', 'file_search_store_name'], fromFileSearchStoreName);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        uploadToFileSearchStoreConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction uploadToFileSearchStoreResumableResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    return toObject;\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n// Code generated by the Google Gen AI SDK generator DO NOT EDIT.\nfunction deleteDocumentConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromForce = getValueByPath(fromObject, ['force']);\n    if (parentObject !== undefined && fromForce != null) {\n        setValueByPath(parentObject, ['_query', 'force'], fromForce);\n    }\n    return toObject;\n}\nfunction deleteDocumentParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], fromName);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        deleteDocumentConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction getDocumentParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], fromName);\n    }\n    return toObject;\n}\nfunction listDocumentsConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, ['pageSize']);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, ['_query', 'pageSize'], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, ['pageToken']);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, ['_query', 'pageToken'], fromPageToken);\n    }\n    return toObject;\n}\nfunction listDocumentsParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromParent = getValueByPath(fromObject, ['parent']);\n    if (fromParent != null) {\n        setValueByPath(toObject, ['_url', 'parent'], fromParent);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        listDocumentsConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listDocumentsResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        'nextPageToken',\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, ['nextPageToken'], fromNextPageToken);\n    }\n    const fromDocuments = getValueByPath(fromObject, ['documents']);\n    if (fromDocuments != null) {\n        let transformedList = fromDocuments;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['documents'], transformedList);\n    }\n    return toObject;\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nclass Documents extends BaseModule {\n    constructor(apiClient) {\n        super();\n        this.apiClient = apiClient;\n        /**\n         * Lists documents.\n         *\n         * @param params - The parameters for the list request.\n         * @return - A pager of documents.\n         *\n         * @example\n         * ```ts\n         * const documents = await ai.documents.list({config: {'pageSize': 2}});\n         * for await (const document of documents) {\n         *   console.log(document);\n         * }\n         * ```\n         */\n        this.list = async (params) => {\n            return new Pager(PagedItem.PAGED_ITEM_DOCUMENTS, (x) => this.listInternal({\n                parent: params.parent,\n                config: x.config,\n            }), await this.listInternal(params), params);\n        };\n    }\n    /**\n     * Gets a Document.\n     *\n     * @param params - The parameters for getting a document.\n     * @return Document.\n     */\n    async get(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error('This method is only supported by the Gemini Developer API.');\n        }\n        else {\n            const body = getDocumentParametersToMldev(params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((resp) => {\n                return resp;\n            });\n        }\n    }\n    /**\n     * Deletes a Document.\n     *\n     * @param params - The parameters for deleting a document.\n     */\n    async delete(params) {\n        var _a, _b;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error('This method is only supported by the Gemini Developer API.');\n        }\n        else {\n            const body = deleteDocumentParametersToMldev(params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            await this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'DELETE',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            });\n        }\n    }\n    /**\n     * Lists all Documents in a FileSearchStore.\n     *\n     * @param params - The parameters for listing documents.\n     * @return ListDocumentsResponse.\n     */\n    async listInternal(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error('This method is only supported by the Gemini Developer API.');\n        }\n        else {\n            const body = listDocumentsParametersToMldev(params);\n            path = formatMap('{parent}/documents', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = listDocumentsResponseFromMldev(apiResponse);\n                const typedResp = new ListDocumentsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nclass FileSearchStores extends BaseModule {\n    constructor(apiClient, documents = new Documents(apiClient)) {\n        super();\n        this.apiClient = apiClient;\n        this.documents = documents;\n        /**\n         * Lists file search stores.\n         *\n         * @param params - The parameters for the list request.\n         * @return - A pager of file search stores.\n         *\n         * @example\n         * ```ts\n         * const fileSearchStores = await ai.fileSearchStores.list({config: {'pageSize': 2}});\n         * for await (const fileSearchStore of fileSearchStores) {\n         *   console.log(fileSearchStore);\n         * }\n         * ```\n         */\n        this.list = async (params = {}) => {\n            return new Pager(PagedItem.PAGED_ITEM_FILE_SEARCH_STORES, (x) => this.listInternal(x), await this.listInternal(params), params);\n        };\n    }\n    /**\n     * Uploads a file asynchronously to a given File Search Store.\n     * This method is not available in Vertex AI.\n     * Supported upload sources:\n     * - Node.js: File path (string) or Blob object.\n     * - Browser: Blob object (e.g., File).\n     *\n     * @remarks\n     * The `mimeType` can be specified in the `config` parameter. If omitted:\n     *  - For file path (string) inputs, the `mimeType` will be inferred from the\n     *     file extension.\n     *  - For Blob object inputs, the `mimeType` will be set to the Blob's `type`\n     *     property.\n     *\n     * This section can contain multiple paragraphs and code examples.\n     *\n     * @param params - Optional parameters specified in the\n     *        `types.UploadToFileSearchStoreParameters` interface.\n     *         @see {@link types.UploadToFileSearchStoreParameters#config} for the optional\n     *         config in the parameters.\n     * @return A promise that resolves to a long running operation.\n     * @throws An error if called on a Vertex AI client.\n     * @throws An error if the `mimeType` is not provided and can not be inferred,\n     * the `mimeType` can be provided in the `params.config` parameter.\n     * @throws An error occurs if a suitable upload location cannot be established.\n     *\n     * @example\n     * The following code uploads a file to a given file search store.\n     *\n     * ```ts\n     * const operation = await ai.fileSearchStores.upload({fileSearchStoreName: 'fileSearchStores/foo-bar', file: 'file.txt', config: {\n     *   mimeType: 'text/plain',\n     * }});\n     * console.log(operation.name);\n     * ```\n     */\n    async uploadToFileSearchStore(params) {\n        if (this.apiClient.isVertexAI()) {\n            throw new Error('Vertex AI does not support uploading files to a file search store.');\n        }\n        return this.apiClient.uploadFileToFileSearchStore(params.fileSearchStoreName, params.file, params.config);\n    }\n    /**\n     * Creates a File Search Store.\n     *\n     * @param params - The parameters for creating a File Search Store.\n     * @return FileSearchStore.\n     */\n    async create(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error('This method is only supported by the Gemini Developer API.');\n        }\n        else {\n            const body = createFileSearchStoreParametersToMldev(params);\n            path = formatMap('fileSearchStores', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((resp) => {\n                return resp;\n            });\n        }\n    }\n    /**\n     * Gets a File Search Store.\n     *\n     * @param params - The parameters for getting a File Search Store.\n     * @return FileSearchStore.\n     */\n    async get(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error('This method is only supported by the Gemini Developer API.');\n        }\n        else {\n            const body = getFileSearchStoreParametersToMldev(params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((resp) => {\n                return resp;\n            });\n        }\n    }\n    /**\n     * Deletes a File Search Store.\n     *\n     * @param params - The parameters for deleting a File Search Store.\n     */\n    async delete(params) {\n        var _a, _b;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error('This method is only supported by the Gemini Developer API.');\n        }\n        else {\n            const body = deleteFileSearchStoreParametersToMldev(params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            await this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'DELETE',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            });\n        }\n    }\n    /**\n     * Lists all FileSearchStore owned by the user.\n     *\n     * @param params - The parameters for listing file search stores.\n     * @return ListFileSearchStoresResponse.\n     */\n    async listInternal(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error('This method is only supported by the Gemini Developer API.');\n        }\n        else {\n            const body = listFileSearchStoresParametersToMldev(params);\n            path = formatMap('fileSearchStores', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = listFileSearchStoresResponseFromMldev(apiResponse);\n                const typedResp = new ListFileSearchStoresResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    async uploadToFileSearchStoreInternal(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error('This method is only supported by the Gemini Developer API.');\n        }\n        else {\n            const body = uploadToFileSearchStoreParametersToMldev(params);\n            path = formatMap('upload/v1beta/{file_search_store_name}:uploadToFileSearchStore', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = uploadToFileSearchStoreResumableResponseFromMldev(apiResponse);\n                const typedResp = new UploadToFileSearchStoreResumableResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Imports a File from File Service to a FileSearchStore.\n     *\n     * This is a long-running operation, see aip.dev/151\n     *\n     * @param params - The parameters for importing a file to a file search store.\n     * @return ImportFileOperation.\n     */\n    async importFile(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error('This method is only supported by the Gemini Developer API.');\n        }\n        else {\n            const body = importFileParametersToMldev(params);\n            path = formatMap('{file_search_store_name}:importFile', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = importFileOperationFromMldev(apiResponse);\n                const typedResp = new ImportFileOperation();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst GOOGLE_API_KEY_HEADER = 'x-goog-api-key';\nconst REQUIRED_VERTEX_AI_SCOPE = 'https://www.googleapis.com/auth/cloud-platform';\nclass NodeAuth {\n    constructor(opts) {\n        if (opts.apiKey !== undefined) {\n            this.apiKey = opts.apiKey;\n            return;\n        }\n        const vertexAuthOptions = buildGoogleAuthOptions(opts.googleAuthOptions);\n        this.googleAuth = new google_auth_library__WEBPACK_IMPORTED_MODULE_0__.GoogleAuth(vertexAuthOptions);\n    }\n    async addAuthHeaders(headers, url) {\n        if (this.apiKey !== undefined) {\n            if (this.apiKey.startsWith('auth_tokens/')) {\n                throw new Error('Ephemeral tokens are only supported by the live API.');\n            }\n            this.addKeyHeader(headers);\n            return;\n        }\n        return this.addGoogleAuthHeaders(headers, url);\n    }\n    addKeyHeader(headers) {\n        if (headers.get(GOOGLE_API_KEY_HEADER) !== null) {\n            return;\n        }\n        if (this.apiKey === undefined) {\n            // This should never happen, this method is only called\n            // when apiKey is set.\n            throw new Error('Trying to set API key header but apiKey is not set');\n        }\n        headers.append(GOOGLE_API_KEY_HEADER, this.apiKey);\n    }\n    async addGoogleAuthHeaders(headers, url) {\n        if (this.googleAuth === undefined) {\n            // This should never happen, addGoogleAuthHeaders should only be\n            // called when there is no apiKey set and in these cases googleAuth\n            // is set.\n            throw new Error('Trying to set google-auth headers but googleAuth is unset');\n        }\n        const authHeaders = await this.googleAuth.getRequestHeaders(url);\n        for (const [key, value] of authHeaders) {\n            if (headers.get(key) !== null) {\n                continue;\n            }\n            headers.append(key, value);\n        }\n    }\n}\nfunction buildGoogleAuthOptions(googleAuthOptions) {\n    let authOptions;\n    if (!googleAuthOptions) {\n        authOptions = {\n            scopes: [REQUIRED_VERTEX_AI_SCOPE],\n        };\n        return authOptions;\n    }\n    else {\n        authOptions = googleAuthOptions;\n        if (!authOptions.scopes) {\n            authOptions.scopes = [REQUIRED_VERTEX_AI_SCOPE];\n            return authOptions;\n        }\n        else if ((typeof authOptions.scopes === 'string' &&\n            authOptions.scopes !== REQUIRED_VERTEX_AI_SCOPE) ||\n            (Array.isArray(authOptions.scopes) &&\n                authOptions.scopes.indexOf(REQUIRED_VERTEX_AI_SCOPE) < 0)) {\n            throw new Error(`Invalid auth scopes. Scopes must include: ${REQUIRED_VERTEX_AI_SCOPE}`);\n        }\n        return authOptions;\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nclass NodeDownloader {\n    async download(params, apiClient) {\n        if (params.downloadPath) {\n            const response = await downloadFile(params, apiClient);\n            if (response instanceof HttpResponse) {\n                const writer = (0,fs__WEBPACK_IMPORTED_MODULE_1__.createWriteStream)(params.downloadPath);\n                const body = node_stream__WEBPACK_IMPORTED_MODULE_3__.Readable.fromWeb(response.responseInternal.body);\n                body.pipe(writer);\n                await (0,node_stream_promises__WEBPACK_IMPORTED_MODULE_4__.finished)(writer);\n            }\n            else {\n                try {\n                    await (0,fs_promises__WEBPACK_IMPORTED_MODULE_2__.writeFile)(params.downloadPath, response, {\n                        encoding: 'base64',\n                    });\n                }\n                catch (error) {\n                    throw new Error(`Failed to write file to ${params.downloadPath}: ${error}`);\n                }\n            }\n        }\n    }\n}\nasync function downloadFile(params, apiClient) {\n    var _a, _b, _c;\n    const name = tFileName(params.file);\n    if (name !== undefined) {\n        return await apiClient.request({\n            path: `files/${name}:download`,\n            httpMethod: 'GET',\n            queryParams: {\n                'alt': 'media',\n            },\n            httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n            abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n        });\n    }\n    else if (isGeneratedVideo(params.file)) {\n        const videoBytes = (_c = params.file.video) === null || _c === void 0 ? void 0 : _c.videoBytes;\n        if (typeof videoBytes === 'string') {\n            return videoBytes;\n        }\n        else {\n            throw new Error('Failed to download generated video, Uri or videoBytes not found.');\n        }\n    }\n    else if (isVideo(params.file)) {\n        const videoBytes = params.file.videoBytes;\n        if (typeof videoBytes === 'string') {\n            return videoBytes;\n        }\n        else {\n            throw new Error('Failed to download video, Uri or videoBytes not found.');\n        }\n    }\n    else {\n        throw new Error('Unsupported file type');\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nclass NodeWebSocketFactory {\n    create(url, headers, callbacks) {\n        return new NodeWebSocket(url, headers, callbacks);\n    }\n}\nclass NodeWebSocket {\n    constructor(url, headers, callbacks) {\n        this.url = url;\n        this.headers = headers;\n        this.callbacks = callbacks;\n    }\n    connect() {\n        this.ws = new ws__WEBPACK_IMPORTED_MODULE_5__.WebSocket(this.url, { headers: this.headers });\n        this.ws.onopen = this.callbacks.onopen;\n        this.ws.onerror = this.callbacks.onerror;\n        this.ws.onclose = this.callbacks.onclose;\n        this.ws.onmessage = this.callbacks.onmessage;\n    }\n    send(message) {\n        if (this.ws === undefined) {\n            throw new Error('WebSocket is not connected');\n        }\n        this.ws.send(message);\n    }\n    close() {\n        if (this.ws === undefined) {\n            throw new Error('WebSocket is not connected');\n        }\n        this.ws.close();\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n// Code generated by the Google Gen AI SDK generator DO NOT EDIT.\nfunction cancelTuningJobParametersToMldev(fromObject, _rootObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], fromName);\n    }\n    return toObject;\n}\nfunction cancelTuningJobParametersToVertex(fromObject, _rootObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], fromName);\n    }\n    return toObject;\n}\nfunction createTuningJobConfigToMldev(fromObject, parentObject, _rootObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['validationDataset']) !== undefined) {\n        throw new Error('validationDataset parameter is not supported in Gemini API.');\n    }\n    const fromTunedModelDisplayName = getValueByPath(fromObject, [\n        'tunedModelDisplayName',\n    ]);\n    if (parentObject !== undefined && fromTunedModelDisplayName != null) {\n        setValueByPath(parentObject, ['displayName'], fromTunedModelDisplayName);\n    }\n    if (getValueByPath(fromObject, ['description']) !== undefined) {\n        throw new Error('description parameter is not supported in Gemini API.');\n    }\n    const fromEpochCount = getValueByPath(fromObject, ['epochCount']);\n    if (parentObject !== undefined && fromEpochCount != null) {\n        setValueByPath(parentObject, ['tuningTask', 'hyperparameters', 'epochCount'], fromEpochCount);\n    }\n    const fromLearningRateMultiplier = getValueByPath(fromObject, [\n        'learningRateMultiplier',\n    ]);\n    if (fromLearningRateMultiplier != null) {\n        setValueByPath(toObject, ['tuningTask', 'hyperparameters', 'learningRateMultiplier'], fromLearningRateMultiplier);\n    }\n    if (getValueByPath(fromObject, ['exportLastCheckpointOnly']) !==\n        undefined) {\n        throw new Error('exportLastCheckpointOnly parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['preTunedModelCheckpointId']) !==\n        undefined) {\n        throw new Error('preTunedModelCheckpointId parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['adapterSize']) !== undefined) {\n        throw new Error('adapterSize parameter is not supported in Gemini API.');\n    }\n    const fromBatchSize = getValueByPath(fromObject, ['batchSize']);\n    if (parentObject !== undefined && fromBatchSize != null) {\n        setValueByPath(parentObject, ['tuningTask', 'hyperparameters', 'batchSize'], fromBatchSize);\n    }\n    const fromLearningRate = getValueByPath(fromObject, ['learningRate']);\n    if (parentObject !== undefined && fromLearningRate != null) {\n        setValueByPath(parentObject, ['tuningTask', 'hyperparameters', 'learningRate'], fromLearningRate);\n    }\n    if (getValueByPath(fromObject, ['labels']) !== undefined) {\n        throw new Error('labels parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['beta']) !== undefined) {\n        throw new Error('beta parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction createTuningJobConfigToVertex(fromObject, parentObject, rootObject) {\n    const toObject = {};\n    let discriminatorValidationDataset = getValueByPath(rootObject, [\n        'config',\n        'method',\n    ]);\n    if (discriminatorValidationDataset === undefined) {\n        discriminatorValidationDataset = 'SUPERVISED_FINE_TUNING';\n    }\n    if (discriminatorValidationDataset === 'SUPERVISED_FINE_TUNING') {\n        const fromValidationDataset = getValueByPath(fromObject, [\n            'validationDataset',\n        ]);\n        if (parentObject !== undefined && fromValidationDataset != null) {\n            setValueByPath(parentObject, ['supervisedTuningSpec'], tuningValidationDatasetToVertex(fromValidationDataset));\n        }\n    }\n    else if (discriminatorValidationDataset === 'PREFERENCE_TUNING') {\n        const fromValidationDataset = getValueByPath(fromObject, [\n            'validationDataset',\n        ]);\n        if (parentObject !== undefined && fromValidationDataset != null) {\n            setValueByPath(parentObject, ['preferenceOptimizationSpec'], tuningValidationDatasetToVertex(fromValidationDataset));\n        }\n    }\n    const fromTunedModelDisplayName = getValueByPath(fromObject, [\n        'tunedModelDisplayName',\n    ]);\n    if (parentObject !== undefined && fromTunedModelDisplayName != null) {\n        setValueByPath(parentObject, ['tunedModelDisplayName'], fromTunedModelDisplayName);\n    }\n    const fromDescription = getValueByPath(fromObject, ['description']);\n    if (parentObject !== undefined && fromDescription != null) {\n        setValueByPath(parentObject, ['description'], fromDescription);\n    }\n    let discriminatorEpochCount = getValueByPath(rootObject, [\n        'config',\n        'method',\n    ]);\n    if (discriminatorEpochCount === undefined) {\n        discriminatorEpochCount = 'SUPERVISED_FINE_TUNING';\n    }\n    if (discriminatorEpochCount === 'SUPERVISED_FINE_TUNING') {\n        const fromEpochCount = getValueByPath(fromObject, ['epochCount']);\n        if (parentObject !== undefined && fromEpochCount != null) {\n            setValueByPath(parentObject, ['supervisedTuningSpec', 'hyperParameters', 'epochCount'], fromEpochCount);\n        }\n    }\n    else if (discriminatorEpochCount === 'PREFERENCE_TUNING') {\n        const fromEpochCount = getValueByPath(fromObject, ['epochCount']);\n        if (parentObject !== undefined && fromEpochCount != null) {\n            setValueByPath(parentObject, ['preferenceOptimizationSpec', 'hyperParameters', 'epochCount'], fromEpochCount);\n        }\n    }\n    let discriminatorLearningRateMultiplier = getValueByPath(rootObject, [\n        'config',\n        'method',\n    ]);\n    if (discriminatorLearningRateMultiplier === undefined) {\n        discriminatorLearningRateMultiplier = 'SUPERVISED_FINE_TUNING';\n    }\n    if (discriminatorLearningRateMultiplier === 'SUPERVISED_FINE_TUNING') {\n        const fromLearningRateMultiplier = getValueByPath(fromObject, [\n            'learningRateMultiplier',\n        ]);\n        if (parentObject !== undefined && fromLearningRateMultiplier != null) {\n            setValueByPath(parentObject, ['supervisedTuningSpec', 'hyperParameters', 'learningRateMultiplier'], fromLearningRateMultiplier);\n        }\n    }\n    else if (discriminatorLearningRateMultiplier === 'PREFERENCE_TUNING') {\n        const fromLearningRateMultiplier = getValueByPath(fromObject, [\n            'learningRateMultiplier',\n        ]);\n        if (parentObject !== undefined && fromLearningRateMultiplier != null) {\n            setValueByPath(parentObject, [\n                'preferenceOptimizationSpec',\n                'hyperParameters',\n                'learningRateMultiplier',\n            ], fromLearningRateMultiplier);\n        }\n    }\n    let discriminatorExportLastCheckpointOnly = getValueByPath(rootObject, ['config', 'method']);\n    if (discriminatorExportLastCheckpointOnly === undefined) {\n        discriminatorExportLastCheckpointOnly = 'SUPERVISED_FINE_TUNING';\n    }\n    if (discriminatorExportLastCheckpointOnly === 'SUPERVISED_FINE_TUNING') {\n        const fromExportLastCheckpointOnly = getValueByPath(fromObject, [\n            'exportLastCheckpointOnly',\n        ]);\n        if (parentObject !== undefined && fromExportLastCheckpointOnly != null) {\n            setValueByPath(parentObject, ['supervisedTuningSpec', 'exportLastCheckpointOnly'], fromExportLastCheckpointOnly);\n        }\n    }\n    else if (discriminatorExportLastCheckpointOnly === 'PREFERENCE_TUNING') {\n        const fromExportLastCheckpointOnly = getValueByPath(fromObject, [\n            'exportLastCheckpointOnly',\n        ]);\n        if (parentObject !== undefined && fromExportLastCheckpointOnly != null) {\n            setValueByPath(parentObject, ['preferenceOptimizationSpec', 'exportLastCheckpointOnly'], fromExportLastCheckpointOnly);\n        }\n    }\n    let discriminatorAdapterSize = getValueByPath(rootObject, [\n        'config',\n        'method',\n    ]);\n    if (discriminatorAdapterSize === undefined) {\n        discriminatorAdapterSize = 'SUPERVISED_FINE_TUNING';\n    }\n    if (discriminatorAdapterSize === 'SUPERVISED_FINE_TUNING') {\n        const fromAdapterSize = getValueByPath(fromObject, ['adapterSize']);\n        if (parentObject !== undefined && fromAdapterSize != null) {\n            setValueByPath(parentObject, ['supervisedTuningSpec', 'hyperParameters', 'adapterSize'], fromAdapterSize);\n        }\n    }\n    else if (discriminatorAdapterSize === 'PREFERENCE_TUNING') {\n        const fromAdapterSize = getValueByPath(fromObject, ['adapterSize']);\n        if (parentObject !== undefined && fromAdapterSize != null) {\n            setValueByPath(parentObject, ['preferenceOptimizationSpec', 'hyperParameters', 'adapterSize'], fromAdapterSize);\n        }\n    }\n    if (getValueByPath(fromObject, ['batchSize']) !== undefined) {\n        throw new Error('batchSize parameter is not supported in Vertex AI.');\n    }\n    if (getValueByPath(fromObject, ['learningRate']) !== undefined) {\n        throw new Error('learningRate parameter is not supported in Vertex AI.');\n    }\n    const fromLabels = getValueByPath(fromObject, ['labels']);\n    if (parentObject !== undefined && fromLabels != null) {\n        setValueByPath(parentObject, ['labels'], fromLabels);\n    }\n    const fromBeta = getValueByPath(fromObject, ['beta']);\n    if (parentObject !== undefined && fromBeta != null) {\n        setValueByPath(parentObject, ['preferenceOptimizationSpec', 'hyperParameters', 'beta'], fromBeta);\n    }\n    return toObject;\n}\nfunction createTuningJobParametersPrivateToMldev(fromObject, rootObject) {\n    const toObject = {};\n    const fromBaseModel = getValueByPath(fromObject, ['baseModel']);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, ['baseModel'], fromBaseModel);\n    }\n    const fromPreTunedModel = getValueByPath(fromObject, [\n        'preTunedModel',\n    ]);\n    if (fromPreTunedModel != null) {\n        setValueByPath(toObject, ['preTunedModel'], fromPreTunedModel);\n    }\n    const fromTrainingDataset = getValueByPath(fromObject, [\n        'trainingDataset',\n    ]);\n    if (fromTrainingDataset != null) {\n        tuningDatasetToMldev(fromTrainingDataset);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        createTuningJobConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction createTuningJobParametersPrivateToVertex(fromObject, rootObject) {\n    const toObject = {};\n    const fromBaseModel = getValueByPath(fromObject, ['baseModel']);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, ['baseModel'], fromBaseModel);\n    }\n    const fromPreTunedModel = getValueByPath(fromObject, [\n        'preTunedModel',\n    ]);\n    if (fromPreTunedModel != null) {\n        setValueByPath(toObject, ['preTunedModel'], fromPreTunedModel);\n    }\n    const fromTrainingDataset = getValueByPath(fromObject, [\n        'trainingDataset',\n    ]);\n    if (fromTrainingDataset != null) {\n        tuningDatasetToVertex(fromTrainingDataset, toObject, rootObject);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        createTuningJobConfigToVertex(fromConfig, toObject, rootObject);\n    }\n    return toObject;\n}\nfunction getTuningJobParametersToMldev(fromObject, _rootObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], fromName);\n    }\n    return toObject;\n}\nfunction getTuningJobParametersToVertex(fromObject, _rootObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], fromName);\n    }\n    return toObject;\n}\nfunction listTuningJobsConfigToMldev(fromObject, parentObject, _rootObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, ['pageSize']);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, ['_query', 'pageSize'], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, ['pageToken']);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, ['_query', 'pageToken'], fromPageToken);\n    }\n    const fromFilter = getValueByPath(fromObject, ['filter']);\n    if (parentObject !== undefined && fromFilter != null) {\n        setValueByPath(parentObject, ['_query', 'filter'], fromFilter);\n    }\n    return toObject;\n}\nfunction listTuningJobsConfigToVertex(fromObject, parentObject, _rootObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, ['pageSize']);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, ['_query', 'pageSize'], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, ['pageToken']);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, ['_query', 'pageToken'], fromPageToken);\n    }\n    const fromFilter = getValueByPath(fromObject, ['filter']);\n    if (parentObject !== undefined && fromFilter != null) {\n        setValueByPath(parentObject, ['_query', 'filter'], fromFilter);\n    }\n    return toObject;\n}\nfunction listTuningJobsParametersToMldev(fromObject, rootObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        listTuningJobsConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listTuningJobsParametersToVertex(fromObject, rootObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        listTuningJobsConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listTuningJobsResponseFromMldev(fromObject, rootObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        'nextPageToken',\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, ['nextPageToken'], fromNextPageToken);\n    }\n    const fromTuningJobs = getValueByPath(fromObject, ['tunedModels']);\n    if (fromTuningJobs != null) {\n        let transformedList = fromTuningJobs;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return tuningJobFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, ['tuningJobs'], transformedList);\n    }\n    return toObject;\n}\nfunction listTuningJobsResponseFromVertex(fromObject, rootObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        'nextPageToken',\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, ['nextPageToken'], fromNextPageToken);\n    }\n    const fromTuningJobs = getValueByPath(fromObject, ['tuningJobs']);\n    if (fromTuningJobs != null) {\n        let transformedList = fromTuningJobs;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return tuningJobFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['tuningJobs'], transformedList);\n    }\n    return toObject;\n}\nfunction tunedModelFromMldev(fromObject, _rootObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['name']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['model'], fromModel);\n    }\n    const fromEndpoint = getValueByPath(fromObject, ['name']);\n    if (fromEndpoint != null) {\n        setValueByPath(toObject, ['endpoint'], fromEndpoint);\n    }\n    return toObject;\n}\nfunction tuningDatasetToMldev(fromObject, _rootObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['gcsUri']) !== undefined) {\n        throw new Error('gcsUri parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['vertexDatasetResource']) !== undefined) {\n        throw new Error('vertexDatasetResource parameter is not supported in Gemini API.');\n    }\n    const fromExamples = getValueByPath(fromObject, ['examples']);\n    if (fromExamples != null) {\n        let transformedList = fromExamples;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['examples', 'examples'], transformedList);\n    }\n    return toObject;\n}\nfunction tuningDatasetToVertex(fromObject, parentObject, rootObject) {\n    const toObject = {};\n    let discriminatorGcsUri = getValueByPath(rootObject, [\n        'config',\n        'method',\n    ]);\n    if (discriminatorGcsUri === undefined) {\n        discriminatorGcsUri = 'SUPERVISED_FINE_TUNING';\n    }\n    if (discriminatorGcsUri === 'SUPERVISED_FINE_TUNING') {\n        const fromGcsUri = getValueByPath(fromObject, ['gcsUri']);\n        if (parentObject !== undefined && fromGcsUri != null) {\n            setValueByPath(parentObject, ['supervisedTuningSpec', 'trainingDatasetUri'], fromGcsUri);\n        }\n    }\n    else if (discriminatorGcsUri === 'PREFERENCE_TUNING') {\n        const fromGcsUri = getValueByPath(fromObject, ['gcsUri']);\n        if (parentObject !== undefined && fromGcsUri != null) {\n            setValueByPath(parentObject, ['preferenceOptimizationSpec', 'trainingDatasetUri'], fromGcsUri);\n        }\n    }\n    let discriminatorVertexDatasetResource = getValueByPath(rootObject, [\n        'config',\n        'method',\n    ]);\n    if (discriminatorVertexDatasetResource === undefined) {\n        discriminatorVertexDatasetResource = 'SUPERVISED_FINE_TUNING';\n    }\n    if (discriminatorVertexDatasetResource === 'SUPERVISED_FINE_TUNING') {\n        const fromVertexDatasetResource = getValueByPath(fromObject, [\n            'vertexDatasetResource',\n        ]);\n        if (parentObject !== undefined && fromVertexDatasetResource != null) {\n            setValueByPath(parentObject, ['supervisedTuningSpec', 'trainingDatasetUri'], fromVertexDatasetResource);\n        }\n    }\n    else if (discriminatorVertexDatasetResource === 'PREFERENCE_TUNING') {\n        const fromVertexDatasetResource = getValueByPath(fromObject, [\n            'vertexDatasetResource',\n        ]);\n        if (parentObject !== undefined && fromVertexDatasetResource != null) {\n            setValueByPath(parentObject, ['preferenceOptimizationSpec', 'trainingDatasetUri'], fromVertexDatasetResource);\n        }\n    }\n    if (getValueByPath(fromObject, ['examples']) !== undefined) {\n        throw new Error('examples parameter is not supported in Vertex AI.');\n    }\n    return toObject;\n}\nfunction tuningJobFromMldev(fromObject, rootObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromState = getValueByPath(fromObject, ['state']);\n    if (fromState != null) {\n        setValueByPath(toObject, ['state'], tTuningJobStatus(fromState));\n    }\n    const fromCreateTime = getValueByPath(fromObject, ['createTime']);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, ['createTime'], fromCreateTime);\n    }\n    const fromStartTime = getValueByPath(fromObject, [\n        'tuningTask',\n        'startTime',\n    ]);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, ['startTime'], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, [\n        'tuningTask',\n        'completeTime',\n    ]);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, ['endTime'], fromEndTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, ['updateTime']);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, ['updateTime'], fromUpdateTime);\n    }\n    const fromDescription = getValueByPath(fromObject, ['description']);\n    if (fromDescription != null) {\n        setValueByPath(toObject, ['description'], fromDescription);\n    }\n    const fromBaseModel = getValueByPath(fromObject, ['baseModel']);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, ['baseModel'], fromBaseModel);\n    }\n    const fromTunedModel = getValueByPath(fromObject, ['_self']);\n    if (fromTunedModel != null) {\n        setValueByPath(toObject, ['tunedModel'], tunedModelFromMldev(fromTunedModel));\n    }\n    return toObject;\n}\nfunction tuningJobFromVertex(fromObject, _rootObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromState = getValueByPath(fromObject, ['state']);\n    if (fromState != null) {\n        setValueByPath(toObject, ['state'], tTuningJobStatus(fromState));\n    }\n    const fromCreateTime = getValueByPath(fromObject, ['createTime']);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, ['createTime'], fromCreateTime);\n    }\n    const fromStartTime = getValueByPath(fromObject, ['startTime']);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, ['startTime'], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, ['endTime']);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, ['endTime'], fromEndTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, ['updateTime']);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, ['updateTime'], fromUpdateTime);\n    }\n    const fromError = getValueByPath(fromObject, ['error']);\n    if (fromError != null) {\n        setValueByPath(toObject, ['error'], fromError);\n    }\n    const fromDescription = getValueByPath(fromObject, ['description']);\n    if (fromDescription != null) {\n        setValueByPath(toObject, ['description'], fromDescription);\n    }\n    const fromBaseModel = getValueByPath(fromObject, ['baseModel']);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, ['baseModel'], fromBaseModel);\n    }\n    const fromTunedModel = getValueByPath(fromObject, ['tunedModel']);\n    if (fromTunedModel != null) {\n        setValueByPath(toObject, ['tunedModel'], fromTunedModel);\n    }\n    const fromPreTunedModel = getValueByPath(fromObject, [\n        'preTunedModel',\n    ]);\n    if (fromPreTunedModel != null) {\n        setValueByPath(toObject, ['preTunedModel'], fromPreTunedModel);\n    }\n    const fromSupervisedTuningSpec = getValueByPath(fromObject, [\n        'supervisedTuningSpec',\n    ]);\n    if (fromSupervisedTuningSpec != null) {\n        setValueByPath(toObject, ['supervisedTuningSpec'], fromSupervisedTuningSpec);\n    }\n    const fromPreferenceOptimizationSpec = getValueByPath(fromObject, [\n        'preferenceOptimizationSpec',\n    ]);\n    if (fromPreferenceOptimizationSpec != null) {\n        setValueByPath(toObject, ['preferenceOptimizationSpec'], fromPreferenceOptimizationSpec);\n    }\n    const fromTuningDataStats = getValueByPath(fromObject, [\n        'tuningDataStats',\n    ]);\n    if (fromTuningDataStats != null) {\n        setValueByPath(toObject, ['tuningDataStats'], fromTuningDataStats);\n    }\n    const fromEncryptionSpec = getValueByPath(fromObject, [\n        'encryptionSpec',\n    ]);\n    if (fromEncryptionSpec != null) {\n        setValueByPath(toObject, ['encryptionSpec'], fromEncryptionSpec);\n    }\n    const fromPartnerModelTuningSpec = getValueByPath(fromObject, [\n        'partnerModelTuningSpec',\n    ]);\n    if (fromPartnerModelTuningSpec != null) {\n        setValueByPath(toObject, ['partnerModelTuningSpec'], fromPartnerModelTuningSpec);\n    }\n    const fromCustomBaseModel = getValueByPath(fromObject, [\n        'customBaseModel',\n    ]);\n    if (fromCustomBaseModel != null) {\n        setValueByPath(toObject, ['customBaseModel'], fromCustomBaseModel);\n    }\n    const fromExperiment = getValueByPath(fromObject, ['experiment']);\n    if (fromExperiment != null) {\n        setValueByPath(toObject, ['experiment'], fromExperiment);\n    }\n    const fromLabels = getValueByPath(fromObject, ['labels']);\n    if (fromLabels != null) {\n        setValueByPath(toObject, ['labels'], fromLabels);\n    }\n    const fromOutputUri = getValueByPath(fromObject, ['outputUri']);\n    if (fromOutputUri != null) {\n        setValueByPath(toObject, ['outputUri'], fromOutputUri);\n    }\n    const fromPipelineJob = getValueByPath(fromObject, ['pipelineJob']);\n    if (fromPipelineJob != null) {\n        setValueByPath(toObject, ['pipelineJob'], fromPipelineJob);\n    }\n    const fromServiceAccount = getValueByPath(fromObject, [\n        'serviceAccount',\n    ]);\n    if (fromServiceAccount != null) {\n        setValueByPath(toObject, ['serviceAccount'], fromServiceAccount);\n    }\n    const fromTunedModelDisplayName = getValueByPath(fromObject, [\n        'tunedModelDisplayName',\n    ]);\n    if (fromTunedModelDisplayName != null) {\n        setValueByPath(toObject, ['tunedModelDisplayName'], fromTunedModelDisplayName);\n    }\n    const fromVeoTuningSpec = getValueByPath(fromObject, [\n        'veoTuningSpec',\n    ]);\n    if (fromVeoTuningSpec != null) {\n        setValueByPath(toObject, ['veoTuningSpec'], fromVeoTuningSpec);\n    }\n    return toObject;\n}\nfunction tuningOperationFromMldev(fromObject, _rootObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, ['metadata']);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, ['metadata'], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, ['done']);\n    if (fromDone != null) {\n        setValueByPath(toObject, ['done'], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, ['error']);\n    if (fromError != null) {\n        setValueByPath(toObject, ['error'], fromError);\n    }\n    return toObject;\n}\nfunction tuningValidationDatasetToVertex(fromObject, _rootObject) {\n    const toObject = {};\n    const fromGcsUri = getValueByPath(fromObject, ['gcsUri']);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, ['validationDatasetUri'], fromGcsUri);\n    }\n    const fromVertexDatasetResource = getValueByPath(fromObject, [\n        'vertexDatasetResource',\n    ]);\n    if (fromVertexDatasetResource != null) {\n        setValueByPath(toObject, ['validationDatasetUri'], fromVertexDatasetResource);\n    }\n    return toObject;\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nclass Tunings extends BaseModule {\n    constructor(apiClient) {\n        super();\n        this.apiClient = apiClient;\n        /**\n         * Gets a TuningJob.\n         *\n         * @param name - The resource name of the tuning job.\n         * @return - A TuningJob object.\n         *\n         * @experimental - The SDK's tuning implementation is experimental, and may\n         * change in future versions.\n         */\n        this.get = async (params) => {\n            return await this.getInternal(params);\n        };\n        /**\n         * Lists tuning jobs.\n         *\n         * @param config - The configuration for the list request.\n         * @return - A list of tuning jobs.\n         *\n         * @experimental - The SDK's tuning implementation is experimental, and may\n         * change in future versions.\n         */\n        this.list = async (params = {}) => {\n            return new Pager(PagedItem.PAGED_ITEM_TUNING_JOBS, (x) => this.listInternal(x), await this.listInternal(params), params);\n        };\n        /**\n         * Creates a supervised fine-tuning job.\n         *\n         * @param params - The parameters for the tuning job.\n         * @return - A TuningJob operation.\n         *\n         * @experimental - The SDK's tuning implementation is experimental, and may\n         * change in future versions.\n         */\n        this.tune = async (params) => {\n            var _a;\n            if (this.apiClient.isVertexAI()) {\n                if (params.baseModel.startsWith('projects/')) {\n                    const preTunedModel = {\n                        tunedModelName: params.baseModel,\n                    };\n                    if ((_a = params.config) === null || _a === void 0 ? void 0 : _a.preTunedModelCheckpointId) {\n                        preTunedModel.checkpointId = params.config.preTunedModelCheckpointId;\n                    }\n                    const paramsPrivate = Object.assign(Object.assign({}, params), { preTunedModel: preTunedModel });\n                    paramsPrivate.baseModel = undefined;\n                    return await this.tuneInternal(paramsPrivate);\n                }\n                else {\n                    const paramsPrivate = Object.assign({}, params);\n                    return await this.tuneInternal(paramsPrivate);\n                }\n            }\n            else {\n                const paramsPrivate = Object.assign({}, params);\n                const operation = await this.tuneMldevInternal(paramsPrivate);\n                let tunedModelName = '';\n                if (operation['metadata'] !== undefined &&\n                    operation['metadata']['tunedModel'] !== undefined) {\n                    tunedModelName = operation['metadata']['tunedModel'];\n                }\n                else if (operation['name'] !== undefined &&\n                    operation['name'].includes('/operations/')) {\n                    tunedModelName = operation['name'].split('/operations/')[0];\n                }\n                const tuningJob = {\n                    name: tunedModelName,\n                    state: JobState.JOB_STATE_QUEUED,\n                };\n                return tuningJob;\n            }\n        };\n    }\n    async getInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = getTuningJobParametersToVertex(params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = tuningJobFromVertex(apiResponse);\n                return resp;\n            });\n        }\n        else {\n            const body = getTuningJobParametersToMldev(params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = tuningJobFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    async listInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = listTuningJobsParametersToVertex(params);\n            path = formatMap('tuningJobs', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = listTuningJobsResponseFromVertex(apiResponse);\n                const typedResp = new ListTuningJobsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            const body = listTuningJobsParametersToMldev(params);\n            path = formatMap('tunedModels', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = listTuningJobsResponseFromMldev(apiResponse);\n                const typedResp = new ListTuningJobsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Cancels a tuning job.\n     *\n     * @param params - The parameters for the cancel request.\n     * @return The empty response returned by the API.\n     *\n     * @example\n     * ```ts\n     * await ai.tunings.cancel({name: '...'}); // The server-generated resource name.\n     * ```\n     */\n    async cancel(params) {\n        var _a, _b, _c, _d;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = cancelTuningJobParametersToVertex(params);\n            path = formatMap('{name}:cancel', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            await this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            });\n        }\n        else {\n            const body = cancelTuningJobParametersToMldev(params);\n            path = formatMap('{name}:cancel', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            await this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            });\n        }\n    }\n    async tuneInternal(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = createTuningJobParametersPrivateToVertex(params, params);\n            path = formatMap('tuningJobs', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = tuningJobFromVertex(apiResponse);\n                return resp;\n            });\n        }\n        else {\n            throw new Error('This method is only supported by the Vertex AI.');\n        }\n    }\n    async tuneMldevInternal(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error('This method is only supported by the Gemini Developer API.');\n        }\n        else {\n            const body = createTuningJobParametersPrivateToMldev(params);\n            path = formatMap('tunedModels', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = tuningOperationFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n}\n\nconst MAX_CHUNK_SIZE = 1024 * 1024 * 8; // bytes\nconst MAX_RETRY_COUNT = 3;\nconst INITIAL_RETRY_DELAY_MS = 1000;\nconst DELAY_MULTIPLIER = 2;\nconst X_GOOG_UPLOAD_STATUS_HEADER_FIELD = 'x-goog-upload-status';\nasync function uploadBlob(file, uploadUrl, apiClient) {\n    var _a;\n    const response = await uploadBlobInternal(file, uploadUrl, apiClient);\n    const responseJson = (await (response === null || response === void 0 ? void 0 : response.json()));\n    if (((_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== 'final') {\n        throw new Error('Failed to upload file: Upload status is not finalized.');\n    }\n    return responseJson['file'];\n}\nasync function uploadBlobToFileSearchStore(file, uploadUrl, apiClient) {\n    var _a;\n    const response = await uploadBlobInternal(file, uploadUrl, apiClient);\n    const responseJson = (await (response === null || response === void 0 ? void 0 : response.json()));\n    if (((_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== 'final') {\n        throw new Error('Failed to upload file: Upload status is not finalized.');\n    }\n    const resp = uploadToFileSearchStoreOperationFromMldev(responseJson);\n    const typedResp = new UploadToFileSearchStoreOperation();\n    Object.assign(typedResp, resp);\n    return typedResp;\n}\nasync function uploadBlobInternal(file, uploadUrl, apiClient) {\n    var _a, _b;\n    let fileSize = 0;\n    let offset = 0;\n    let response = new HttpResponse(new Response());\n    let uploadCommand = 'upload';\n    fileSize = file.size;\n    while (offset < fileSize) {\n        const chunkSize = Math.min(MAX_CHUNK_SIZE, fileSize - offset);\n        const chunk = file.slice(offset, offset + chunkSize);\n        if (offset + chunkSize >= fileSize) {\n            uploadCommand += ', finalize';\n        }\n        let retryCount = 0;\n        let currentDelayMs = INITIAL_RETRY_DELAY_MS;\n        while (retryCount < MAX_RETRY_COUNT) {\n            response = await apiClient.request({\n                path: '',\n                body: chunk,\n                httpMethod: 'POST',\n                httpOptions: {\n                    apiVersion: '',\n                    baseUrl: uploadUrl,\n                    headers: {\n                        'X-Goog-Upload-Command': uploadCommand,\n                        'X-Goog-Upload-Offset': String(offset),\n                        'Content-Length': String(chunkSize),\n                    },\n                },\n            });\n            if ((_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) {\n                break;\n            }\n            retryCount++;\n            await sleep(currentDelayMs);\n            currentDelayMs = currentDelayMs * DELAY_MULTIPLIER;\n        }\n        offset += chunkSize;\n        // The `x-goog-upload-status` header field can be `active`, `final` and\n        //`cancelled` in resposne.\n        if (((_b = response === null || response === void 0 ? void 0 : response.headers) === null || _b === void 0 ? void 0 : _b[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== 'active') {\n            break;\n        }\n        // TODO(b/401391430) Investigate why the upload status is not finalized\n        // even though all content has been uploaded.\n        if (fileSize <= offset) {\n            throw new Error('All content has been uploaded, but the upload status is not finalized.');\n        }\n    }\n    return response;\n}\nasync function getBlobStat(file) {\n    const fileStat = { size: file.size, type: file.type };\n    return fileStat;\n}\nfunction sleep(ms) {\n    return new Promise((resolvePromise) => setTimeout(resolvePromise, ms));\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nclass NodeUploader {\n    async stat(file) {\n        const fileStat = { size: 0, type: undefined };\n        if (typeof file === 'string') {\n            const originalStat = await fs_promises__WEBPACK_IMPORTED_MODULE_2__.stat(file);\n            fileStat.size = originalStat.size;\n            fileStat.type = this.inferMimeType(file);\n            return fileStat;\n        }\n        else {\n            return await getBlobStat(file);\n        }\n    }\n    async upload(file, uploadUrl, apiClient) {\n        if (typeof file === 'string') {\n            return await this.uploadFileFromPath(file, uploadUrl, apiClient);\n        }\n        else {\n            return uploadBlob(file, uploadUrl, apiClient);\n        }\n    }\n    async uploadToFileSearchStore(file, uploadUrl, apiClient) {\n        if (typeof file === 'string') {\n            return await this.uploadFileToFileSearchStoreFromPath(file, uploadUrl, apiClient);\n        }\n        else {\n            return uploadBlobToFileSearchStore(file, uploadUrl, apiClient);\n        }\n    }\n    /**\n     * Infers the MIME type of a file based on its extension.\n     *\n     * @param filePath The path to the file.\n     * @returns The MIME type of the file, or undefined if it cannot be inferred.\n     */\n    inferMimeType(filePath) {\n        // Get the file extension.\n        const fileExtension = filePath.slice(filePath.lastIndexOf('.') + 1);\n        // Create a map of file extensions to MIME types.\n        const mimeTypes = {\n            'aac': 'audio/aac',\n            'abw': 'application/x-abiword',\n            'arc': 'application/x-freearc',\n            'avi': 'video/x-msvideo',\n            'azw': 'application/vnd.amazon.ebook',\n            'bin': 'application/octet-stream',\n            'bmp': 'image/bmp',\n            'bz': 'application/x-bzip',\n            'bz2': 'application/x-bzip2',\n            'csh': 'application/x-csh',\n            'css': 'text/css',\n            'csv': 'text/csv',\n            'doc': 'application/msword',\n            'docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n            'eot': 'application/vnd.ms-fontobject',\n            'epub': 'application/epub+zip',\n            'gz': 'application/gzip',\n            'gif': 'image/gif',\n            'htm': 'text/html',\n            'html': 'text/html',\n            'ico': 'image/vnd.microsoft.icon',\n            'ics': 'text/calendar',\n            'jar': 'application/java-archive',\n            'jpeg': 'image/jpeg',\n            'jpg': 'image/jpeg',\n            'js': 'text/javascript',\n            'json': 'application/json',\n            'jsonld': 'application/ld+json',\n            'kml': 'application/vnd.google-earth.kml+xml',\n            'kmz': 'application/vnd.google-earth.kmz+xml',\n            'mjs': 'text/javascript',\n            'mp3': 'audio/mpeg',\n            'mp4': 'video/mp4',\n            'mpeg': 'video/mpeg',\n            'mpkg': 'application/vnd.apple.installer+xml',\n            'odt': 'application/vnd.oasis.opendocument.text',\n            'oga': 'audio/ogg',\n            'ogv': 'video/ogg',\n            'ogx': 'application/ogg',\n            'opus': 'audio/opus',\n            'otf': 'font/otf',\n            'png': 'image/png',\n            'pdf': 'application/pdf',\n            'php': 'application/x-httpd-php',\n            'ppt': 'application/vnd.ms-powerpoint',\n            'pptx': 'application/vnd.openxmlformats-officedocument.presentationml.presentation',\n            'rar': 'application/vnd.rar',\n            'rtf': 'application/rtf',\n            'sh': 'application/x-sh',\n            'svg': 'image/svg+xml',\n            'swf': 'application/x-shockwave-flash',\n            'tar': 'application/x-tar',\n            'tif': 'image/tiff',\n            'tiff': 'image/tiff',\n            'ts': 'video/mp2t',\n            'ttf': 'font/ttf',\n            'txt': 'text/plain',\n            'vsd': 'application/vnd.visio',\n            'wav': 'audio/wav',\n            'weba': 'audio/webm',\n            'webm': 'video/webm',\n            'webp': 'image/webp',\n            'woff': 'font/woff',\n            'woff2': 'font/woff2',\n            'xhtml': 'application/xhtml+xml',\n            'xls': 'application/vnd.ms-excel',\n            'xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n            'xml': 'application/xml',\n            'xul': 'application/vnd.mozilla.xul+xml',\n            'zip': 'application/zip',\n            '3gp': 'video/3gpp',\n            '3g2': 'video/3gpp2',\n            '7z': 'application/x-7z-compressed',\n        };\n        // Look up the MIME type based on the file extension.\n        const mimeType = mimeTypes[fileExtension.toLowerCase()];\n        // Return the MIME type.\n        return mimeType;\n    }\n    async uploadFileFromPath(file, uploadUrl, apiClient) {\n        var _a;\n        const response = await this.uploadFileFromPathInternal(file, uploadUrl, apiClient);\n        const responseJson = (await (response === null || response === void 0 ? void 0 : response.json()));\n        if (((_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== 'final') {\n            throw new Error('Failed to upload file: Upload status is not finalized.');\n        }\n        return responseJson['file'];\n    }\n    async uploadFileToFileSearchStoreFromPath(file, uploadUrl, apiClient) {\n        var _a;\n        const response = await this.uploadFileFromPathInternal(file, uploadUrl, apiClient);\n        const responseJson = (await (response === null || response === void 0 ? void 0 : response.json()));\n        if (((_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== 'final') {\n            throw new Error('Failed to upload file: Upload status is not finalized.');\n        }\n        const resp = uploadToFileSearchStoreOperationFromMldev(responseJson);\n        const typedResp = new UploadToFileSearchStoreOperation();\n        Object.assign(typedResp, resp);\n        return typedResp;\n    }\n    async uploadFileFromPathInternal(file, uploadUrl, apiClient) {\n        var _a, _b;\n        let fileSize = 0;\n        let offset = 0;\n        let response = new HttpResponse(new Response());\n        let uploadCommand = 'upload';\n        let fileHandle;\n        const fileName = path__WEBPACK_IMPORTED_MODULE_6__.basename(file);\n        try {\n            fileHandle = await fs_promises__WEBPACK_IMPORTED_MODULE_2__.open(file, 'r');\n            if (!fileHandle) {\n                throw new Error(`Failed to open file`);\n            }\n            fileSize = (await fileHandle.stat()).size;\n            while (offset < fileSize) {\n                const chunkSize = Math.min(MAX_CHUNK_SIZE, fileSize - offset);\n                if (offset + chunkSize >= fileSize) {\n                    uploadCommand += ', finalize';\n                }\n                const buffer = new Uint8Array(chunkSize);\n                const { bytesRead: bytesRead } = await fileHandle.read(buffer, 0, chunkSize, offset);\n                if (bytesRead !== chunkSize) {\n                    throw new Error(`Failed to read ${chunkSize} bytes from file at offset ${offset}. bytes actually read: ${bytesRead}`);\n                }\n                const chunk = new Blob([buffer]);\n                let retryCount = 0;\n                let currentDelayMs = INITIAL_RETRY_DELAY_MS;\n                while (retryCount < MAX_RETRY_COUNT) {\n                    response = await apiClient.request({\n                        path: '',\n                        body: chunk,\n                        httpMethod: 'POST',\n                        httpOptions: {\n                            apiVersion: '',\n                            baseUrl: uploadUrl,\n                            headers: {\n                                'X-Goog-Upload-Command': uploadCommand,\n                                'X-Goog-Upload-Offset': String(offset),\n                                'Content-Length': String(bytesRead),\n                                'X-Goog-Upload-File-Name': fileName,\n                            },\n                        },\n                    });\n                    if ((_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) {\n                        break;\n                    }\n                    retryCount++;\n                    await sleep(currentDelayMs);\n                    currentDelayMs = currentDelayMs * DELAY_MULTIPLIER;\n                }\n                offset += bytesRead;\n                // The `x-goog-upload-status` header field can be `active`, `final` and\n                //`cancelled` in resposne.\n                if (((_b = response === null || response === void 0 ? void 0 : response.headers) === null || _b === void 0 ? void 0 : _b[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== 'active') {\n                    break;\n                }\n                if (fileSize <= offset) {\n                    throw new Error('All content has been uploaded, but the upload status is not finalized.');\n                }\n            }\n            return response;\n        }\n        finally {\n            // Ensure the file handle is always closed\n            if (fileHandle) {\n                await fileHandle.close();\n            }\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst LANGUAGE_LABEL_PREFIX = 'gl-node/';\n/**\n * The Google GenAI SDK.\n *\n * @remarks\n * Provides access to the GenAI features through either the {@link\n * https://cloud.google.com/vertex-ai/docs/reference/rest | Gemini API} or\n * the {@link https://cloud.google.com/vertex-ai/docs/reference/rest | Vertex AI\n * API}.\n *\n * The {@link GoogleGenAIOptions.vertexai} value determines which of the API\n * services to use.\n *\n * When using the Gemini API, a {@link GoogleGenAIOptions.apiKey} must also be\n * set. When using Vertex AI, both {@link GoogleGenAIOptions.project} and {@link\n * GoogleGenAIOptions.location} must be set, or a {@link\n * GoogleGenAIOptions.apiKey} must be set when using Express Mode.\n *\n * Explicitly passed in values in {@link GoogleGenAIOptions} will always take\n * precedence over environment variables. If both project/location and api_key\n * exist in the environment variables, the project/location will be used.\n *\n * @example\n * Initializing the SDK for using the Gemini API:\n * ```ts\n * import {GoogleGenAI} from '@google/genai';\n * const ai = new GoogleGenAI({apiKey: 'GEMINI_API_KEY'});\n * ```\n *\n * @example\n * Initializing the SDK for using the Vertex AI API:\n * ```ts\n * import {GoogleGenAI} from '@google/genai';\n * const ai = new GoogleGenAI({\n *   vertexai: true,\n *   project: 'PROJECT_ID',\n *   location: 'PROJECT_LOCATION'\n * });\n * ```\n *\n */\nclass GoogleGenAI {\n    constructor(options) {\n        var _a, _b, _c, _d, _e, _f;\n        // Validate explicitly set initializer values.\n        if ((options.project || options.location) && options.apiKey) {\n            throw new Error('Project/location and API key are mutually exclusive in the client initializer.');\n        }\n        this.vertexai =\n            (_b = (_a = options.vertexai) !== null && _a !== void 0 ? _a : getBooleanEnv('GOOGLE_GENAI_USE_VERTEXAI')) !== null && _b !== void 0 ? _b : false;\n        const envApiKey = getApiKeyFromEnv();\n        const envProject = getEnv('GOOGLE_CLOUD_PROJECT');\n        const envLocation = getEnv('GOOGLE_CLOUD_LOCATION');\n        this.apiKey = (_c = options.apiKey) !== null && _c !== void 0 ? _c : envApiKey;\n        this.project = (_d = options.project) !== null && _d !== void 0 ? _d : envProject;\n        this.location = (_e = options.location) !== null && _e !== void 0 ? _e : envLocation;\n        // Handle when to use Vertex AI in express mode (api key)\n        if (options.vertexai) {\n            if ((_f = options.googleAuthOptions) === null || _f === void 0 ? void 0 : _f.credentials) {\n                // Explicit credentials take precedence over implicit api_key.\n                console.debug('The user provided Google Cloud credentials will take precedence' +\n                    ' over the API key from the environment variable.');\n                this.apiKey = undefined;\n            }\n            // Explicit api_key and explicit project/location already handled above.\n            if ((envProject || envLocation) && options.apiKey) {\n                // Explicit api_key takes precedence over implicit project/location.\n                console.debug('The user provided Vertex AI API key will take precedence over' +\n                    ' the project/location from the environment variables.');\n                this.project = undefined;\n                this.location = undefined;\n            }\n            else if ((options.project || options.location) && envApiKey) {\n                // Explicit project/location takes precedence over implicit api_key.\n                console.debug('The user provided project/location will take precedence over' +\n                    ' the API key from the environment variables.');\n                this.apiKey = undefined;\n            }\n            else if ((envProject || envLocation) && envApiKey) {\n                // Implicit project/location takes precedence over implicit api_key.\n                console.debug('The project/location from the environment variables will take' +\n                    ' precedence over the API key from the environment variables.');\n                this.apiKey = undefined;\n            }\n            if (!this.location && !this.apiKey) {\n                this.location = 'global';\n            }\n        }\n        const baseUrl = getBaseUrl(options.httpOptions, options.vertexai, getEnv('GOOGLE_VERTEX_BASE_URL'), getEnv('GOOGLE_GEMINI_BASE_URL'));\n        if (baseUrl) {\n            if (options.httpOptions) {\n                options.httpOptions.baseUrl = baseUrl;\n            }\n            else {\n                options.httpOptions = { baseUrl: baseUrl };\n            }\n        }\n        this.apiVersion = options.apiVersion;\n        const auth = new NodeAuth({\n            apiKey: this.apiKey,\n            googleAuthOptions: options.googleAuthOptions,\n        });\n        this.apiClient = new ApiClient({\n            auth: auth,\n            project: this.project,\n            location: this.location,\n            apiVersion: this.apiVersion,\n            apiKey: this.apiKey,\n            vertexai: this.vertexai,\n            httpOptions: options.httpOptions,\n            userAgentExtra: LANGUAGE_LABEL_PREFIX + process.version,\n            uploader: new NodeUploader(),\n            downloader: new NodeDownloader(),\n        });\n        this.models = new Models(this.apiClient);\n        this.live = new Live(this.apiClient, auth, new NodeWebSocketFactory());\n        this.batches = new Batches(this.apiClient);\n        this.chats = new Chats(this.models, this.apiClient);\n        this.caches = new Caches(this.apiClient);\n        this.files = new Files(this.apiClient);\n        this.operations = new Operations(this.apiClient);\n        this.authTokens = new Tokens(this.apiClient);\n        this.tunings = new Tunings(this.apiClient);\n        this.fileSearchStores = new FileSearchStores(this.apiClient);\n    }\n}\nfunction getEnv(env) {\n    var _a, _b, _c;\n    return (_c = (_b = (_a = process === null || process === void 0 ? void 0 : process.env) === null || _a === void 0 ? void 0 : _a[env]) === null || _b === void 0 ? void 0 : _b.trim()) !== null && _c !== void 0 ? _c : undefined;\n}\nfunction getBooleanEnv(env) {\n    return stringToBoolean(getEnv(env));\n}\nfunction stringToBoolean(str) {\n    if (str === undefined) {\n        return false;\n    }\n    return str.toLowerCase() === 'true';\n}\nfunction getApiKeyFromEnv() {\n    const envGoogleApiKey = getEnv('GOOGLE_API_KEY');\n    const envGeminiApiKey = getEnv('GEMINI_API_KEY');\n    if (envGoogleApiKey && envGeminiApiKey) {\n        console.warn('Both GOOGLE_API_KEY and GEMINI_API_KEY are set. Using GOOGLE_API_KEY.');\n    }\n    return envGoogleApiKey || envGeminiApiKey || undefined;\n}\n\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdvb2dsZS9nZW5haS9kaXN0L25vZGUvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWlEO0FBQ1Y7QUFDTDtBQUNNO0FBQ0Q7QUFDUztBQUNuQjtBQUNBOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQ0FBaUM7QUFDNUM7QUFDQSx1QkFBdUIsc0NBQXNDO0FBQzdEO0FBQ0E7QUFDQSx1QkFBdUIsNkNBQTZDO0FBQ3BFO0FBQ0EsK0JBQStCLHlCQUF5QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsSUFBSSxLQUFLO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxJQUFJO0FBQ3hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsc0JBQXNCLFdBQVc7QUFDbEY7QUFDQTtBQUNBLGdGQUFnRixJQUFJO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msc0JBQXNCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsU0FBUztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxjQUFjLGNBQWMsR0FBRyxjQUFjLEVBQUU7QUFDdkQsUUFBUTtBQUNSO0FBQ0EsV0FBVyxjQUFjLFlBQVksZUFBZSxHQUFHLFlBQVksZUFBZTtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MscUJBQXFCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMEJBQTBCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRCQUE0QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0VBQWdFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9CQUFvQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQkFBb0I7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQkFBMEI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRCQUE0QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtEQUFrRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0RBQWtEO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0NBQXNDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9DQUFvQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBDQUEwQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdEQUFnRDtBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9DQUFvQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQ0FBMEM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0NBQW9DO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdEQUFnRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQ0FBc0M7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQ0FBa0M7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRCQUE0QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMENBQTBDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0NBQWdDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQ0FBa0M7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0QkFBNEI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdDQUFnQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNERBQTREO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnRUFBZ0U7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0QkFBNEI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0VBQWdFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtDQUFrQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4REFBOEQ7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhDQUE4QztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRDQUE0QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrREFBa0Q7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOENBQThDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvREFBb0Q7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9EQUFvRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0QkFBNEI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0NBQWtDO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9FQUFvRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwREFBMEQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBEQUEwRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQ0FBb0M7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNDQUFzQztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0NBQWdDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnREFBZ0Q7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQ0FBc0M7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0Q0FBNEM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3Q0FBd0M7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0Q0FBNEM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQ0FBb0M7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNCQUFzQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0RBQWtEO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0REFBNEQ7QUFDN0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSxXQUFXLHdCQUF3QixtQkFBbUIsMEJBQTBCO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsd0NBQXdDLHlCQUF5QixPQUFPO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsV0FBVyx3QkFBd0IsbUJBQW1CLDBCQUEwQjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGNBQWM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGNBQWM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHdEQUF3RDtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixjQUFjO0FBQ2QsWUFBWTtBQUNaLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDLFVBQVU7QUFDVixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QyxVQUFVO0FBQ1YsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDJCQUEyQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMkJBQTJCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGNBQWM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGNBQWM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwyQkFBMkI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxTQUFTLFVBQVUsU0FBUztBQUM3RDtBQUNBO0FBQ0EsK0NBQStDLE1BQU07QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsTUFBTTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix1QkFBdUIsYUFBYSx3QkFBd0IsR0FBRyxpQkFBaUI7QUFDM0c7QUFDQTtBQUNBLDJCQUEyQix1QkFBdUIsYUFBYSx3QkFBd0IscUJBQXFCLGlCQUFpQjtBQUM3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLFlBQVk7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMseUJBQXlCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHlCQUF5QjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwrQ0FBK0M7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRyxTQUFTLGVBQWUsR0FBRyxlQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixTQUFTLGFBQWEsR0FBRyxlQUFlLEVBQUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixhQUFhO0FBQzlCO0FBQ0E7QUFDQSwwQkFBMEIsZUFBZTtBQUN6QyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsMERBQTBELG9CQUFvQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxlQUFlO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixvQkFBb0IsR0FBRyxhQUFhO0FBQ25FO0FBQ0EsNENBQTRDLGVBQWU7QUFDM0QsK0JBQStCLG9CQUFvQixhQUFhLHFCQUFxQixHQUFHLGFBQWE7QUFDckc7QUFDQTtBQUNBLCtCQUErQixvQkFBb0IsYUFBYSxxQkFBcUIsR0FBRyxlQUFlLEdBQUcsYUFBYTtBQUN2SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZUFBZSxHQUFHLGFBQWE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLEtBQUs7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsYUFBYTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSw0RUFBNEUsSUFBSTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGlCQUFpQjtBQUMvQztBQUNBO0FBQ0EsNkVBQTZFLElBQUk7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsV0FBVztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFdBQVc7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsV0FBVztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx3Q0FBd0M7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0tBQWdLO0FBQ2hLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4QkFBOEI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxTQUFTLGNBQWM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsYUFBYTtBQUNiO0FBQ0EseUJBQXlCO0FBQ3pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsU0FBUyxjQUFjO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDBEQUEwRDtBQUM3RTtBQUNBLHNCQUFzQiw2REFBNkQ7QUFDbkY7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFDQUFxQztBQUN4RCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFNBQVMsZUFBZTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsTUFBTTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQSxxREFBcUQsYUFBYTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxvQkFBb0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU8sUUFBUSxhQUFhO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxZQUFZLFFBQVEsYUFBYTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE1BQU07QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixNQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsWUFBWSxHQUFHO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxLQUFLO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLEtBQUs7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxZQUFZLEdBQUc7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxLQUFLO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxLQUFLO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsWUFBWSxHQUFHO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxLQUFLO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsS0FBSztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsU0FBUyxlQUFlO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixZQUFZLEdBQUc7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsWUFBWSxHQUFHO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixLQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixLQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixLQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsME1BQTBNLGNBQWM7QUFDeE4sOEJBQThCLHNCQUFzQjtBQUNwRCwwQkFBMEIsWUFBWSxzQkFBc0IscUNBQXFDLDJDQUEyQyxNQUFNO0FBQ2xKLDRCQUE0QixNQUFNLGlCQUFpQixZQUFZO0FBQy9ELHVCQUF1QjtBQUN2Qiw4QkFBOEI7QUFDOUIsNkJBQTZCO0FBQzdCLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkdBQTJHLHVGQUF1RixjQUFjO0FBQ2hOLHVCQUF1Qiw4QkFBOEIsZ0RBQWdELHdEQUF3RDtBQUM3Siw2Q0FBNkMsc0NBQXNDLFVBQVUsbUJBQW1CLElBQUk7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHlDQUF5QztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw4QkFBOEI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQywwQkFBMEI7QUFDL0Q7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsd0JBQXdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsMEJBQTBCO0FBQy9EO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBHQUEwRyxnR0FBZ0c7QUFDMU07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsU0FBUyxnQkFBZ0I7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix5Q0FBeUM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMENBQTBDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxLQUFLO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixnQkFBZ0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLEtBQUs7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QiwwQ0FBMEMsWUFBWTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxXQUFXLDhGQUE4RjtBQUNwSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNEJBQTRCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDJCQUEyQixhQUFhLDRCQUE0QjtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHFCQUFxQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxrQkFBa0Isb0JBQW9CO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMEVBQTBFLGtCQUFrQixvQkFBb0I7QUFDaEg7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxjQUFjO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLE9BQU8sSUFBSSwwQkFBMEI7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSxxQkFBcUIsSUFBSSxFQUFFO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxHQUFHO0FBQzVDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsa0JBQWtCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxvQkFBb0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsdUpBQXVKLFVBQVUsMkNBQTJDLFNBQVMsR0FBRyxnQkFBZ0Isc0NBQXNDLElBQUk7QUFDM1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0dBQXdHLElBQUksb0JBQW9CLG1CQUFtQixjQUFjLG1CQUFtQjtBQUNwTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELFVBQVU7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsUUFBUTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUdBQXFHLHlDQUF5QztBQUM5STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsYUFBYTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7QUFDWixVQUFVO0FBQ1YsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpQkFBaUIsbUNBQW1DLFdBQVcsMkNBQTJDLE9BQU87QUFDeEk7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGVBQWU7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaLFVBQVU7QUFDVixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlCQUFpQiw4QkFBOEIsV0FBVztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3SUFBd0ksbUNBQW1DLHdCQUF3QixHQUFHO0FBQ3RNO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlCQUFpQixtQ0FBbUMsV0FBVyxxQkFBcUIsT0FBTyxHQUFHLFFBQVEsR0FBRyxPQUFPO0FBQ3JJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVEsYUFBYSxTQUFTO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRixvQkFBb0I7QUFDdEc7QUFDQTtBQUNBLGlDQUFpQyxvREFBb0Q7QUFDckY7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG1DQUFtQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsd0JBQXdCO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzQ0FBc0M7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGVBQWU7QUFDekM7QUFDQSw2QkFBNkIsa0JBQWtCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIscUJBQXFCO0FBQzVDLHVCQUF1QixxQkFBcUI7QUFDNUM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUNBQXFDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxNQUFNO0FBQ25EO0FBQ0EsbUxBQW1MLGlCQUFpQjtBQUNwTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxNQUFNO0FBQ25EO0FBQ0EsK0RBQStELGlCQUFpQjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLHFCQUFxQjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxvQkFBb0IseUJBQXlCO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxnQ0FBZ0MscUJBQXFCO0FBQzlIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxpQkFBaUI7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0hBQWdILDhFQUE4RTtBQUM5TDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxTUFBcU0sZ0JBQWdCLGlCQUFpQix1QkFBdUI7QUFDN1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixNQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE1BQU07QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsTUFBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUdBQXlHLHVGQUF1RjtBQUNoTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE1BQU07QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlHQUF5Ryx1RkFBdUY7QUFDaE07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsTUFBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixNQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE1BQU07QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsTUFBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixNQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE1BQU07QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE1BQU07QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixNQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLDBCQUEwQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsS0FBSztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixLQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFdBQVc7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsV0FBVztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE1BQU07QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsS0FBSztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELDBCQUEwQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsS0FBSztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixLQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixNQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE1BQU07QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixNQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE1BQU07QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE1BQU07QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDBCQUEwQjtBQUNwRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMEJBQTBCO0FBQ3BELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGNBQWM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGNBQWM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGFBQWE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLElBQUksR0FBRyxHQUFHO0FBQzFFO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUSxPQUFPO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELE1BQU07QUFDekQ7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIseUJBQXlCO0FBQ25ELFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxTQUFTLGVBQWU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixLQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE9BQU87QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxTQUFTLGVBQWU7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0RBQXNEO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixLQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsdUJBQXVCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsdUJBQXVCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDJEQUFVO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUseUJBQXlCO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHFEQUFpQjtBQUNoRCw2QkFBNkIsaURBQVE7QUFDckM7QUFDQSxzQkFBc0IsOERBQVE7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHNEQUFTO0FBQ25DO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSwrREFBK0Qsb0JBQW9CLElBQUksTUFBTTtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixLQUFLO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix5Q0FBZ0IsYUFBYSx1QkFBdUI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLGFBQWEsOEJBQThCO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixLQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFlBQVksR0FBRztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSx1Q0FBdUMsNkNBQU87QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsMENBQWE7QUFDdEM7QUFDQSwrQkFBK0IsNkNBQU87QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0Esc0RBQXNELFdBQVcsNEJBQTRCLE9BQU8seUJBQXlCLFVBQVU7QUFDdkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RCx3RUFBd0U7QUFDeEUsUUFBUTtBQUNSLE9BQU87QUFDUDtBQUNBLFFBQVEsbUNBQW1DO0FBQzNDO0FBQ0E7QUFDQSxpQ0FBaUMsaUNBQWlDO0FBQ2xFLG9DQUFvQyxrQ0FBa0MsS0FBSztBQUMzRSxnQ0FBZ0MsbUJBQW1CO0FBQ25ELDhCQUE4QjtBQUM5QjtBQUNBLG1DQUFtQywwQkFBMEI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLCtCQUErQix5QkFBeUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFbStFO0FBQ24rRSIsInNvdXJjZXMiOlsid2VicGFjazovL2pld2VsYXJ5LWFwcC8uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL2dlbmFpL2Rpc3Qvbm9kZS9pbmRleC5tanM/YmM2MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBHb29nbGVBdXRoIH0gZnJvbSAnZ29vZ2xlLWF1dGgtbGlicmFyeSc7XG5pbXBvcnQgeyBjcmVhdGVXcml0ZVN0cmVhbSB9IGZyb20gJ2ZzJztcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzL3Byb21pc2VzJztcbmltcG9ydCB7IHdyaXRlRmlsZSB9IGZyb20gJ2ZzL3Byb21pc2VzJztcbmltcG9ydCB7IFJlYWRhYmxlIH0gZnJvbSAnbm9kZTpzdHJlYW0nO1xuaW1wb3J0IHsgZmluaXNoZWQgfSBmcm9tICdub2RlOnN0cmVhbS9wcm9taXNlcyc7XG5pbXBvcnQgKiBhcyBOb2RlV3MgZnJvbSAnd3MnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xubGV0IF9kZWZhdWx0QmFzZUdlbWluaVVybCA9IHVuZGVmaW5lZDtcbmxldCBfZGVmYXVsdEJhc2VWZXJ0ZXhVcmwgPSB1bmRlZmluZWQ7XG4vKipcbiAqIE92ZXJyaWRlcyB0aGUgYmFzZSBVUkxzIGZvciB0aGUgR2VtaW5pIEFQSSBhbmQgVmVydGV4IEFJIEFQSS5cbiAqXG4gKiBAcmVtYXJrcyBUaGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBjYWxsZWQgYmVmb3JlIGluaXRpYWxpemluZyB0aGUgU0RLLiBJZiB0aGVcbiAqIGJhc2UgVVJMcyBhcmUgc2V0IGFmdGVyIGluaXRpYWxpemluZyB0aGUgU0RLLCB0aGUgYmFzZSBVUkxzIHdpbGwgbm90IGJlXG4gKiB1cGRhdGVkLiBCYXNlIFVSTHMgcHJvdmlkZWQgaW4gdGhlIEh0dHBPcHRpb25zIHdpbGwgYWxzbyB0YWtlIHByZWNlZGVuY2Ugb3ZlclxuICogVVJMcyBzZXQgaGVyZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7R29vZ2xlR2VuQUksIHNldERlZmF1bHRCYXNlVXJsc30gZnJvbSAnQGdvb2dsZS9nZW5haSc7XG4gKiAvLyBPdmVycmlkZSB0aGUgYmFzZSBVUkwgZm9yIHRoZSBHZW1pbmkgQVBJLlxuICogc2V0RGVmYXVsdEJhc2VVcmxzKHtnZW1pbmlVcmw6J2h0dHBzOi8vZ2VtaW5pLmdvb2dsZS5jb20nfSk7XG4gKlxuICogLy8gT3ZlcnJpZGUgdGhlIGJhc2UgVVJMIGZvciB0aGUgVmVydGV4IEFJIEFQSS5cbiAqIHNldERlZmF1bHRCYXNlVXJscyh7dmVydGV4VXJsOiAnaHR0cHM6Ly92ZXJ0ZXhhaS5nb29nbGVhcGlzLmNvbSd9KTtcbiAqXG4gKiBjb25zdCBhaSA9IG5ldyBHb29nbGVHZW5BSSh7YXBpS2V5OiAnR0VNSU5JX0FQSV9LRVknfSk7XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gc2V0RGVmYXVsdEJhc2VVcmxzKGJhc2VVcmxQYXJhbXMpIHtcbiAgICBfZGVmYXVsdEJhc2VHZW1pbmlVcmwgPSBiYXNlVXJsUGFyYW1zLmdlbWluaVVybDtcbiAgICBfZGVmYXVsdEJhc2VWZXJ0ZXhVcmwgPSBiYXNlVXJsUGFyYW1zLnZlcnRleFVybDtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgZGVmYXVsdCBiYXNlIFVSTHMgZm9yIHRoZSBHZW1pbmkgQVBJIGFuZCBWZXJ0ZXggQUkgQVBJLlxuICovXG5mdW5jdGlvbiBnZXREZWZhdWx0QmFzZVVybHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2VtaW5pVXJsOiBfZGVmYXVsdEJhc2VHZW1pbmlVcmwsXG4gICAgICAgIHZlcnRleFVybDogX2RlZmF1bHRCYXNlVmVydGV4VXJsLFxuICAgIH07XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGRlZmF1bHQgYmFzZSBVUkwgYmFzZWQgb24gdGhlIGZvbGxvd2luZyBwcmlvcml0eTpcbiAqICAgMS4gQmFzZSBVUkxzIHNldCB2aWEgSHR0cE9wdGlvbnMuXG4gKiAgIDIuIEJhc2UgVVJMcyBzZXQgdmlhIHRoZSBsYXRlc3QgY2FsbCB0byBzZXREZWZhdWx0QmFzZVVybHMuXG4gKiAgIDMuIEJhc2UgVVJMcyBzZXQgdmlhIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0QmFzZVVybChodHRwT3B0aW9ucywgdmVydGV4YWksIHZlcnRleEJhc2VVcmxGcm9tRW52LCBnZW1pbmlCYXNlVXJsRnJvbUVudikge1xuICAgIHZhciBfYSwgX2I7XG4gICAgaWYgKCEoaHR0cE9wdGlvbnMgPT09IG51bGwgfHwgaHR0cE9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGh0dHBPcHRpb25zLmJhc2VVcmwpKSB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRCYXNlVXJscyA9IGdldERlZmF1bHRCYXNlVXJscygpO1xuICAgICAgICBpZiAodmVydGV4YWkpIHtcbiAgICAgICAgICAgIHJldHVybiAoX2EgPSBkZWZhdWx0QmFzZVVybHMudmVydGV4VXJsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB2ZXJ0ZXhCYXNlVXJsRnJvbUVudjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAoX2IgPSBkZWZhdWx0QmFzZVVybHMuZ2VtaW5pVXJsKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBnZW1pbmlCYXNlVXJsRnJvbUVudjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaHR0cE9wdGlvbnMuYmFzZVVybDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY2xhc3MgQmFzZU1vZHVsZSB7XG59XG5mdW5jdGlvbiBmb3JtYXRNYXAodGVtcGxhdGVTdHJpbmcsIHZhbHVlTWFwKSB7XG4gICAgLy8gVXNlIGEgcmVndWxhciBleHByZXNzaW9uIHRvIGZpbmQgYWxsIHBsYWNlaG9sZGVycyBpbiB0aGUgdGVtcGxhdGUgc3RyaW5nXG4gICAgY29uc3QgcmVnZXggPSAvXFx7KFtefV0rKVxcfS9nO1xuICAgIC8vIFJlcGxhY2UgZWFjaCBwbGFjZWhvbGRlciB3aXRoIGl0cyBjb3JyZXNwb25kaW5nIHZhbHVlIGZyb20gdGhlIHZhbHVlTWFwXG4gICAgcmV0dXJuIHRlbXBsYXRlU3RyaW5nLnJlcGxhY2UocmVnZXgsIChtYXRjaCwga2V5KSA9PiB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWVNYXAsIGtleSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVNYXBba2V5XTtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIHZhbHVlIHRvIGEgc3RyaW5nIGlmIGl0J3Mgbm90IGEgc3RyaW5nIGFscmVhZHlcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsID8gU3RyaW5nKHZhbHVlKSA6ICcnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSGFuZGxlIG1pc3Npbmcga2V5c1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXkgJyR7a2V5fScgbm90IGZvdW5kIGluIHZhbHVlTWFwLmApO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBzZXRWYWx1ZUJ5UGF0aChkYXRhLCBrZXlzLCB2YWx1ZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgaWYgKGtleS5lbmRzV2l0aCgnW10nKSkge1xuICAgICAgICAgICAgY29uc3Qga2V5TmFtZSA9IGtleS5zbGljZSgwLCAtMik7XG4gICAgICAgICAgICBpZiAoIShrZXlOYW1lIGluIGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFba2V5TmFtZV0gPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiB2YWx1ZS5sZW5ndGggfSwgKCkgPT4gKHt9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFZhbHVlIG11c3QgYmUgYSBsaXN0IGdpdmVuIGFuIGFycmF5IHBhdGggJHtrZXl9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YVtrZXlOYW1lXSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcnJheURhdGEgPSBkYXRhW2tleU5hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGFycmF5RGF0YS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZW50cnkgPSBhcnJheURhdGFbal07XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aChlbnRyeSwga2V5cy5zbGljZShpICsgMSksIHZhbHVlW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBkIG9mIGFycmF5RGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgoZCwga2V5cy5zbGljZShpICsgMSksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkuZW5kc1dpdGgoJ1swXScpKSB7XG4gICAgICAgICAgICBjb25zdCBrZXlOYW1lID0ga2V5LnNsaWNlKDAsIC0zKTtcbiAgICAgICAgICAgIGlmICghKGtleU5hbWUgaW4gZGF0YSkpIHtcbiAgICAgICAgICAgICAgICBkYXRhW2tleU5hbWVdID0gW3t9XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFycmF5RGF0YSA9IGRhdGFba2V5TmFtZV07XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aChhcnJheURhdGFbMF0sIGtleXMuc2xpY2UoaSArIDEpLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYXRhW2tleV0gfHwgdHlwZW9mIGRhdGFba2V5XSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGRhdGFba2V5XSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGRhdGEgPSBkYXRhW2tleV07XG4gICAgfVxuICAgIGNvbnN0IGtleVRvU2V0ID0ga2V5c1trZXlzLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IGV4aXN0aW5nRGF0YSA9IGRhdGFba2V5VG9TZXRdO1xuICAgIGlmIChleGlzdGluZ0RhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIXZhbHVlIHx8XG4gICAgICAgICAgICAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoID09PSAwKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gZXhpc3RpbmdEYXRhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBleGlzdGluZ0RhdGEgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBleGlzdGluZ0RhdGEgIT09IG51bGwgJiZcbiAgICAgICAgICAgIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGV4aXN0aW5nRGF0YSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3Qgc2V0IHZhbHVlIGZvciBhbiBleGlzdGluZyBrZXkuIEtleTogJHtrZXlUb1NldH1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGtleVRvU2V0ID09PSAnX3NlbGYnICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICB2YWx1ZSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZUFzUmVjb3JkID0gdmFsdWU7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGRhdGEsIHZhbHVlQXNSZWNvcmQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGF0YVtrZXlUb1NldF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFZhbHVlQnlQYXRoKGRhdGEsIGtleXMsIGRlZmF1bHRWYWx1ZSA9IHVuZGVmaW5lZCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMSAmJiBrZXlzWzBdID09PSAnX3NlbGYnKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gJ29iamVjdCcgfHwgZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgaWYgKGtleS5lbmRzV2l0aCgnW10nKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleU5hbWUgPSBrZXkuc2xpY2UoMCwgLTIpO1xuICAgICAgICAgICAgICAgIGlmIChrZXlOYW1lIGluIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJyYXlEYXRhID0gZGF0YVtrZXlOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5RGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5RGF0YS5tYXAoKGQpID0+IGdldFZhbHVlQnlQYXRoKGQsIGtleXMuc2xpY2UoaSArIDEpLCBkZWZhdWx0VmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGRhdGFba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFR5cGVFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG59XG4vKipcbiAqIE1vdmVzIHZhbHVlcyBmcm9tIHNvdXJjZSBwYXRocyB0byBkZXN0aW5hdGlvbiBwYXRocy5cbiAqXG4gKiBFeGFtcGxlczpcbiAqICAgbW92ZVZhbHVlQnlQYXRoKFxuICogICAgIHsncmVxdWVzdHMnOiBbeydjb250ZW50JzogdjF9LCB7J2NvbnRlbnQnOiB2Mn1dfSxcbiAqICAgICB7J3JlcXVlc3RzW10uKic6ICdyZXF1ZXN0c1tdLnJlcXVlc3QuKid9XG4gKiAgIClcbiAqICAgICAtPiB7J3JlcXVlc3RzJzogW3sncmVxdWVzdCc6IHsnY29udGVudCc6IHYxfX0sIHsncmVxdWVzdCc6IHsnY29udGVudCc6IHYyfX1dfVxuICovXG5mdW5jdGlvbiBtb3ZlVmFsdWVCeVBhdGgoZGF0YSwgcGF0aHMpIHtcbiAgICBmb3IgKGNvbnN0IFtzb3VyY2VQYXRoLCBkZXN0UGF0aF0gb2YgT2JqZWN0LmVudHJpZXMocGF0aHMpKSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZUtleXMgPSBzb3VyY2VQYXRoLnNwbGl0KCcuJyk7XG4gICAgICAgIGNvbnN0IGRlc3RLZXlzID0gZGVzdFBhdGguc3BsaXQoJy4nKTtcbiAgICAgICAgLy8gRGV0ZXJtaW5lIGtleXMgdG8gZXhjbHVkZSBmcm9tIHdpbGRjYXJkIHRvIGF2b2lkIGN5Y2xpYyByZWZlcmVuY2VzXG4gICAgICAgIGNvbnN0IGV4Y2x1ZGVLZXlzID0gbmV3IFNldCgpO1xuICAgICAgICBsZXQgd2lsZGNhcmRJZHggPSAtMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlS2V5c1tpXSA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgd2lsZGNhcmRJZHggPSBpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh3aWxkY2FyZElkeCAhPT0gLTEgJiYgZGVzdEtleXMubGVuZ3RoID4gd2lsZGNhcmRJZHgpIHtcbiAgICAgICAgICAgIC8vIEV4dHJhY3QgdGhlIGludGVybWVkaWF0ZSBrZXkgYmV0d2VlbiBzb3VyY2UgYW5kIGRlc3QgcGF0aHNcbiAgICAgICAgICAgIC8vIEV4YW1wbGU6IHNvdXJjZT1bJ3JlcXVlc3RzW10nLCAnKiddLCBkZXN0PVsncmVxdWVzdHNbXScsICdyZXF1ZXN0JywgJyonXVxuICAgICAgICAgICAgLy8gV2Ugd2FudCB0byBleGNsdWRlICdyZXF1ZXN0J1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHdpbGRjYXJkSWR4OyBpIDwgZGVzdEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBkZXN0S2V5c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ICE9PSAnKicgJiYgIWtleS5lbmRzV2l0aCgnW10nKSAmJiAha2V5LmVuZHNXaXRoKCdbMF0nKSkge1xuICAgICAgICAgICAgICAgICAgICBleGNsdWRlS2V5cy5hZGQoa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgX21vdmVWYWx1ZVJlY3Vyc2l2ZShkYXRhLCBzb3VyY2VLZXlzLCBkZXN0S2V5cywgMCwgZXhjbHVkZUtleXMpO1xuICAgIH1cbn1cbi8qKlxuICogUmVjdXJzaXZlbHkgbW92ZXMgdmFsdWVzIGZyb20gc291cmNlIHBhdGggdG8gZGVzdGluYXRpb24gcGF0aC5cbiAqL1xuZnVuY3Rpb24gX21vdmVWYWx1ZVJlY3Vyc2l2ZShkYXRhLCBzb3VyY2VLZXlzLCBkZXN0S2V5cywga2V5SWR4LCBleGNsdWRlS2V5cykge1xuICAgIGlmIChrZXlJZHggPj0gc291cmNlS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGRhdGEgIT09ICdvYmplY3QnIHx8IGRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBrZXkgPSBzb3VyY2VLZXlzW2tleUlkeF07XG4gICAgaWYgKGtleS5lbmRzV2l0aCgnW10nKSkge1xuICAgICAgICBjb25zdCBrZXlOYW1lID0ga2V5LnNsaWNlKDAsIC0yKTtcbiAgICAgICAgY29uc3QgZGF0YVJlY29yZCA9IGRhdGE7XG4gICAgICAgIGlmIChrZXlOYW1lIGluIGRhdGFSZWNvcmQgJiYgQXJyYXkuaXNBcnJheShkYXRhUmVjb3JkW2tleU5hbWVdKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGRhdGFSZWNvcmRba2V5TmFtZV0pIHtcbiAgICAgICAgICAgICAgICBfbW92ZVZhbHVlUmVjdXJzaXZlKGl0ZW0sIHNvdXJjZUtleXMsIGRlc3RLZXlzLCBrZXlJZHggKyAxLCBleGNsdWRlS2V5cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoa2V5ID09PSAnKicpIHtcbiAgICAgICAgLy8gd2lsZGNhcmQgLSBtb3ZlIGFsbCBmaWVsZHNcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJiBkYXRhICE9PSBudWxsICYmICFBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhUmVjb3JkID0gZGF0YTtcbiAgICAgICAgICAgIGNvbnN0IGtleXNUb01vdmUgPSBPYmplY3Qua2V5cyhkYXRhUmVjb3JkKS5maWx0ZXIoKGspID0+ICFrLnN0YXJ0c1dpdGgoJ18nKSAmJiAhZXhjbHVkZUtleXMuaGFzKGspKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlc1RvTW92ZSA9IHt9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBrIG9mIGtleXNUb01vdmUpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZXNUb01vdmVba10gPSBkYXRhUmVjb3JkW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2V0IHZhbHVlcyBhdCBkZXN0aW5hdGlvblxuICAgICAgICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXModmFsdWVzVG9Nb3ZlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0Rlc3RLZXlzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBkayBvZiBkZXN0S2V5cy5zbGljZShrZXlJZHgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkayA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdEZXN0S2V5cy5wdXNoKGspO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3RGVzdEtleXMucHVzaChkayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgoZGF0YVJlY29yZCwgbmV3RGVzdEtleXMsIHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBrIG9mIGtleXNUb01vdmUpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgZGF0YVJlY29yZFtrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gTmF2aWdhdGUgdG8gbmV4dCBsZXZlbFxuICAgICAgICBjb25zdCBkYXRhUmVjb3JkID0gZGF0YTtcbiAgICAgICAgaWYgKGtleSBpbiBkYXRhUmVjb3JkKSB7XG4gICAgICAgICAgICBfbW92ZVZhbHVlUmVjdXJzaXZlKGRhdGFSZWNvcmRba2V5XSwgc291cmNlS2V5cywgZGVzdEtleXMsIGtleUlkeCArIDEsIGV4Y2x1ZGVLZXlzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuZnVuY3Rpb24gdEJ5dGVzJDEoZnJvbUJ5dGVzKSB7XG4gICAgaWYgKHR5cGVvZiBmcm9tQnl0ZXMgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZnJvbUltYWdlQnl0ZXMgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIH1cbiAgICAvLyBUT0RPKGIvMzg5MTMzOTE0KTogUmVtb3ZlIGR1bW15IGJ5dGVzIGNvbnZlcnRlci5cbiAgICByZXR1cm4gZnJvbUJ5dGVzO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG4vLyBDb2RlIGdlbmVyYXRlZCBieSB0aGUgR29vZ2xlIEdlbiBBSSBTREsgZ2VuZXJhdG9yIERPIE5PVCBFRElULlxuZnVuY3Rpb24gZmV0Y2hQcmVkaWN0T3BlcmF0aW9uUGFyYW1ldGVyc1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21PcGVyYXRpb25OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3BlcmF0aW9uTmFtZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21PcGVyYXRpb25OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnb3BlcmF0aW9uTmFtZSddLCBmcm9tT3BlcmF0aW9uTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNvdXJjZU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc291cmNlTmFtZSddKTtcbiAgICBpZiAoZnJvbVJlc291cmNlTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAncmVzb3VyY2VOYW1lJ10sIGZyb21SZXNvdXJjZU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVZpZGVvc09wZXJhdGlvbkZyb21NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21ldGFkYXRhJ10pO1xuICAgIGlmIChmcm9tTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZXRhZGF0YSddLCBmcm9tTWV0YWRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRG9uZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZG9uZSddKTtcbiAgICBpZiAoZnJvbURvbmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkb25lJ10sIGZyb21Eb25lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVycm9yID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlcnJvciddKTtcbiAgICBpZiAoZnJvbUVycm9yICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXJyb3InXSwgZnJvbUVycm9yKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2UnLFxuICAgICAgICAnZ2VuZXJhdGVWaWRlb1Jlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2UnXSwgZ2VuZXJhdGVWaWRlb3NSZXNwb25zZUZyb21NbGRldiQxKGZyb21SZXNwb25zZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVZpZGVvc09wZXJhdGlvbkZyb21WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZXRhZGF0YSddKTtcbiAgICBpZiAoZnJvbU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWV0YWRhdGEnXSwgZnJvbU1ldGFkYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURvbmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RvbmUnXSk7XG4gICAgaWYgKGZyb21Eb25lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZG9uZSddLCBmcm9tRG9uZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FcnJvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXJyb3InXSk7XG4gICAgaWYgKGZyb21FcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vycm9yJ10sIGZyb21FcnJvcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVzcG9uc2UnXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlJ10sIGdlbmVyYXRlVmlkZW9zUmVzcG9uc2VGcm9tVmVydGV4JDEoZnJvbVJlc3BvbnNlKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVmlkZW9zUmVzcG9uc2VGcm9tTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tR2VuZXJhdGVkVmlkZW9zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ2VuZXJhdGVkU2FtcGxlcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21HZW5lcmF0ZWRWaWRlb3MgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUdlbmVyYXRlZFZpZGVvcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZWRWaWRlb0Zyb21NbGRldiQxKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2VuZXJhdGVkVmlkZW9zJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SYWlNZWRpYUZpbHRlcmVkQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyYWlNZWRpYUZpbHRlcmVkQ291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmFpTWVkaWFGaWx0ZXJlZENvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmFpTWVkaWFGaWx0ZXJlZENvdW50J10sIGZyb21SYWlNZWRpYUZpbHRlcmVkQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyYWlNZWRpYUZpbHRlcmVkUmVhc29ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SYWlNZWRpYUZpbHRlcmVkUmVhc29ucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JhaU1lZGlhRmlsdGVyZWRSZWFzb25zJ10sIGZyb21SYWlNZWRpYUZpbHRlcmVkUmVhc29ucyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVmlkZW9zUmVzcG9uc2VGcm9tVmVydGV4JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUdlbmVyYXRlZFZpZGVvcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmlkZW9zJ10pO1xuICAgIGlmIChmcm9tR2VuZXJhdGVkVmlkZW9zICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21HZW5lcmF0ZWRWaWRlb3M7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVkVmlkZW9Gcm9tVmVydGV4JDEoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnZW5lcmF0ZWRWaWRlb3MnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJhaU1lZGlhRmlsdGVyZWRDb3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JhaU1lZGlhRmlsdGVyZWRDb3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SYWlNZWRpYUZpbHRlcmVkQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyYWlNZWRpYUZpbHRlcmVkQ291bnQnXSwgZnJvbVJhaU1lZGlhRmlsdGVyZWRDb3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SYWlNZWRpYUZpbHRlcmVkUmVhc29ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JhaU1lZGlhRmlsdGVyZWRSZWFzb25zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJhaU1lZGlhRmlsdGVyZWRSZWFzb25zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMnXSwgZnJvbVJhaU1lZGlhRmlsdGVyZWRSZWFzb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVkVmlkZW9Gcm9tTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVmlkZW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZpZGVvJ10pO1xuICAgIGlmIChmcm9tVmlkZW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlbyddLCB2aWRlb0Zyb21NbGRldiQxKGZyb21WaWRlbykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZWRWaWRlb0Zyb21WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVmlkZW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ19zZWxmJ10pO1xuICAgIGlmIChmcm9tVmlkZW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlbyddLCB2aWRlb0Zyb21WZXJ0ZXgkMShmcm9tVmlkZW8pKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2V0T3BlcmF0aW9uUGFyYW1ldGVyc1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU9wZXJhdGlvbk5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvcGVyYXRpb25OYW1lJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU9wZXJhdGlvbk5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ29wZXJhdGlvbk5hbWUnXSwgZnJvbU9wZXJhdGlvbk5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZXRPcGVyYXRpb25QYXJhbWV0ZXJzVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU9wZXJhdGlvbk5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvcGVyYXRpb25OYW1lJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU9wZXJhdGlvbk5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ29wZXJhdGlvbk5hbWUnXSwgZnJvbU9wZXJhdGlvbk5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBpbXBvcnRGaWxlT3BlcmF0aW9uRnJvbU1sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWV0YWRhdGEnXSk7XG4gICAgaWYgKGZyb21NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21ldGFkYXRhJ10sIGZyb21NZXRhZGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Eb25lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkb25lJ10pO1xuICAgIGlmIChmcm9tRG9uZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RvbmUnXSwgZnJvbURvbmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXJyb3IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Vycm9yJ10pO1xuICAgIGlmIChmcm9tRXJyb3IgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlcnJvciddLCBmcm9tRXJyb3IpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc3BvbnNlJ10pO1xuICAgIGlmIChmcm9tUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZSddLCBpbXBvcnRGaWxlUmVzcG9uc2VGcm9tTWxkZXYkMShmcm9tUmVzcG9uc2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gaW1wb3J0RmlsZVJlc3BvbnNlRnJvbU1sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYXJlbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcmVudCddKTtcbiAgICBpZiAoZnJvbVBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcmVudCddLCBmcm9tUGFyZW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURvY3VtZW50TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZG9jdW1lbnROYW1lJ10pO1xuICAgIGlmIChmcm9tRG9jdW1lbnROYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZG9jdW1lbnROYW1lJ10sIGZyb21Eb2N1bWVudE5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cGxvYWRUb0ZpbGVTZWFyY2hTdG9yZU9wZXJhdGlvbkZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZXRhZGF0YSddKTtcbiAgICBpZiAoZnJvbU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWV0YWRhdGEnXSwgZnJvbU1ldGFkYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURvbmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RvbmUnXSk7XG4gICAgaWYgKGZyb21Eb25lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZG9uZSddLCBmcm9tRG9uZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FcnJvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXJyb3InXSk7XG4gICAgaWYgKGZyb21FcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vycm9yJ10sIGZyb21FcnJvcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVzcG9uc2UnXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlJ10sIHVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlUmVzcG9uc2VGcm9tTWxkZXYoZnJvbVJlc3BvbnNlKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlUmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYXJlbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcmVudCddKTtcbiAgICBpZiAoZnJvbVBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcmVudCddLCBmcm9tUGFyZW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURvY3VtZW50TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZG9jdW1lbnROYW1lJ10pO1xuICAgIGlmIChmcm9tRG9jdW1lbnROYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZG9jdW1lbnROYW1lJ10sIGZyb21Eb2N1bWVudE5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB2aWRlb0Zyb21NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21VcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VyaSddKTtcbiAgICBpZiAoZnJvbVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VyaSddLCBmcm9tVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZpZGVvQnl0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuY29kZWRWaWRlbyddKTtcbiAgICBpZiAoZnJvbVZpZGVvQnl0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlb0J5dGVzJ10sIHRCeXRlcyQxKGZyb21WaWRlb0J5dGVzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5jb2RpbmcnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZpZGVvRnJvbVZlcnRleCQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21VcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2djc1VyaSddKTtcbiAgICBpZiAoZnJvbVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VyaSddLCBmcm9tVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZpZGVvQnl0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdieXRlc0Jhc2U2NEVuY29kZWQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVmlkZW9CeXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvQnl0ZXMnXSwgdEJ5dGVzJDEoZnJvbVZpZGVvQnl0ZXMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG4vKiogT3V0Y29tZSBvZiB0aGUgY29kZSBleGVjdXRpb24uICovXG52YXIgT3V0Y29tZTtcbihmdW5jdGlvbiAoT3V0Y29tZSkge1xuICAgIC8qKlxuICAgICAqIFVuc3BlY2lmaWVkIHN0YXR1cy4gVGhpcyB2YWx1ZSBzaG91bGQgbm90IGJlIHVzZWQuXG4gICAgICovXG4gICAgT3V0Y29tZVtcIk9VVENPTUVfVU5TUEVDSUZJRURcIl0gPSBcIk9VVENPTUVfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBDb2RlIGV4ZWN1dGlvbiBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LlxuICAgICAqL1xuICAgIE91dGNvbWVbXCJPVVRDT01FX09LXCJdID0gXCJPVVRDT01FX09LXCI7XG4gICAgLyoqXG4gICAgICogQ29kZSBleGVjdXRpb24gZmluaXNoZWQgYnV0IHdpdGggYSBmYWlsdXJlLiBgc3RkZXJyYCBzaG91bGQgY29udGFpbiB0aGUgcmVhc29uLlxuICAgICAqL1xuICAgIE91dGNvbWVbXCJPVVRDT01FX0ZBSUxFRFwiXSA9IFwiT1VUQ09NRV9GQUlMRURcIjtcbiAgICAvKipcbiAgICAgKiBDb2RlIGV4ZWN1dGlvbiByYW4gZm9yIHRvbyBsb25nLCBhbmQgd2FzIGNhbmNlbGxlZC4gVGhlcmUgbWF5IG9yIG1heSBub3QgYmUgYSBwYXJ0aWFsIG91dHB1dCBwcmVzZW50LlxuICAgICAqL1xuICAgIE91dGNvbWVbXCJPVVRDT01FX0RFQURMSU5FX0VYQ0VFREVEXCJdID0gXCJPVVRDT01FX0RFQURMSU5FX0VYQ0VFREVEXCI7XG59KShPdXRjb21lIHx8IChPdXRjb21lID0ge30pKTtcbi8qKiBQcm9ncmFtbWluZyBsYW5ndWFnZSBvZiB0aGUgYGNvZGVgLiAqL1xudmFyIExhbmd1YWdlO1xuKGZ1bmN0aW9uIChMYW5ndWFnZSkge1xuICAgIC8qKlxuICAgICAqIFVuc3BlY2lmaWVkIGxhbmd1YWdlLiBUaGlzIHZhbHVlIHNob3VsZCBub3QgYmUgdXNlZC5cbiAgICAgKi9cbiAgICBMYW5ndWFnZVtcIkxBTkdVQUdFX1VOU1BFQ0lGSUVEXCJdID0gXCJMQU5HVUFHRV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIFB5dGhvbiA+PSAzLjEwLCB3aXRoIG51bXB5IGFuZCBzaW1weSBhdmFpbGFibGUuXG4gICAgICovXG4gICAgTGFuZ3VhZ2VbXCJQWVRIT05cIl0gPSBcIlBZVEhPTlwiO1xufSkoTGFuZ3VhZ2UgfHwgKExhbmd1YWdlID0ge30pKTtcbi8qKiBTcGVjaWZpZXMgaG93IHRoZSByZXNwb25zZSBzaG91bGQgYmUgc2NoZWR1bGVkIGluIHRoZSBjb252ZXJzYXRpb24uICovXG52YXIgRnVuY3Rpb25SZXNwb25zZVNjaGVkdWxpbmc7XG4oZnVuY3Rpb24gKEZ1bmN0aW9uUmVzcG9uc2VTY2hlZHVsaW5nKSB7XG4gICAgLyoqXG4gICAgICogVGhpcyB2YWx1ZSBpcyB1bnVzZWQuXG4gICAgICovXG4gICAgRnVuY3Rpb25SZXNwb25zZVNjaGVkdWxpbmdbXCJTQ0hFRFVMSU5HX1VOU1BFQ0lGSUVEXCJdID0gXCJTQ0hFRFVMSU5HX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogT25seSBhZGQgdGhlIHJlc3VsdCB0byB0aGUgY29udmVyc2F0aW9uIGNvbnRleHQsIGRvIG5vdCBpbnRlcnJ1cHQgb3IgdHJpZ2dlciBnZW5lcmF0aW9uLlxuICAgICAqL1xuICAgIEZ1bmN0aW9uUmVzcG9uc2VTY2hlZHVsaW5nW1wiU0lMRU5UXCJdID0gXCJTSUxFTlRcIjtcbiAgICAvKipcbiAgICAgKiBBZGQgdGhlIHJlc3VsdCB0byB0aGUgY29udmVyc2F0aW9uIGNvbnRleHQsIGFuZCBwcm9tcHQgdG8gZ2VuZXJhdGUgb3V0cHV0IHdpdGhvdXQgaW50ZXJydXB0aW5nIG9uZ29pbmcgZ2VuZXJhdGlvbi5cbiAgICAgKi9cbiAgICBGdW5jdGlvblJlc3BvbnNlU2NoZWR1bGluZ1tcIldIRU5fSURMRVwiXSA9IFwiV0hFTl9JRExFXCI7XG4gICAgLyoqXG4gICAgICogQWRkIHRoZSByZXN1bHQgdG8gdGhlIGNvbnZlcnNhdGlvbiBjb250ZXh0LCBpbnRlcnJ1cHQgb25nb2luZyBnZW5lcmF0aW9uIGFuZCBwcm9tcHQgdG8gZ2VuZXJhdGUgb3V0cHV0LlxuICAgICAqL1xuICAgIEZ1bmN0aW9uUmVzcG9uc2VTY2hlZHVsaW5nW1wiSU5URVJSVVBUXCJdID0gXCJJTlRFUlJVUFRcIjtcbn0pKEZ1bmN0aW9uUmVzcG9uc2VTY2hlZHVsaW5nIHx8IChGdW5jdGlvblJlc3BvbnNlU2NoZWR1bGluZyA9IHt9KSk7XG4vKiogVGhlIHR5cGUgb2YgdGhlIGRhdGEuICovXG52YXIgVHlwZTtcbihmdW5jdGlvbiAoVHlwZSkge1xuICAgIC8qKlxuICAgICAqIE5vdCBzcGVjaWZpZWQsIHNob3VsZCBub3QgYmUgdXNlZC5cbiAgICAgKi9cbiAgICBUeXBlW1wiVFlQRV9VTlNQRUNJRklFRFwiXSA9IFwiVFlQRV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIE9wZW5BUEkgc3RyaW5nIHR5cGVcbiAgICAgKi9cbiAgICBUeXBlW1wiU1RSSU5HXCJdID0gXCJTVFJJTkdcIjtcbiAgICAvKipcbiAgICAgKiBPcGVuQVBJIG51bWJlciB0eXBlXG4gICAgICovXG4gICAgVHlwZVtcIk5VTUJFUlwiXSA9IFwiTlVNQkVSXCI7XG4gICAgLyoqXG4gICAgICogT3BlbkFQSSBpbnRlZ2VyIHR5cGVcbiAgICAgKi9cbiAgICBUeXBlW1wiSU5URUdFUlwiXSA9IFwiSU5URUdFUlwiO1xuICAgIC8qKlxuICAgICAqIE9wZW5BUEkgYm9vbGVhbiB0eXBlXG4gICAgICovXG4gICAgVHlwZVtcIkJPT0xFQU5cIl0gPSBcIkJPT0xFQU5cIjtcbiAgICAvKipcbiAgICAgKiBPcGVuQVBJIGFycmF5IHR5cGVcbiAgICAgKi9cbiAgICBUeXBlW1wiQVJSQVlcIl0gPSBcIkFSUkFZXCI7XG4gICAgLyoqXG4gICAgICogT3BlbkFQSSBvYmplY3QgdHlwZVxuICAgICAqL1xuICAgIFR5cGVbXCJPQkpFQ1RcIl0gPSBcIk9CSkVDVFwiO1xuICAgIC8qKlxuICAgICAqIE51bGwgdHlwZVxuICAgICAqL1xuICAgIFR5cGVbXCJOVUxMXCJdID0gXCJOVUxMXCI7XG59KShUeXBlIHx8IChUeXBlID0ge30pKTtcbi8qKiBUaGUgbW9kZSBvZiB0aGUgcHJlZGljdG9yIHRvIGJlIHVzZWQgaW4gZHluYW1pYyByZXRyaWV2YWwuICovXG52YXIgTW9kZTtcbihmdW5jdGlvbiAoTW9kZSkge1xuICAgIC8qKlxuICAgICAqIEFsd2F5cyB0cmlnZ2VyIHJldHJpZXZhbC5cbiAgICAgKi9cbiAgICBNb2RlW1wiTU9ERV9VTlNQRUNJRklFRFwiXSA9IFwiTU9ERV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIFJ1biByZXRyaWV2YWwgb25seSB3aGVuIHN5c3RlbSBkZWNpZGVzIGl0IGlzIG5lY2Vzc2FyeS5cbiAgICAgKi9cbiAgICBNb2RlW1wiTU9ERV9EWU5BTUlDXCJdID0gXCJNT0RFX0RZTkFNSUNcIjtcbn0pKE1vZGUgfHwgKE1vZGUgPSB7fSkpO1xuLyoqIFRoZSBBUEkgc3BlYyB0aGF0IHRoZSBleHRlcm5hbCBBUEkgaW1wbGVtZW50cy4gVGhpcyBlbnVtIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4gKi9cbnZhciBBcGlTcGVjO1xuKGZ1bmN0aW9uIChBcGlTcGVjKSB7XG4gICAgLyoqXG4gICAgICogVW5zcGVjaWZpZWQgQVBJIHNwZWMuIFRoaXMgdmFsdWUgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICAgICAqL1xuICAgIEFwaVNwZWNbXCJBUElfU1BFQ19VTlNQRUNJRklFRFwiXSA9IFwiQVBJX1NQRUNfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBTaW1wbGUgc2VhcmNoIEFQSSBzcGVjLlxuICAgICAqL1xuICAgIEFwaVNwZWNbXCJTSU1QTEVfU0VBUkNIXCJdID0gXCJTSU1QTEVfU0VBUkNIXCI7XG4gICAgLyoqXG4gICAgICogRWxhc3RpYyBzZWFyY2ggQVBJIHNwZWMuXG4gICAgICovXG4gICAgQXBpU3BlY1tcIkVMQVNUSUNfU0VBUkNIXCJdID0gXCJFTEFTVElDX1NFQVJDSFwiO1xufSkoQXBpU3BlYyB8fCAoQXBpU3BlYyA9IHt9KSk7XG4vKiogVHlwZSBvZiBhdXRoIHNjaGVtZS4gVGhpcyBlbnVtIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4gKi9cbnZhciBBdXRoVHlwZTtcbihmdW5jdGlvbiAoQXV0aFR5cGUpIHtcbiAgICBBdXRoVHlwZVtcIkFVVEhfVFlQRV9VTlNQRUNJRklFRFwiXSA9IFwiQVVUSF9UWVBFX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogTm8gQXV0aC5cbiAgICAgKi9cbiAgICBBdXRoVHlwZVtcIk5PX0FVVEhcIl0gPSBcIk5PX0FVVEhcIjtcbiAgICAvKipcbiAgICAgKiBBUEkgS2V5IEF1dGguXG4gICAgICovXG4gICAgQXV0aFR5cGVbXCJBUElfS0VZX0FVVEhcIl0gPSBcIkFQSV9LRVlfQVVUSFwiO1xuICAgIC8qKlxuICAgICAqIEhUVFAgQmFzaWMgQXV0aC5cbiAgICAgKi9cbiAgICBBdXRoVHlwZVtcIkhUVFBfQkFTSUNfQVVUSFwiXSA9IFwiSFRUUF9CQVNJQ19BVVRIXCI7XG4gICAgLyoqXG4gICAgICogR29vZ2xlIFNlcnZpY2UgQWNjb3VudCBBdXRoLlxuICAgICAqL1xuICAgIEF1dGhUeXBlW1wiR09PR0xFX1NFUlZJQ0VfQUNDT1VOVF9BVVRIXCJdID0gXCJHT09HTEVfU0VSVklDRV9BQ0NPVU5UX0FVVEhcIjtcbiAgICAvKipcbiAgICAgKiBPQXV0aCBhdXRoLlxuICAgICAqL1xuICAgIEF1dGhUeXBlW1wiT0FVVEhcIl0gPSBcIk9BVVRIXCI7XG4gICAgLyoqXG4gICAgICogT3BlbklEIENvbm5lY3QgKE9JREMpIEF1dGguXG4gICAgICovXG4gICAgQXV0aFR5cGVbXCJPSURDX0FVVEhcIl0gPSBcIk9JRENfQVVUSFwiO1xufSkoQXV0aFR5cGUgfHwgKEF1dGhUeXBlID0ge30pKTtcbi8qKiBUaGUgbG9jYXRpb24gb2YgdGhlIEFQSSBrZXkuIFRoaXMgZW51bSBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuICovXG52YXIgSHR0cEVsZW1lbnRMb2NhdGlvbjtcbihmdW5jdGlvbiAoSHR0cEVsZW1lbnRMb2NhdGlvbikge1xuICAgIEh0dHBFbGVtZW50TG9jYXRpb25bXCJIVFRQX0lOX1VOU1BFQ0lGSUVEXCJdID0gXCJIVFRQX0lOX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogRWxlbWVudCBpcyBpbiB0aGUgSFRUUCByZXF1ZXN0IHF1ZXJ5LlxuICAgICAqL1xuICAgIEh0dHBFbGVtZW50TG9jYXRpb25bXCJIVFRQX0lOX1FVRVJZXCJdID0gXCJIVFRQX0lOX1FVRVJZXCI7XG4gICAgLyoqXG4gICAgICogRWxlbWVudCBpcyBpbiB0aGUgSFRUUCByZXF1ZXN0IGhlYWRlci5cbiAgICAgKi9cbiAgICBIdHRwRWxlbWVudExvY2F0aW9uW1wiSFRUUF9JTl9IRUFERVJcIl0gPSBcIkhUVFBfSU5fSEVBREVSXCI7XG4gICAgLyoqXG4gICAgICogRWxlbWVudCBpcyBpbiB0aGUgSFRUUCByZXF1ZXN0IHBhdGguXG4gICAgICovXG4gICAgSHR0cEVsZW1lbnRMb2NhdGlvbltcIkhUVFBfSU5fUEFUSFwiXSA9IFwiSFRUUF9JTl9QQVRIXCI7XG4gICAgLyoqXG4gICAgICogRWxlbWVudCBpcyBpbiB0aGUgSFRUUCByZXF1ZXN0IGJvZHkuXG4gICAgICovXG4gICAgSHR0cEVsZW1lbnRMb2NhdGlvbltcIkhUVFBfSU5fQk9EWVwiXSA9IFwiSFRUUF9JTl9CT0RZXCI7XG4gICAgLyoqXG4gICAgICogRWxlbWVudCBpcyBpbiB0aGUgSFRUUCByZXF1ZXN0IGNvb2tpZS5cbiAgICAgKi9cbiAgICBIdHRwRWxlbWVudExvY2F0aW9uW1wiSFRUUF9JTl9DT09LSUVcIl0gPSBcIkhUVFBfSU5fQ09PS0lFXCI7XG59KShIdHRwRWxlbWVudExvY2F0aW9uIHx8IChIdHRwRWxlbWVudExvY2F0aW9uID0ge30pKTtcbi8qKiBTaXRlcyB3aXRoIGNvbmZpZGVuY2UgbGV2ZWwgY2hvc2VuICYgYWJvdmUgdGhpcyB2YWx1ZSB3aWxsIGJlIGJsb2NrZWQgZnJvbSB0aGUgc2VhcmNoIHJlc3VsdHMuIFRoaXMgZW51bSBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuICovXG52YXIgUGhpc2hCbG9ja1RocmVzaG9sZDtcbihmdW5jdGlvbiAoUGhpc2hCbG9ja1RocmVzaG9sZCkge1xuICAgIC8qKlxuICAgICAqIERlZmF1bHRzIHRvIHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIFBoaXNoQmxvY2tUaHJlc2hvbGRbXCJQSElTSF9CTE9DS19USFJFU0hPTERfVU5TUEVDSUZJRURcIl0gPSBcIlBISVNIX0JMT0NLX1RIUkVTSE9MRF9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIEJsb2NrcyBMb3cgYW5kIGFib3ZlIGNvbmZpZGVuY2UgVVJMIHRoYXQgaXMgcmlza3kuXG4gICAgICovXG4gICAgUGhpc2hCbG9ja1RocmVzaG9sZFtcIkJMT0NLX0xPV19BTkRfQUJPVkVcIl0gPSBcIkJMT0NLX0xPV19BTkRfQUJPVkVcIjtcbiAgICAvKipcbiAgICAgKiBCbG9ja3MgTWVkaXVtIGFuZCBhYm92ZSBjb25maWRlbmNlIFVSTCB0aGF0IGlzIHJpc2t5LlxuICAgICAqL1xuICAgIFBoaXNoQmxvY2tUaHJlc2hvbGRbXCJCTE9DS19NRURJVU1fQU5EX0FCT1ZFXCJdID0gXCJCTE9DS19NRURJVU1fQU5EX0FCT1ZFXCI7XG4gICAgLyoqXG4gICAgICogQmxvY2tzIEhpZ2ggYW5kIGFib3ZlIGNvbmZpZGVuY2UgVVJMIHRoYXQgaXMgcmlza3kuXG4gICAgICovXG4gICAgUGhpc2hCbG9ja1RocmVzaG9sZFtcIkJMT0NLX0hJR0hfQU5EX0FCT1ZFXCJdID0gXCJCTE9DS19ISUdIX0FORF9BQk9WRVwiO1xuICAgIC8qKlxuICAgICAqIEJsb2NrcyBIaWdoZXIgYW5kIGFib3ZlIGNvbmZpZGVuY2UgVVJMIHRoYXQgaXMgcmlza3kuXG4gICAgICovXG4gICAgUGhpc2hCbG9ja1RocmVzaG9sZFtcIkJMT0NLX0hJR0hFUl9BTkRfQUJPVkVcIl0gPSBcIkJMT0NLX0hJR0hFUl9BTkRfQUJPVkVcIjtcbiAgICAvKipcbiAgICAgKiBCbG9ja3MgVmVyeSBoaWdoIGFuZCBhYm92ZSBjb25maWRlbmNlIFVSTCB0aGF0IGlzIHJpc2t5LlxuICAgICAqL1xuICAgIFBoaXNoQmxvY2tUaHJlc2hvbGRbXCJCTE9DS19WRVJZX0hJR0hfQU5EX0FCT1ZFXCJdID0gXCJCTE9DS19WRVJZX0hJR0hfQU5EX0FCT1ZFXCI7XG4gICAgLyoqXG4gICAgICogQmxvY2tzIEV4dHJlbWVseSBoaWdoIGNvbmZpZGVuY2UgVVJMIHRoYXQgaXMgcmlza3kuXG4gICAgICovXG4gICAgUGhpc2hCbG9ja1RocmVzaG9sZFtcIkJMT0NLX09OTFlfRVhUUkVNRUxZX0hJR0hcIl0gPSBcIkJMT0NLX09OTFlfRVhUUkVNRUxZX0hJR0hcIjtcbn0pKFBoaXNoQmxvY2tUaHJlc2hvbGQgfHwgKFBoaXNoQmxvY2tUaHJlc2hvbGQgPSB7fSkpO1xuLyoqIFRoZSBsZXZlbCBvZiB0aG91Z2h0cyB0b2tlbnMgdGhhdCB0aGUgbW9kZWwgc2hvdWxkIGdlbmVyYXRlLiAqL1xudmFyIFRoaW5raW5nTGV2ZWw7XG4oZnVuY3Rpb24gKFRoaW5raW5nTGV2ZWwpIHtcbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHZhbHVlLlxuICAgICAqL1xuICAgIFRoaW5raW5nTGV2ZWxbXCJUSElOS0lOR19MRVZFTF9VTlNQRUNJRklFRFwiXSA9IFwiVEhJTktJTkdfTEVWRUxfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBMb3cgdGhpbmtpbmcgbGV2ZWwuXG4gICAgICovXG4gICAgVGhpbmtpbmdMZXZlbFtcIkxPV1wiXSA9IFwiTE9XXCI7XG4gICAgLyoqXG4gICAgICogSGlnaCB0aGlua2luZyBsZXZlbC5cbiAgICAgKi9cbiAgICBUaGlua2luZ0xldmVsW1wiSElHSFwiXSA9IFwiSElHSFwiO1xufSkoVGhpbmtpbmdMZXZlbCB8fCAoVGhpbmtpbmdMZXZlbCA9IHt9KSk7XG4vKiogSGFybSBjYXRlZ29yeS4gKi9cbnZhciBIYXJtQ2F0ZWdvcnk7XG4oZnVuY3Rpb24gKEhhcm1DYXRlZ29yeSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBoYXJtIGNhdGVnb3J5IGlzIHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIEhhcm1DYXRlZ29yeVtcIkhBUk1fQ0FURUdPUllfVU5TUEVDSUZJRURcIl0gPSBcIkhBUk1fQ0FURUdPUllfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgaGFybSBjYXRlZ29yeSBpcyBoYXJhc3NtZW50LlxuICAgICAqL1xuICAgIEhhcm1DYXRlZ29yeVtcIkhBUk1fQ0FURUdPUllfSEFSQVNTTUVOVFwiXSA9IFwiSEFSTV9DQVRFR09SWV9IQVJBU1NNRU5UXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGhhcm0gY2F0ZWdvcnkgaXMgaGF0ZSBzcGVlY2guXG4gICAgICovXG4gICAgSGFybUNhdGVnb3J5W1wiSEFSTV9DQVRFR09SWV9IQVRFX1NQRUVDSFwiXSA9IFwiSEFSTV9DQVRFR09SWV9IQVRFX1NQRUVDSFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBoYXJtIGNhdGVnb3J5IGlzIHNleHVhbGx5IGV4cGxpY2l0IGNvbnRlbnQuXG4gICAgICovXG4gICAgSGFybUNhdGVnb3J5W1wiSEFSTV9DQVRFR09SWV9TRVhVQUxMWV9FWFBMSUNJVFwiXSA9IFwiSEFSTV9DQVRFR09SWV9TRVhVQUxMWV9FWFBMSUNJVFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBoYXJtIGNhdGVnb3J5IGlzIGRhbmdlcm91cyBjb250ZW50LlxuICAgICAqL1xuICAgIEhhcm1DYXRlZ29yeVtcIkhBUk1fQ0FURUdPUllfREFOR0VST1VTX0NPTlRFTlRcIl0gPSBcIkhBUk1fQ0FURUdPUllfREFOR0VST1VTX0NPTlRFTlRcIjtcbiAgICAvKipcbiAgICAgKiBEZXByZWNhdGVkOiBFbGVjdGlvbiBmaWx0ZXIgaXMgbm90IGxvbmdlciBzdXBwb3J0ZWQuIFRoZSBoYXJtIGNhdGVnb3J5IGlzIGNpdmljIGludGVncml0eS5cbiAgICAgKi9cbiAgICBIYXJtQ2F0ZWdvcnlbXCJIQVJNX0NBVEVHT1JZX0NJVklDX0lOVEVHUklUWVwiXSA9IFwiSEFSTV9DQVRFR09SWV9DSVZJQ19JTlRFR1JJVFlcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgaGFybSBjYXRlZ29yeSBpcyBpbWFnZSBoYXRlLiBUaGlzIGVudW0gdmFsdWUgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLlxuICAgICAqL1xuICAgIEhhcm1DYXRlZ29yeVtcIkhBUk1fQ0FURUdPUllfSU1BR0VfSEFURVwiXSA9IFwiSEFSTV9DQVRFR09SWV9JTUFHRV9IQVRFXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGhhcm0gY2F0ZWdvcnkgaXMgaW1hZ2UgZGFuZ2Vyb3VzIGNvbnRlbnQuIFRoaXMgZW51bSB2YWx1ZSBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuXG4gICAgICovXG4gICAgSGFybUNhdGVnb3J5W1wiSEFSTV9DQVRFR09SWV9JTUFHRV9EQU5HRVJPVVNfQ09OVEVOVFwiXSA9IFwiSEFSTV9DQVRFR09SWV9JTUFHRV9EQU5HRVJPVVNfQ09OVEVOVFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBoYXJtIGNhdGVnb3J5IGlzIGltYWdlIGhhcmFzc21lbnQuIFRoaXMgZW51bSB2YWx1ZSBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuXG4gICAgICovXG4gICAgSGFybUNhdGVnb3J5W1wiSEFSTV9DQVRFR09SWV9JTUFHRV9IQVJBU1NNRU5UXCJdID0gXCJIQVJNX0NBVEVHT1JZX0lNQUdFX0hBUkFTU01FTlRcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgaGFybSBjYXRlZ29yeSBpcyBpbWFnZSBzZXh1YWxseSBleHBsaWNpdCBjb250ZW50LiBUaGlzIGVudW0gdmFsdWUgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLlxuICAgICAqL1xuICAgIEhhcm1DYXRlZ29yeVtcIkhBUk1fQ0FURUdPUllfSU1BR0VfU0VYVUFMTFlfRVhQTElDSVRcIl0gPSBcIkhBUk1fQ0FURUdPUllfSU1BR0VfU0VYVUFMTFlfRVhQTElDSVRcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgaGFybSBjYXRlZ29yeSBpcyBmb3IgamFpbGJyZWFrIHByb21wdHMuIFRoaXMgZW51bSB2YWx1ZSBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuXG4gICAgICovXG4gICAgSGFybUNhdGVnb3J5W1wiSEFSTV9DQVRFR09SWV9KQUlMQlJFQUtcIl0gPSBcIkhBUk1fQ0FURUdPUllfSkFJTEJSRUFLXCI7XG59KShIYXJtQ2F0ZWdvcnkgfHwgKEhhcm1DYXRlZ29yeSA9IHt9KSk7XG4vKiogU3BlY2lmeSBpZiB0aGUgdGhyZXNob2xkIGlzIHVzZWQgZm9yIHByb2JhYmlsaXR5IG9yIHNldmVyaXR5IHNjb3JlLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgdGhyZXNob2xkIGlzIHVzZWQgZm9yIHByb2JhYmlsaXR5IHNjb3JlLiBUaGlzIGVudW0gaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLiAqL1xudmFyIEhhcm1CbG9ja01ldGhvZDtcbihmdW5jdGlvbiAoSGFybUJsb2NrTWV0aG9kKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGhhcm0gYmxvY2sgbWV0aG9kIGlzIHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIEhhcm1CbG9ja01ldGhvZFtcIkhBUk1fQkxPQ0tfTUVUSE9EX1VOU1BFQ0lGSUVEXCJdID0gXCJIQVJNX0JMT0NLX01FVEhPRF9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBoYXJtIGJsb2NrIG1ldGhvZCB1c2VzIGJvdGggcHJvYmFiaWxpdHkgYW5kIHNldmVyaXR5IHNjb3Jlcy5cbiAgICAgKi9cbiAgICBIYXJtQmxvY2tNZXRob2RbXCJTRVZFUklUWVwiXSA9IFwiU0VWRVJJVFlcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgaGFybSBibG9jayBtZXRob2QgdXNlcyB0aGUgcHJvYmFiaWxpdHkgc2NvcmUuXG4gICAgICovXG4gICAgSGFybUJsb2NrTWV0aG9kW1wiUFJPQkFCSUxJVFlcIl0gPSBcIlBST0JBQklMSVRZXCI7XG59KShIYXJtQmxvY2tNZXRob2QgfHwgKEhhcm1CbG9ja01ldGhvZCA9IHt9KSk7XG4vKiogVGhlIGhhcm0gYmxvY2sgdGhyZXNob2xkLiAqL1xudmFyIEhhcm1CbG9ja1RocmVzaG9sZDtcbihmdW5jdGlvbiAoSGFybUJsb2NrVGhyZXNob2xkKSB7XG4gICAgLyoqXG4gICAgICogVW5zcGVjaWZpZWQgaGFybSBibG9jayB0aHJlc2hvbGQuXG4gICAgICovXG4gICAgSGFybUJsb2NrVGhyZXNob2xkW1wiSEFSTV9CTE9DS19USFJFU0hPTERfVU5TUEVDSUZJRURcIl0gPSBcIkhBUk1fQkxPQ0tfVEhSRVNIT0xEX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogQmxvY2sgbG93IHRocmVzaG9sZCBhbmQgYWJvdmUgKGkuZS4gYmxvY2sgbW9yZSkuXG4gICAgICovXG4gICAgSGFybUJsb2NrVGhyZXNob2xkW1wiQkxPQ0tfTE9XX0FORF9BQk9WRVwiXSA9IFwiQkxPQ0tfTE9XX0FORF9BQk9WRVwiO1xuICAgIC8qKlxuICAgICAqIEJsb2NrIG1lZGl1bSB0aHJlc2hvbGQgYW5kIGFib3ZlLlxuICAgICAqL1xuICAgIEhhcm1CbG9ja1RocmVzaG9sZFtcIkJMT0NLX01FRElVTV9BTkRfQUJPVkVcIl0gPSBcIkJMT0NLX01FRElVTV9BTkRfQUJPVkVcIjtcbiAgICAvKipcbiAgICAgKiBCbG9jayBvbmx5IGhpZ2ggdGhyZXNob2xkIChpLmUuIGJsb2NrIGxlc3MpLlxuICAgICAqL1xuICAgIEhhcm1CbG9ja1RocmVzaG9sZFtcIkJMT0NLX09OTFlfSElHSFwiXSA9IFwiQkxPQ0tfT05MWV9ISUdIXCI7XG4gICAgLyoqXG4gICAgICogQmxvY2sgbm9uZS5cbiAgICAgKi9cbiAgICBIYXJtQmxvY2tUaHJlc2hvbGRbXCJCTE9DS19OT05FXCJdID0gXCJCTE9DS19OT05FXCI7XG4gICAgLyoqXG4gICAgICogVHVybiBvZmYgdGhlIHNhZmV0eSBmaWx0ZXIuXG4gICAgICovXG4gICAgSGFybUJsb2NrVGhyZXNob2xkW1wiT0ZGXCJdID0gXCJPRkZcIjtcbn0pKEhhcm1CbG9ja1RocmVzaG9sZCB8fCAoSGFybUJsb2NrVGhyZXNob2xkID0ge30pKTtcbi8qKiBPdXRwdXQgb25seS4gVGhlIHJlYXNvbiB3aHkgdGhlIG1vZGVsIHN0b3BwZWQgZ2VuZXJhdGluZyB0b2tlbnMuXG5cbklmIGVtcHR5LCB0aGUgbW9kZWwgaGFzIG5vdCBzdG9wcGVkIGdlbmVyYXRpbmcgdGhlIHRva2Vucy4gKi9cbnZhciBGaW5pc2hSZWFzb247XG4oZnVuY3Rpb24gKEZpbmlzaFJlYXNvbikge1xuICAgIC8qKlxuICAgICAqIFRoZSBmaW5pc2ggcmVhc29uIGlzIHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIEZpbmlzaFJlYXNvbltcIkZJTklTSF9SRUFTT05fVU5TUEVDSUZJRURcIl0gPSBcIkZJTklTSF9SRUFTT05fVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBUb2tlbiBnZW5lcmF0aW9uIHJlYWNoZWQgYSBuYXR1cmFsIHN0b3BwaW5nIHBvaW50IG9yIGEgY29uZmlndXJlZCBzdG9wIHNlcXVlbmNlLlxuICAgICAqL1xuICAgIEZpbmlzaFJlYXNvbltcIlNUT1BcIl0gPSBcIlNUT1BcIjtcbiAgICAvKipcbiAgICAgKiBUb2tlbiBnZW5lcmF0aW9uIHJlYWNoZWQgdGhlIGNvbmZpZ3VyZWQgbWF4aW11bSBvdXRwdXQgdG9rZW5zLlxuICAgICAqL1xuICAgIEZpbmlzaFJlYXNvbltcIk1BWF9UT0tFTlNcIl0gPSBcIk1BWF9UT0tFTlNcIjtcbiAgICAvKipcbiAgICAgKiBUb2tlbiBnZW5lcmF0aW9uIHN0b3BwZWQgYmVjYXVzZSB0aGUgY29udGVudCBwb3RlbnRpYWxseSBjb250YWlucyBzYWZldHkgdmlvbGF0aW9ucy4gTk9URTogV2hlbiBzdHJlYW1pbmcsIFtjb250ZW50XVtdIGlzIGVtcHR5IGlmIGNvbnRlbnQgZmlsdGVycyBibG9ja3MgdGhlIG91dHB1dC5cbiAgICAgKi9cbiAgICBGaW5pc2hSZWFzb25bXCJTQUZFVFlcIl0gPSBcIlNBRkVUWVwiO1xuICAgIC8qKlxuICAgICAqIFRoZSB0b2tlbiBnZW5lcmF0aW9uIHN0b3BwZWQgYmVjYXVzZSBvZiBwb3RlbnRpYWwgcmVjaXRhdGlvbi5cbiAgICAgKi9cbiAgICBGaW5pc2hSZWFzb25bXCJSRUNJVEFUSU9OXCJdID0gXCJSRUNJVEFUSU9OXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHRva2VuIGdlbmVyYXRpb24gc3RvcHBlZCBiZWNhdXNlIG9mIHVzaW5nIGFuIHVuc3VwcG9ydGVkIGxhbmd1YWdlLlxuICAgICAqL1xuICAgIEZpbmlzaFJlYXNvbltcIkxBTkdVQUdFXCJdID0gXCJMQU5HVUFHRVwiO1xuICAgIC8qKlxuICAgICAqIEFsbCBvdGhlciByZWFzb25zIHRoYXQgc3RvcHBlZCB0aGUgdG9rZW4gZ2VuZXJhdGlvbi5cbiAgICAgKi9cbiAgICBGaW5pc2hSZWFzb25bXCJPVEhFUlwiXSA9IFwiT1RIRVJcIjtcbiAgICAvKipcbiAgICAgKiBUb2tlbiBnZW5lcmF0aW9uIHN0b3BwZWQgYmVjYXVzZSB0aGUgY29udGVudCBjb250YWlucyBmb3JiaWRkZW4gdGVybXMuXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiQkxPQ0tMSVNUXCJdID0gXCJCTE9DS0xJU1RcIjtcbiAgICAvKipcbiAgICAgKiBUb2tlbiBnZW5lcmF0aW9uIHN0b3BwZWQgZm9yIHBvdGVudGlhbGx5IGNvbnRhaW5pbmcgcHJvaGliaXRlZCBjb250ZW50LlxuICAgICAqL1xuICAgIEZpbmlzaFJlYXNvbltcIlBST0hJQklURURfQ09OVEVOVFwiXSA9IFwiUFJPSElCSVRFRF9DT05URU5UXCI7XG4gICAgLyoqXG4gICAgICogVG9rZW4gZ2VuZXJhdGlvbiBzdG9wcGVkIGJlY2F1c2UgdGhlIGNvbnRlbnQgcG90ZW50aWFsbHkgY29udGFpbnMgU2Vuc2l0aXZlIFBlcnNvbmFsbHkgSWRlbnRpZmlhYmxlIEluZm9ybWF0aW9uIChTUElJKS5cbiAgICAgKi9cbiAgICBGaW5pc2hSZWFzb25bXCJTUElJXCJdID0gXCJTUElJXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGZ1bmN0aW9uIGNhbGwgZ2VuZXJhdGVkIGJ5IHRoZSBtb2RlbCBpcyBpbnZhbGlkLlxuICAgICAqL1xuICAgIEZpbmlzaFJlYXNvbltcIk1BTEZPUk1FRF9GVU5DVElPTl9DQUxMXCJdID0gXCJNQUxGT1JNRURfRlVOQ1RJT05fQ0FMTFwiO1xuICAgIC8qKlxuICAgICAqIFRva2VuIGdlbmVyYXRpb24gc3RvcHBlZCBiZWNhdXNlIGdlbmVyYXRlZCBpbWFnZXMgaGF2ZSBzYWZldHkgdmlvbGF0aW9ucy5cbiAgICAgKi9cbiAgICBGaW5pc2hSZWFzb25bXCJJTUFHRV9TQUZFVFlcIl0gPSBcIklNQUdFX1NBRkVUWVwiO1xuICAgIC8qKlxuICAgICAqIFRoZSB0b29sIGNhbGwgZ2VuZXJhdGVkIGJ5IHRoZSBtb2RlbCBpcyBpbnZhbGlkLlxuICAgICAqL1xuICAgIEZpbmlzaFJlYXNvbltcIlVORVhQRUNURURfVE9PTF9DQUxMXCJdID0gXCJVTkVYUEVDVEVEX1RPT0xfQ0FMTFwiO1xuICAgIC8qKlxuICAgICAqIEltYWdlIGdlbmVyYXRpb24gc3RvcHBlZCBiZWNhdXNlIHRoZSBnZW5lcmF0ZWQgaW1hZ2VzIGhhdmUgcHJvaGliaXRlZCBjb250ZW50LlxuICAgICAqL1xuICAgIEZpbmlzaFJlYXNvbltcIklNQUdFX1BST0hJQklURURfQ09OVEVOVFwiXSA9IFwiSU1BR0VfUFJPSElCSVRFRF9DT05URU5UXCI7XG4gICAgLyoqXG4gICAgICogVGhlIG1vZGVsIHdhcyBleHBlY3RlZCB0byBnZW5lcmF0ZSBhbiBpbWFnZSwgYnV0IG5vbmUgd2FzIGdlbmVyYXRlZC5cbiAgICAgKi9cbiAgICBGaW5pc2hSZWFzb25bXCJOT19JTUFHRVwiXSA9IFwiTk9fSU1BR0VcIjtcbn0pKEZpbmlzaFJlYXNvbiB8fCAoRmluaXNoUmVhc29uID0ge30pKTtcbi8qKiBPdXRwdXQgb25seS4gSGFybSBwcm9iYWJpbGl0eSBsZXZlbHMgaW4gdGhlIGNvbnRlbnQuICovXG52YXIgSGFybVByb2JhYmlsaXR5O1xuKGZ1bmN0aW9uIChIYXJtUHJvYmFiaWxpdHkpIHtcbiAgICAvKipcbiAgICAgKiBIYXJtIHByb2JhYmlsaXR5IHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIEhhcm1Qcm9iYWJpbGl0eVtcIkhBUk1fUFJPQkFCSUxJVFlfVU5TUEVDSUZJRURcIl0gPSBcIkhBUk1fUFJPQkFCSUxJVFlfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBOZWdsaWdpYmxlIGxldmVsIG9mIGhhcm0uXG4gICAgICovXG4gICAgSGFybVByb2JhYmlsaXR5W1wiTkVHTElHSUJMRVwiXSA9IFwiTkVHTElHSUJMRVwiO1xuICAgIC8qKlxuICAgICAqIExvdyBsZXZlbCBvZiBoYXJtLlxuICAgICAqL1xuICAgIEhhcm1Qcm9iYWJpbGl0eVtcIkxPV1wiXSA9IFwiTE9XXCI7XG4gICAgLyoqXG4gICAgICogTWVkaXVtIGxldmVsIG9mIGhhcm0uXG4gICAgICovXG4gICAgSGFybVByb2JhYmlsaXR5W1wiTUVESVVNXCJdID0gXCJNRURJVU1cIjtcbiAgICAvKipcbiAgICAgKiBIaWdoIGxldmVsIG9mIGhhcm0uXG4gICAgICovXG4gICAgSGFybVByb2JhYmlsaXR5W1wiSElHSFwiXSA9IFwiSElHSFwiO1xufSkoSGFybVByb2JhYmlsaXR5IHx8IChIYXJtUHJvYmFiaWxpdHkgPSB7fSkpO1xuLyoqIE91dHB1dCBvbmx5LiBIYXJtIHNldmVyaXR5IGxldmVscyBpbiB0aGUgY29udGVudC4gVGhpcyBlbnVtIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4gKi9cbnZhciBIYXJtU2V2ZXJpdHk7XG4oZnVuY3Rpb24gKEhhcm1TZXZlcml0eSkge1xuICAgIC8qKlxuICAgICAqIEhhcm0gc2V2ZXJpdHkgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgSGFybVNldmVyaXR5W1wiSEFSTV9TRVZFUklUWV9VTlNQRUNJRklFRFwiXSA9IFwiSEFSTV9TRVZFUklUWV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIE5lZ2xpZ2libGUgbGV2ZWwgb2YgaGFybSBzZXZlcml0eS5cbiAgICAgKi9cbiAgICBIYXJtU2V2ZXJpdHlbXCJIQVJNX1NFVkVSSVRZX05FR0xJR0lCTEVcIl0gPSBcIkhBUk1fU0VWRVJJVFlfTkVHTElHSUJMRVwiO1xuICAgIC8qKlxuICAgICAqIExvdyBsZXZlbCBvZiBoYXJtIHNldmVyaXR5LlxuICAgICAqL1xuICAgIEhhcm1TZXZlcml0eVtcIkhBUk1fU0VWRVJJVFlfTE9XXCJdID0gXCJIQVJNX1NFVkVSSVRZX0xPV1wiO1xuICAgIC8qKlxuICAgICAqIE1lZGl1bSBsZXZlbCBvZiBoYXJtIHNldmVyaXR5LlxuICAgICAqL1xuICAgIEhhcm1TZXZlcml0eVtcIkhBUk1fU0VWRVJJVFlfTUVESVVNXCJdID0gXCJIQVJNX1NFVkVSSVRZX01FRElVTVwiO1xuICAgIC8qKlxuICAgICAqIEhpZ2ggbGV2ZWwgb2YgaGFybSBzZXZlcml0eS5cbiAgICAgKi9cbiAgICBIYXJtU2V2ZXJpdHlbXCJIQVJNX1NFVkVSSVRZX0hJR0hcIl0gPSBcIkhBUk1fU0VWRVJJVFlfSElHSFwiO1xufSkoSGFybVNldmVyaXR5IHx8IChIYXJtU2V2ZXJpdHkgPSB7fSkpO1xuLyoqIFN0YXR1cyBvZiB0aGUgdXJsIHJldHJpZXZhbC4gKi9cbnZhciBVcmxSZXRyaWV2YWxTdGF0dXM7XG4oZnVuY3Rpb24gKFVybFJldHJpZXZhbFN0YXR1cykge1xuICAgIC8qKlxuICAgICAqIERlZmF1bHQgdmFsdWUuIFRoaXMgdmFsdWUgaXMgdW51c2VkLlxuICAgICAqL1xuICAgIFVybFJldHJpZXZhbFN0YXR1c1tcIlVSTF9SRVRSSUVWQUxfU1RBVFVTX1VOU1BFQ0lGSUVEXCJdID0gXCJVUkxfUkVUUklFVkFMX1NUQVRVU19VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIFVybCByZXRyaWV2YWwgaXMgc3VjY2Vzc2Z1bC5cbiAgICAgKi9cbiAgICBVcmxSZXRyaWV2YWxTdGF0dXNbXCJVUkxfUkVUUklFVkFMX1NUQVRVU19TVUNDRVNTXCJdID0gXCJVUkxfUkVUUklFVkFMX1NUQVRVU19TVUNDRVNTXCI7XG4gICAgLyoqXG4gICAgICogVXJsIHJldHJpZXZhbCBpcyBmYWlsZWQgZHVlIHRvIGVycm9yLlxuICAgICAqL1xuICAgIFVybFJldHJpZXZhbFN0YXR1c1tcIlVSTF9SRVRSSUVWQUxfU1RBVFVTX0VSUk9SXCJdID0gXCJVUkxfUkVUUklFVkFMX1NUQVRVU19FUlJPUlwiO1xuICAgIC8qKlxuICAgICAqIFVybCByZXRyaWV2YWwgaXMgZmFpbGVkIGJlY2F1c2UgdGhlIGNvbnRlbnQgaXMgYmVoaW5kIHBheXdhbGwuIFRoaXMgZW51bSB2YWx1ZSBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS5cbiAgICAgKi9cbiAgICBVcmxSZXRyaWV2YWxTdGF0dXNbXCJVUkxfUkVUUklFVkFMX1NUQVRVU19QQVlXQUxMXCJdID0gXCJVUkxfUkVUUklFVkFMX1NUQVRVU19QQVlXQUxMXCI7XG4gICAgLyoqXG4gICAgICogVXJsIHJldHJpZXZhbCBpcyBmYWlsZWQgYmVjYXVzZSB0aGUgY29udGVudCBpcyB1bnNhZmUuIFRoaXMgZW51bSB2YWx1ZSBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS5cbiAgICAgKi9cbiAgICBVcmxSZXRyaWV2YWxTdGF0dXNbXCJVUkxfUkVUUklFVkFMX1NUQVRVU19VTlNBRkVcIl0gPSBcIlVSTF9SRVRSSUVWQUxfU1RBVFVTX1VOU0FGRVwiO1xufSkoVXJsUmV0cmlldmFsU3RhdHVzIHx8IChVcmxSZXRyaWV2YWxTdGF0dXMgPSB7fSkpO1xuLyoqIE91dHB1dCBvbmx5LiBUaGUgcmVhc29uIHdoeSB0aGUgcHJvbXB0IHdhcyBibG9ja2VkLiAqL1xudmFyIEJsb2NrZWRSZWFzb247XG4oZnVuY3Rpb24gKEJsb2NrZWRSZWFzb24pIHtcbiAgICAvKipcbiAgICAgKiBUaGUgYmxvY2tlZCByZWFzb24gaXMgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgQmxvY2tlZFJlYXNvbltcIkJMT0NLRURfUkVBU09OX1VOU1BFQ0lGSUVEXCJdID0gXCJCTE9DS0VEX1JFQVNPTl9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBwcm9tcHQgd2FzIGJsb2NrZWQgZm9yIHNhZmV0eSByZWFzb25zLlxuICAgICAqL1xuICAgIEJsb2NrZWRSZWFzb25bXCJTQUZFVFlcIl0gPSBcIlNBRkVUWVwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBwcm9tcHQgd2FzIGJsb2NrZWQgZm9yIG90aGVyIHJlYXNvbnMuIEZvciBleGFtcGxlLCBpdCBtYXkgYmUgZHVlIHRvIHRoZSBwcm9tcHQncyBsYW5ndWFnZSwgb3IgYmVjYXVzZSBpdCBjb250YWlucyBvdGhlciBoYXJtZnVsIGNvbnRlbnQuXG4gICAgICovXG4gICAgQmxvY2tlZFJlYXNvbltcIk9USEVSXCJdID0gXCJPVEhFUlwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBwcm9tcHQgd2FzIGJsb2NrZWQgYmVjYXVzZSBpdCBjb250YWlucyBhIHRlcm0gZnJvbSB0aGUgdGVybWlub2xvZ3kgYmxvY2tsaXN0LlxuICAgICAqL1xuICAgIEJsb2NrZWRSZWFzb25bXCJCTE9DS0xJU1RcIl0gPSBcIkJMT0NLTElTVFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBwcm9tcHQgd2FzIGJsb2NrZWQgYmVjYXVzZSBpdCBjb250YWlucyBwcm9oaWJpdGVkIGNvbnRlbnQuXG4gICAgICovXG4gICAgQmxvY2tlZFJlYXNvbltcIlBST0hJQklURURfQ09OVEVOVFwiXSA9IFwiUFJPSElCSVRFRF9DT05URU5UXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHByb21wdCB3YXMgYmxvY2tlZCBiZWNhdXNlIGl0IGNvbnRhaW5zIGNvbnRlbnQgdGhhdCBpcyB1bnNhZmUgZm9yIGltYWdlIGdlbmVyYXRpb24uXG4gICAgICovXG4gICAgQmxvY2tlZFJlYXNvbltcIklNQUdFX1NBRkVUWVwiXSA9IFwiSU1BR0VfU0FGRVRZXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHByb21wdCB3YXMgYmxvY2tlZCBieSBNb2RlbCBBcm1vci4gVGhpcyBlbnVtIHZhbHVlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS5cbiAgICAgKi9cbiAgICBCbG9ja2VkUmVhc29uW1wiTU9ERUxfQVJNT1JcIl0gPSBcIk1PREVMX0FSTU9SXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHByb21wdCB3YXMgYmxvY2tlZCBhcyBhIGphaWxicmVhayBhdHRlbXB0LiBUaGlzIGVudW0gdmFsdWUgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLlxuICAgICAqL1xuICAgIEJsb2NrZWRSZWFzb25bXCJKQUlMQlJFQUtcIl0gPSBcIkpBSUxCUkVBS1wiO1xufSkoQmxvY2tlZFJlYXNvbiB8fCAoQmxvY2tlZFJlYXNvbiA9IHt9KSk7XG4vKiogT3V0cHV0IG9ubHkuIFRoZSB0cmFmZmljIHR5cGUgZm9yIHRoaXMgcmVxdWVzdC4gVGhpcyBlbnVtIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4gKi9cbnZhciBUcmFmZmljVHlwZTtcbihmdW5jdGlvbiAoVHJhZmZpY1R5cGUpIHtcbiAgICAvKipcbiAgICAgKiBVbnNwZWNpZmllZCByZXF1ZXN0IHRyYWZmaWMgdHlwZS5cbiAgICAgKi9cbiAgICBUcmFmZmljVHlwZVtcIlRSQUZGSUNfVFlQRV9VTlNQRUNJRklFRFwiXSA9IFwiVFJBRkZJQ19UWVBFX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHJlcXVlc3Qgd2FzIHByb2Nlc3NlZCB1c2luZyBQYXktQXMtWW91LUdvIHF1b3RhLlxuICAgICAqL1xuICAgIFRyYWZmaWNUeXBlW1wiT05fREVNQU5EXCJdID0gXCJPTl9ERU1BTkRcIjtcbiAgICAvKipcbiAgICAgKiBUeXBlIGZvciBQcm92aXNpb25lZCBUaHJvdWdocHV0IHRyYWZmaWMuXG4gICAgICovXG4gICAgVHJhZmZpY1R5cGVbXCJQUk9WSVNJT05FRF9USFJPVUdIUFVUXCJdID0gXCJQUk9WSVNJT05FRF9USFJPVUdIUFVUXCI7XG59KShUcmFmZmljVHlwZSB8fCAoVHJhZmZpY1R5cGUgPSB7fSkpO1xuLyoqIFNlcnZlciBjb250ZW50IG1vZGFsaXRpZXMuICovXG52YXIgTW9kYWxpdHk7XG4oZnVuY3Rpb24gKE1vZGFsaXR5KSB7XG4gICAgLyoqXG4gICAgICogVGhlIG1vZGFsaXR5IGlzIHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIE1vZGFsaXR5W1wiTU9EQUxJVFlfVU5TUEVDSUZJRURcIl0gPSBcIk1PREFMSVRZX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoZSBtb2RlbCBzaG91bGQgcmV0dXJuIHRleHRcbiAgICAgKi9cbiAgICBNb2RhbGl0eVtcIlRFWFRcIl0gPSBcIlRFWFRcIjtcbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhlIG1vZGVsIHNob3VsZCByZXR1cm4gaW1hZ2VzLlxuICAgICAqL1xuICAgIE1vZGFsaXR5W1wiSU1BR0VcIl0gPSBcIklNQUdFXCI7XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoZSBtb2RlbCBzaG91bGQgcmV0dXJuIGF1ZGlvLlxuICAgICAqL1xuICAgIE1vZGFsaXR5W1wiQVVESU9cIl0gPSBcIkFVRElPXCI7XG59KShNb2RhbGl0eSB8fCAoTW9kYWxpdHkgPSB7fSkpO1xuLyoqIFRoZSBtZWRpYSByZXNvbHV0aW9uIHRvIHVzZS4gKi9cbnZhciBNZWRpYVJlc29sdXRpb247XG4oZnVuY3Rpb24gKE1lZGlhUmVzb2x1dGlvbikge1xuICAgIC8qKlxuICAgICAqIE1lZGlhIHJlc29sdXRpb24gaGFzIG5vdCBiZWVuIHNldFxuICAgICAqL1xuICAgIE1lZGlhUmVzb2x1dGlvbltcIk1FRElBX1JFU09MVVRJT05fVU5TUEVDSUZJRURcIl0gPSBcIk1FRElBX1JFU09MVVRJT05fVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBNZWRpYSByZXNvbHV0aW9uIHNldCB0byBsb3cgKDY0IHRva2VucykuXG4gICAgICovXG4gICAgTWVkaWFSZXNvbHV0aW9uW1wiTUVESUFfUkVTT0xVVElPTl9MT1dcIl0gPSBcIk1FRElBX1JFU09MVVRJT05fTE9XXCI7XG4gICAgLyoqXG4gICAgICogTWVkaWEgcmVzb2x1dGlvbiBzZXQgdG8gbWVkaXVtICgyNTYgdG9rZW5zKS5cbiAgICAgKi9cbiAgICBNZWRpYVJlc29sdXRpb25bXCJNRURJQV9SRVNPTFVUSU9OX01FRElVTVwiXSA9IFwiTUVESUFfUkVTT0xVVElPTl9NRURJVU1cIjtcbiAgICAvKipcbiAgICAgKiBNZWRpYSByZXNvbHV0aW9uIHNldCB0byBoaWdoICh6b29tZWQgcmVmcmFtaW5nIHdpdGggMjU2IHRva2VucykuXG4gICAgICovXG4gICAgTWVkaWFSZXNvbHV0aW9uW1wiTUVESUFfUkVTT0xVVElPTl9ISUdIXCJdID0gXCJNRURJQV9SRVNPTFVUSU9OX0hJR0hcIjtcbn0pKE1lZGlhUmVzb2x1dGlvbiB8fCAoTWVkaWFSZXNvbHV0aW9uID0ge30pKTtcbi8qKiBUdW5pbmcgbW9kZS4gVGhpcyBlbnVtIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4gKi9cbnZhciBUdW5pbmdNb2RlO1xuKGZ1bmN0aW9uIChUdW5pbmdNb2RlKSB7XG4gICAgLyoqXG4gICAgICogVHVuaW5nIG1vZGUgaXMgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgVHVuaW5nTW9kZVtcIlRVTklOR19NT0RFX1VOU1BFQ0lGSUVEXCJdID0gXCJUVU5JTkdfTU9ERV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIEZ1bGwgZmluZS10dW5pbmcgbW9kZS5cbiAgICAgKi9cbiAgICBUdW5pbmdNb2RlW1wiVFVOSU5HX01PREVfRlVMTFwiXSA9IFwiVFVOSU5HX01PREVfRlVMTFwiO1xuICAgIC8qKlxuICAgICAqIFBFRlQgYWRhcHRlciB0dW5pbmcgbW9kZS5cbiAgICAgKi9cbiAgICBUdW5pbmdNb2RlW1wiVFVOSU5HX01PREVfUEVGVF9BREFQVEVSXCJdID0gXCJUVU5JTkdfTU9ERV9QRUZUX0FEQVBURVJcIjtcbn0pKFR1bmluZ01vZGUgfHwgKFR1bmluZ01vZGUgPSB7fSkpO1xuLyoqIEFkYXB0ZXIgc2l6ZSBmb3IgdHVuaW5nLiBUaGlzIGVudW0gaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLiAqL1xudmFyIEFkYXB0ZXJTaXplO1xuKGZ1bmN0aW9uIChBZGFwdGVyU2l6ZSkge1xuICAgIC8qKlxuICAgICAqIEFkYXB0ZXIgc2l6ZSBpcyB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBBZGFwdGVyU2l6ZVtcIkFEQVBURVJfU0laRV9VTlNQRUNJRklFRFwiXSA9IFwiQURBUFRFUl9TSVpFX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogQWRhcHRlciBzaXplIDEuXG4gICAgICovXG4gICAgQWRhcHRlclNpemVbXCJBREFQVEVSX1NJWkVfT05FXCJdID0gXCJBREFQVEVSX1NJWkVfT05FXCI7XG4gICAgLyoqXG4gICAgICogQWRhcHRlciBzaXplIDIuXG4gICAgICovXG4gICAgQWRhcHRlclNpemVbXCJBREFQVEVSX1NJWkVfVFdPXCJdID0gXCJBREFQVEVSX1NJWkVfVFdPXCI7XG4gICAgLyoqXG4gICAgICogQWRhcHRlciBzaXplIDQuXG4gICAgICovXG4gICAgQWRhcHRlclNpemVbXCJBREFQVEVSX1NJWkVfRk9VUlwiXSA9IFwiQURBUFRFUl9TSVpFX0ZPVVJcIjtcbiAgICAvKipcbiAgICAgKiBBZGFwdGVyIHNpemUgOC5cbiAgICAgKi9cbiAgICBBZGFwdGVyU2l6ZVtcIkFEQVBURVJfU0laRV9FSUdIVFwiXSA9IFwiQURBUFRFUl9TSVpFX0VJR0hUXCI7XG4gICAgLyoqXG4gICAgICogQWRhcHRlciBzaXplIDE2LlxuICAgICAqL1xuICAgIEFkYXB0ZXJTaXplW1wiQURBUFRFUl9TSVpFX1NJWFRFRU5cIl0gPSBcIkFEQVBURVJfU0laRV9TSVhURUVOXCI7XG4gICAgLyoqXG4gICAgICogQWRhcHRlciBzaXplIDMyLlxuICAgICAqL1xuICAgIEFkYXB0ZXJTaXplW1wiQURBUFRFUl9TSVpFX1RISVJUWV9UV09cIl0gPSBcIkFEQVBURVJfU0laRV9USElSVFlfVFdPXCI7XG59KShBZGFwdGVyU2l6ZSB8fCAoQWRhcHRlclNpemUgPSB7fSkpO1xuLyoqIEpvYiBzdGF0ZS4gKi9cbnZhciBKb2JTdGF0ZTtcbihmdW5jdGlvbiAoSm9iU3RhdGUpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgam9iIHN0YXRlIGlzIHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIEpvYlN0YXRlW1wiSk9CX1NUQVRFX1VOU1BFQ0lGSUVEXCJdID0gXCJKT0JfU1RBVEVfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgam9iIGhhcyBiZWVuIGp1c3QgY3JlYXRlZCBvciByZXN1bWVkIGFuZCBwcm9jZXNzaW5nIGhhcyBub3QgeWV0IGJlZ3VuLlxuICAgICAqL1xuICAgIEpvYlN0YXRlW1wiSk9CX1NUQVRFX1FVRVVFRFwiXSA9IFwiSk9CX1NUQVRFX1FVRVVFRFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBzZXJ2aWNlIGlzIHByZXBhcmluZyB0byBydW4gdGhlIGpvYi5cbiAgICAgKi9cbiAgICBKb2JTdGF0ZVtcIkpPQl9TVEFURV9QRU5ESU5HXCJdID0gXCJKT0JfU1RBVEVfUEVORElOR1wiO1xuICAgIC8qKlxuICAgICAqIFRoZSBqb2IgaXMgaW4gcHJvZ3Jlc3MuXG4gICAgICovXG4gICAgSm9iU3RhdGVbXCJKT0JfU1RBVEVfUlVOTklOR1wiXSA9IFwiSk9CX1NUQVRFX1JVTk5JTkdcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgam9iIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkuXG4gICAgICovXG4gICAgSm9iU3RhdGVbXCJKT0JfU1RBVEVfU1VDQ0VFREVEXCJdID0gXCJKT0JfU1RBVEVfU1VDQ0VFREVEXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGpvYiBmYWlsZWQuXG4gICAgICovXG4gICAgSm9iU3RhdGVbXCJKT0JfU1RBVEVfRkFJTEVEXCJdID0gXCJKT0JfU1RBVEVfRkFJTEVEXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGpvYiBpcyBiZWluZyBjYW5jZWxsZWQuIEZyb20gdGhpcyBzdGF0ZSB0aGUgam9iIG1heSBvbmx5IGdvIHRvIGVpdGhlciBgSk9CX1NUQVRFX1NVQ0NFRURFRGAsIGBKT0JfU1RBVEVfRkFJTEVEYCBvciBgSk9CX1NUQVRFX0NBTkNFTExFRGAuXG4gICAgICovXG4gICAgSm9iU3RhdGVbXCJKT0JfU1RBVEVfQ0FOQ0VMTElOR1wiXSA9IFwiSk9CX1NUQVRFX0NBTkNFTExJTkdcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgam9iIGhhcyBiZWVuIGNhbmNlbGxlZC5cbiAgICAgKi9cbiAgICBKb2JTdGF0ZVtcIkpPQl9TVEFURV9DQU5DRUxMRURcIl0gPSBcIkpPQl9TVEFURV9DQU5DRUxMRURcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgam9iIGhhcyBiZWVuIHN0b3BwZWQsIGFuZCBjYW4gYmUgcmVzdW1lZC5cbiAgICAgKi9cbiAgICBKb2JTdGF0ZVtcIkpPQl9TVEFURV9QQVVTRURcIl0gPSBcIkpPQl9TVEFURV9QQVVTRURcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgam9iIGhhcyBleHBpcmVkLlxuICAgICAqL1xuICAgIEpvYlN0YXRlW1wiSk9CX1NUQVRFX0VYUElSRURcIl0gPSBcIkpPQl9TVEFURV9FWFBJUkVEXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGpvYiBpcyBiZWluZyB1cGRhdGVkLiBPbmx5IGpvYnMgaW4gdGhlIGBKT0JfU1RBVEVfUlVOTklOR2Agc3RhdGUgY2FuIGJlIHVwZGF0ZWQuIEFmdGVyIHVwZGF0aW5nLCB0aGUgam9iIGdvZXMgYmFjayB0byB0aGUgYEpPQl9TVEFURV9SVU5OSU5HYCBzdGF0ZS5cbiAgICAgKi9cbiAgICBKb2JTdGF0ZVtcIkpPQl9TVEFURV9VUERBVElOR1wiXSA9IFwiSk9CX1NUQVRFX1VQREFUSU5HXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGpvYiBpcyBwYXJ0aWFsbHkgc3VjY2VlZGVkLCBzb21lIHJlc3VsdHMgbWF5IGJlIG1pc3NpbmcgZHVlIHRvIGVycm9ycy5cbiAgICAgKi9cbiAgICBKb2JTdGF0ZVtcIkpPQl9TVEFURV9QQVJUSUFMTFlfU1VDQ0VFREVEXCJdID0gXCJKT0JfU1RBVEVfUEFSVElBTExZX1NVQ0NFRURFRFwiO1xufSkoSm9iU3RhdGUgfHwgKEpvYlN0YXRlID0ge30pKTtcbi8qKiBUaGUgdHVuaW5nIHRhc2suIEVpdGhlciBJMlYgb3IgVDJWLiBUaGlzIGVudW0gaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLiAqL1xudmFyIFR1bmluZ1Rhc2s7XG4oZnVuY3Rpb24gKFR1bmluZ1Rhc2spIHtcbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHZhbHVlLiBUaGlzIHZhbHVlIGlzIHVudXNlZC5cbiAgICAgKi9cbiAgICBUdW5pbmdUYXNrW1wiVFVOSU5HX1RBU0tfVU5TUEVDSUZJRURcIl0gPSBcIlRVTklOR19UQVNLX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogVHVuaW5nIHRhc2sgZm9yIGltYWdlIHRvIHZpZGVvLlxuICAgICAqL1xuICAgIFR1bmluZ1Rhc2tbXCJUVU5JTkdfVEFTS19JMlZcIl0gPSBcIlRVTklOR19UQVNLX0kyVlwiO1xuICAgIC8qKlxuICAgICAqIFR1bmluZyB0YXNrIGZvciB0ZXh0IHRvIHZpZGVvLlxuICAgICAqL1xuICAgIFR1bmluZ1Rhc2tbXCJUVU5JTkdfVEFTS19UMlZcIl0gPSBcIlRVTklOR19UQVNLX1QyVlwiO1xuICAgIC8qKlxuICAgICAqIFR1bmluZyB0YXNrIGZvciByZWZlcmVuY2UgdG8gdmlkZW8uXG4gICAgICovXG4gICAgVHVuaW5nVGFza1tcIlRVTklOR19UQVNLX1IyVlwiXSA9IFwiVFVOSU5HX1RBU0tfUjJWXCI7XG59KShUdW5pbmdUYXNrIHx8IChUdW5pbmdUYXNrID0ge30pKTtcbi8qKiBUaGUgdG9rZW5pemF0aW9uIHF1YWxpdHkgdXNlZCBmb3IgZ2l2ZW4gbWVkaWEuICovXG52YXIgUGFydE1lZGlhUmVzb2x1dGlvbkxldmVsO1xuKGZ1bmN0aW9uIChQYXJ0TWVkaWFSZXNvbHV0aW9uTGV2ZWwpIHtcbiAgICAvKipcbiAgICAgKiBNZWRpYSByZXNvbHV0aW9uIGhhcyBub3QgYmVlbiBzZXQuXG4gICAgICovXG4gICAgUGFydE1lZGlhUmVzb2x1dGlvbkxldmVsW1wiTUVESUFfUkVTT0xVVElPTl9VTlNQRUNJRklFRFwiXSA9IFwiTUVESUFfUkVTT0xVVElPTl9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIE1lZGlhIHJlc29sdXRpb24gc2V0IHRvIGxvdy5cbiAgICAgKi9cbiAgICBQYXJ0TWVkaWFSZXNvbHV0aW9uTGV2ZWxbXCJNRURJQV9SRVNPTFVUSU9OX0xPV1wiXSA9IFwiTUVESUFfUkVTT0xVVElPTl9MT1dcIjtcbiAgICAvKipcbiAgICAgKiBNZWRpYSByZXNvbHV0aW9uIHNldCB0byBtZWRpdW0uXG4gICAgICovXG4gICAgUGFydE1lZGlhUmVzb2x1dGlvbkxldmVsW1wiTUVESUFfUkVTT0xVVElPTl9NRURJVU1cIl0gPSBcIk1FRElBX1JFU09MVVRJT05fTUVESVVNXCI7XG4gICAgLyoqXG4gICAgICogTWVkaWEgcmVzb2x1dGlvbiBzZXQgdG8gaGlnaC5cbiAgICAgKi9cbiAgICBQYXJ0TWVkaWFSZXNvbHV0aW9uTGV2ZWxbXCJNRURJQV9SRVNPTFVUSU9OX0hJR0hcIl0gPSBcIk1FRElBX1JFU09MVVRJT05fSElHSFwiO1xufSkoUGFydE1lZGlhUmVzb2x1dGlvbkxldmVsIHx8IChQYXJ0TWVkaWFSZXNvbHV0aW9uTGV2ZWwgPSB7fSkpO1xuLyoqIE9wdGlvbnMgZm9yIGZlYXR1cmUgc2VsZWN0aW9uIHByZWZlcmVuY2UuICovXG52YXIgRmVhdHVyZVNlbGVjdGlvblByZWZlcmVuY2U7XG4oZnVuY3Rpb24gKEZlYXR1cmVTZWxlY3Rpb25QcmVmZXJlbmNlKSB7XG4gICAgRmVhdHVyZVNlbGVjdGlvblByZWZlcmVuY2VbXCJGRUFUVVJFX1NFTEVDVElPTl9QUkVGRVJFTkNFX1VOU1BFQ0lGSUVEXCJdID0gXCJGRUFUVVJFX1NFTEVDVElPTl9QUkVGRVJFTkNFX1VOU1BFQ0lGSUVEXCI7XG4gICAgRmVhdHVyZVNlbGVjdGlvblByZWZlcmVuY2VbXCJQUklPUklUSVpFX1FVQUxJVFlcIl0gPSBcIlBSSU9SSVRJWkVfUVVBTElUWVwiO1xuICAgIEZlYXR1cmVTZWxlY3Rpb25QcmVmZXJlbmNlW1wiQkFMQU5DRURcIl0gPSBcIkJBTEFOQ0VEXCI7XG4gICAgRmVhdHVyZVNlbGVjdGlvblByZWZlcmVuY2VbXCJQUklPUklUSVpFX0NPU1RcIl0gPSBcIlBSSU9SSVRJWkVfQ09TVFwiO1xufSkoRmVhdHVyZVNlbGVjdGlvblByZWZlcmVuY2UgfHwgKEZlYXR1cmVTZWxlY3Rpb25QcmVmZXJlbmNlID0ge30pKTtcbi8qKiBEZWZpbmVzIHRoZSBmdW5jdGlvbiBiZWhhdmlvci4gRGVmYXVsdHMgdG8gYEJMT0NLSU5HYC4gKi9cbnZhciBCZWhhdmlvcjtcbihmdW5jdGlvbiAoQmVoYXZpb3IpIHtcbiAgICAvKipcbiAgICAgKiBUaGlzIHZhbHVlIGlzIHVudXNlZC5cbiAgICAgKi9cbiAgICBCZWhhdmlvcltcIlVOU1BFQ0lGSUVEXCJdID0gXCJVTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIElmIHNldCwgdGhlIHN5c3RlbSB3aWxsIHdhaXQgdG8gcmVjZWl2ZSB0aGUgZnVuY3Rpb24gcmVzcG9uc2UgYmVmb3JlIGNvbnRpbnVpbmcgdGhlIGNvbnZlcnNhdGlvbi5cbiAgICAgKi9cbiAgICBCZWhhdmlvcltcIkJMT0NLSU5HXCJdID0gXCJCTE9DS0lOR1wiO1xuICAgIC8qKlxuICAgICAqIElmIHNldCwgdGhlIHN5c3RlbSB3aWxsIG5vdCB3YWl0IHRvIHJlY2VpdmUgdGhlIGZ1bmN0aW9uIHJlc3BvbnNlLiBJbnN0ZWFkLCBpdCB3aWxsIGF0dGVtcHQgdG8gaGFuZGxlIGZ1bmN0aW9uIHJlc3BvbnNlcyBhcyB0aGV5IGJlY29tZSBhdmFpbGFibGUgd2hpbGUgbWFpbnRhaW5pbmcgdGhlIGNvbnZlcnNhdGlvbiBiZXR3ZWVuIHRoZSB1c2VyIGFuZCB0aGUgbW9kZWwuXG4gICAgICovXG4gICAgQmVoYXZpb3JbXCJOT05fQkxPQ0tJTkdcIl0gPSBcIk5PTl9CTE9DS0lOR1wiO1xufSkoQmVoYXZpb3IgfHwgKEJlaGF2aW9yID0ge30pKTtcbi8qKiBDb25maWcgZm9yIHRoZSBkeW5hbWljIHJldHJpZXZhbCBjb25maWcgbW9kZS4gKi9cbnZhciBEeW5hbWljUmV0cmlldmFsQ29uZmlnTW9kZTtcbihmdW5jdGlvbiAoRHluYW1pY1JldHJpZXZhbENvbmZpZ01vZGUpIHtcbiAgICAvKipcbiAgICAgKiBBbHdheXMgdHJpZ2dlciByZXRyaWV2YWwuXG4gICAgICovXG4gICAgRHluYW1pY1JldHJpZXZhbENvbmZpZ01vZGVbXCJNT0RFX1VOU1BFQ0lGSUVEXCJdID0gXCJNT0RFX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogUnVuIHJldHJpZXZhbCBvbmx5IHdoZW4gc3lzdGVtIGRlY2lkZXMgaXQgaXMgbmVjZXNzYXJ5LlxuICAgICAqL1xuICAgIER5bmFtaWNSZXRyaWV2YWxDb25maWdNb2RlW1wiTU9ERV9EWU5BTUlDXCJdID0gXCJNT0RFX0RZTkFNSUNcIjtcbn0pKER5bmFtaWNSZXRyaWV2YWxDb25maWdNb2RlIHx8IChEeW5hbWljUmV0cmlldmFsQ29uZmlnTW9kZSA9IHt9KSk7XG4vKiogVGhlIGVudmlyb25tZW50IGJlaW5nIG9wZXJhdGVkLiAqL1xudmFyIEVudmlyb25tZW50O1xuKGZ1bmN0aW9uIChFbnZpcm9ubWVudCkge1xuICAgIC8qKlxuICAgICAqIERlZmF1bHRzIHRvIGJyb3dzZXIuXG4gICAgICovXG4gICAgRW52aXJvbm1lbnRbXCJFTlZJUk9OTUVOVF9VTlNQRUNJRklFRFwiXSA9IFwiRU5WSVJPTk1FTlRfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBPcGVyYXRlcyBpbiBhIHdlYiBicm93c2VyLlxuICAgICAqL1xuICAgIEVudmlyb25tZW50W1wiRU5WSVJPTk1FTlRfQlJPV1NFUlwiXSA9IFwiRU5WSVJPTk1FTlRfQlJPV1NFUlwiO1xufSkoRW52aXJvbm1lbnQgfHwgKEVudmlyb25tZW50ID0ge30pKTtcbi8qKiBDb25maWcgZm9yIHRoZSBmdW5jdGlvbiBjYWxsaW5nIGNvbmZpZyBtb2RlLiAqL1xudmFyIEZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ01vZGU7XG4oZnVuY3Rpb24gKEZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ01vZGUpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgZnVuY3Rpb24gY2FsbGluZyBjb25maWcgbW9kZSBpcyB1bnNwZWNpZmllZC4gU2hvdWxkIG5vdCBiZSB1c2VkLlxuICAgICAqL1xuICAgIEZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ01vZGVbXCJNT0RFX1VOU1BFQ0lGSUVEXCJdID0gXCJNT0RFX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBtb2RlbCBiZWhhdmlvciwgbW9kZWwgZGVjaWRlcyB0byBwcmVkaWN0IGVpdGhlciBmdW5jdGlvbiBjYWxscyBvciBuYXR1cmFsIGxhbmd1YWdlIHJlc3BvbnNlLlxuICAgICAqL1xuICAgIEZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ01vZGVbXCJBVVRPXCJdID0gXCJBVVRPXCI7XG4gICAgLyoqXG4gICAgICogTW9kZWwgaXMgY29uc3RyYWluZWQgdG8gYWx3YXlzIHByZWRpY3RpbmcgZnVuY3Rpb24gY2FsbHMgb25seS4gSWYgXCJhbGxvd2VkX2Z1bmN0aW9uX25hbWVzXCIgYXJlIHNldCwgdGhlIHByZWRpY3RlZCBmdW5jdGlvbiBjYWxscyB3aWxsIGJlIGxpbWl0ZWQgdG8gYW55IG9uZSBvZiBcImFsbG93ZWRfZnVuY3Rpb25fbmFtZXNcIiwgZWxzZSB0aGUgcHJlZGljdGVkIGZ1bmN0aW9uIGNhbGxzIHdpbGwgYmUgYW55IG9uZSBvZiB0aGUgcHJvdmlkZWQgXCJmdW5jdGlvbl9kZWNsYXJhdGlvbnNcIi5cbiAgICAgKi9cbiAgICBGdW5jdGlvbkNhbGxpbmdDb25maWdNb2RlW1wiQU5ZXCJdID0gXCJBTllcIjtcbiAgICAvKipcbiAgICAgKiBNb2RlbCB3aWxsIG5vdCBwcmVkaWN0IGFueSBmdW5jdGlvbiBjYWxscy4gTW9kZWwgYmVoYXZpb3IgaXMgc2FtZSBhcyB3aGVuIG5vdCBwYXNzaW5nIGFueSBmdW5jdGlvbiBkZWNsYXJhdGlvbnMuXG4gICAgICovXG4gICAgRnVuY3Rpb25DYWxsaW5nQ29uZmlnTW9kZVtcIk5PTkVcIl0gPSBcIk5PTkVcIjtcbiAgICAvKipcbiAgICAgKiBNb2RlbCBkZWNpZGVzIHRvIHByZWRpY3QgZWl0aGVyIGEgZnVuY3Rpb24gY2FsbCBvciBhIG5hdHVyYWwgbGFuZ3VhZ2UgcmVzcG9uc2UsIGJ1dCB3aWxsIHZhbGlkYXRlIGZ1bmN0aW9uIGNhbGxzIHdpdGggY29uc3RyYWluZWQgZGVjb2RpbmcuIElmIFwiYWxsb3dlZF9mdW5jdGlvbl9uYW1lc1wiIGFyZSBzZXQsIHRoZSBwcmVkaWN0ZWQgZnVuY3Rpb24gY2FsbCB3aWxsIGJlIGxpbWl0ZWQgdG8gYW55IG9uZSBvZiBcImFsbG93ZWRfZnVuY3Rpb25fbmFtZXNcIiwgZWxzZSB0aGUgcHJlZGljdGVkIGZ1bmN0aW9uIGNhbGwgd2lsbCBiZSBhbnkgb25lIG9mIHRoZSBwcm92aWRlZCBcImZ1bmN0aW9uX2RlY2xhcmF0aW9uc1wiLlxuICAgICAqL1xuICAgIEZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ01vZGVbXCJWQUxJREFURURcIl0gPSBcIlZBTElEQVRFRFwiO1xufSkoRnVuY3Rpb25DYWxsaW5nQ29uZmlnTW9kZSB8fCAoRnVuY3Rpb25DYWxsaW5nQ29uZmlnTW9kZSA9IHt9KSk7XG4vKiogRW51bSB0aGF0IGNvbnRyb2xzIHRoZSBzYWZldHkgZmlsdGVyIGxldmVsIGZvciBvYmplY3Rpb25hYmxlIGNvbnRlbnQuICovXG52YXIgU2FmZXR5RmlsdGVyTGV2ZWw7XG4oZnVuY3Rpb24gKFNhZmV0eUZpbHRlckxldmVsKSB7XG4gICAgU2FmZXR5RmlsdGVyTGV2ZWxbXCJCTE9DS19MT1dfQU5EX0FCT1ZFXCJdID0gXCJCTE9DS19MT1dfQU5EX0FCT1ZFXCI7XG4gICAgU2FmZXR5RmlsdGVyTGV2ZWxbXCJCTE9DS19NRURJVU1fQU5EX0FCT1ZFXCJdID0gXCJCTE9DS19NRURJVU1fQU5EX0FCT1ZFXCI7XG4gICAgU2FmZXR5RmlsdGVyTGV2ZWxbXCJCTE9DS19PTkxZX0hJR0hcIl0gPSBcIkJMT0NLX09OTFlfSElHSFwiO1xuICAgIFNhZmV0eUZpbHRlckxldmVsW1wiQkxPQ0tfTk9ORVwiXSA9IFwiQkxPQ0tfTk9ORVwiO1xufSkoU2FmZXR5RmlsdGVyTGV2ZWwgfHwgKFNhZmV0eUZpbHRlckxldmVsID0ge30pKTtcbi8qKiBFbnVtIHRoYXQgY29udHJvbHMgdGhlIGdlbmVyYXRpb24gb2YgcGVvcGxlLiAqL1xudmFyIFBlcnNvbkdlbmVyYXRpb247XG4oZnVuY3Rpb24gKFBlcnNvbkdlbmVyYXRpb24pIHtcbiAgICAvKipcbiAgICAgKiBCbG9jayBnZW5lcmF0aW9uIG9mIGltYWdlcyBvZiBwZW9wbGUuXG4gICAgICovXG4gICAgUGVyc29uR2VuZXJhdGlvbltcIkRPTlRfQUxMT1dcIl0gPSBcIkRPTlRfQUxMT1dcIjtcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBpbWFnZXMgb2YgYWR1bHRzLCBidXQgbm90IGNoaWxkcmVuLlxuICAgICAqL1xuICAgIFBlcnNvbkdlbmVyYXRpb25bXCJBTExPV19BRFVMVFwiXSA9IFwiQUxMT1dfQURVTFRcIjtcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBpbWFnZXMgdGhhdCBpbmNsdWRlIGFkdWx0cyBhbmQgY2hpbGRyZW4uXG4gICAgICovXG4gICAgUGVyc29uR2VuZXJhdGlvbltcIkFMTE9XX0FMTFwiXSA9IFwiQUxMT1dfQUxMXCI7XG59KShQZXJzb25HZW5lcmF0aW9uIHx8IChQZXJzb25HZW5lcmF0aW9uID0ge30pKTtcbi8qKiBFbnVtIHRoYXQgc3BlY2lmaWVzIHRoZSBsYW5ndWFnZSBvZiB0aGUgdGV4dCBpbiB0aGUgcHJvbXB0LiAqL1xudmFyIEltYWdlUHJvbXB0TGFuZ3VhZ2U7XG4oZnVuY3Rpb24gKEltYWdlUHJvbXB0TGFuZ3VhZ2UpIHtcbiAgICAvKipcbiAgICAgKiBBdXRvLWRldGVjdCB0aGUgbGFuZ3VhZ2UuXG4gICAgICovXG4gICAgSW1hZ2VQcm9tcHRMYW5ndWFnZVtcImF1dG9cIl0gPSBcImF1dG9cIjtcbiAgICAvKipcbiAgICAgKiBFbmdsaXNoXG4gICAgICovXG4gICAgSW1hZ2VQcm9tcHRMYW5ndWFnZVtcImVuXCJdID0gXCJlblwiO1xuICAgIC8qKlxuICAgICAqIEphcGFuZXNlXG4gICAgICovXG4gICAgSW1hZ2VQcm9tcHRMYW5ndWFnZVtcImphXCJdID0gXCJqYVwiO1xuICAgIC8qKlxuICAgICAqIEtvcmVhblxuICAgICAqL1xuICAgIEltYWdlUHJvbXB0TGFuZ3VhZ2VbXCJrb1wiXSA9IFwia29cIjtcbiAgICAvKipcbiAgICAgKiBIaW5kaVxuICAgICAqL1xuICAgIEltYWdlUHJvbXB0TGFuZ3VhZ2VbXCJoaVwiXSA9IFwiaGlcIjtcbiAgICAvKipcbiAgICAgKiBDaGluZXNlXG4gICAgICovXG4gICAgSW1hZ2VQcm9tcHRMYW5ndWFnZVtcInpoXCJdID0gXCJ6aFwiO1xuICAgIC8qKlxuICAgICAqIFBvcnR1Z3Vlc2VcbiAgICAgKi9cbiAgICBJbWFnZVByb21wdExhbmd1YWdlW1wicHRcIl0gPSBcInB0XCI7XG4gICAgLyoqXG4gICAgICogU3BhbmlzaFxuICAgICAqL1xuICAgIEltYWdlUHJvbXB0TGFuZ3VhZ2VbXCJlc1wiXSA9IFwiZXNcIjtcbn0pKEltYWdlUHJvbXB0TGFuZ3VhZ2UgfHwgKEltYWdlUHJvbXB0TGFuZ3VhZ2UgPSB7fSkpO1xuLyoqIEVudW0gcmVwcmVzZW50aW5nIHRoZSBtYXNrIG1vZGUgb2YgYSBtYXNrIHJlZmVyZW5jZSBpbWFnZS4gKi9cbnZhciBNYXNrUmVmZXJlbmNlTW9kZTtcbihmdW5jdGlvbiAoTWFza1JlZmVyZW5jZU1vZGUpIHtcbiAgICBNYXNrUmVmZXJlbmNlTW9kZVtcIk1BU0tfTU9ERV9ERUZBVUxUXCJdID0gXCJNQVNLX01PREVfREVGQVVMVFwiO1xuICAgIE1hc2tSZWZlcmVuY2VNb2RlW1wiTUFTS19NT0RFX1VTRVJfUFJPVklERURcIl0gPSBcIk1BU0tfTU9ERV9VU0VSX1BST1ZJREVEXCI7XG4gICAgTWFza1JlZmVyZW5jZU1vZGVbXCJNQVNLX01PREVfQkFDS0dST1VORFwiXSA9IFwiTUFTS19NT0RFX0JBQ0tHUk9VTkRcIjtcbiAgICBNYXNrUmVmZXJlbmNlTW9kZVtcIk1BU0tfTU9ERV9GT1JFR1JPVU5EXCJdID0gXCJNQVNLX01PREVfRk9SRUdST1VORFwiO1xuICAgIE1hc2tSZWZlcmVuY2VNb2RlW1wiTUFTS19NT0RFX1NFTUFOVElDXCJdID0gXCJNQVNLX01PREVfU0VNQU5USUNcIjtcbn0pKE1hc2tSZWZlcmVuY2VNb2RlIHx8IChNYXNrUmVmZXJlbmNlTW9kZSA9IHt9KSk7XG4vKiogRW51bSByZXByZXNlbnRpbmcgdGhlIGNvbnRyb2wgdHlwZSBvZiBhIGNvbnRyb2wgcmVmZXJlbmNlIGltYWdlLiAqL1xudmFyIENvbnRyb2xSZWZlcmVuY2VUeXBlO1xuKGZ1bmN0aW9uIChDb250cm9sUmVmZXJlbmNlVHlwZSkge1xuICAgIENvbnRyb2xSZWZlcmVuY2VUeXBlW1wiQ09OVFJPTF9UWVBFX0RFRkFVTFRcIl0gPSBcIkNPTlRST0xfVFlQRV9ERUZBVUxUXCI7XG4gICAgQ29udHJvbFJlZmVyZW5jZVR5cGVbXCJDT05UUk9MX1RZUEVfQ0FOTllcIl0gPSBcIkNPTlRST0xfVFlQRV9DQU5OWVwiO1xuICAgIENvbnRyb2xSZWZlcmVuY2VUeXBlW1wiQ09OVFJPTF9UWVBFX1NDUklCQkxFXCJdID0gXCJDT05UUk9MX1RZUEVfU0NSSUJCTEVcIjtcbiAgICBDb250cm9sUmVmZXJlbmNlVHlwZVtcIkNPTlRST0xfVFlQRV9GQUNFX01FU0hcIl0gPSBcIkNPTlRST0xfVFlQRV9GQUNFX01FU0hcIjtcbn0pKENvbnRyb2xSZWZlcmVuY2VUeXBlIHx8IChDb250cm9sUmVmZXJlbmNlVHlwZSA9IHt9KSk7XG4vKiogRW51bSByZXByZXNlbnRpbmcgdGhlIHN1YmplY3QgdHlwZSBvZiBhIHN1YmplY3QgcmVmZXJlbmNlIGltYWdlLiAqL1xudmFyIFN1YmplY3RSZWZlcmVuY2VUeXBlO1xuKGZ1bmN0aW9uIChTdWJqZWN0UmVmZXJlbmNlVHlwZSkge1xuICAgIFN1YmplY3RSZWZlcmVuY2VUeXBlW1wiU1VCSkVDVF9UWVBFX0RFRkFVTFRcIl0gPSBcIlNVQkpFQ1RfVFlQRV9ERUZBVUxUXCI7XG4gICAgU3ViamVjdFJlZmVyZW5jZVR5cGVbXCJTVUJKRUNUX1RZUEVfUEVSU09OXCJdID0gXCJTVUJKRUNUX1RZUEVfUEVSU09OXCI7XG4gICAgU3ViamVjdFJlZmVyZW5jZVR5cGVbXCJTVUJKRUNUX1RZUEVfQU5JTUFMXCJdID0gXCJTVUJKRUNUX1RZUEVfQU5JTUFMXCI7XG4gICAgU3ViamVjdFJlZmVyZW5jZVR5cGVbXCJTVUJKRUNUX1RZUEVfUFJPRFVDVFwiXSA9IFwiU1VCSkVDVF9UWVBFX1BST0RVQ1RcIjtcbn0pKFN1YmplY3RSZWZlcmVuY2VUeXBlIHx8IChTdWJqZWN0UmVmZXJlbmNlVHlwZSA9IHt9KSk7XG4vKiogRW51bSByZXByZXNlbnRpbmcgdGhlIGVkaXRpbmcgbW9kZS4gKi9cbnZhciBFZGl0TW9kZTtcbihmdW5jdGlvbiAoRWRpdE1vZGUpIHtcbiAgICBFZGl0TW9kZVtcIkVESVRfTU9ERV9ERUZBVUxUXCJdID0gXCJFRElUX01PREVfREVGQVVMVFwiO1xuICAgIEVkaXRNb2RlW1wiRURJVF9NT0RFX0lOUEFJTlRfUkVNT1ZBTFwiXSA9IFwiRURJVF9NT0RFX0lOUEFJTlRfUkVNT1ZBTFwiO1xuICAgIEVkaXRNb2RlW1wiRURJVF9NT0RFX0lOUEFJTlRfSU5TRVJUSU9OXCJdID0gXCJFRElUX01PREVfSU5QQUlOVF9JTlNFUlRJT05cIjtcbiAgICBFZGl0TW9kZVtcIkVESVRfTU9ERV9PVVRQQUlOVFwiXSA9IFwiRURJVF9NT0RFX09VVFBBSU5UXCI7XG4gICAgRWRpdE1vZGVbXCJFRElUX01PREVfQ09OVFJPTExFRF9FRElUSU5HXCJdID0gXCJFRElUX01PREVfQ09OVFJPTExFRF9FRElUSU5HXCI7XG4gICAgRWRpdE1vZGVbXCJFRElUX01PREVfU1RZTEVcIl0gPSBcIkVESVRfTU9ERV9TVFlMRVwiO1xuICAgIEVkaXRNb2RlW1wiRURJVF9NT0RFX0JHU1dBUFwiXSA9IFwiRURJVF9NT0RFX0JHU1dBUFwiO1xuICAgIEVkaXRNb2RlW1wiRURJVF9NT0RFX1BST0RVQ1RfSU1BR0VcIl0gPSBcIkVESVRfTU9ERV9QUk9EVUNUX0lNQUdFXCI7XG59KShFZGl0TW9kZSB8fCAoRWRpdE1vZGUgPSB7fSkpO1xuLyoqIEVudW0gdGhhdCByZXByZXNlbnRzIHRoZSBzZWdtZW50YXRpb24gbW9kZS4gKi9cbnZhciBTZWdtZW50TW9kZTtcbihmdW5jdGlvbiAoU2VnbWVudE1vZGUpIHtcbiAgICBTZWdtZW50TW9kZVtcIkZPUkVHUk9VTkRcIl0gPSBcIkZPUkVHUk9VTkRcIjtcbiAgICBTZWdtZW50TW9kZVtcIkJBQ0tHUk9VTkRcIl0gPSBcIkJBQ0tHUk9VTkRcIjtcbiAgICBTZWdtZW50TW9kZVtcIlBST01QVFwiXSA9IFwiUFJPTVBUXCI7XG4gICAgU2VnbWVudE1vZGVbXCJTRU1BTlRJQ1wiXSA9IFwiU0VNQU5USUNcIjtcbiAgICBTZWdtZW50TW9kZVtcIklOVEVSQUNUSVZFXCJdID0gXCJJTlRFUkFDVElWRVwiO1xufSkoU2VnbWVudE1vZGUgfHwgKFNlZ21lbnRNb2RlID0ge30pKTtcbi8qKiBFbnVtIGZvciB0aGUgcmVmZXJlbmNlIHR5cGUgb2YgYSB2aWRlbyBnZW5lcmF0aW9uIHJlZmVyZW5jZSBpbWFnZS4gKi9cbnZhciBWaWRlb0dlbmVyYXRpb25SZWZlcmVuY2VUeXBlO1xuKGZ1bmN0aW9uIChWaWRlb0dlbmVyYXRpb25SZWZlcmVuY2VUeXBlKSB7XG4gICAgLyoqXG4gICAgICogQSByZWZlcmVuY2UgaW1hZ2UgdGhhdCBwcm92aWRlcyBhc3NldHMgdG8gdGhlIGdlbmVyYXRlZCB2aWRlbyxcbiAgICAgICAgc3VjaCBhcyB0aGUgc2NlbmUsIGFuIG9iamVjdCwgYSBjaGFyYWN0ZXIsIGV0Yy5cbiAgICAgKi9cbiAgICBWaWRlb0dlbmVyYXRpb25SZWZlcmVuY2VUeXBlW1wiQVNTRVRcIl0gPSBcIkFTU0VUXCI7XG4gICAgLyoqXG4gICAgICogQSByZWZlcmVuY2UgaW1hZ2UgdGhhdCBwcm92aWRlcyBhZXN0aGV0aWNzIGluY2x1ZGluZyBjb2xvcnMsXG4gICAgICAgIGxpZ2h0aW5nLCB0ZXh0dXJlLCBldGMuLCB0byBiZSB1c2VkIGFzIHRoZSBzdHlsZSBvZiB0aGUgZ2VuZXJhdGVkIHZpZGVvLFxuICAgICAgICBzdWNoIGFzICdhbmltZScsICdwaG90b2dyYXBoeScsICdvcmlnYW1pJywgZXRjLlxuICAgICAqL1xuICAgIFZpZGVvR2VuZXJhdGlvblJlZmVyZW5jZVR5cGVbXCJTVFlMRVwiXSA9IFwiU1RZTEVcIjtcbn0pKFZpZGVvR2VuZXJhdGlvblJlZmVyZW5jZVR5cGUgfHwgKFZpZGVvR2VuZXJhdGlvblJlZmVyZW5jZVR5cGUgPSB7fSkpO1xuLyoqIEVudW0gZm9yIHRoZSBtYXNrIG1vZGUgb2YgYSB2aWRlbyBnZW5lcmF0aW9uIG1hc2suICovXG52YXIgVmlkZW9HZW5lcmF0aW9uTWFza01vZGU7XG4oZnVuY3Rpb24gKFZpZGVvR2VuZXJhdGlvbk1hc2tNb2RlKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGltYWdlIG1hc2sgY29udGFpbnMgYSBtYXNrZWQgcmVjdGFuZ3VsYXIgcmVnaW9uIHdoaWNoIGlzXG4gICAgICAgIGFwcGxpZWQgb24gdGhlIGZpcnN0IGZyYW1lIG9mIHRoZSBpbnB1dCB2aWRlby4gVGhlIG9iamVjdCBkZXNjcmliZWQgaW5cbiAgICAgICAgdGhlIHByb21wdCBpcyBpbnNlcnRlZCBpbnRvIHRoaXMgcmVnaW9uIGFuZCB3aWxsIGFwcGVhciBpbiBzdWJzZXF1ZW50XG4gICAgICAgIGZyYW1lcy5cbiAgICAgKi9cbiAgICBWaWRlb0dlbmVyYXRpb25NYXNrTW9kZVtcIklOU0VSVFwiXSA9IFwiSU5TRVJUXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGltYWdlIG1hc2sgaXMgdXNlZCB0byBkZXRlcm1pbmUgYW4gb2JqZWN0IGluIHRoZVxuICAgICAgICBmaXJzdCB2aWRlbyBmcmFtZSB0byB0cmFjay4gVGhpcyBvYmplY3QgaXMgcmVtb3ZlZCBmcm9tIHRoZSB2aWRlby5cbiAgICAgKi9cbiAgICBWaWRlb0dlbmVyYXRpb25NYXNrTW9kZVtcIlJFTU9WRVwiXSA9IFwiUkVNT1ZFXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGltYWdlIG1hc2sgaXMgdXNlZCB0byBkZXRlcm1pbmUgYSByZWdpb24gaW4gdGhlXG4gICAgICAgIHZpZGVvLiBPYmplY3RzIGluIHRoaXMgcmVnaW9uIHdpbGwgYmUgcmVtb3ZlZC5cbiAgICAgKi9cbiAgICBWaWRlb0dlbmVyYXRpb25NYXNrTW9kZVtcIlJFTU9WRV9TVEFUSUNcIl0gPSBcIlJFTU9WRV9TVEFUSUNcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgaW1hZ2UgbWFzayBjb250YWlucyBhIG1hc2tlZCByZWN0YW5ndWxhciByZWdpb24gd2hlcmVcbiAgICAgICAgdGhlIGlucHV0IHZpZGVvIHdpbGwgZ28uIFRoZSByZW1haW5pbmcgYXJlYSB3aWxsIGJlIGdlbmVyYXRlZC4gVmlkZW9cbiAgICAgICAgbWFza3MgYXJlIG5vdCBzdXBwb3J0ZWQuXG4gICAgICovXG4gICAgVmlkZW9HZW5lcmF0aW9uTWFza01vZGVbXCJPVVRQQUlOVFwiXSA9IFwiT1VUUEFJTlRcIjtcbn0pKFZpZGVvR2VuZXJhdGlvbk1hc2tNb2RlIHx8IChWaWRlb0dlbmVyYXRpb25NYXNrTW9kZSA9IHt9KSk7XG4vKiogRW51bSB0aGF0IGNvbnRyb2xzIHRoZSBjb21wcmVzc2lvbiBxdWFsaXR5IG9mIHRoZSBnZW5lcmF0ZWQgdmlkZW9zLiAqL1xudmFyIFZpZGVvQ29tcHJlc3Npb25RdWFsaXR5O1xuKGZ1bmN0aW9uIChWaWRlb0NvbXByZXNzaW9uUXVhbGl0eSkge1xuICAgIC8qKlxuICAgICAqIE9wdGltaXplZCB2aWRlbyBjb21wcmVzc2lvbiBxdWFsaXR5LiBUaGlzIHdpbGwgcHJvZHVjZSB2aWRlb3NcbiAgICAgICAgd2l0aCBhIGNvbXByZXNzZWQsIHNtYWxsZXIgZmlsZSBzaXplLlxuICAgICAqL1xuICAgIFZpZGVvQ29tcHJlc3Npb25RdWFsaXR5W1wiT1BUSU1JWkVEXCJdID0gXCJPUFRJTUlaRURcIjtcbiAgICAvKipcbiAgICAgKiBMb3NzbGVzcyB2aWRlbyBjb21wcmVzc2lvbiBxdWFsaXR5LiBUaGlzIHdpbGwgcHJvZHVjZSB2aWRlb3NcbiAgICAgICAgd2l0aCBhIGxhcmdlciBmaWxlIHNpemUuXG4gICAgICovXG4gICAgVmlkZW9Db21wcmVzc2lvblF1YWxpdHlbXCJMT1NTTEVTU1wiXSA9IFwiTE9TU0xFU1NcIjtcbn0pKFZpZGVvQ29tcHJlc3Npb25RdWFsaXR5IHx8IChWaWRlb0NvbXByZXNzaW9uUXVhbGl0eSA9IHt9KSk7XG4vKiogRW51bSByZXByZXNlbnRpbmcgdGhlIHR1bmluZyBtZXRob2QuICovXG52YXIgVHVuaW5nTWV0aG9kO1xuKGZ1bmN0aW9uIChUdW5pbmdNZXRob2QpIHtcbiAgICAvKipcbiAgICAgKiBTdXBlcnZpc2VkIGZpbmUgdHVuaW5nLlxuICAgICAqL1xuICAgIFR1bmluZ01ldGhvZFtcIlNVUEVSVklTRURfRklORV9UVU5JTkdcIl0gPSBcIlNVUEVSVklTRURfRklORV9UVU5JTkdcIjtcbiAgICAvKipcbiAgICAgKiBQcmVmZXJlbmNlIG9wdGltaXphdGlvbiB0dW5pbmcuXG4gICAgICovXG4gICAgVHVuaW5nTWV0aG9kW1wiUFJFRkVSRU5DRV9UVU5JTkdcIl0gPSBcIlBSRUZFUkVOQ0VfVFVOSU5HXCI7XG59KShUdW5pbmdNZXRob2QgfHwgKFR1bmluZ01ldGhvZCA9IHt9KSk7XG4vKiogU3RhdGUgZm9yIHRoZSBsaWZlY3ljbGUgb2YgYSBEb2N1bWVudC4gKi9cbnZhciBEb2N1bWVudFN0YXRlO1xuKGZ1bmN0aW9uIChEb2N1bWVudFN0YXRlKSB7XG4gICAgRG9jdW1lbnRTdGF0ZVtcIlNUQVRFX1VOU1BFQ0lGSUVEXCJdID0gXCJTVEFURV9VTlNQRUNJRklFRFwiO1xuICAgIERvY3VtZW50U3RhdGVbXCJTVEFURV9QRU5ESU5HXCJdID0gXCJTVEFURV9QRU5ESU5HXCI7XG4gICAgRG9jdW1lbnRTdGF0ZVtcIlNUQVRFX0FDVElWRVwiXSA9IFwiU1RBVEVfQUNUSVZFXCI7XG4gICAgRG9jdW1lbnRTdGF0ZVtcIlNUQVRFX0ZBSUxFRFwiXSA9IFwiU1RBVEVfRkFJTEVEXCI7XG59KShEb2N1bWVudFN0YXRlIHx8IChEb2N1bWVudFN0YXRlID0ge30pKTtcbi8qKiBTdGF0ZSBmb3IgdGhlIGxpZmVjeWNsZSBvZiBhIEZpbGUuICovXG52YXIgRmlsZVN0YXRlO1xuKGZ1bmN0aW9uIChGaWxlU3RhdGUpIHtcbiAgICBGaWxlU3RhdGVbXCJTVEFURV9VTlNQRUNJRklFRFwiXSA9IFwiU1RBVEVfVU5TUEVDSUZJRURcIjtcbiAgICBGaWxlU3RhdGVbXCJQUk9DRVNTSU5HXCJdID0gXCJQUk9DRVNTSU5HXCI7XG4gICAgRmlsZVN0YXRlW1wiQUNUSVZFXCJdID0gXCJBQ1RJVkVcIjtcbiAgICBGaWxlU3RhdGVbXCJGQUlMRURcIl0gPSBcIkZBSUxFRFwiO1xufSkoRmlsZVN0YXRlIHx8IChGaWxlU3RhdGUgPSB7fSkpO1xuLyoqIFNvdXJjZSBvZiB0aGUgRmlsZS4gKi9cbnZhciBGaWxlU291cmNlO1xuKGZ1bmN0aW9uIChGaWxlU291cmNlKSB7XG4gICAgRmlsZVNvdXJjZVtcIlNPVVJDRV9VTlNQRUNJRklFRFwiXSA9IFwiU09VUkNFX1VOU1BFQ0lGSUVEXCI7XG4gICAgRmlsZVNvdXJjZVtcIlVQTE9BREVEXCJdID0gXCJVUExPQURFRFwiO1xuICAgIEZpbGVTb3VyY2VbXCJHRU5FUkFURURcIl0gPSBcIkdFTkVSQVRFRFwiO1xufSkoRmlsZVNvdXJjZSB8fCAoRmlsZVNvdXJjZSA9IHt9KSk7XG4vKiogVGhlIHJlYXNvbiB3aHkgdGhlIHR1cm4gaXMgY29tcGxldGUuICovXG52YXIgVHVybkNvbXBsZXRlUmVhc29uO1xuKGZ1bmN0aW9uIChUdXJuQ29tcGxldGVSZWFzb24pIHtcbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHZhbHVlLiBSZWFzb24gaXMgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgVHVybkNvbXBsZXRlUmVhc29uW1wiVFVSTl9DT01QTEVURV9SRUFTT05fVU5TUEVDSUZJRURcIl0gPSBcIlRVUk5fQ09NUExFVEVfUkVBU09OX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGZ1bmN0aW9uIGNhbGwgZ2VuZXJhdGVkIGJ5IHRoZSBtb2RlbCBpcyBpbnZhbGlkLlxuICAgICAqL1xuICAgIFR1cm5Db21wbGV0ZVJlYXNvbltcIk1BTEZPUk1FRF9GVU5DVElPTl9DQUxMXCJdID0gXCJNQUxGT1JNRURfRlVOQ1RJT05fQ0FMTFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSByZXNwb25zZSBpcyByZWplY3RlZCBieSB0aGUgbW9kZWwuXG4gICAgICovXG4gICAgVHVybkNvbXBsZXRlUmVhc29uW1wiUkVTUE9OU0VfUkVKRUNURURcIl0gPSBcIlJFU1BPTlNFX1JFSkVDVEVEXCI7XG4gICAgLyoqXG4gICAgICogTmVlZHMgbW9yZSBpbnB1dCBmcm9tIHRoZSB1c2VyLlxuICAgICAqL1xuICAgIFR1cm5Db21wbGV0ZVJlYXNvbltcIk5FRURfTU9SRV9JTlBVVFwiXSA9IFwiTkVFRF9NT1JFX0lOUFVUXCI7XG59KShUdXJuQ29tcGxldGVSZWFzb24gfHwgKFR1cm5Db21wbGV0ZVJlYXNvbiA9IHt9KSk7XG4vKiogU2VydmVyIGNvbnRlbnQgbW9kYWxpdGllcy4gKi9cbnZhciBNZWRpYU1vZGFsaXR5O1xuKGZ1bmN0aW9uIChNZWRpYU1vZGFsaXR5KSB7XG4gICAgLyoqXG4gICAgICogVGhlIG1vZGFsaXR5IGlzIHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIE1lZGlhTW9kYWxpdHlbXCJNT0RBTElUWV9VTlNQRUNJRklFRFwiXSA9IFwiTU9EQUxJVFlfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBQbGFpbiB0ZXh0LlxuICAgICAqL1xuICAgIE1lZGlhTW9kYWxpdHlbXCJURVhUXCJdID0gXCJURVhUXCI7XG4gICAgLyoqXG4gICAgICogSW1hZ2VzLlxuICAgICAqL1xuICAgIE1lZGlhTW9kYWxpdHlbXCJJTUFHRVwiXSA9IFwiSU1BR0VcIjtcbiAgICAvKipcbiAgICAgKiBWaWRlby5cbiAgICAgKi9cbiAgICBNZWRpYU1vZGFsaXR5W1wiVklERU9cIl0gPSBcIlZJREVPXCI7XG4gICAgLyoqXG4gICAgICogQXVkaW8uXG4gICAgICovXG4gICAgTWVkaWFNb2RhbGl0eVtcIkFVRElPXCJdID0gXCJBVURJT1wiO1xuICAgIC8qKlxuICAgICAqIERvY3VtZW50LCBlLmcuIFBERi5cbiAgICAgKi9cbiAgICBNZWRpYU1vZGFsaXR5W1wiRE9DVU1FTlRcIl0gPSBcIkRPQ1VNRU5UXCI7XG59KShNZWRpYU1vZGFsaXR5IHx8IChNZWRpYU1vZGFsaXR5ID0ge30pKTtcbi8qKiBTdGFydCBvZiBzcGVlY2ggc2Vuc2l0aXZpdHkuICovXG52YXIgU3RhcnRTZW5zaXRpdml0eTtcbihmdW5jdGlvbiAoU3RhcnRTZW5zaXRpdml0eSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IGlzIFNUQVJUX1NFTlNJVElWSVRZX0xPVy5cbiAgICAgKi9cbiAgICBTdGFydFNlbnNpdGl2aXR5W1wiU1RBUlRfU0VOU0lUSVZJVFlfVU5TUEVDSUZJRURcIl0gPSBcIlNUQVJUX1NFTlNJVElWSVRZX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogQXV0b21hdGljIGRldGVjdGlvbiB3aWxsIGRldGVjdCB0aGUgc3RhcnQgb2Ygc3BlZWNoIG1vcmUgb2Z0ZW4uXG4gICAgICovXG4gICAgU3RhcnRTZW5zaXRpdml0eVtcIlNUQVJUX1NFTlNJVElWSVRZX0hJR0hcIl0gPSBcIlNUQVJUX1NFTlNJVElWSVRZX0hJR0hcIjtcbiAgICAvKipcbiAgICAgKiBBdXRvbWF0aWMgZGV0ZWN0aW9uIHdpbGwgZGV0ZWN0IHRoZSBzdGFydCBvZiBzcGVlY2ggbGVzcyBvZnRlbi5cbiAgICAgKi9cbiAgICBTdGFydFNlbnNpdGl2aXR5W1wiU1RBUlRfU0VOU0lUSVZJVFlfTE9XXCJdID0gXCJTVEFSVF9TRU5TSVRJVklUWV9MT1dcIjtcbn0pKFN0YXJ0U2Vuc2l0aXZpdHkgfHwgKFN0YXJ0U2Vuc2l0aXZpdHkgPSB7fSkpO1xuLyoqIEVuZCBvZiBzcGVlY2ggc2Vuc2l0aXZpdHkuICovXG52YXIgRW5kU2Vuc2l0aXZpdHk7XG4oZnVuY3Rpb24gKEVuZFNlbnNpdGl2aXR5KSB7XG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgaXMgRU5EX1NFTlNJVElWSVRZX0xPVy5cbiAgICAgKi9cbiAgICBFbmRTZW5zaXRpdml0eVtcIkVORF9TRU5TSVRJVklUWV9VTlNQRUNJRklFRFwiXSA9IFwiRU5EX1NFTlNJVElWSVRZX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogQXV0b21hdGljIGRldGVjdGlvbiBlbmRzIHNwZWVjaCBtb3JlIG9mdGVuLlxuICAgICAqL1xuICAgIEVuZFNlbnNpdGl2aXR5W1wiRU5EX1NFTlNJVElWSVRZX0hJR0hcIl0gPSBcIkVORF9TRU5TSVRJVklUWV9ISUdIXCI7XG4gICAgLyoqXG4gICAgICogQXV0b21hdGljIGRldGVjdGlvbiBlbmRzIHNwZWVjaCBsZXNzIG9mdGVuLlxuICAgICAqL1xuICAgIEVuZFNlbnNpdGl2aXR5W1wiRU5EX1NFTlNJVElWSVRZX0xPV1wiXSA9IFwiRU5EX1NFTlNJVElWSVRZX0xPV1wiO1xufSkoRW5kU2Vuc2l0aXZpdHkgfHwgKEVuZFNlbnNpdGl2aXR5ID0ge30pKTtcbi8qKiBUaGUgZGlmZmVyZW50IHdheXMgb2YgaGFuZGxpbmcgdXNlciBhY3Rpdml0eS4gKi9cbnZhciBBY3Rpdml0eUhhbmRsaW5nO1xuKGZ1bmN0aW9uIChBY3Rpdml0eUhhbmRsaW5nKSB7XG4gICAgLyoqXG4gICAgICogSWYgdW5zcGVjaWZpZWQsIHRoZSBkZWZhdWx0IGJlaGF2aW9yIGlzIGBTVEFSVF9PRl9BQ1RJVklUWV9JTlRFUlJVUFRTYC5cbiAgICAgKi9cbiAgICBBY3Rpdml0eUhhbmRsaW5nW1wiQUNUSVZJVFlfSEFORExJTkdfVU5TUEVDSUZJRURcIl0gPSBcIkFDVElWSVRZX0hBTkRMSU5HX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgc3RhcnQgb2YgYWN0aXZpdHkgd2lsbCBpbnRlcnJ1cHQgdGhlIG1vZGVsJ3MgcmVzcG9uc2UgKGFsc28gY2FsbGVkIFwiYmFyZ2UgaW5cIikuIFRoZSBtb2RlbCdzIGN1cnJlbnQgcmVzcG9uc2Ugd2lsbCBiZSBjdXQtb2ZmIGluIHRoZSBtb21lbnQgb2YgdGhlIGludGVycnVwdGlvbi4gVGhpcyBpcyB0aGUgZGVmYXVsdCBiZWhhdmlvci5cbiAgICAgKi9cbiAgICBBY3Rpdml0eUhhbmRsaW5nW1wiU1RBUlRfT0ZfQUNUSVZJVFlfSU5URVJSVVBUU1wiXSA9IFwiU1RBUlRfT0ZfQUNUSVZJVFlfSU5URVJSVVBUU1wiO1xuICAgIC8qKlxuICAgICAqIFRoZSBtb2RlbCdzIHJlc3BvbnNlIHdpbGwgbm90IGJlIGludGVycnVwdGVkLlxuICAgICAqL1xuICAgIEFjdGl2aXR5SGFuZGxpbmdbXCJOT19JTlRFUlJVUFRJT05cIl0gPSBcIk5PX0lOVEVSUlVQVElPTlwiO1xufSkoQWN0aXZpdHlIYW5kbGluZyB8fCAoQWN0aXZpdHlIYW5kbGluZyA9IHt9KSk7XG4vKiogT3B0aW9ucyBhYm91dCB3aGljaCBpbnB1dCBpcyBpbmNsdWRlZCBpbiB0aGUgdXNlcidzIHR1cm4uICovXG52YXIgVHVybkNvdmVyYWdlO1xuKGZ1bmN0aW9uIChUdXJuQ292ZXJhZ2UpIHtcbiAgICAvKipcbiAgICAgKiBJZiB1bnNwZWNpZmllZCwgdGhlIGRlZmF1bHQgYmVoYXZpb3IgaXMgYFRVUk5fSU5DTFVERVNfT05MWV9BQ1RJVklUWWAuXG4gICAgICovXG4gICAgVHVybkNvdmVyYWdlW1wiVFVSTl9DT1ZFUkFHRV9VTlNQRUNJRklFRFwiXSA9IFwiVFVSTl9DT1ZFUkFHRV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSB1c2VycyB0dXJuIG9ubHkgaW5jbHVkZXMgYWN0aXZpdHkgc2luY2UgdGhlIGxhc3QgdHVybiwgZXhjbHVkaW5nIGluYWN0aXZpdHkgKGUuZy4gc2lsZW5jZSBvbiB0aGUgYXVkaW8gc3RyZWFtKS4gVGhpcyBpcyB0aGUgZGVmYXVsdCBiZWhhdmlvci5cbiAgICAgKi9cbiAgICBUdXJuQ292ZXJhZ2VbXCJUVVJOX0lOQ0xVREVTX09OTFlfQUNUSVZJVFlcIl0gPSBcIlRVUk5fSU5DTFVERVNfT05MWV9BQ1RJVklUWVwiO1xuICAgIC8qKlxuICAgICAqIFRoZSB1c2VycyB0dXJuIGluY2x1ZGVzIGFsbCByZWFsdGltZSBpbnB1dCBzaW5jZSB0aGUgbGFzdCB0dXJuLCBpbmNsdWRpbmcgaW5hY3Rpdml0eSAoZS5nLiBzaWxlbmNlIG9uIHRoZSBhdWRpbyBzdHJlYW0pLlxuICAgICAqL1xuICAgIFR1cm5Db3ZlcmFnZVtcIlRVUk5fSU5DTFVERVNfQUxMX0lOUFVUXCJdID0gXCJUVVJOX0lOQ0xVREVTX0FMTF9JTlBVVFwiO1xufSkoVHVybkNvdmVyYWdlIHx8IChUdXJuQ292ZXJhZ2UgPSB7fSkpO1xuLyoqIFNjYWxlIG9mIHRoZSBnZW5lcmF0ZWQgbXVzaWMuICovXG52YXIgU2NhbGU7XG4oZnVuY3Rpb24gKFNjYWxlKSB7XG4gICAgLyoqXG4gICAgICogRGVmYXVsdCB2YWx1ZS4gVGhpcyB2YWx1ZSBpcyB1bnVzZWQuXG4gICAgICovXG4gICAgU2NhbGVbXCJTQ0FMRV9VTlNQRUNJRklFRFwiXSA9IFwiU0NBTEVfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBDIG1ham9yIG9yIEEgbWlub3IuXG4gICAgICovXG4gICAgU2NhbGVbXCJDX01BSk9SX0FfTUlOT1JcIl0gPSBcIkNfTUFKT1JfQV9NSU5PUlwiO1xuICAgIC8qKlxuICAgICAqIERiIG1ham9yIG9yIEJiIG1pbm9yLlxuICAgICAqL1xuICAgIFNjYWxlW1wiRF9GTEFUX01BSk9SX0JfRkxBVF9NSU5PUlwiXSA9IFwiRF9GTEFUX01BSk9SX0JfRkxBVF9NSU5PUlwiO1xuICAgIC8qKlxuICAgICAqIEQgbWFqb3Igb3IgQiBtaW5vci5cbiAgICAgKi9cbiAgICBTY2FsZVtcIkRfTUFKT1JfQl9NSU5PUlwiXSA9IFwiRF9NQUpPUl9CX01JTk9SXCI7XG4gICAgLyoqXG4gICAgICogRWIgbWFqb3Igb3IgQyBtaW5vclxuICAgICAqL1xuICAgIFNjYWxlW1wiRV9GTEFUX01BSk9SX0NfTUlOT1JcIl0gPSBcIkVfRkxBVF9NQUpPUl9DX01JTk9SXCI7XG4gICAgLyoqXG4gICAgICogRSBtYWpvciBvciBEYiBtaW5vci5cbiAgICAgKi9cbiAgICBTY2FsZVtcIkVfTUFKT1JfRF9GTEFUX01JTk9SXCJdID0gXCJFX01BSk9SX0RfRkxBVF9NSU5PUlwiO1xuICAgIC8qKlxuICAgICAqIEYgbWFqb3Igb3IgRCBtaW5vci5cbiAgICAgKi9cbiAgICBTY2FsZVtcIkZfTUFKT1JfRF9NSU5PUlwiXSA9IFwiRl9NQUpPUl9EX01JTk9SXCI7XG4gICAgLyoqXG4gICAgICogR2IgbWFqb3Igb3IgRWIgbWlub3IuXG4gICAgICovXG4gICAgU2NhbGVbXCJHX0ZMQVRfTUFKT1JfRV9GTEFUX01JTk9SXCJdID0gXCJHX0ZMQVRfTUFKT1JfRV9GTEFUX01JTk9SXCI7XG4gICAgLyoqXG4gICAgICogRyBtYWpvciBvciBFIG1pbm9yLlxuICAgICAqL1xuICAgIFNjYWxlW1wiR19NQUpPUl9FX01JTk9SXCJdID0gXCJHX01BSk9SX0VfTUlOT1JcIjtcbiAgICAvKipcbiAgICAgKiBBYiBtYWpvciBvciBGIG1pbm9yLlxuICAgICAqL1xuICAgIFNjYWxlW1wiQV9GTEFUX01BSk9SX0ZfTUlOT1JcIl0gPSBcIkFfRkxBVF9NQUpPUl9GX01JTk9SXCI7XG4gICAgLyoqXG4gICAgICogQSBtYWpvciBvciBHYiBtaW5vci5cbiAgICAgKi9cbiAgICBTY2FsZVtcIkFfTUFKT1JfR19GTEFUX01JTk9SXCJdID0gXCJBX01BSk9SX0dfRkxBVF9NSU5PUlwiO1xuICAgIC8qKlxuICAgICAqIEJiIG1ham9yIG9yIEcgbWlub3IuXG4gICAgICovXG4gICAgU2NhbGVbXCJCX0ZMQVRfTUFKT1JfR19NSU5PUlwiXSA9IFwiQl9GTEFUX01BSk9SX0dfTUlOT1JcIjtcbiAgICAvKipcbiAgICAgKiBCIG1ham9yIG9yIEFiIG1pbm9yLlxuICAgICAqL1xuICAgIFNjYWxlW1wiQl9NQUpPUl9BX0ZMQVRfTUlOT1JcIl0gPSBcIkJfTUFKT1JfQV9GTEFUX01JTk9SXCI7XG59KShTY2FsZSB8fCAoU2NhbGUgPSB7fSkpO1xuLyoqIFRoZSBtb2RlIG9mIG11c2ljIGdlbmVyYXRpb24uICovXG52YXIgTXVzaWNHZW5lcmF0aW9uTW9kZTtcbihmdW5jdGlvbiAoTXVzaWNHZW5lcmF0aW9uTW9kZSkge1xuICAgIC8qKlxuICAgICAqIFJlbHkgb24gdGhlIHNlcnZlciBkZWZhdWx0IGdlbmVyYXRpb24gbW9kZS5cbiAgICAgKi9cbiAgICBNdXNpY0dlbmVyYXRpb25Nb2RlW1wiTVVTSUNfR0VORVJBVElPTl9NT0RFX1VOU1BFQ0lGSUVEXCJdID0gXCJNVVNJQ19HRU5FUkFUSU9OX01PREVfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBTdGVlciB0ZXh0IHByb21wdHMgdG8gcmVnaW9ucyBvZiBsYXRlbnQgc3BhY2Ugd2l0aCBoaWdoZXIgcXVhbGl0eVxuICAgICAgICBtdXNpYy5cbiAgICAgKi9cbiAgICBNdXNpY0dlbmVyYXRpb25Nb2RlW1wiUVVBTElUWVwiXSA9IFwiUVVBTElUWVwiO1xuICAgIC8qKlxuICAgICAqIFN0ZWVyIHRleHQgcHJvbXB0cyB0byByZWdpb25zIG9mIGxhdGVudCBzcGFjZSB3aXRoIGEgbGFyZ2VyXG4gICAgICAgIGRpdmVyc2l0eSBvZiBtdXNpYy5cbiAgICAgKi9cbiAgICBNdXNpY0dlbmVyYXRpb25Nb2RlW1wiRElWRVJTSVRZXCJdID0gXCJESVZFUlNJVFlcIjtcbiAgICAvKipcbiAgICAgKiBTdGVlciB0ZXh0IHByb21wdHMgdG8gcmVnaW9ucyBvZiBsYXRlbnQgc3BhY2UgbW9yZSBsaWtlbHkgdG9cbiAgICAgICAgZ2VuZXJhdGUgbXVzaWMgd2l0aCB2b2NhbHMuXG4gICAgICovXG4gICAgTXVzaWNHZW5lcmF0aW9uTW9kZVtcIlZPQ0FMSVpBVElPTlwiXSA9IFwiVk9DQUxJWkFUSU9OXCI7XG59KShNdXNpY0dlbmVyYXRpb25Nb2RlIHx8IChNdXNpY0dlbmVyYXRpb25Nb2RlID0ge30pKTtcbi8qKiBUaGUgcGxheWJhY2sgY29udHJvbCBzaWduYWwgdG8gYXBwbHkgdG8gdGhlIG11c2ljIGdlbmVyYXRpb24uICovXG52YXIgTGl2ZU11c2ljUGxheWJhY2tDb250cm9sO1xuKGZ1bmN0aW9uIChMaXZlTXVzaWNQbGF5YmFja0NvbnRyb2wpIHtcbiAgICAvKipcbiAgICAgKiBUaGlzIHZhbHVlIGlzIHVudXNlZC5cbiAgICAgKi9cbiAgICBMaXZlTXVzaWNQbGF5YmFja0NvbnRyb2xbXCJQTEFZQkFDS19DT05UUk9MX1VOU1BFQ0lGSUVEXCJdID0gXCJQTEFZQkFDS19DT05UUk9MX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogU3RhcnQgZ2VuZXJhdGluZyB0aGUgbXVzaWMuXG4gICAgICovXG4gICAgTGl2ZU11c2ljUGxheWJhY2tDb250cm9sW1wiUExBWVwiXSA9IFwiUExBWVwiO1xuICAgIC8qKlxuICAgICAqIEhvbGQgdGhlIG11c2ljIGdlbmVyYXRpb24uIFVzZSBQTEFZIHRvIHJlc3VtZSBmcm9tIHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuICAgICAqL1xuICAgIExpdmVNdXNpY1BsYXliYWNrQ29udHJvbFtcIlBBVVNFXCJdID0gXCJQQVVTRVwiO1xuICAgIC8qKlxuICAgICAqIFN0b3AgdGhlIG11c2ljIGdlbmVyYXRpb24gYW5kIHJlc2V0IHRoZSBjb250ZXh0IChwcm9tcHRzIHJldGFpbmVkKS5cbiAgICAgICAgVXNlIFBMQVkgdG8gcmVzdGFydCB0aGUgbXVzaWMgZ2VuZXJhdGlvbi5cbiAgICAgKi9cbiAgICBMaXZlTXVzaWNQbGF5YmFja0NvbnRyb2xbXCJTVE9QXCJdID0gXCJTVE9QXCI7XG4gICAgLyoqXG4gICAgICogUmVzZXQgdGhlIGNvbnRleHQgb2YgdGhlIG11c2ljIGdlbmVyYXRpb24gd2l0aG91dCBzdG9wcGluZyBpdC5cbiAgICAgICAgUmV0YWlucyB0aGUgY3VycmVudCBwcm9tcHRzIGFuZCBjb25maWcuXG4gICAgICovXG4gICAgTGl2ZU11c2ljUGxheWJhY2tDb250cm9sW1wiUkVTRVRfQ09OVEVYVFwiXSA9IFwiUkVTRVRfQ09OVEVYVFwiO1xufSkoTGl2ZU11c2ljUGxheWJhY2tDb250cm9sIHx8IChMaXZlTXVzaWNQbGF5YmFja0NvbnRyb2wgPSB7fSkpO1xuLyoqIFJhdyBtZWRpYSBieXRlcyBmb3IgZnVuY3Rpb24gcmVzcG9uc2UuXG5cblRleHQgc2hvdWxkIG5vdCBiZSBzZW50IGFzIHJhdyBieXRlcywgdXNlIHRoZSBGdW5jdGlvblJlc3BvbnNlLnJlc3BvbnNlXG5maWVsZC4gKi9cbmNsYXNzIEZ1bmN0aW9uUmVzcG9uc2VCbG9iIHtcbn1cbi8qKiBVUkkgYmFzZWQgZGF0YSBmb3IgZnVuY3Rpb24gcmVzcG9uc2UuICovXG5jbGFzcyBGdW5jdGlvblJlc3BvbnNlRmlsZURhdGEge1xufVxuLyoqIEEgZGF0YXR5cGUgY29udGFpbmluZyBtZWRpYSB0aGF0IGlzIHBhcnQgb2YgYSBgRnVuY3Rpb25SZXNwb25zZWAgbWVzc2FnZS5cblxuQSBgRnVuY3Rpb25SZXNwb25zZVBhcnRgIGNvbnNpc3RzIG9mIGRhdGEgd2hpY2ggaGFzIGFuIGFzc29jaWF0ZWQgZGF0YXR5cGUuIEFcbmBGdW5jdGlvblJlc3BvbnNlUGFydGAgY2FuIG9ubHkgY29udGFpbiBvbmUgb2YgdGhlIGFjY2VwdGVkIHR5cGVzIGluXG5gRnVuY3Rpb25SZXNwb25zZVBhcnQuZGF0YWAuXG5cbkEgYEZ1bmN0aW9uUmVzcG9uc2VQYXJ0YCBtdXN0IGhhdmUgYSBmaXhlZCBJQU5BIE1JTUUgdHlwZSBpZGVudGlmeWluZyB0aGVcbnR5cGUgYW5kIHN1YnR5cGUgb2YgdGhlIG1lZGlhIGlmIHRoZSBgaW5saW5lX2RhdGFgIGZpZWxkIGlzIGZpbGxlZCB3aXRoIHJhd1xuYnl0ZXMuICovXG5jbGFzcyBGdW5jdGlvblJlc3BvbnNlUGFydCB7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBgRnVuY3Rpb25SZXNwb25zZVBhcnRgIG9iamVjdCBmcm9tIGEgYGJhc2U2NGAgZW5jb2RlZCBgc3RyaW5nYC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25SZXNwb25zZVBhcnRGcm9tQmFzZTY0KGRhdGEsIG1pbWVUeXBlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW5saW5lRGF0YToge1xuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIG1pbWVUeXBlOiBtaW1lVHlwZSxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgYEZ1bmN0aW9uUmVzcG9uc2VQYXJ0YCBvYmplY3QgZnJvbSBhIGBVUklgIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25SZXNwb25zZVBhcnRGcm9tVXJpKHVyaSwgbWltZVR5cGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBmaWxlRGF0YToge1xuICAgICAgICAgICAgZmlsZVVyaTogdXJpLFxuICAgICAgICAgICAgbWltZVR5cGU6IG1pbWVUeXBlLFxuICAgICAgICB9LFxuICAgIH07XG59XG4vKiogQSBmdW5jdGlvbiByZXNwb25zZS4gKi9cbmNsYXNzIEZ1bmN0aW9uUmVzcG9uc2Uge1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgYFBhcnRgIG9iamVjdCBmcm9tIGEgYFVSSWAgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBjcmVhdGVQYXJ0RnJvbVVyaSh1cmksIG1pbWVUeXBlLCBtZWRpYVJlc29sdXRpb24pIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IGZpbGVEYXRhOiB7XG4gICAgICAgICAgICBmaWxlVXJpOiB1cmksXG4gICAgICAgICAgICBtaW1lVHlwZTogbWltZVR5cGUsXG4gICAgICAgIH0gfSwgKG1lZGlhUmVzb2x1dGlvbiAmJiB7IG1lZGlhUmVzb2x1dGlvbjogeyBsZXZlbDogbWVkaWFSZXNvbHV0aW9uIH0gfSkpO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgYFBhcnRgIG9iamVjdCBmcm9tIGEgYHRleHRgIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUGFydEZyb21UZXh0KHRleHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYSBgUGFydGAgb2JqZWN0IGZyb20gYSBgRnVuY3Rpb25DYWxsYCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBhcnRGcm9tRnVuY3Rpb25DYWxsKG5hbWUsIGFyZ3MpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBmdW5jdGlvbkNhbGw6IHtcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICBhcmdzOiBhcmdzLFxuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYSBgUGFydGAgb2JqZWN0IGZyb20gYSBgRnVuY3Rpb25SZXNwb25zZWAgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBjcmVhdGVQYXJ0RnJvbUZ1bmN0aW9uUmVzcG9uc2UoaWQsIG5hbWUsIHJlc3BvbnNlLCBwYXJ0cyA9IFtdKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZnVuY3Rpb25SZXNwb25zZTogT2JqZWN0LmFzc2lnbih7IGlkOiBpZCwgbmFtZTogbmFtZSwgcmVzcG9uc2U6IHJlc3BvbnNlIH0sIChwYXJ0cy5sZW5ndGggPiAwICYmIHsgcGFydHMgfSkpLFxuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYSBgUGFydGAgb2JqZWN0IGZyb20gYSBgYmFzZTY0YCBlbmNvZGVkIGBzdHJpbmdgLlxuICovXG5mdW5jdGlvbiBjcmVhdGVQYXJ0RnJvbUJhc2U2NChkYXRhLCBtaW1lVHlwZSwgbWVkaWFSZXNvbHV0aW9uKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyBpbmxpbmVEYXRhOiB7XG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgbWltZVR5cGU6IG1pbWVUeXBlLFxuICAgICAgICB9IH0sIChtZWRpYVJlc29sdXRpb24gJiYgeyBtZWRpYVJlc29sdXRpb246IHsgbGV2ZWw6IG1lZGlhUmVzb2x1dGlvbiB9IH0pKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGBQYXJ0YCBvYmplY3QgZnJvbSB0aGUgYG91dGNvbWVgIGFuZCBgb3V0cHV0YCBvZiBhIGBDb2RlRXhlY3V0aW9uUmVzdWx0YCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBhcnRGcm9tQ29kZUV4ZWN1dGlvblJlc3VsdChvdXRjb21lLCBvdXRwdXQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb2RlRXhlY3V0aW9uUmVzdWx0OiB7XG4gICAgICAgICAgICBvdXRjb21lOiBvdXRjb21lLFxuICAgICAgICAgICAgb3V0cHV0OiBvdXRwdXQsXG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGBQYXJ0YCBvYmplY3QgZnJvbSB0aGUgYGNvZGVgIGFuZCBgbGFuZ3VhZ2VgIG9mIGFuIGBFeGVjdXRhYmxlQ29kZWAgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBjcmVhdGVQYXJ0RnJvbUV4ZWN1dGFibGVDb2RlKGNvZGUsIGxhbmd1YWdlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZXhlY3V0YWJsZUNvZGU6IHtcbiAgICAgICAgICAgIGNvZGU6IGNvZGUsXG4gICAgICAgICAgICBsYW5ndWFnZTogbGFuZ3VhZ2UsXG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9pc1BhcnQob2JqKSB7XG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gKCdmaWxlRGF0YScgaW4gb2JqIHx8XG4gICAgICAgICAgICAndGV4dCcgaW4gb2JqIHx8XG4gICAgICAgICAgICAnZnVuY3Rpb25DYWxsJyBpbiBvYmogfHxcbiAgICAgICAgICAgICdmdW5jdGlvblJlc3BvbnNlJyBpbiBvYmogfHxcbiAgICAgICAgICAgICdpbmxpbmVEYXRhJyBpbiBvYmogfHxcbiAgICAgICAgICAgICd2aWRlb01ldGFkYXRhJyBpbiBvYmogfHxcbiAgICAgICAgICAgICdjb2RlRXhlY3V0aW9uUmVzdWx0JyBpbiBvYmogfHxcbiAgICAgICAgICAgICdleGVjdXRhYmxlQ29kZScgaW4gb2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gX3RvUGFydHMocGFydE9yU3RyaW5nKSB7XG4gICAgY29uc3QgcGFydHMgPSBbXTtcbiAgICBpZiAodHlwZW9mIHBhcnRPclN0cmluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcGFydHMucHVzaChjcmVhdGVQYXJ0RnJvbVRleHQocGFydE9yU3RyaW5nKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKF9pc1BhcnQocGFydE9yU3RyaW5nKSkge1xuICAgICAgICBwYXJ0cy5wdXNoKHBhcnRPclN0cmluZyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocGFydE9yU3RyaW5nKSkge1xuICAgICAgICBpZiAocGFydE9yU3RyaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYXJ0T3JTdHJpbmcgY2Fubm90IGJlIGFuIGVtcHR5IGFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRPclN0cmluZykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goY3JlYXRlUGFydEZyb21UZXh0KHBhcnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKF9pc1BhcnQocGFydCkpIHtcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHBhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlbGVtZW50IGluIFBhcnRVbmlvbiBtdXN0IGJlIGEgUGFydCBvYmplY3Qgb3Igc3RyaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFydE9yU3RyaW5nIG11c3QgYmUgYSBQYXJ0IG9iamVjdCwgc3RyaW5nLCBvciBhcnJheScpO1xuICAgIH1cbiAgICByZXR1cm4gcGFydHM7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBgQ29udGVudGAgb2JqZWN0IHdpdGggYSB1c2VyIHJvbGUgZnJvbSBhIGBQYXJ0TGlzdFVuaW9uYCBvYmplY3Qgb3IgYHN0cmluZ2AuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVVzZXJDb250ZW50KHBhcnRPclN0cmluZykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHJvbGU6ICd1c2VyJyxcbiAgICAgICAgcGFydHM6IF90b1BhcnRzKHBhcnRPclN0cmluZyksXG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGBDb250ZW50YCBvYmplY3Qgd2l0aCBhIG1vZGVsIHJvbGUgZnJvbSBhIGBQYXJ0TGlzdFVuaW9uYCBvYmplY3Qgb3IgYHN0cmluZ2AuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU1vZGVsQ29udGVudChwYXJ0T3JTdHJpbmcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICByb2xlOiAnbW9kZWwnLFxuICAgICAgICBwYXJ0czogX3RvUGFydHMocGFydE9yU3RyaW5nKSxcbiAgICB9O1xufVxuLyoqIEEgd3JhcHBlciBjbGFzcyBmb3IgdGhlIGh0dHAgcmVzcG9uc2UuICovXG5jbGFzcyBIdHRwUmVzcG9uc2Uge1xuICAgIGNvbnN0cnVjdG9yKHJlc3BvbnNlKSB7XG4gICAgICAgIC8vIFByb2Nlc3MgdGhlIGhlYWRlcnMuXG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBwYWlyIG9mIHJlc3BvbnNlLmhlYWRlcnMuZW50cmllcygpKSB7XG4gICAgICAgICAgICBoZWFkZXJzW3BhaXJbMF1dID0gcGFpclsxXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgICAgICAvLyBLZWVwIHRoZSBvcmlnaW5hbCByZXNwb25zZS5cbiAgICAgICAgdGhpcy5yZXNwb25zZUludGVybmFsID0gcmVzcG9uc2U7XG4gICAgfVxuICAgIGpzb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3BvbnNlSW50ZXJuYWwuanNvbigpO1xuICAgIH1cbn1cbi8qKiBDb250ZW50IGZpbHRlciByZXN1bHRzIGZvciBhIHByb21wdCBzZW50IGluIHRoZSByZXF1ZXN0LiBOb3RlOiBUaGlzIGlzIHNlbnQgb25seSBpbiB0aGUgZmlyc3Qgc3RyZWFtIGNodW5rIGFuZCBvbmx5IGlmIG5vIGNhbmRpZGF0ZXMgd2VyZSBnZW5lcmF0ZWQgZHVlIHRvIGNvbnRlbnQgdmlvbGF0aW9ucy4gKi9cbmNsYXNzIEdlbmVyYXRlQ29udGVudFJlc3BvbnNlUHJvbXB0RmVlZGJhY2sge1xufVxuLyoqIFVzYWdlIG1ldGFkYXRhIGFib3V0IHRoZSBjb250ZW50IGdlbmVyYXRpb24gcmVxdWVzdCBhbmQgcmVzcG9uc2UuIFRoaXMgbWVzc2FnZSBwcm92aWRlcyBhIGRldGFpbGVkIGJyZWFrZG93biBvZiB0b2tlbiB1c2FnZSBhbmQgb3RoZXIgcmVsZXZhbnQgbWV0cmljcy4gVGhpcyBkYXRhIHR5cGUgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLiAqL1xuY2xhc3MgR2VuZXJhdGVDb250ZW50UmVzcG9uc2VVc2FnZU1ldGFkYXRhIHtcbn1cbi8qKiBSZXNwb25zZSBtZXNzYWdlIGZvciBQcmVkaWN0aW9uU2VydmljZS5HZW5lcmF0ZUNvbnRlbnQuICovXG5jbGFzcyBHZW5lcmF0ZUNvbnRlbnRSZXNwb25zZSB7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29uY2F0ZW5hdGlvbiBvZiBhbGwgdGV4dCBwYXJ0cyBmcm9tIHRoZSBmaXJzdCBjYW5kaWRhdGUgaW4gdGhlIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgY2FuZGlkYXRlcyBpbiB0aGUgcmVzcG9uc2UsIHRoZSB0ZXh0IGZyb20gdGhlIGZpcnN0XG4gICAgICogb25lIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICogSWYgdGhlcmUgYXJlIG5vbi10ZXh0IHBhcnRzIGluIHRoZSByZXNwb25zZSwgdGhlIGNvbmNhdGVuYXRpb24gb2YgYWxsIHRleHRcbiAgICAgKiBwYXJ0cyB3aWxsIGJlIHJldHVybmVkLCBhbmQgYSB3YXJuaW5nIHdpbGwgYmUgbG9nZ2VkLlxuICAgICAqIElmIHRoZXJlIGFyZSB0aG91Z2h0IHBhcnRzIGluIHRoZSByZXNwb25zZSwgdGhlIGNvbmNhdGVuYXRpb24gb2YgYWxsIHRleHRcbiAgICAgKiBwYXJ0cyBleGNsdWRpbmcgdGhlIHRob3VnaHQgcGFydHMgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLm1vZGVscy5nZW5lcmF0ZUNvbnRlbnQoe1xuICAgICAqICAgbW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoJyxcbiAgICAgKiAgIGNvbnRlbnRzOlxuICAgICAqICAgICAnV2h5IGlzIHRoZSBza3kgYmx1ZT8nLFxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogY29uc29sZS5kZWJ1ZyhyZXNwb25zZS50ZXh0KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBnZXQgdGV4dCgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaDtcbiAgICAgICAgaWYgKCgoX2QgPSAoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLmNhbmRpZGF0ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNvbnRlbnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5wYXJ0cykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmxlbmd0aCkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2FuZGlkYXRlcyAmJiB0aGlzLmNhbmRpZGF0ZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCd0aGVyZSBhcmUgbXVsdGlwbGUgY2FuZGlkYXRlcyBpbiB0aGUgcmVzcG9uc2UsIHJldHVybmluZyB0ZXh0IGZyb20gdGhlIGZpcnN0IG9uZS4nKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdGV4dCA9ICcnO1xuICAgICAgICBsZXQgYW55VGV4dFBhcnRUZXh0ID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IG5vblRleHRQYXJ0cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgKF9oID0gKF9nID0gKF9mID0gKF9lID0gdGhpcy5jYW5kaWRhdGVzKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2VbMF0pID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5jb250ZW50KSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cucGFydHMpICE9PSBudWxsICYmIF9oICE9PSB2b2lkIDAgPyBfaCA6IFtdKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIGZpZWxkVmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHBhcnQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkTmFtZSAhPT0gJ3RleHQnICYmXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkTmFtZSAhPT0gJ3Rob3VnaHQnICYmXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkTmFtZSAhPT0gJ3Rob3VnaHRTaWduYXR1cmUnICYmXG4gICAgICAgICAgICAgICAgICAgIChmaWVsZFZhbHVlICE9PSBudWxsIHx8IGZpZWxkVmFsdWUgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9uVGV4dFBhcnRzLnB1c2goZmllbGROYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhcnQudGV4dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBhcnQudGhvdWdodCA9PT0gJ2Jvb2xlYW4nICYmIHBhcnQudGhvdWdodCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYW55VGV4dFBhcnRUZXh0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0ZXh0ICs9IHBhcnQudGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm9uVGV4dFBhcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgdGhlcmUgYXJlIG5vbi10ZXh0IHBhcnRzICR7bm9uVGV4dFBhcnRzfSBpbiB0aGUgcmVzcG9uc2UsIHJldHVybmluZyBjb25jYXRlbmF0aW9uIG9mIGFsbCB0ZXh0IHBhcnRzLiBQbGVhc2UgcmVmZXIgdG8gdGhlIG5vbiB0ZXh0IHBhcnRzIGZvciBhIGZ1bGwgcmVzcG9uc2UgZnJvbSBtb2RlbC5gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwYXJ0LnRleHQgPT09ICcnIGlzIGRpZmZlcmVudCBmcm9tIHBhcnQudGV4dCBpcyBudWxsXG4gICAgICAgIHJldHVybiBhbnlUZXh0UGFydFRleHQgPyB0ZXh0IDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb25jYXRlbmF0aW9uIG9mIGFsbCBpbmxpbmUgZGF0YSBwYXJ0cyBmcm9tIHRoZSBmaXJzdCBjYW5kaWRhdGVcbiAgICAgKiBpbiB0aGUgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIElmIHRoZXJlIGFyZSBtdWx0aXBsZSBjYW5kaWRhdGVzIGluIHRoZSByZXNwb25zZSwgdGhlIGlubGluZSBkYXRhIGZyb20gdGhlXG4gICAgICogZmlyc3Qgb25lIHdpbGwgYmUgcmV0dXJuZWQuIElmIHRoZXJlIGFyZSBub24taW5saW5lIGRhdGEgcGFydHMgaW4gdGhlXG4gICAgICogcmVzcG9uc2UsIHRoZSBjb25jYXRlbmF0aW9uIG9mIGFsbCBpbmxpbmUgZGF0YSBwYXJ0cyB3aWxsIGJlIHJldHVybmVkLCBhbmRcbiAgICAgKiBhIHdhcm5pbmcgd2lsbCBiZSBsb2dnZWQuXG4gICAgICovXG4gICAgZ2V0IGRhdGEoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2g7XG4gICAgICAgIGlmICgoKF9kID0gKF9jID0gKF9iID0gKF9hID0gdGhpcy5jYW5kaWRhdGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jb250ZW50KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucGFydHMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5sZW5ndGgpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNhbmRpZGF0ZXMgJiYgdGhpcy5jYW5kaWRhdGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybigndGhlcmUgYXJlIG11bHRpcGxlIGNhbmRpZGF0ZXMgaW4gdGhlIHJlc3BvbnNlLCByZXR1cm5pbmcgZGF0YSBmcm9tIHRoZSBmaXJzdCBvbmUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRhdGEgPSAnJztcbiAgICAgICAgY29uc3Qgbm9uRGF0YVBhcnRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiAoX2ggPSAoX2cgPSAoX2YgPSAoX2UgPSB0aGlzLmNhbmRpZGF0ZXMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZVswXSkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmNvbnRlbnQpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5wYXJ0cykgIT09IG51bGwgJiYgX2ggIT09IHZvaWQgMCA/IF9oIDogW10pIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgZmllbGRWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocGFydCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGROYW1lICE9PSAnaW5saW5lRGF0YScgJiZcbiAgICAgICAgICAgICAgICAgICAgKGZpZWxkVmFsdWUgIT09IG51bGwgfHwgZmllbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgICAgICAgICBub25EYXRhUGFydHMucHVzaChmaWVsZE5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJ0LmlubGluZURhdGEgJiYgdHlwZW9mIHBhcnQuaW5saW5lRGF0YS5kYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGRhdGEgKz0gYXRvYihwYXJ0LmlubGluZURhdGEuZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vbkRhdGFQYXJ0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYHRoZXJlIGFyZSBub24tZGF0YSBwYXJ0cyAke25vbkRhdGFQYXJ0c30gaW4gdGhlIHJlc3BvbnNlLCByZXR1cm5pbmcgY29uY2F0ZW5hdGlvbiBvZiBhbGwgZGF0YSBwYXJ0cy4gUGxlYXNlIHJlZmVyIHRvIHRoZSBub24gZGF0YSBwYXJ0cyBmb3IgYSBmdWxsIHJlc3BvbnNlIGZyb20gbW9kZWwuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGEubGVuZ3RoID4gMCA/IGJ0b2EoZGF0YSkgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZ1bmN0aW9uIGNhbGxzIGZyb20gdGhlIGZpcnN0IGNhbmRpZGF0ZSBpbiB0aGUgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIElmIHRoZXJlIGFyZSBtdWx0aXBsZSBjYW5kaWRhdGVzIGluIHRoZSByZXNwb25zZSwgdGhlIGZ1bmN0aW9uIGNhbGxzIGZyb21cbiAgICAgKiB0aGUgZmlyc3Qgb25lIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICogSWYgdGhlcmUgYXJlIG5vIGZ1bmN0aW9uIGNhbGxzIGluIHRoZSByZXNwb25zZSwgdW5kZWZpbmVkIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgY29udHJvbExpZ2h0RnVuY3Rpb25EZWNsYXJhdGlvbjogRnVuY3Rpb25EZWNsYXJhdGlvbiA9IHtcbiAgICAgKiAgIG5hbWU6ICdjb250cm9sTGlnaHQnLFxuICAgICAqICAgcGFyYW1ldGVyczoge1xuICAgICAqICAgdHlwZTogVHlwZS5PQkpFQ1QsXG4gICAgICogICBkZXNjcmlwdGlvbjogJ1NldCB0aGUgYnJpZ2h0bmVzcyBhbmQgY29sb3IgdGVtcGVyYXR1cmUgb2YgYSByb29tIGxpZ2h0LicsXG4gICAgICogICBwcm9wZXJ0aWVzOiB7XG4gICAgICogICAgIGJyaWdodG5lc3M6IHtcbiAgICAgKiAgICAgICB0eXBlOiBUeXBlLk5VTUJFUixcbiAgICAgKiAgICAgICBkZXNjcmlwdGlvbjpcbiAgICAgKiAgICAgICAgICdMaWdodCBsZXZlbCBmcm9tIDAgdG8gMTAwLiBaZXJvIGlzIG9mZiBhbmQgMTAwIGlzIGZ1bGwgYnJpZ2h0bmVzcy4nLFxuICAgICAqICAgICB9LFxuICAgICAqICAgICBjb2xvclRlbXBlcmF0dXJlOiB7XG4gICAgICogICAgICAgdHlwZTogVHlwZS5TVFJJTkcsXG4gICAgICogICAgICAgZGVzY3JpcHRpb246XG4gICAgICogICAgICAgICAnQ29sb3IgdGVtcGVyYXR1cmUgb2YgdGhlIGxpZ2h0IGZpeHR1cmUgd2hpY2ggY2FuIGJlIGBkYXlsaWdodGAsIGBjb29sYCBvciBgd2FybWAuJyxcbiAgICAgKiAgICAgfSxcbiAgICAgKiAgIH0sXG4gICAgICogICByZXF1aXJlZDogWydicmlnaHRuZXNzJywgJ2NvbG9yVGVtcGVyYXR1cmUnXSxcbiAgICAgKiAgfTtcbiAgICAgKiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhaS5tb2RlbHMuZ2VuZXJhdGVDb250ZW50KHtcbiAgICAgKiAgICAgbW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoJyxcbiAgICAgKiAgICAgY29udGVudHM6ICdEaW0gdGhlIGxpZ2h0cyBzbyB0aGUgcm9vbSBmZWVscyBjb3p5IGFuZCB3YXJtLicsXG4gICAgICogICAgIGNvbmZpZzoge1xuICAgICAqICAgICAgIHRvb2xzOiBbe2Z1bmN0aW9uRGVjbGFyYXRpb25zOiBbY29udHJvbExpZ2h0RnVuY3Rpb25EZWNsYXJhdGlvbl19XSxcbiAgICAgKiAgICAgICB0b29sQ29uZmlnOiB7XG4gICAgICogICAgICAgICBmdW5jdGlvbkNhbGxpbmdDb25maWc6IHtcbiAgICAgKiAgICAgICAgICAgbW9kZTogRnVuY3Rpb25DYWxsaW5nQ29uZmlnTW9kZS5BTlksXG4gICAgICogICAgICAgICAgIGFsbG93ZWRGdW5jdGlvbk5hbWVzOiBbJ2NvbnRyb2xMaWdodCddLFxuICAgICAqICAgICAgICAgfSxcbiAgICAgKiAgICAgICB9LFxuICAgICAqICAgICB9LFxuICAgICAqICAgfSk7XG4gICAgICogIGNvbnNvbGUuZGVidWcoSlNPTi5zdHJpbmdpZnkocmVzcG9uc2UuZnVuY3Rpb25DYWxscykpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldCBmdW5jdGlvbkNhbGxzKCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oO1xuICAgICAgICBpZiAoKChfZCA9IChfYyA9IChfYiA9IChfYSA9IHRoaXMuY2FuZGlkYXRlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY29udGVudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnBhcnRzKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QubGVuZ3RoKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jYW5kaWRhdGVzICYmIHRoaXMuY2FuZGlkYXRlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ3RoZXJlIGFyZSBtdWx0aXBsZSBjYW5kaWRhdGVzIGluIHRoZSByZXNwb25zZSwgcmV0dXJuaW5nIGZ1bmN0aW9uIGNhbGxzIGZyb20gdGhlIGZpcnN0IG9uZS4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmdW5jdGlvbkNhbGxzID0gKF9oID0gKF9nID0gKF9mID0gKF9lID0gdGhpcy5jYW5kaWRhdGVzKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2VbMF0pID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5jb250ZW50KSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cucGFydHMpID09PSBudWxsIHx8IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaC5maWx0ZXIoKHBhcnQpID0+IHBhcnQuZnVuY3Rpb25DYWxsKS5tYXAoKHBhcnQpID0+IHBhcnQuZnVuY3Rpb25DYWxsKS5maWx0ZXIoKGZ1bmN0aW9uQ2FsbCkgPT4gZnVuY3Rpb25DYWxsICE9PSB1bmRlZmluZWQpO1xuICAgICAgICBpZiAoKGZ1bmN0aW9uQ2FsbHMgPT09IG51bGwgfHwgZnVuY3Rpb25DYWxscyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZnVuY3Rpb25DYWxscy5sZW5ndGgpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbkNhbGxzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBleGVjdXRhYmxlIGNvZGUgZnJvbSB0aGUgZmlyc3QgY2FuZGlkYXRlIGluIHRoZSByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogSWYgdGhlcmUgYXJlIG11bHRpcGxlIGNhbmRpZGF0ZXMgaW4gdGhlIHJlc3BvbnNlLCB0aGUgZXhlY3V0YWJsZSBjb2RlIGZyb21cbiAgICAgKiB0aGUgZmlyc3Qgb25lIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICogSWYgdGhlcmUgYXJlIG5vIGV4ZWN1dGFibGUgY29kZSBpbiB0aGUgcmVzcG9uc2UsIHVuZGVmaW5lZCB3aWxsIGJlXG4gICAgICogcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhaS5tb2RlbHMuZ2VuZXJhdGVDb250ZW50KHtcbiAgICAgKiAgIG1vZGVsOiAnZ2VtaW5pLTIuMC1mbGFzaCcsXG4gICAgICogICBjb250ZW50czpcbiAgICAgKiAgICAgJ1doYXQgaXMgdGhlIHN1bSBvZiB0aGUgZmlyc3QgNTAgcHJpbWUgbnVtYmVycz8gR2VuZXJhdGUgYW5kIHJ1biBjb2RlIGZvciB0aGUgY2FsY3VsYXRpb24sIGFuZCBtYWtlIHN1cmUgeW91IGdldCBhbGwgNTAuJ1xuICAgICAqICAgY29uZmlnOiB7XG4gICAgICogICAgIHRvb2xzOiBbe2NvZGVFeGVjdXRpb246IHt9fV0sXG4gICAgICogICB9LFxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogY29uc29sZS5kZWJ1ZyhyZXNwb25zZS5leGVjdXRhYmxlQ29kZSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IGV4ZWN1dGFibGVDb2RlKCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfajtcbiAgICAgICAgaWYgKCgoX2QgPSAoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLmNhbmRpZGF0ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNvbnRlbnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5wYXJ0cykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmxlbmd0aCkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2FuZGlkYXRlcyAmJiB0aGlzLmNhbmRpZGF0ZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCd0aGVyZSBhcmUgbXVsdGlwbGUgY2FuZGlkYXRlcyBpbiB0aGUgcmVzcG9uc2UsIHJldHVybmluZyBleGVjdXRhYmxlIGNvZGUgZnJvbSB0aGUgZmlyc3Qgb25lLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4ZWN1dGFibGVDb2RlID0gKF9oID0gKF9nID0gKF9mID0gKF9lID0gdGhpcy5jYW5kaWRhdGVzKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2VbMF0pID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5jb250ZW50KSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cucGFydHMpID09PSBudWxsIHx8IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaC5maWx0ZXIoKHBhcnQpID0+IHBhcnQuZXhlY3V0YWJsZUNvZGUpLm1hcCgocGFydCkgPT4gcGFydC5leGVjdXRhYmxlQ29kZSkuZmlsdGVyKChleGVjdXRhYmxlQ29kZSkgPT4gZXhlY3V0YWJsZUNvZGUgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgIGlmICgoZXhlY3V0YWJsZUNvZGUgPT09IG51bGwgfHwgZXhlY3V0YWJsZUNvZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV4ZWN1dGFibGVDb2RlLmxlbmd0aCkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChfaiA9IGV4ZWN1dGFibGVDb2RlID09PSBudWxsIHx8IGV4ZWN1dGFibGVDb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBleGVjdXRhYmxlQ29kZVswXSkgPT09IG51bGwgfHwgX2ogPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9qLmNvZGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZpcnN0IGNvZGUgZXhlY3V0aW9uIHJlc3VsdCBmcm9tIHRoZSBmaXJzdCBjYW5kaWRhdGUgaW4gdGhlIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgY2FuZGlkYXRlcyBpbiB0aGUgcmVzcG9uc2UsIHRoZSBjb2RlIGV4ZWN1dGlvbiByZXN1bHQgZnJvbVxuICAgICAqIHRoZSBmaXJzdCBvbmUgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKiBJZiB0aGVyZSBhcmUgbm8gY29kZSBleGVjdXRpb24gcmVzdWx0IGluIHRoZSByZXNwb25zZSwgdW5kZWZpbmVkIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhaS5tb2RlbHMuZ2VuZXJhdGVDb250ZW50KHtcbiAgICAgKiAgIG1vZGVsOiAnZ2VtaW5pLTIuMC1mbGFzaCcsXG4gICAgICogICBjb250ZW50czpcbiAgICAgKiAgICAgJ1doYXQgaXMgdGhlIHN1bSBvZiB0aGUgZmlyc3QgNTAgcHJpbWUgbnVtYmVycz8gR2VuZXJhdGUgYW5kIHJ1biBjb2RlIGZvciB0aGUgY2FsY3VsYXRpb24sIGFuZCBtYWtlIHN1cmUgeW91IGdldCBhbGwgNTAuJ1xuICAgICAqICAgY29uZmlnOiB7XG4gICAgICogICAgIHRvb2xzOiBbe2NvZGVFeGVjdXRpb246IHt9fV0sXG4gICAgICogICB9LFxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogY29uc29sZS5kZWJ1ZyhyZXNwb25zZS5jb2RlRXhlY3V0aW9uUmVzdWx0KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBnZXQgY29kZUV4ZWN1dGlvblJlc3VsdCgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2o7XG4gICAgICAgIGlmICgoKF9kID0gKF9jID0gKF9iID0gKF9hID0gdGhpcy5jYW5kaWRhdGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jb250ZW50KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucGFydHMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5sZW5ndGgpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNhbmRpZGF0ZXMgJiYgdGhpcy5jYW5kaWRhdGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybigndGhlcmUgYXJlIG11bHRpcGxlIGNhbmRpZGF0ZXMgaW4gdGhlIHJlc3BvbnNlLCByZXR1cm5pbmcgY29kZSBleGVjdXRpb24gcmVzdWx0IGZyb20gdGhlIGZpcnN0IG9uZS4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb2RlRXhlY3V0aW9uUmVzdWx0ID0gKF9oID0gKF9nID0gKF9mID0gKF9lID0gdGhpcy5jYW5kaWRhdGVzKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2VbMF0pID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5jb250ZW50KSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cucGFydHMpID09PSBudWxsIHx8IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaC5maWx0ZXIoKHBhcnQpID0+IHBhcnQuY29kZUV4ZWN1dGlvblJlc3VsdCkubWFwKChwYXJ0KSA9PiBwYXJ0LmNvZGVFeGVjdXRpb25SZXN1bHQpLmZpbHRlcigoY29kZUV4ZWN1dGlvblJlc3VsdCkgPT4gY29kZUV4ZWN1dGlvblJlc3VsdCAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKChjb2RlRXhlY3V0aW9uUmVzdWx0ID09PSBudWxsIHx8IGNvZGVFeGVjdXRpb25SZXN1bHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvZGVFeGVjdXRpb25SZXN1bHQubGVuZ3RoKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKF9qID0gY29kZUV4ZWN1dGlvblJlc3VsdCA9PT0gbnVsbCB8fCBjb2RlRXhlY3V0aW9uUmVzdWx0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb2RlRXhlY3V0aW9uUmVzdWx0WzBdKSA9PT0gbnVsbCB8fCBfaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2oub3V0cHV0O1xuICAgIH1cbn1cbi8qKiBSZXNwb25zZSBmb3IgdGhlIGVtYmVkX2NvbnRlbnQgbWV0aG9kLiAqL1xuY2xhc3MgRW1iZWRDb250ZW50UmVzcG9uc2Uge1xufVxuLyoqIFRoZSBvdXRwdXQgaW1hZ2VzIHJlc3BvbnNlLiAqL1xuY2xhc3MgR2VuZXJhdGVJbWFnZXNSZXNwb25zZSB7XG59XG4vKiogUmVzcG9uc2UgZm9yIHRoZSByZXF1ZXN0IHRvIGVkaXQgYW4gaW1hZ2UuICovXG5jbGFzcyBFZGl0SW1hZ2VSZXNwb25zZSB7XG59XG5jbGFzcyBVcHNjYWxlSW1hZ2VSZXNwb25zZSB7XG59XG4vKiogVGhlIG91dHB1dCBpbWFnZXMgcmVzcG9uc2UuICovXG5jbGFzcyBSZWNvbnRleHRJbWFnZVJlc3BvbnNlIHtcbn1cbi8qKiBUaGUgb3V0cHV0IGltYWdlcyByZXNwb25zZS4gKi9cbmNsYXNzIFNlZ21lbnRJbWFnZVJlc3BvbnNlIHtcbn1cbmNsYXNzIExpc3RNb2RlbHNSZXNwb25zZSB7XG59XG5jbGFzcyBEZWxldGVNb2RlbFJlc3BvbnNlIHtcbn1cbi8qKiBSZXNwb25zZSBmb3IgY291bnRpbmcgdG9rZW5zLiAqL1xuY2xhc3MgQ291bnRUb2tlbnNSZXNwb25zZSB7XG59XG4vKiogUmVzcG9uc2UgZm9yIGNvbXB1dGluZyB0b2tlbnMuICovXG5jbGFzcyBDb21wdXRlVG9rZW5zUmVzcG9uc2Uge1xufVxuLyoqIFJlc3BvbnNlIHdpdGggZ2VuZXJhdGVkIHZpZGVvcy4gKi9cbmNsYXNzIEdlbmVyYXRlVmlkZW9zUmVzcG9uc2Uge1xufVxuLyoqIEEgdmlkZW8gZ2VuZXJhdGlvbiBvcGVyYXRpb24uICovXG5jbGFzcyBHZW5lcmF0ZVZpZGVvc09wZXJhdGlvbiB7XG4gICAgLyoqXG4gICAgICogSW5zdGFudGlhdGVzIGFuIE9wZXJhdGlvbiBvZiB0aGUgc2FtZSB0eXBlIGFzIHRoZSBvbmUgYmVpbmcgY2FsbGVkIHdpdGggdGhlIGZpZWxkcyBzZXQgZnJvbSB0aGUgQVBJIHJlc3BvbnNlLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9mcm9tQVBJUmVzcG9uc2UoeyBhcGlSZXNwb25zZSwgX2lzVmVydGV4QUksIH0pIHtcbiAgICAgICAgY29uc3Qgb3BlcmF0aW9uID0gbmV3IEdlbmVyYXRlVmlkZW9zT3BlcmF0aW9uKCk7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgY29uc3Qgb3AgPSBhcGlSZXNwb25zZTtcbiAgICAgICAgaWYgKF9pc1ZlcnRleEFJKSB7XG4gICAgICAgICAgICByZXNwb25zZSA9IGdlbmVyYXRlVmlkZW9zT3BlcmF0aW9uRnJvbVZlcnRleCQxKG9wKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gZ2VuZXJhdGVWaWRlb3NPcGVyYXRpb25Gcm9tTWxkZXYkMShvcCk7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmFzc2lnbihvcGVyYXRpb24sIHJlc3BvbnNlKTtcbiAgICAgICAgcmV0dXJuIG9wZXJhdGlvbjtcbiAgICB9XG59XG4vKiogUmVzcG9uc2UgZm9yIHRoZSBsaXN0IHR1bmluZyBqb2JzIG1ldGhvZC4gKi9cbmNsYXNzIExpc3RUdW5pbmdKb2JzUmVzcG9uc2Uge1xufVxuLyoqIEVtcHR5IHJlc3BvbnNlIGZvciBjYWNoZXMuZGVsZXRlIG1ldGhvZC4gKi9cbmNsYXNzIERlbGV0ZUNhY2hlZENvbnRlbnRSZXNwb25zZSB7XG59XG5jbGFzcyBMaXN0Q2FjaGVkQ29udGVudHNSZXNwb25zZSB7XG59XG4vKiogQ29uZmlnIGZvciBkb2N1bWVudHMubGlzdCByZXR1cm4gdmFsdWUuICovXG5jbGFzcyBMaXN0RG9jdW1lbnRzUmVzcG9uc2Uge1xufVxuLyoqIENvbmZpZyBmb3IgZmlsZV9zZWFyY2hfc3RvcmVzLmxpc3QgcmV0dXJuIHZhbHVlLiAqL1xuY2xhc3MgTGlzdEZpbGVTZWFyY2hTdG9yZXNSZXNwb25zZSB7XG59XG4vKiogUmVzcG9uc2UgZm9yIHRoZSByZXN1bWFibGUgdXBsb2FkIG1ldGhvZC4gKi9cbmNsYXNzIFVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlUmVzdW1hYmxlUmVzcG9uc2Uge1xufVxuLyoqIFJlc3BvbnNlIGZvciBJbXBvcnRGaWxlIHRvIGltcG9ydCBhIEZpbGUgQVBJIGZpbGUgd2l0aCBhIGZpbGUgc2VhcmNoIHN0b3JlLiAqL1xuY2xhc3MgSW1wb3J0RmlsZVJlc3BvbnNlIHtcbn1cbi8qKiBMb25nLXJ1bm5pbmcgb3BlcmF0aW9uIGZvciBpbXBvcnRpbmcgYSBmaWxlIHRvIGEgRmlsZVNlYXJjaFN0b3JlLiAqL1xuY2xhc3MgSW1wb3J0RmlsZU9wZXJhdGlvbiB7XG4gICAgLyoqXG4gICAgICogSW5zdGFudGlhdGVzIGFuIE9wZXJhdGlvbiBvZiB0aGUgc2FtZSB0eXBlIGFzIHRoZSBvbmUgYmVpbmcgY2FsbGVkIHdpdGggdGhlIGZpZWxkcyBzZXQgZnJvbSB0aGUgQVBJIHJlc3BvbnNlLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9mcm9tQVBJUmVzcG9uc2UoeyBhcGlSZXNwb25zZSwgX2lzVmVydGV4QUksIH0pIHtcbiAgICAgICAgY29uc3Qgb3BlcmF0aW9uID0gbmV3IEltcG9ydEZpbGVPcGVyYXRpb24oKTtcbiAgICAgICAgY29uc3Qgb3AgPSBhcGlSZXNwb25zZTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBpbXBvcnRGaWxlT3BlcmF0aW9uRnJvbU1sZGV2JDEob3ApO1xuICAgICAgICBPYmplY3QuYXNzaWduKG9wZXJhdGlvbiwgcmVzcG9uc2UpO1xuICAgICAgICByZXR1cm4gb3BlcmF0aW9uO1xuICAgIH1cbn1cbi8qKiBSZXNwb25zZSBmb3IgdGhlIGxpc3QgZmlsZXMgbWV0aG9kLiAqL1xuY2xhc3MgTGlzdEZpbGVzUmVzcG9uc2Uge1xufVxuLyoqIFJlc3BvbnNlIGZvciB0aGUgY3JlYXRlIGZpbGUgbWV0aG9kLiAqL1xuY2xhc3MgQ3JlYXRlRmlsZVJlc3BvbnNlIHtcbn1cbi8qKiBSZXNwb25zZSBmb3IgdGhlIGRlbGV0ZSBmaWxlIG1ldGhvZC4gKi9cbmNsYXNzIERlbGV0ZUZpbGVSZXNwb25zZSB7XG59XG4vKiogQ29uZmlnIGZvciBgaW5saW5lZF9yZXNwb25zZXNgIHBhcmFtZXRlci4gKi9cbmNsYXNzIElubGluZWRSZXNwb25zZSB7XG59XG4vKiogQ29uZmlnIGZvciBgcmVzcG9uc2VgIHBhcmFtZXRlci4gKi9cbmNsYXNzIFNpbmdsZUVtYmVkQ29udGVudFJlc3BvbnNlIHtcbn1cbi8qKiBDb25maWcgZm9yIGBpbmxpbmVkX2VtYmVkZGluZ19yZXNwb25zZXNgIHBhcmFtZXRlci4gKi9cbmNsYXNzIElubGluZWRFbWJlZENvbnRlbnRSZXNwb25zZSB7XG59XG4vKiogQ29uZmlnIGZvciBiYXRjaGVzLmxpc3QgcmV0dXJuIHZhbHVlLiAqL1xuY2xhc3MgTGlzdEJhdGNoSm9ic1Jlc3BvbnNlIHtcbn1cbi8qKiBSZXByZXNlbnRzIGEgc2luZ2xlIHJlc3BvbnNlIGluIGEgcmVwbGF5LiAqL1xuY2xhc3MgUmVwbGF5UmVzcG9uc2Uge1xufVxuLyoqIEEgcmF3IHJlZmVyZW5jZSBpbWFnZS5cblxuQSByYXcgcmVmZXJlbmNlIGltYWdlIHJlcHJlc2VudHMgdGhlIGJhc2UgaW1hZ2UgdG8gZWRpdCwgcHJvdmlkZWQgYnkgdGhlIHVzZXIuXG5JdCBjYW4gb3B0aW9uYWxseSBiZSBwcm92aWRlZCBpbiBhZGRpdGlvbiB0byBhIG1hc2sgcmVmZXJlbmNlIGltYWdlIG9yXG5hIHN0eWxlIHJlZmVyZW5jZSBpbWFnZS4gKi9cbmNsYXNzIFJhd1JlZmVyZW5jZUltYWdlIHtcbiAgICAvKiogSW50ZXJuYWwgbWV0aG9kIHRvIGNvbnZlcnQgdG8gUmVmZXJlbmNlSW1hZ2VBUElJbnRlcm5hbC4gKi9cbiAgICB0b1JlZmVyZW5jZUltYWdlQVBJKCkge1xuICAgICAgICBjb25zdCByZWZlcmVuY2VJbWFnZUFQSSA9IHtcbiAgICAgICAgICAgIHJlZmVyZW5jZVR5cGU6ICdSRUZFUkVOQ0VfVFlQRV9SQVcnLFxuICAgICAgICAgICAgcmVmZXJlbmNlSW1hZ2U6IHRoaXMucmVmZXJlbmNlSW1hZ2UsXG4gICAgICAgICAgICByZWZlcmVuY2VJZDogdGhpcy5yZWZlcmVuY2VJZCxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlZmVyZW5jZUltYWdlQVBJO1xuICAgIH1cbn1cbi8qKiBBIG1hc2sgcmVmZXJlbmNlIGltYWdlLlxuXG5UaGlzIGVuY2Fwc3VsYXRlcyBlaXRoZXIgYSBtYXNrIGltYWdlIHByb3ZpZGVkIGJ5IHRoZSB1c2VyIGFuZCBjb25maWdzIGZvclxudGhlIHVzZXIgcHJvdmlkZWQgbWFzaywgb3Igb25seSBjb25maWcgcGFyYW1ldGVycyBmb3IgdGhlIG1vZGVsIHRvIGdlbmVyYXRlXG5hIG1hc2suXG5cbkEgbWFzayBpbWFnZSBpcyBhbiBpbWFnZSB3aG9zZSBub24temVybyB2YWx1ZXMgaW5kaWNhdGUgd2hlcmUgdG8gZWRpdCB0aGUgYmFzZVxuaW1hZ2UuIElmIHRoZSB1c2VyIHByb3ZpZGVzIGEgbWFzayBpbWFnZSwgdGhlIG1hc2sgbXVzdCBiZSBpbiB0aGUgc2FtZVxuZGltZW5zaW9ucyBhcyB0aGUgcmF3IGltYWdlLiAqL1xuY2xhc3MgTWFza1JlZmVyZW5jZUltYWdlIHtcbiAgICAvKiogSW50ZXJuYWwgbWV0aG9kIHRvIGNvbnZlcnQgdG8gUmVmZXJlbmNlSW1hZ2VBUElJbnRlcm5hbC4gKi9cbiAgICB0b1JlZmVyZW5jZUltYWdlQVBJKCkge1xuICAgICAgICBjb25zdCByZWZlcmVuY2VJbWFnZUFQSSA9IHtcbiAgICAgICAgICAgIHJlZmVyZW5jZVR5cGU6ICdSRUZFUkVOQ0VfVFlQRV9NQVNLJyxcbiAgICAgICAgICAgIHJlZmVyZW5jZUltYWdlOiB0aGlzLnJlZmVyZW5jZUltYWdlLFxuICAgICAgICAgICAgcmVmZXJlbmNlSWQ6IHRoaXMucmVmZXJlbmNlSWQsXG4gICAgICAgICAgICBtYXNrSW1hZ2VDb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmVmZXJlbmNlSW1hZ2VBUEk7XG4gICAgfVxufVxuLyoqIEEgY29udHJvbCByZWZlcmVuY2UgaW1hZ2UuXG5cblRoZSBpbWFnZSBvZiB0aGUgY29udHJvbCByZWZlcmVuY2UgaW1hZ2UgaXMgZWl0aGVyIGEgY29udHJvbCBpbWFnZSBwcm92aWRlZFxuYnkgdGhlIHVzZXIsIG9yIGEgcmVndWxhciBpbWFnZSB3aGljaCB0aGUgYmFja2VuZCB3aWxsIHVzZSB0byBnZW5lcmF0ZSBhXG5jb250cm9sIGltYWdlIG9mLiBJbiB0aGUgY2FzZSBvZiB0aGUgbGF0dGVyLCB0aGVcbmVuYWJsZV9jb250cm9sX2ltYWdlX2NvbXB1dGF0aW9uIGZpZWxkIGluIHRoZSBjb25maWcgc2hvdWxkIGJlIHNldCB0byBUcnVlLlxuXG5BIGNvbnRyb2wgaW1hZ2UgaXMgYW4gaW1hZ2UgdGhhdCByZXByZXNlbnRzIGEgc2tldGNoIGltYWdlIG9mIGFyZWFzIGZvciB0aGVcbm1vZGVsIHRvIGZpbGwgaW4gYmFzZWQgb24gdGhlIHByb21wdC4gKi9cbmNsYXNzIENvbnRyb2xSZWZlcmVuY2VJbWFnZSB7XG4gICAgLyoqIEludGVybmFsIG1ldGhvZCB0byBjb252ZXJ0IHRvIFJlZmVyZW5jZUltYWdlQVBJSW50ZXJuYWwuICovXG4gICAgdG9SZWZlcmVuY2VJbWFnZUFQSSgpIHtcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlSW1hZ2VBUEkgPSB7XG4gICAgICAgICAgICByZWZlcmVuY2VUeXBlOiAnUkVGRVJFTkNFX1RZUEVfQ09OVFJPTCcsXG4gICAgICAgICAgICByZWZlcmVuY2VJbWFnZTogdGhpcy5yZWZlcmVuY2VJbWFnZSxcbiAgICAgICAgICAgIHJlZmVyZW5jZUlkOiB0aGlzLnJlZmVyZW5jZUlkLFxuICAgICAgICAgICAgY29udHJvbEltYWdlQ29uZmlnOiB0aGlzLmNvbmZpZyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlZmVyZW5jZUltYWdlQVBJO1xuICAgIH1cbn1cbi8qKiBBIHN0eWxlIHJlZmVyZW5jZSBpbWFnZS5cblxuVGhpcyBlbmNhcHN1bGF0ZXMgYSBzdHlsZSByZWZlcmVuY2UgaW1hZ2UgcHJvdmlkZWQgYnkgdGhlIHVzZXIsIGFuZFxuYWRkaXRpb25hbGx5IG9wdGlvbmFsIGNvbmZpZyBwYXJhbWV0ZXJzIGZvciB0aGUgc3R5bGUgcmVmZXJlbmNlIGltYWdlLlxuXG5BIHJhdyByZWZlcmVuY2UgaW1hZ2UgY2FuIGFsc28gYmUgcHJvdmlkZWQgYXMgYSBkZXN0aW5hdGlvbiBmb3IgdGhlIHN0eWxlIHRvXG5iZSBhcHBsaWVkIHRvLiAqL1xuY2xhc3MgU3R5bGVSZWZlcmVuY2VJbWFnZSB7XG4gICAgLyoqIEludGVybmFsIG1ldGhvZCB0byBjb252ZXJ0IHRvIFJlZmVyZW5jZUltYWdlQVBJSW50ZXJuYWwuICovXG4gICAgdG9SZWZlcmVuY2VJbWFnZUFQSSgpIHtcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlSW1hZ2VBUEkgPSB7XG4gICAgICAgICAgICByZWZlcmVuY2VUeXBlOiAnUkVGRVJFTkNFX1RZUEVfU1RZTEUnLFxuICAgICAgICAgICAgcmVmZXJlbmNlSW1hZ2U6IHRoaXMucmVmZXJlbmNlSW1hZ2UsXG4gICAgICAgICAgICByZWZlcmVuY2VJZDogdGhpcy5yZWZlcmVuY2VJZCxcbiAgICAgICAgICAgIHN0eWxlSW1hZ2VDb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmVmZXJlbmNlSW1hZ2VBUEk7XG4gICAgfVxufVxuLyoqIEEgc3ViamVjdCByZWZlcmVuY2UgaW1hZ2UuXG5cblRoaXMgZW5jYXBzdWxhdGVzIGEgc3ViamVjdCByZWZlcmVuY2UgaW1hZ2UgcHJvdmlkZWQgYnkgdGhlIHVzZXIsIGFuZFxuYWRkaXRpb25hbGx5IG9wdGlvbmFsIGNvbmZpZyBwYXJhbWV0ZXJzIGZvciB0aGUgc3ViamVjdCByZWZlcmVuY2UgaW1hZ2UuXG5cbkEgcmF3IHJlZmVyZW5jZSBpbWFnZSBjYW4gYWxzbyBiZSBwcm92aWRlZCBhcyBhIGRlc3RpbmF0aW9uIGZvciB0aGUgc3ViamVjdCB0b1xuYmUgYXBwbGllZCB0by4gKi9cbmNsYXNzIFN1YmplY3RSZWZlcmVuY2VJbWFnZSB7XG4gICAgLyogSW50ZXJuYWwgbWV0aG9kIHRvIGNvbnZlcnQgdG8gUmVmZXJlbmNlSW1hZ2VBUElJbnRlcm5hbC4gKi9cbiAgICB0b1JlZmVyZW5jZUltYWdlQVBJKCkge1xuICAgICAgICBjb25zdCByZWZlcmVuY2VJbWFnZUFQSSA9IHtcbiAgICAgICAgICAgIHJlZmVyZW5jZVR5cGU6ICdSRUZFUkVOQ0VfVFlQRV9TVUJKRUNUJyxcbiAgICAgICAgICAgIHJlZmVyZW5jZUltYWdlOiB0aGlzLnJlZmVyZW5jZUltYWdlLFxuICAgICAgICAgICAgcmVmZXJlbmNlSWQ6IHRoaXMucmVmZXJlbmNlSWQsXG4gICAgICAgICAgICBzdWJqZWN0SW1hZ2VDb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmVmZXJlbmNlSW1hZ2VBUEk7XG4gICAgfVxufVxuLyoqIEEgY29udGVudCByZWZlcmVuY2UgaW1hZ2UuXG5cbkEgY29udGVudCByZWZlcmVuY2UgaW1hZ2UgcmVwcmVzZW50cyBhIHN1YmplY3QgdG8gcmVmZXJlbmNlIChleC4gcGVyc29uLFxucHJvZHVjdCwgYW5pbWFsKSBwcm92aWRlZCBieSB0aGUgdXNlci4gSXQgY2FuIG9wdGlvbmFsbHkgYmUgcHJvdmlkZWQgaW5cbmFkZGl0aW9uIHRvIGEgc3R5bGUgcmVmZXJlbmNlIGltYWdlIChleC4gYmFja2dyb3VuZCwgc3R5bGUgcmVmZXJlbmNlKS4gKi9cbmNsYXNzIENvbnRlbnRSZWZlcmVuY2VJbWFnZSB7XG4gICAgLyoqIEludGVybmFsIG1ldGhvZCB0byBjb252ZXJ0IHRvIFJlZmVyZW5jZUltYWdlQVBJSW50ZXJuYWwuICovXG4gICAgdG9SZWZlcmVuY2VJbWFnZUFQSSgpIHtcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlSW1hZ2VBUEkgPSB7XG4gICAgICAgICAgICByZWZlcmVuY2VUeXBlOiAnUkVGRVJFTkNFX1RZUEVfQ09OVEVOVCcsXG4gICAgICAgICAgICByZWZlcmVuY2VJbWFnZTogdGhpcy5yZWZlcmVuY2VJbWFnZSxcbiAgICAgICAgICAgIHJlZmVyZW5jZUlkOiB0aGlzLnJlZmVyZW5jZUlkLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmVmZXJlbmNlSW1hZ2VBUEk7XG4gICAgfVxufVxuLyoqIFJlc3BvbnNlIG1lc3NhZ2UgZm9yIEFQSSBjYWxsLiAqL1xuY2xhc3MgTGl2ZVNlcnZlck1lc3NhZ2Uge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvbmNhdGVuYXRpb24gb2YgYWxsIHRleHQgcGFydHMgZnJvbSB0aGUgc2VydmVyIGNvbnRlbnQgaWYgcHJlc2VudC5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogSWYgdGhlcmUgYXJlIG5vbi10ZXh0IHBhcnRzIGluIHRoZSByZXNwb25zZSwgdGhlIGNvbmNhdGVuYXRpb24gb2YgYWxsIHRleHRcbiAgICAgKiBwYXJ0cyB3aWxsIGJlIHJldHVybmVkLCBhbmQgYSB3YXJuaW5nIHdpbGwgYmUgbG9nZ2VkLlxuICAgICAqL1xuICAgIGdldCB0ZXh0KCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgbGV0IHRleHQgPSAnJztcbiAgICAgICAgbGV0IGFueVRleHRQYXJ0Rm91bmQgPSBmYWxzZTtcbiAgICAgICAgY29uc3Qgbm9uVGV4dFBhcnRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiAoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLnNlcnZlckNvbnRlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tb2RlbFR1cm4pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5wYXJ0cykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogW10pIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgZmllbGRWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocGFydCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGROYW1lICE9PSAndGV4dCcgJiZcbiAgICAgICAgICAgICAgICAgICAgZmllbGROYW1lICE9PSAndGhvdWdodCcgJiZcbiAgICAgICAgICAgICAgICAgICAgZmllbGRWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBub25UZXh0UGFydHMucHVzaChmaWVsZE5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydC50ZXh0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydC50aG91Z2h0ID09PSAnYm9vbGVhbicgJiYgcGFydC50aG91Z2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhbnlUZXh0UGFydEZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0ZXh0ICs9IHBhcnQudGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm9uVGV4dFBhcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgdGhlcmUgYXJlIG5vbi10ZXh0IHBhcnRzICR7bm9uVGV4dFBhcnRzfSBpbiB0aGUgcmVzcG9uc2UsIHJldHVybmluZyBjb25jYXRlbmF0aW9uIG9mIGFsbCB0ZXh0IHBhcnRzLiBQbGVhc2UgcmVmZXIgdG8gdGhlIG5vbiB0ZXh0IHBhcnRzIGZvciBhIGZ1bGwgcmVzcG9uc2UgZnJvbSBtb2RlbC5gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwYXJ0LnRleHQgPT09ICcnIGlzIGRpZmZlcmVudCBmcm9tIHBhcnQudGV4dCBpcyBudWxsXG4gICAgICAgIHJldHVybiBhbnlUZXh0UGFydEZvdW5kID8gdGV4dCA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29uY2F0ZW5hdGlvbiBvZiBhbGwgaW5saW5lIGRhdGEgcGFydHMgZnJvbSB0aGUgc2VydmVyIGNvbnRlbnQgaWYgcHJlc2VudC5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogSWYgdGhlcmUgYXJlIG5vbi1pbmxpbmUgZGF0YSBwYXJ0cyBpbiB0aGVcbiAgICAgKiByZXNwb25zZSwgdGhlIGNvbmNhdGVuYXRpb24gb2YgYWxsIGlubGluZSBkYXRhIHBhcnRzIHdpbGwgYmUgcmV0dXJuZWQsIGFuZFxuICAgICAqIGEgd2FybmluZyB3aWxsIGJlIGxvZ2dlZC5cbiAgICAgKi9cbiAgICBnZXQgZGF0YSgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGxldCBkYXRhID0gJyc7XG4gICAgICAgIGNvbnN0IG5vbkRhdGFQYXJ0cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgKF9jID0gKF9iID0gKF9hID0gdGhpcy5zZXJ2ZXJDb250ZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubW9kZWxUdXJuKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucGFydHMpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFtdKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIGZpZWxkVmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHBhcnQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkTmFtZSAhPT0gJ2lubGluZURhdGEnICYmIGZpZWxkVmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9uRGF0YVBhcnRzLnB1c2goZmllbGROYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFydC5pbmxpbmVEYXRhICYmIHR5cGVvZiBwYXJ0LmlubGluZURhdGEuZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBkYXRhICs9IGF0b2IocGFydC5pbmxpbmVEYXRhLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChub25EYXRhUGFydHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGB0aGVyZSBhcmUgbm9uLWRhdGEgcGFydHMgJHtub25EYXRhUGFydHN9IGluIHRoZSByZXNwb25zZSwgcmV0dXJuaW5nIGNvbmNhdGVuYXRpb24gb2YgYWxsIGRhdGEgcGFydHMuIFBsZWFzZSByZWZlciB0byB0aGUgbm9uIGRhdGEgcGFydHMgZm9yIGEgZnVsbCByZXNwb25zZSBmcm9tIG1vZGVsLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhLmxlbmd0aCA+IDAgPyBidG9hKGRhdGEpIDogdW5kZWZpbmVkO1xuICAgIH1cbn1cbi8qKiBDbGllbnQgZ2VuZXJhdGVkIHJlc3BvbnNlIHRvIGEgYFRvb2xDYWxsYCByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXIuXG5cbkluZGl2aWR1YWwgYEZ1bmN0aW9uUmVzcG9uc2VgIG9iamVjdHMgYXJlIG1hdGNoZWQgdG8gdGhlIHJlc3BlY3RpdmVcbmBGdW5jdGlvbkNhbGxgIG9iamVjdHMgYnkgdGhlIGBpZGAgZmllbGQuXG5cbk5vdGUgdGhhdCBpbiB0aGUgdW5hcnkgYW5kIHNlcnZlci1zdHJlYW1pbmcgR2VuZXJhdGVDb250ZW50IEFQSXMgZnVuY3Rpb25cbmNhbGxpbmcgaGFwcGVucyBieSBleGNoYW5naW5nIHRoZSBgQ29udGVudGAgcGFydHMsIHdoaWxlIGluIHRoZSBiaWRpXG5HZW5lcmF0ZUNvbnRlbnQgQVBJcyBmdW5jdGlvbiBjYWxsaW5nIGhhcHBlbnMgb3ZlciB0aGlzIGRlZGljYXRlZCBzZXQgb2Zcbm1lc3NhZ2VzLiAqL1xuY2xhc3MgTGl2ZUNsaWVudFRvb2xSZXNwb25zZSB7XG59XG4vKiogUGFyYW1ldGVycyBmb3Igc2VuZGluZyB0b29sIHJlc3BvbnNlcyB0byB0aGUgbGl2ZSBBUEkuICovXG5jbGFzcyBMaXZlU2VuZFRvb2xSZXNwb25zZVBhcmFtZXRlcnMge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvKiogVG9vbCByZXNwb25zZXMgdG8gc2VuZCB0byB0aGUgc2Vzc2lvbi4gKi9cbiAgICAgICAgdGhpcy5mdW5jdGlvblJlc3BvbnNlcyA9IFtdO1xuICAgIH1cbn1cbi8qKiBSZXNwb25zZSBtZXNzYWdlIGZvciB0aGUgTGl2ZU11c2ljQ2xpZW50TWVzc2FnZSBjYWxsLiAqL1xuY2xhc3MgTGl2ZU11c2ljU2VydmVyTWVzc2FnZSB7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZmlyc3QgYXVkaW8gY2h1bmsgZnJvbSB0aGUgc2VydmVyIGNvbnRlbnQsIGlmIHByZXNlbnQuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIElmIHRoZXJlIGFyZSBubyBhdWRpbyBjaHVua3MgaW4gdGhlIHJlc3BvbnNlLCB1bmRlZmluZWQgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKi9cbiAgICBnZXQgYXVkaW9DaHVuaygpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VydmVyQ29udGVudCAmJlxuICAgICAgICAgICAgdGhpcy5zZXJ2ZXJDb250ZW50LmF1ZGlvQ2h1bmtzICYmXG4gICAgICAgICAgICB0aGlzLnNlcnZlckNvbnRlbnQuYXVkaW9DaHVua3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VydmVyQ29udGVudC5hdWRpb0NodW5rc1swXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbi8qKiBUaGUgcmVzcG9uc2Ugd2hlbiBsb25nLXJ1bm5pbmcgb3BlcmF0aW9uIGZvciB1cGxvYWRpbmcgYSBmaWxlIHRvIGEgRmlsZVNlYXJjaFN0b3JlIGNvbXBsZXRlLiAqL1xuY2xhc3MgVXBsb2FkVG9GaWxlU2VhcmNoU3RvcmVSZXNwb25zZSB7XG59XG4vKiogTG9uZy1ydW5uaW5nIG9wZXJhdGlvbiBmb3IgdXBsb2FkaW5nIGEgZmlsZSB0byBhIEZpbGVTZWFyY2hTdG9yZS4gKi9cbmNsYXNzIFVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlT3BlcmF0aW9uIHtcbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZXMgYW4gT3BlcmF0aW9uIG9mIHRoZSBzYW1lIHR5cGUgYXMgdGhlIG9uZSBiZWluZyBjYWxsZWQgd2l0aCB0aGUgZmllbGRzIHNldCBmcm9tIHRoZSBBUEkgcmVzcG9uc2UuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX2Zyb21BUElSZXNwb25zZSh7IGFwaVJlc3BvbnNlLCBfaXNWZXJ0ZXhBSSwgfSkge1xuICAgICAgICBjb25zdCBvcGVyYXRpb24gPSBuZXcgVXBsb2FkVG9GaWxlU2VhcmNoU3RvcmVPcGVyYXRpb24oKTtcbiAgICAgICAgY29uc3Qgb3AgPSBhcGlSZXNwb25zZTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB1cGxvYWRUb0ZpbGVTZWFyY2hTdG9yZU9wZXJhdGlvbkZyb21NbGRldihvcCk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24ob3BlcmF0aW9uLCByZXNwb25zZSk7XG4gICAgICAgIHJldHVybiBvcGVyYXRpb247XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5mdW5jdGlvbiB0TW9kZWwoYXBpQ2xpZW50LCBtb2RlbCkge1xuICAgIGlmICghbW9kZWwgfHwgdHlwZW9mIG1vZGVsICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21vZGVsIGlzIHJlcXVpcmVkIGFuZCBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgfVxuICAgIGlmIChtb2RlbC5pbmNsdWRlcygnLi4nKSB8fCBtb2RlbC5pbmNsdWRlcygnPycpIHx8IG1vZGVsLmluY2x1ZGVzKCcmJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIG1vZGVsIHBhcmFtZXRlcicpO1xuICAgIH1cbiAgICBpZiAoYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICBpZiAobW9kZWwuc3RhcnRzV2l0aCgncHVibGlzaGVycy8nKSB8fFxuICAgICAgICAgICAgbW9kZWwuc3RhcnRzV2l0aCgncHJvamVjdHMvJykgfHxcbiAgICAgICAgICAgIG1vZGVsLnN0YXJ0c1dpdGgoJ21vZGVscy8nKSkge1xuICAgICAgICAgICAgcmV0dXJuIG1vZGVsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1vZGVsLmluZGV4T2YoJy8nKSA+PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJ0cyA9IG1vZGVsLnNwbGl0KCcvJywgMik7XG4gICAgICAgICAgICByZXR1cm4gYHB1Ymxpc2hlcnMvJHtwYXJ0c1swXX0vbW9kZWxzLyR7cGFydHNbMV19YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBgcHVibGlzaGVycy9nb29nbGUvbW9kZWxzLyR7bW9kZWx9YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKG1vZGVsLnN0YXJ0c1dpdGgoJ21vZGVscy8nKSB8fCBtb2RlbC5zdGFydHNXaXRoKCd0dW5lZE1vZGVscy8nKSkge1xuICAgICAgICAgICAgcmV0dXJuIG1vZGVsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGBtb2RlbHMvJHttb2RlbH1gO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gdENhY2hlc01vZGVsKGFwaUNsaWVudCwgbW9kZWwpIHtcbiAgICBjb25zdCB0cmFuc2Zvcm1lZE1vZGVsID0gdE1vZGVsKGFwaUNsaWVudCwgbW9kZWwpO1xuICAgIGlmICghdHJhbnNmb3JtZWRNb2RlbCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGlmICh0cmFuc2Zvcm1lZE1vZGVsLnN0YXJ0c1dpdGgoJ3B1Ymxpc2hlcnMvJykgJiYgYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAvLyB2ZXJ0ZXggY2FjaGVzIG9ubHkgc3VwcG9ydCBtb2RlbCBuYW1lIHN0YXJ0IHdpdGggcHJvamVjdHMuXG4gICAgICAgIHJldHVybiBgcHJvamVjdHMvJHthcGlDbGllbnQuZ2V0UHJvamVjdCgpfS9sb2NhdGlvbnMvJHthcGlDbGllbnQuZ2V0TG9jYXRpb24oKX0vJHt0cmFuc2Zvcm1lZE1vZGVsfWA7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRyYW5zZm9ybWVkTW9kZWwuc3RhcnRzV2l0aCgnbW9kZWxzLycpICYmIGFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgcmV0dXJuIGBwcm9qZWN0cy8ke2FwaUNsaWVudC5nZXRQcm9qZWN0KCl9L2xvY2F0aW9ucy8ke2FwaUNsaWVudC5nZXRMb2NhdGlvbigpfS9wdWJsaXNoZXJzL2dvb2dsZS8ke3RyYW5zZm9ybWVkTW9kZWx9YDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZE1vZGVsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRCbG9icyhibG9icykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGJsb2JzKSkge1xuICAgICAgICByZXR1cm4gYmxvYnMubWFwKChibG9iKSA9PiB0QmxvYihibG9iKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gW3RCbG9iKGJsb2JzKV07XG4gICAgfVxufVxuZnVuY3Rpb24gdEJsb2IoYmxvYikge1xuICAgIGlmICh0eXBlb2YgYmxvYiA9PT0gJ29iamVjdCcgJiYgYmxvYiAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gYmxvYjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgcGFyc2UgaW5wdXQgYXMgQmxvYi4gVW5zdXBwb3J0ZWQgYmxvYiB0eXBlOiAke3R5cGVvZiBibG9ifWApO1xufVxuZnVuY3Rpb24gdEltYWdlQmxvYihibG9iKSB7XG4gICAgY29uc3QgdHJhbnNmb3JtZWRCbG9iID0gdEJsb2IoYmxvYik7XG4gICAgaWYgKHRyYW5zZm9ybWVkQmxvYi5taW1lVHlwZSAmJlxuICAgICAgICB0cmFuc2Zvcm1lZEJsb2IubWltZVR5cGUuc3RhcnRzV2l0aCgnaW1hZ2UvJykpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkQmxvYjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBtaW1lIHR5cGU6ICR7dHJhbnNmb3JtZWRCbG9iLm1pbWVUeXBlfWApO1xufVxuZnVuY3Rpb24gdEF1ZGlvQmxvYihibG9iKSB7XG4gICAgY29uc3QgdHJhbnNmb3JtZWRCbG9iID0gdEJsb2IoYmxvYik7XG4gICAgaWYgKHRyYW5zZm9ybWVkQmxvYi5taW1lVHlwZSAmJlxuICAgICAgICB0cmFuc2Zvcm1lZEJsb2IubWltZVR5cGUuc3RhcnRzV2l0aCgnYXVkaW8vJykpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkQmxvYjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBtaW1lIHR5cGU6ICR7dHJhbnNmb3JtZWRCbG9iLm1pbWVUeXBlfWApO1xufVxuZnVuY3Rpb24gdFBhcnQob3JpZ2luKSB7XG4gICAgaWYgKG9yaWdpbiA9PT0gbnVsbCB8fCBvcmlnaW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcnRVbmlvbiBpcyByZXF1aXJlZCcpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9yaWdpbiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcmlnaW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB7IHRleHQ6IG9yaWdpbiB9O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHBhcnQgdHlwZTogJHt0eXBlb2Ygb3JpZ2lufWApO1xufVxuZnVuY3Rpb24gdFBhcnRzKG9yaWdpbikge1xuICAgIGlmIChvcmlnaW4gPT09IG51bGwgfHxcbiAgICAgICAgb3JpZ2luID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgKEFycmF5LmlzQXJyYXkob3JpZ2luKSAmJiBvcmlnaW4ubGVuZ3RoID09PSAwKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcnRMaXN0VW5pb24gaXMgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3JpZ2luKSkge1xuICAgICAgICByZXR1cm4gb3JpZ2luLm1hcCgoaXRlbSkgPT4gdFBhcnQoaXRlbSkpO1xuICAgIH1cbiAgICByZXR1cm4gW3RQYXJ0KG9yaWdpbildO1xufVxuZnVuY3Rpb24gX2lzQ29udGVudChvcmlnaW4pIHtcbiAgICByZXR1cm4gKG9yaWdpbiAhPT0gbnVsbCAmJlxuICAgICAgICBvcmlnaW4gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICB0eXBlb2Ygb3JpZ2luID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAncGFydHMnIGluIG9yaWdpbiAmJlxuICAgICAgICBBcnJheS5pc0FycmF5KG9yaWdpbi5wYXJ0cykpO1xufVxuZnVuY3Rpb24gX2lzRnVuY3Rpb25DYWxsUGFydChvcmlnaW4pIHtcbiAgICByZXR1cm4gKG9yaWdpbiAhPT0gbnVsbCAmJlxuICAgICAgICBvcmlnaW4gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICB0eXBlb2Ygb3JpZ2luID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAnZnVuY3Rpb25DYWxsJyBpbiBvcmlnaW4pO1xufVxuZnVuY3Rpb24gX2lzRnVuY3Rpb25SZXNwb25zZVBhcnQob3JpZ2luKSB7XG4gICAgcmV0dXJuIChvcmlnaW4gIT09IG51bGwgJiZcbiAgICAgICAgb3JpZ2luICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgdHlwZW9mIG9yaWdpbiA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgJ2Z1bmN0aW9uUmVzcG9uc2UnIGluIG9yaWdpbik7XG59XG5mdW5jdGlvbiB0Q29udGVudChvcmlnaW4pIHtcbiAgICBpZiAob3JpZ2luID09PSBudWxsIHx8IG9yaWdpbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ29udGVudFVuaW9uIGlzIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGlmIChfaXNDb250ZW50KG9yaWdpbikpIHtcbiAgICAgICAgLy8gX2lzQ29udGVudCBpcyBhIHV0aWxpdHkgZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgdGhlXG4gICAgICAgIC8vIG9yaWdpbiBpcyBhIENvbnRlbnQuXG4gICAgICAgIHJldHVybiBvcmlnaW47XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHJvbGU6ICd1c2VyJyxcbiAgICAgICAgcGFydHM6IHRQYXJ0cyhvcmlnaW4pLFxuICAgIH07XG59XG5mdW5jdGlvbiB0Q29udGVudHNGb3JFbWJlZChhcGlDbGllbnQsIG9yaWdpbikge1xuICAgIGlmICghb3JpZ2luKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgaWYgKGFwaUNsaWVudC5pc1ZlcnRleEFJKCkgJiYgQXJyYXkuaXNBcnJheShvcmlnaW4pKSB7XG4gICAgICAgIHJldHVybiBvcmlnaW4uZmxhdE1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IHRDb250ZW50KGl0ZW0pO1xuICAgICAgICAgICAgaWYgKGNvbnRlbnQucGFydHMgJiZcbiAgICAgICAgICAgICAgICBjb250ZW50LnBhcnRzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICBjb250ZW50LnBhcnRzWzBdLnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbY29udGVudC5wYXJ0c1swXS50ZXh0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgY29uc3QgY29udGVudCA9IHRDb250ZW50KG9yaWdpbik7XG4gICAgICAgIGlmIChjb250ZW50LnBhcnRzICYmXG4gICAgICAgICAgICBjb250ZW50LnBhcnRzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgIGNvbnRlbnQucGFydHNbMF0udGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gW2NvbnRlbnQucGFydHNbMF0udGV4dF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcmlnaW4pKSB7XG4gICAgICAgIHJldHVybiBvcmlnaW4ubWFwKChpdGVtKSA9PiB0Q29udGVudChpdGVtKSk7XG4gICAgfVxuICAgIHJldHVybiBbdENvbnRlbnQob3JpZ2luKV07XG59XG5mdW5jdGlvbiB0Q29udGVudHMob3JpZ2luKSB7XG4gICAgaWYgKG9yaWdpbiA9PT0gbnVsbCB8fFxuICAgICAgICBvcmlnaW4gPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAoQXJyYXkuaXNBcnJheShvcmlnaW4pICYmIG9yaWdpbi5sZW5ndGggPT09IDApKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY29udGVudHMgYXJlIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheShvcmlnaW4pKSB7XG4gICAgICAgIC8vIElmIGl0J3Mgbm90IGFuIGFycmF5LCBpdCdzIGEgc2luZ2xlIGNvbnRlbnQgb3IgYSBzaW5nbGUgUGFydFVuaW9uLlxuICAgICAgICBpZiAoX2lzRnVuY3Rpb25DYWxsUGFydChvcmlnaW4pIHx8IF9pc0Z1bmN0aW9uUmVzcG9uc2VQYXJ0KG9yaWdpbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVG8gc3BlY2lmeSBmdW5jdGlvbkNhbGwgb3IgZnVuY3Rpb25SZXNwb25zZSBwYXJ0cywgcGxlYXNlIHdyYXAgdGhlbSBpbiBhIENvbnRlbnQgb2JqZWN0LCBzcGVjaWZ5aW5nIHRoZSByb2xlIGZvciB0aGVtJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt0Q29udGVudChvcmlnaW4pXTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgY29uc3QgYWNjdW11bGF0ZWRQYXJ0cyA9IFtdO1xuICAgIGNvbnN0IGlzQ29udGVudEFycmF5ID0gX2lzQ29udGVudChvcmlnaW5bMF0pO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBvcmlnaW4pIHtcbiAgICAgICAgY29uc3QgaXNDb250ZW50ID0gX2lzQ29udGVudChpdGVtKTtcbiAgICAgICAgaWYgKGlzQ29udGVudCAhPSBpc0NvbnRlbnRBcnJheSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXhpbmcgQ29udGVudCBhbmQgUGFydHMgaXMgbm90IHN1cHBvcnRlZCwgcGxlYXNlIGdyb3VwIHRoZSBwYXJ0cyBpbnRvIGEgdGhlIGFwcHJvcHJpYXRlIENvbnRlbnQgb2JqZWN0cyBhbmQgc3BlY2lmeSB0aGUgcm9sZXMgZm9yIHRoZW0nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDb250ZW50KSB7XG4gICAgICAgICAgICAvLyBgaXNDb250ZW50YCBjb250YWlucyB0aGUgcmVzdWx0IG9mIF9pc0NvbnRlbnQsIHdoaWNoIGlzIGEgdXRpbGl0eVxuICAgICAgICAgICAgLy8gZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgdGhlIGl0ZW0gaXMgYSBDb250ZW50LlxuICAgICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoX2lzRnVuY3Rpb25DYWxsUGFydChpdGVtKSB8fCBfaXNGdW5jdGlvblJlc3BvbnNlUGFydChpdGVtKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUbyBzcGVjaWZ5IGZ1bmN0aW9uQ2FsbCBvciBmdW5jdGlvblJlc3BvbnNlIHBhcnRzLCBwbGVhc2Ugd3JhcCB0aGVtLCBhbmQgYW55IG90aGVyIHBhcnRzLCBpbiBDb250ZW50IG9iamVjdHMgYXMgYXBwcm9wcmlhdGUsIHNwZWNpZnlpbmcgdGhlIHJvbGUgZm9yIHRoZW0nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFjY3VtdWxhdGVkUGFydHMucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWlzQ29udGVudEFycmF5KSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHsgcm9sZTogJ3VzZXInLCBwYXJ0czogdFBhcnRzKGFjY3VtdWxhdGVkUGFydHMpIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLypcblRyYW5zZm9ybSB0aGUgdHlwZSBmaWVsZCBmcm9tIGFuIGFycmF5IG9mIHR5cGVzIHRvIGFuIGFycmF5IG9mIGFueU9mIGZpZWxkcy5cbkV4YW1wbGU6XG4gIHt0eXBlOiBbJ1NUUklORycsICdOVU1CRVInXX1cbndpbGwgYmUgdHJhbnNmb3JtZWQgdG9cbiAge2FueU9mOiBbe3R5cGU6ICdTVFJJTkcnfSwge3R5cGU6ICdOVU1CRVInfV19XG4qL1xuZnVuY3Rpb24gZmxhdHRlblR5cGVBcnJheVRvQW55T2YodHlwZUxpc3QsIHJlc3VsdGluZ1NjaGVtYSkge1xuICAgIGlmICh0eXBlTGlzdC5pbmNsdWRlcygnbnVsbCcpKSB7XG4gICAgICAgIHJlc3VsdGluZ1NjaGVtYVsnbnVsbGFibGUnXSA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGxpc3RXaXRob3V0TnVsbCA9IHR5cGVMaXN0LmZpbHRlcigodHlwZSkgPT4gdHlwZSAhPT0gJ251bGwnKTtcbiAgICBpZiAobGlzdFdpdGhvdXROdWxsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXN1bHRpbmdTY2hlbWFbJ3R5cGUnXSA9IE9iamVjdC52YWx1ZXMoVHlwZSkuaW5jbHVkZXMobGlzdFdpdGhvdXROdWxsWzBdLnRvVXBwZXJDYXNlKCkpXG4gICAgICAgICAgICA/IGxpc3RXaXRob3V0TnVsbFswXS50b1VwcGVyQ2FzZSgpXG4gICAgICAgICAgICA6IFR5cGUuVFlQRV9VTlNQRUNJRklFRDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdGluZ1NjaGVtYVsnYW55T2YnXSA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGkgb2YgbGlzdFdpdGhvdXROdWxsKSB7XG4gICAgICAgICAgICByZXN1bHRpbmdTY2hlbWFbJ2FueU9mJ10ucHVzaCh7XG4gICAgICAgICAgICAgICAgJ3R5cGUnOiBPYmplY3QudmFsdWVzKFR5cGUpLmluY2x1ZGVzKGkudG9VcHBlckNhc2UoKSlcbiAgICAgICAgICAgICAgICAgICAgPyBpLnRvVXBwZXJDYXNlKClcbiAgICAgICAgICAgICAgICAgICAgOiBUeXBlLlRZUEVfVU5TUEVDSUZJRUQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHByb2Nlc3NKc29uU2NoZW1hKF9qc29uU2NoZW1hKSB7XG4gICAgY29uc3QgZ2VuQUlTY2hlbWEgPSB7fTtcbiAgICBjb25zdCBzY2hlbWFGaWVsZE5hbWVzID0gWydpdGVtcyddO1xuICAgIGNvbnN0IGxpc3RTY2hlbWFGaWVsZE5hbWVzID0gWydhbnlPZiddO1xuICAgIGNvbnN0IGRpY3RTY2hlbWFGaWVsZE5hbWVzID0gWydwcm9wZXJ0aWVzJ107XG4gICAgaWYgKF9qc29uU2NoZW1hWyd0eXBlJ10gJiYgX2pzb25TY2hlbWFbJ2FueU9mJ10pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0eXBlIGFuZCBhbnlPZiBjYW5ub3QgYmUgYm90aCBwb3B1bGF0ZWQuJyk7XG4gICAgfVxuICAgIC8qXG4gICAgVGhpcyBpcyB0byBoYW5kbGUgdGhlIG51bGxhYmxlIGFycmF5IG9yIG9iamVjdC4gVGhlIF9qc29uU2NoZW1hIHdpbGxcbiAgICBiZSBpbiB0aGUgZm9ybWF0IG9mIHthbnlPZjogW3t0eXBlOiAnbnVsbCd9LCB7dHlwZTogJ29iamVjdCd9XX0uIFRoZVxuICAgIGxvZ2ljIGlzIHRvIGNoZWNrIGlmIGFueU9mIGhhcyAyIGVsZW1lbnRzIGFuZCBvbmUgb2YgdGhlIGVsZW1lbnQgaXMgbnVsbCxcbiAgICBpZiBzbywgdGhlIGFueU9mIGZpZWxkIGlzIHVubmVjZXNzYXJ5LCBzbyB3ZSBuZWVkIHRvIGdldCByaWQgb2YgdGhlIGFueU9mXG4gICAgZmllbGQgYW5kIG1ha2UgdGhlIHNjaGVtYSBudWxsYWJsZS4gVGhlbiB1c2UgdGhlIG90aGVyIGVsZW1lbnQgYXMgdGhlIG5ld1xuICAgIF9qc29uU2NoZW1hIGZvciBwcm9jZXNzaW5nLiBUaGlzIGlzIGJlY2F1c2UgdGhlIGJhY2tlbmQgZG9lc24ndCBoYXZlIGEgbnVsbFxuICAgIHR5cGUuXG4gICAgVGhpcyBoYXMgdG8gYmUgY2hlY2tlZCBiZWZvcmUgd2UgcHJvY2VzcyBhbnkgb3RoZXIgZmllbGRzLlxuICAgIEZvciBleGFtcGxlOlxuICAgICAgY29uc3Qgb2JqZWN0TnVsbGFibGUgPSB6Lm9iamVjdCh7XG4gICAgICAgIG51bGxhYmxlQXJyYXk6IHouYXJyYXkoei5zdHJpbmcoKSkubnVsbGFibGUoKSxcbiAgICAgIH0pO1xuICAgIFdpbGwgaGF2ZSB0aGUgcmF3IF9qc29uU2NoZW1hIGFzOlxuICAgIHtcbiAgICAgIHR5cGU6ICdPQkpFQ1QnLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgIG51bGxhYmxlQXJyYXk6IHtcbiAgICAgICAgICAgICBhbnlPZjogW1xuICAgICAgICAgICAgICAgIHt0eXBlOiAnbnVsbCd9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICAgICAgICAgICAgICBpdGVtczoge3R5cGU6ICdzdHJpbmcnfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZXF1aXJlZDogWyAnbnVsbGFibGVBcnJheScgXSxcbiAgICB9XG4gICAgV2lsbCByZXN1bHQgaW4gZm9sbG93aW5nIHNjaGVtYSBjb21wYXRpYmxlIHdpdGggR2VtaW5pIEFQSTpcbiAgICAgIHtcbiAgICAgICAgdHlwZTogJ09CSkVDVCcsXG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgbnVsbGFibGVBcnJheToge1xuICAgICAgICAgICAgICBudWxsYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgdHlwZTogJ0FSUkFZJyxcbiAgICAgICAgICAgICAgaXRlbXM6IHt0eXBlOiAnc3RyaW5nJ30sXG4gICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVxdWlyZWQ6IFsgJ251bGxhYmxlQXJyYXknIF0sXG4gICAgICB9XG4gICAgKi9cbiAgICBjb25zdCBpbmNvbWluZ0FueU9mID0gX2pzb25TY2hlbWFbJ2FueU9mJ107XG4gICAgaWYgKGluY29taW5nQW55T2YgIT0gbnVsbCAmJiBpbmNvbWluZ0FueU9mLmxlbmd0aCA9PSAyKSB7XG4gICAgICAgIGlmIChpbmNvbWluZ0FueU9mWzBdWyd0eXBlJ10gPT09ICdudWxsJykge1xuICAgICAgICAgICAgZ2VuQUlTY2hlbWFbJ251bGxhYmxlJ10gPSB0cnVlO1xuICAgICAgICAgICAgX2pzb25TY2hlbWEgPSBpbmNvbWluZ0FueU9mWzFdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluY29taW5nQW55T2ZbMV1bJ3R5cGUnXSA9PT0gJ251bGwnKSB7XG4gICAgICAgICAgICBnZW5BSVNjaGVtYVsnbnVsbGFibGUnXSA9IHRydWU7XG4gICAgICAgICAgICBfanNvblNjaGVtYSA9IGluY29taW5nQW55T2ZbMF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKF9qc29uU2NoZW1hWyd0eXBlJ10gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBmbGF0dGVuVHlwZUFycmF5VG9BbnlPZihfanNvblNjaGVtYVsndHlwZSddLCBnZW5BSVNjaGVtYSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgZmllbGRWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoX2pzb25TY2hlbWEpKSB7XG4gICAgICAgIC8vIFNraXAgaWYgdGhlIGZpZWxkdmFsdWUgaXMgdW5kZWZpbmVkIG9yIG51bGwuXG4gICAgICAgIGlmIChmaWVsZFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWVsZE5hbWUgPT0gJ3R5cGUnKSB7XG4gICAgICAgICAgICBpZiAoZmllbGRWYWx1ZSA9PT0gJ251bGwnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0eXBlOiBudWxsIGNhbiBub3QgYmUgdGhlIG9ubHkgcG9zc2libGUgdHlwZSBmb3IgdGhlIGZpZWxkLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpZWxkVmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIC8vIHdlIGhhdmUgYWxyZWFkeSBoYW5kbGVkIHRoZSB0eXBlIGZpZWxkIHdpdGggYXJyYXkgb2YgdHlwZXMgaW4gdGhlXG4gICAgICAgICAgICAgICAgLy8gYmVnaW5uaW5nIG9mIHRoaXMgZnVuY3Rpb24uXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZW5BSVNjaGVtYVsndHlwZSddID0gT2JqZWN0LnZhbHVlcyhUeXBlKS5pbmNsdWRlcyhmaWVsZFZhbHVlLnRvVXBwZXJDYXNlKCkpXG4gICAgICAgICAgICAgICAgPyBmaWVsZFZhbHVlLnRvVXBwZXJDYXNlKClcbiAgICAgICAgICAgICAgICA6IFR5cGUuVFlQRV9VTlNQRUNJRklFRDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzY2hlbWFGaWVsZE5hbWVzLmluY2x1ZGVzKGZpZWxkTmFtZSkpIHtcbiAgICAgICAgICAgIGdlbkFJU2NoZW1hW2ZpZWxkTmFtZV0gPVxuICAgICAgICAgICAgICAgIHByb2Nlc3NKc29uU2NoZW1hKGZpZWxkVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxpc3RTY2hlbWFGaWVsZE5hbWVzLmluY2x1ZGVzKGZpZWxkTmFtZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpc3RTY2hlbWFGaWVsZFZhbHVlID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgZmllbGRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtWyd0eXBlJ10gPT0gJ251bGwnKSB7XG4gICAgICAgICAgICAgICAgICAgIGdlbkFJU2NoZW1hWydudWxsYWJsZSddID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxpc3RTY2hlbWFGaWVsZFZhbHVlLnB1c2gocHJvY2Vzc0pzb25TY2hlbWEoaXRlbSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2VuQUlTY2hlbWFbZmllbGROYW1lXSA9XG4gICAgICAgICAgICAgICAgbGlzdFNjaGVtYUZpZWxkVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGljdFNjaGVtYUZpZWxkTmFtZXMuaW5jbHVkZXMoZmllbGROYW1lKSkge1xuICAgICAgICAgICAgY29uc3QgZGljdFNjaGVtYUZpZWxkVmFsdWUgPSB7fTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGZpZWxkVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZGljdFNjaGVtYUZpZWxkVmFsdWVba2V5XSA9IHByb2Nlc3NKc29uU2NoZW1hKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdlbkFJU2NoZW1hW2ZpZWxkTmFtZV0gPVxuICAgICAgICAgICAgICAgIGRpY3RTY2hlbWFGaWVsZFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gYWRkaXRpb25hbFByb3BlcnRpZXMgaXMgbm90IGluY2x1ZGVkIGluIEpTT05TY2hlbWEsIHNraXBwaW5nIGl0LlxuICAgICAgICAgICAgaWYgKGZpZWxkTmFtZSA9PT0gJ2FkZGl0aW9uYWxQcm9wZXJ0aWVzJykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2VuQUlTY2hlbWFbZmllbGROYW1lXSA9IGZpZWxkVmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGdlbkFJU2NoZW1hO1xufVxuLy8gd2UgdGFrZSB0aGUgdW5rbm93biBpbiB0aGUgc2NoZW1hIGZpZWxkIGJlY2F1c2Ugd2Ugd2FudCBlbmFibGUgdXNlciB0byBwYXNzXG4vLyB0aGUgb3V0cHV0IG9mIG1ham9yIHNjaGVtYSBkZWNsYXJhdGlvbiB0b29scyB3aXRob3V0IGNhc3RpbmcuIFRvb2xzIHN1Y2ggYXNcbi8vIHpvZFRvSnNvblNjaGVtYSwgdHlwZWJveCwgem9kVG9Kc29uU2NoZW1hIGZ1bmN0aW9uIGNhbiByZXR1cm4gSnNvblNjaGVtYTdUeXBlXG4vLyBvciBvYmplY3QsIHNlZSBkZXRhaWxzIGluXG4vLyBodHRwczovL2dpdGh1Yi5jb20vU3RlZmFuVGVyZGVsbC96b2QtdG8tanNvbi1zY2hlbWEvYmxvYi83MDUyNWVmZTU1NWNkMjI2NjkxZTA5M2QxNzEzNzBhM2IxMDkyMWQxL3NyYy96b2RUb0pzb25TY2hlbWEudHMjTDdcbi8vIHR5cGVib3ggY2FuIHJldHVybiB1bmtub3duLCBzZWUgZGV0YWlscyBpblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3NpbmNsYWlyeng4MS90eXBlYm94L2Jsb2IvNWE1NDMxNDM5ZjdkNWNhNmI0OTRkMGQxOGZiZmQ3YjFhMzU2ZDY3Yy9zcmMvdHlwZS9jcmVhdGUvdHlwZS50cyNMMzVcbi8vIE5vdGU6IHByb3BlciBqc29uIHNjaGVtYXMgd2l0aCB0aGUgJHNjaGVtYSBmaWVsZCBzZXQgbmV2ZXIgYXJyaXZlIHRvIHRoaXNcbi8vIHRyYW5zZm9ybWVyLiBTY2hlbWFzIHdpdGggJHNjaGVtYSBhcmUgcm91dGVkIHRvIHRoZSBlcXVpdmFsZW50IEFQSSBqc29uXG4vLyBzY2hlbWEgZmllbGQuXG5mdW5jdGlvbiB0U2NoZW1hKHNjaGVtYSkge1xuICAgIHJldHVybiBwcm9jZXNzSnNvblNjaGVtYShzY2hlbWEpO1xufVxuZnVuY3Rpb24gdFNwZWVjaENvbmZpZyhzcGVlY2hDb25maWcpIHtcbiAgICBpZiAodHlwZW9mIHNwZWVjaENvbmZpZyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIHNwZWVjaENvbmZpZztcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHNwZWVjaENvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZvaWNlQ29uZmlnOiB7XG4gICAgICAgICAgICAgICAgcHJlYnVpbHRWb2ljZUNvbmZpZzoge1xuICAgICAgICAgICAgICAgICAgICB2b2ljZU5hbWU6IHNwZWVjaENvbmZpZyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgc3BlZWNoQ29uZmlnIHR5cGU6ICR7dHlwZW9mIHNwZWVjaENvbmZpZ31gKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0TGl2ZVNwZWVjaENvbmZpZyhzcGVlY2hDb25maWcpIHtcbiAgICBpZiAoJ211bHRpU3BlYWtlclZvaWNlQ29uZmlnJyBpbiBzcGVlY2hDb25maWcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtdWx0aVNwZWFrZXJWb2ljZUNvbmZpZyBpcyBub3Qgc3VwcG9ydGVkIGluIHRoZSBsaXZlIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHNwZWVjaENvbmZpZztcbn1cbmZ1bmN0aW9uIHRUb29sKHRvb2wpIHtcbiAgICBpZiAodG9vbC5mdW5jdGlvbkRlY2xhcmF0aW9ucykge1xuICAgICAgICBmb3IgKGNvbnN0IGZ1bmN0aW9uRGVjbGFyYXRpb24gb2YgdG9vbC5mdW5jdGlvbkRlY2xhcmF0aW9ucykge1xuICAgICAgICAgICAgaWYgKGZ1bmN0aW9uRGVjbGFyYXRpb24ucGFyYW1ldGVycykge1xuICAgICAgICAgICAgICAgIGlmICghT2JqZWN0LmtleXMoZnVuY3Rpb25EZWNsYXJhdGlvbi5wYXJhbWV0ZXJzKS5pbmNsdWRlcygnJHNjaGVtYScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uRGVjbGFyYXRpb24ucGFyYW1ldGVycyA9IHByb2Nlc3NKc29uU2NoZW1hKGZ1bmN0aW9uRGVjbGFyYXRpb24ucGFyYW1ldGVycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZ1bmN0aW9uRGVjbGFyYXRpb24ucGFyYW1ldGVyc0pzb25TY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uRGVjbGFyYXRpb24ucGFyYW1ldGVyc0pzb25TY2hlbWEgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uRGVjbGFyYXRpb24ucGFyYW1ldGVycztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBmdW5jdGlvbkRlY2xhcmF0aW9uLnBhcmFtZXRlcnM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZnVuY3Rpb25EZWNsYXJhdGlvbi5yZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGlmICghT2JqZWN0LmtleXMoZnVuY3Rpb25EZWNsYXJhdGlvbi5yZXNwb25zZSkuaW5jbHVkZXMoJyRzY2hlbWEnKSkge1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9uLnJlc3BvbnNlID0gcHJvY2Vzc0pzb25TY2hlbWEoZnVuY3Rpb25EZWNsYXJhdGlvbi5yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZ1bmN0aW9uRGVjbGFyYXRpb24ucmVzcG9uc2VKc29uU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9uLnJlc3BvbnNlSnNvblNjaGVtYSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25EZWNsYXJhdGlvbi5yZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBmdW5jdGlvbkRlY2xhcmF0aW9uLnJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0b29sO1xufVxuZnVuY3Rpb24gdFRvb2xzKHRvb2xzKSB7XG4gICAgLy8gQ2hlY2sgaWYgdGhlIGluY29taW5nIHR5cGUgaXMgZGVmaW5lZC5cbiAgICBpZiAodG9vbHMgPT09IHVuZGVmaW5lZCB8fCB0b29scyA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Rvb2xzIGlzIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheSh0b29scykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0b29scyBpcyByZXF1aXJlZCBhbmQgbXVzdCBiZSBhbiBhcnJheSBvZiBUb29scycpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHRvb2wgb2YgdG9vbHMpIHtcbiAgICAgICAgcmVzdWx0LnB1c2godG9vbCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIFByZXBlbmRzIHJlc291cmNlIG5hbWUgd2l0aCBwcm9qZWN0LCBsb2NhdGlvbiwgcmVzb3VyY2VfcHJlZml4IGlmIG5lZWRlZC5cbiAqXG4gKiBAcGFyYW0gY2xpZW50IFRoZSBBUEkgY2xpZW50LlxuICogQHBhcmFtIHJlc291cmNlTmFtZSBUaGUgcmVzb3VyY2UgbmFtZS5cbiAqIEBwYXJhbSByZXNvdXJjZVByZWZpeCBUaGUgcmVzb3VyY2UgcHJlZml4LlxuICogQHBhcmFtIHNwbGl0c0FmdGVyUHJlZml4IFRoZSBudW1iZXIgb2Ygc3BsaXRzIGFmdGVyIHRoZSBwcmVmaXguXG4gKiBAcmV0dXJucyBUaGUgY29tcGxldGVkIHJlc291cmNlIG5hbWUuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogYGBgXG4gKiByZXNvdXJjZV9uYW1lID0gJzEyMydcbiAqIHJlc291cmNlX3ByZWZpeCA9ICdjYWNoZWRDb250ZW50cydcbiAqIHNwbGl0c19hZnRlcl9wcmVmaXggPSAxXG4gKiBjbGllbnQudmVydGV4YWkgPSBUcnVlXG4gKiBjbGllbnQucHJvamVjdCA9ICdiYXInXG4gKiBjbGllbnQubG9jYXRpb24gPSAndXMtd2VzdDEnXG4gKiBfcmVzb3VyY2VfbmFtZShjbGllbnQsIHJlc291cmNlX25hbWUsIHJlc291cmNlX3ByZWZpeCwgc3BsaXRzX2FmdGVyX3ByZWZpeClcbiAqIHJldHVybnM6ICdwcm9qZWN0cy9iYXIvbG9jYXRpb25zL3VzLXdlc3QxL2NhY2hlZENvbnRlbnRzLzEyMydcbiAqIGBgYFxuICpcbiAqIGBgYFxuICogcmVzb3VyY2VfbmFtZSA9ICdwcm9qZWN0cy9mb28vbG9jYXRpb25zL3VzLWNlbnRyYWwxL2NhY2hlZENvbnRlbnRzLzEyMydcbiAqIHJlc291cmNlX3ByZWZpeCA9ICdjYWNoZWRDb250ZW50cydcbiAqIHNwbGl0c19hZnRlcl9wcmVmaXggPSAxXG4gKiBjbGllbnQudmVydGV4YWkgPSBUcnVlXG4gKiBjbGllbnQucHJvamVjdCA9ICdiYXInXG4gKiBjbGllbnQubG9jYXRpb24gPSAndXMtd2VzdDEnXG4gKiBfcmVzb3VyY2VfbmFtZShjbGllbnQsIHJlc291cmNlX25hbWUsIHJlc291cmNlX3ByZWZpeCwgc3BsaXRzX2FmdGVyX3ByZWZpeClcbiAqIHJldHVybnM6ICdwcm9qZWN0cy9mb28vbG9jYXRpb25zL3VzLWNlbnRyYWwxL2NhY2hlZENvbnRlbnRzLzEyMydcbiAqIGBgYFxuICpcbiAqIGBgYFxuICogcmVzb3VyY2VfbmFtZSA9ICcxMjMnXG4gKiByZXNvdXJjZV9wcmVmaXggPSAnY2FjaGVkQ29udGVudHMnXG4gKiBzcGxpdHNfYWZ0ZXJfcHJlZml4ID0gMVxuICogY2xpZW50LnZlcnRleGFpID0gRmFsc2VcbiAqIF9yZXNvdXJjZV9uYW1lKGNsaWVudCwgcmVzb3VyY2VfbmFtZSwgcmVzb3VyY2VfcHJlZml4LCBzcGxpdHNfYWZ0ZXJfcHJlZml4KVxuICogcmV0dXJucyAnY2FjaGVkQ29udGVudHMvMTIzJ1xuICogYGBgXG4gKlxuICogYGBgXG4gKiByZXNvdXJjZV9uYW1lID0gJ3NvbWUvd3JvbmcvY2FjaGVkQ29udGVudHMvcmVzb3VyY2UvbmFtZS8xMjMnXG4gKiByZXNvdXJjZV9wcmVmaXggPSAnY2FjaGVkQ29udGVudHMnXG4gKiBzcGxpdHNfYWZ0ZXJfcHJlZml4ID0gMVxuICogY2xpZW50LnZlcnRleGFpID0gRmFsc2VcbiAqICMgY2xpZW50LnZlcnRleGFpID0gVHJ1ZVxuICogX3Jlc291cmNlX25hbWUoY2xpZW50LCByZXNvdXJjZV9uYW1lLCByZXNvdXJjZV9wcmVmaXgsIHNwbGl0c19hZnRlcl9wcmVmaXgpXG4gKiAtPiAnc29tZS93cm9uZy9yZXNvdXJjZS9uYW1lLzEyMydcbiAqIGBgYFxuICovXG5mdW5jdGlvbiByZXNvdXJjZU5hbWUoY2xpZW50LCByZXNvdXJjZU5hbWUsIHJlc291cmNlUHJlZml4LCBzcGxpdHNBZnRlclByZWZpeCA9IDEpIHtcbiAgICBjb25zdCBzaG91bGRBcHBlbmRQcmVmaXggPSAhcmVzb3VyY2VOYW1lLnN0YXJ0c1dpdGgoYCR7cmVzb3VyY2VQcmVmaXh9L2ApICYmXG4gICAgICAgIHJlc291cmNlTmFtZS5zcGxpdCgnLycpLmxlbmd0aCA9PT0gc3BsaXRzQWZ0ZXJQcmVmaXg7XG4gICAgaWYgKGNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgaWYgKHJlc291cmNlTmFtZS5zdGFydHNXaXRoKCdwcm9qZWN0cy8nKSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc291cmNlTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXNvdXJjZU5hbWUuc3RhcnRzV2l0aCgnbG9jYXRpb25zLycpKSB7XG4gICAgICAgICAgICByZXR1cm4gYHByb2plY3RzLyR7Y2xpZW50LmdldFByb2plY3QoKX0vJHtyZXNvdXJjZU5hbWV9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXNvdXJjZU5hbWUuc3RhcnRzV2l0aChgJHtyZXNvdXJjZVByZWZpeH0vYCkpIHtcbiAgICAgICAgICAgIHJldHVybiBgcHJvamVjdHMvJHtjbGllbnQuZ2V0UHJvamVjdCgpfS9sb2NhdGlvbnMvJHtjbGllbnQuZ2V0TG9jYXRpb24oKX0vJHtyZXNvdXJjZU5hbWV9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzaG91bGRBcHBlbmRQcmVmaXgpIHtcbiAgICAgICAgICAgIHJldHVybiBgcHJvamVjdHMvJHtjbGllbnQuZ2V0UHJvamVjdCgpfS9sb2NhdGlvbnMvJHtjbGllbnQuZ2V0TG9jYXRpb24oKX0vJHtyZXNvdXJjZVByZWZpeH0vJHtyZXNvdXJjZU5hbWV9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvdXJjZU5hbWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNob3VsZEFwcGVuZFByZWZpeCkge1xuICAgICAgICByZXR1cm4gYCR7cmVzb3VyY2VQcmVmaXh9LyR7cmVzb3VyY2VOYW1lfWA7XG4gICAgfVxuICAgIHJldHVybiByZXNvdXJjZU5hbWU7XG59XG5mdW5jdGlvbiB0Q2FjaGVkQ29udGVudE5hbWUoYXBpQ2xpZW50LCBuYW1lKSB7XG4gICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25hbWUgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzb3VyY2VOYW1lKGFwaUNsaWVudCwgbmFtZSwgJ2NhY2hlZENvbnRlbnRzJyk7XG59XG5mdW5jdGlvbiB0VHVuaW5nSm9iU3RhdHVzKHN0YXR1cykge1xuICAgIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgICAgIGNhc2UgJ1NUQVRFX1VOU1BFQ0lGSUVEJzpcbiAgICAgICAgICAgIHJldHVybiAnSk9CX1NUQVRFX1VOU1BFQ0lGSUVEJztcbiAgICAgICAgY2FzZSAnQ1JFQVRJTkcnOlxuICAgICAgICAgICAgcmV0dXJuICdKT0JfU1RBVEVfUlVOTklORyc7XG4gICAgICAgIGNhc2UgJ0FDVElWRSc6XG4gICAgICAgICAgICByZXR1cm4gJ0pPQl9TVEFURV9TVUNDRUVERUQnO1xuICAgICAgICBjYXNlICdGQUlMRUQnOlxuICAgICAgICAgICAgcmV0dXJuICdKT0JfU1RBVEVfRkFJTEVEJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBzdGF0dXM7XG4gICAgfVxufVxuZnVuY3Rpb24gdEJ5dGVzKGZyb21JbWFnZUJ5dGVzKSB7XG4gICAgcmV0dXJuIHRCeXRlcyQxKGZyb21JbWFnZUJ5dGVzKTtcbn1cbmZ1bmN0aW9uIF9pc0ZpbGUob3JpZ2luKSB7XG4gICAgcmV0dXJuIChvcmlnaW4gIT09IG51bGwgJiZcbiAgICAgICAgb3JpZ2luICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgdHlwZW9mIG9yaWdpbiA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgJ25hbWUnIGluIG9yaWdpbik7XG59XG5mdW5jdGlvbiBpc0dlbmVyYXRlZFZpZGVvKG9yaWdpbikge1xuICAgIHJldHVybiAob3JpZ2luICE9PSBudWxsICYmXG4gICAgICAgIG9yaWdpbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHR5cGVvZiBvcmlnaW4gPT09ICdvYmplY3QnICYmXG4gICAgICAgICd2aWRlbycgaW4gb3JpZ2luKTtcbn1cbmZ1bmN0aW9uIGlzVmlkZW8ob3JpZ2luKSB7XG4gICAgcmV0dXJuIChvcmlnaW4gIT09IG51bGwgJiZcbiAgICAgICAgb3JpZ2luICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgdHlwZW9mIG9yaWdpbiA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgJ3VyaScgaW4gb3JpZ2luKTtcbn1cbmZ1bmN0aW9uIHRGaWxlTmFtZShmcm9tTmFtZSkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgbmFtZTtcbiAgICBpZiAoX2lzRmlsZShmcm9tTmFtZSkpIHtcbiAgICAgICAgbmFtZSA9IGZyb21OYW1lLm5hbWU7XG4gICAgfVxuICAgIGlmIChpc1ZpZGVvKGZyb21OYW1lKSkge1xuICAgICAgICBuYW1lID0gZnJvbU5hbWUudXJpO1xuICAgICAgICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpc0dlbmVyYXRlZFZpZGVvKGZyb21OYW1lKSkge1xuICAgICAgICBuYW1lID0gKF9hID0gZnJvbU5hbWUudmlkZW8pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51cmk7XG4gICAgICAgIGlmIChuYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBmcm9tTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbmFtZSA9IGZyb21OYW1lO1xuICAgIH1cbiAgICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGV4dHJhY3QgZmlsZSBuYW1lIGZyb20gdGhlIHByb3ZpZGVkIGlucHV0LicpO1xuICAgIH1cbiAgICBpZiAobmFtZS5zdGFydHNXaXRoKCdodHRwczovLycpKSB7XG4gICAgICAgIGNvbnN0IHN1ZmZpeCA9IG5hbWUuc3BsaXQoJ2ZpbGVzLycpWzFdO1xuICAgICAgICBjb25zdCBtYXRjaCA9IHN1ZmZpeC5tYXRjaCgvW2EtejAtOV0rLyk7XG4gICAgICAgIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZXh0cmFjdCBmaWxlIG5hbWUgZnJvbSBVUkkgJHtuYW1lfWApO1xuICAgICAgICB9XG4gICAgICAgIG5hbWUgPSBtYXRjaFswXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobmFtZS5zdGFydHNXaXRoKCdmaWxlcy8nKSkge1xuICAgICAgICBuYW1lID0gbmFtZS5zcGxpdCgnZmlsZXMvJylbMV07XG4gICAgfVxuICAgIHJldHVybiBuYW1lO1xufVxuZnVuY3Rpb24gdE1vZGVsc1VybChhcGlDbGllbnQsIGJhc2VNb2RlbHMpIHtcbiAgICBsZXQgcmVzO1xuICAgIGlmIChhcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgIHJlcyA9IGJhc2VNb2RlbHMgPyAncHVibGlzaGVycy9nb29nbGUvbW9kZWxzJyA6ICdtb2RlbHMnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVzID0gYmFzZU1vZGVscyA/ICdtb2RlbHMnIDogJ3R1bmVkTW9kZWxzJztcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIHRFeHRyYWN0TW9kZWxzKHJlc3BvbnNlKSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgWydtb2RlbHMnLCAndHVuZWRNb2RlbHMnLCAncHVibGlzaGVyTW9kZWxzJ10pIHtcbiAgICAgICAgaWYgKGhhc0ZpZWxkKHJlc3BvbnNlLCBrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2Vba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW107XG59XG5mdW5jdGlvbiBoYXNGaWVsZChkYXRhLCBmaWVsZE5hbWUpIHtcbiAgICByZXR1cm4gZGF0YSAhPT0gbnVsbCAmJiB0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgJiYgZmllbGROYW1lIGluIGRhdGE7XG59XG5mdW5jdGlvbiBtY3BUb0dlbWluaVRvb2wobWNwVG9vbCwgY29uZmlnID0ge30pIHtcbiAgICBjb25zdCBtY3BUb29sU2NoZW1hID0gbWNwVG9vbDtcbiAgICBjb25zdCBmdW5jdGlvbkRlY2xhcmF0aW9uID0ge1xuICAgICAgICBuYW1lOiBtY3BUb29sU2NoZW1hWyduYW1lJ10sXG4gICAgICAgIGRlc2NyaXB0aW9uOiBtY3BUb29sU2NoZW1hWydkZXNjcmlwdGlvbiddLFxuICAgICAgICBwYXJhbWV0ZXJzSnNvblNjaGVtYTogbWNwVG9vbFNjaGVtYVsnaW5wdXRTY2hlbWEnXSxcbiAgICB9O1xuICAgIGlmIChtY3BUb29sU2NoZW1hWydvdXRwdXRTY2hlbWEnXSkge1xuICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9uWydyZXNwb25zZUpzb25TY2hlbWEnXSA9IG1jcFRvb2xTY2hlbWFbJ291dHB1dFNjaGVtYSddO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLmJlaGF2aW9yKSB7XG4gICAgICAgIGZ1bmN0aW9uRGVjbGFyYXRpb25bJ2JlaGF2aW9yJ10gPSBjb25maWcuYmVoYXZpb3I7XG4gICAgfVxuICAgIGNvbnN0IGdlbWluaVRvb2wgPSB7XG4gICAgICAgIGZ1bmN0aW9uRGVjbGFyYXRpb25zOiBbXG4gICAgICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9uLFxuICAgICAgICBdLFxuICAgIH07XG4gICAgcmV0dXJuIGdlbWluaVRvb2w7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgbGlzdCBvZiBNQ1AgdG9vbHMgdG8gYSBzaW5nbGUgR2VtaW5pIHRvb2wgd2l0aCBhIGxpc3Qgb2YgZnVuY3Rpb25cbiAqIGRlY2xhcmF0aW9ucy5cbiAqL1xuZnVuY3Rpb24gbWNwVG9vbHNUb0dlbWluaVRvb2wobWNwVG9vbHMsIGNvbmZpZyA9IHt9KSB7XG4gICAgY29uc3QgZnVuY3Rpb25EZWNsYXJhdGlvbnMgPSBbXTtcbiAgICBjb25zdCB0b29sTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCBtY3BUb29sIG9mIG1jcFRvb2xzKSB7XG4gICAgICAgIGNvbnN0IG1jcFRvb2xOYW1lID0gbWNwVG9vbC5uYW1lO1xuICAgICAgICBpZiAodG9vbE5hbWVzLmhhcyhtY3BUb29sTmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGZ1bmN0aW9uIG5hbWUgJHttY3BUb29sTmFtZX0gZm91bmQgaW4gTUNQIHRvb2xzLiBQbGVhc2UgZW5zdXJlIGZ1bmN0aW9uIG5hbWVzIGFyZSB1bmlxdWUuYCk7XG4gICAgICAgIH1cbiAgICAgICAgdG9vbE5hbWVzLmFkZChtY3BUb29sTmFtZSk7XG4gICAgICAgIGNvbnN0IGdlbWluaVRvb2wgPSBtY3BUb0dlbWluaVRvb2wobWNwVG9vbCwgY29uZmlnKTtcbiAgICAgICAgaWYgKGdlbWluaVRvb2wuZnVuY3Rpb25EZWNsYXJhdGlvbnMpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uRGVjbGFyYXRpb25zLnB1c2goLi4uZ2VtaW5pVG9vbC5mdW5jdGlvbkRlY2xhcmF0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgZnVuY3Rpb25EZWNsYXJhdGlvbnM6IGZ1bmN0aW9uRGVjbGFyYXRpb25zIH07XG59XG4vLyBUcmFuc2Zvcm1zIGEgc291cmNlIGlucHV0IGludG8gYSBCYXRjaEpvYlNvdXJjZSBvYmplY3Qgd2l0aCB2YWxpZGF0aW9uLlxuZnVuY3Rpb24gdEJhdGNoSm9iU291cmNlKGNsaWVudCwgc3JjKSB7XG4gICAgbGV0IHNvdXJjZU9iajtcbiAgICBpZiAodHlwZW9mIHNyYyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGlmIChzcmMuc3RhcnRzV2l0aCgnZ3M6Ly8nKSkge1xuICAgICAgICAgICAgICAgIHNvdXJjZU9iaiA9IHsgZm9ybWF0OiAnanNvbmwnLCBnY3NVcmk6IFtzcmNdIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzcmMuc3RhcnRzV2l0aCgnYnE6Ly8nKSkge1xuICAgICAgICAgICAgICAgIHNvdXJjZU9iaiA9IHsgZm9ybWF0OiAnYmlncXVlcnknLCBiaWdxdWVyeVVyaTogc3JjIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHN0cmluZyBzb3VyY2UgZm9yIFZlcnRleCBBSTogJHtzcmN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBNTERFVlxuICAgICAgICAgICAgaWYgKHNyYy5zdGFydHNXaXRoKCdmaWxlcy8nKSkge1xuICAgICAgICAgICAgICAgIHNvdXJjZU9iaiA9IHsgZmlsZU5hbWU6IHNyYyB9OyAvLyBEZWZhdWx0IHRvIGZpbGVOYW1lIGZvciBzdHJpbmcgaW5wdXRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgc3RyaW5nIHNvdXJjZSBmb3IgR2VtaW5pIEFQSTogJHtzcmN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzcmMpKSB7XG4gICAgICAgIGlmIChjbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lubGluZWRSZXF1ZXN0W10gaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgc291cmNlT2JqID0geyBpbmxpbmVkUmVxdWVzdHM6IHNyYyB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gSXQncyBhbHJlYWR5IGEgQmF0Y2hKb2JTb3VyY2Ugb2JqZWN0XG4gICAgICAgIHNvdXJjZU9iaiA9IHNyYztcbiAgICB9XG4gICAgLy8gVmFsaWRhdGlvbiBsb2dpY1xuICAgIGNvbnN0IHZlcnRleFNvdXJjZXNDb3VudCA9IFtzb3VyY2VPYmouZ2NzVXJpLCBzb3VyY2VPYmouYmlncXVlcnlVcmldLmZpbHRlcihCb29sZWFuKS5sZW5ndGg7XG4gICAgY29uc3QgbWxkZXZTb3VyY2VzQ291bnQgPSBbXG4gICAgICAgIHNvdXJjZU9iai5pbmxpbmVkUmVxdWVzdHMsXG4gICAgICAgIHNvdXJjZU9iai5maWxlTmFtZSxcbiAgICBdLmZpbHRlcihCb29sZWFuKS5sZW5ndGg7XG4gICAgaWYgKGNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgaWYgKG1sZGV2U291cmNlc0NvdW50ID4gMCB8fCB2ZXJ0ZXhTb3VyY2VzQ291bnQgIT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhhY3RseSBvbmUgb2YgYGdjc1VyaWAgb3IgYGJpZ3F1ZXJ5VXJpYCBtdXN0IGJlIHNldCBmb3IgVmVydGV4IEFJLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBNTERFVlxuICAgICAgICBpZiAodmVydGV4U291cmNlc0NvdW50ID4gMCB8fCBtbGRldlNvdXJjZXNDb3VudCAhPT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeGFjdGx5IG9uZSBvZiBgaW5saW5lZFJlcXVlc3RzYCwgYGZpbGVOYW1lYCwgJyArXG4gICAgICAgICAgICAgICAgJ211c3QgYmUgc2V0IGZvciBHZW1pbmkgQVBJLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2VPYmo7XG59XG5mdW5jdGlvbiB0QmF0Y2hKb2JEZXN0aW5hdGlvbihkZXN0KSB7XG4gICAgaWYgKHR5cGVvZiBkZXN0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9XG4gICAgY29uc3QgZGVzdFN0cmluZyA9IGRlc3Q7XG4gICAgaWYgKGRlc3RTdHJpbmcuc3RhcnRzV2l0aCgnZ3M6Ly8nKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZm9ybWF0OiAnanNvbmwnLFxuICAgICAgICAgICAgZ2NzVXJpOiBkZXN0U3RyaW5nLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChkZXN0U3RyaW5nLnN0YXJ0c1dpdGgoJ2JxOi8vJykpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZvcm1hdDogJ2JpZ3F1ZXJ5JyxcbiAgICAgICAgICAgIGJpZ3F1ZXJ5VXJpOiBkZXN0U3RyaW5nLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkZXN0aW5hdGlvbjogJHtkZXN0U3RyaW5nfWApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRSZWN2QmF0Y2hKb2JEZXN0aW5hdGlvbihkZXN0KSB7XG4gICAgLy8gRW5zdXJlIGRlc3QgaXMgYSBub24tbnVsbCBvYmplY3QgYmVmb3JlIHByb2NlZWRpbmcuXG4gICAgaWYgKHR5cGVvZiBkZXN0ICE9PSAnb2JqZWN0JyB8fCBkZXN0ID09PSBudWxsKSB7XG4gICAgICAgIC8vIElmIHRoZSBpbnB1dCBpcyBub3QgYW4gb2JqZWN0LCBpdCBjYW5ub3QgYmUgYSB2YWxpZCBCYXRjaEpvYkRlc3RpbmF0aW9uXG4gICAgICAgIC8vIGJhc2VkIG9uIHRoZSBvcGVyYXRpb25zIHBlcmZvcm1lZC4gUmV0dXJuIGl0IGNhc3QsIG9yIGhhbmRsZSBhcyBhbiBlcnJvci5cbiAgICAgICAgLy8gQ2FzdGluZyBhbiBlbXB0eSBvYmplY3QgbWlnaHQgYmUgYSBzYWZlIGRlZmF1bHQuXG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgLy8gQ2FzdCB0byBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiB0byBhbGxvdyBzdHJpbmcgcHJvcGVydHkgYWNjZXNzLlxuICAgIGNvbnN0IG9iaiA9IGRlc3Q7XG4gICAgLy8gU2FmZWx5IGFjY2VzcyBuZXN0ZWQgcHJvcGVydGllcy5cbiAgICBjb25zdCBpbmxpbmVSZXNwb25zZXNWYWwgPSBvYmpbJ2lubGluZWRSZXNwb25zZXMnXTtcbiAgICBpZiAodHlwZW9mIGlubGluZVJlc3BvbnNlc1ZhbCAhPT0gJ29iamVjdCcgfHwgaW5saW5lUmVzcG9uc2VzVmFsID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH1cbiAgICBjb25zdCBpbmxpbmVSZXNwb25zZXNPYmogPSBpbmxpbmVSZXNwb25zZXNWYWw7XG4gICAgY29uc3QgcmVzcG9uc2VzQXJyYXkgPSBpbmxpbmVSZXNwb25zZXNPYmpbJ2lubGluZWRSZXNwb25zZXMnXTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVzcG9uc2VzQXJyYXkpIHx8IHJlc3BvbnNlc0FycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgYW55IHJlc3BvbnNlIGhhcyB0aGUgJ2VtYmVkZGluZycgcHJvcGVydHkuXG4gICAgbGV0IGhhc0VtYmVkZGluZyA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgcmVzcG9uc2VJdGVtIG9mIHJlc3BvbnNlc0FycmF5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzcG9uc2VJdGVtICE9PSAnb2JqZWN0JyB8fCByZXNwb25zZUl0ZW0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlSXRlbU9iaiA9IHJlc3BvbnNlSXRlbTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VWYWwgPSByZXNwb25zZUl0ZW1PYmpbJ3Jlc3BvbnNlJ107XG4gICAgICAgIGlmICh0eXBlb2YgcmVzcG9uc2VWYWwgIT09ICdvYmplY3QnIHx8IHJlc3BvbnNlVmFsID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZU9iaiA9IHJlc3BvbnNlVmFsO1xuICAgICAgICAvLyBDaGVjayBmb3IgdGhlIGV4aXN0ZW5jZSBvZiB0aGUgJ2VtYmVkZGluZycga2V5LlxuICAgICAgICBpZiAocmVzcG9uc2VPYmpbJ2VtYmVkZGluZyddICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGhhc0VtYmVkZGluZyA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBQZXJmb3JtIHRoZSB0cmFuc2Zvcm1hdGlvbiBpZiBhbiBlbWJlZGRpbmcgd2FzIGZvdW5kLlxuICAgIGlmIChoYXNFbWJlZGRpbmcpIHtcbiAgICAgICAgb2JqWydpbmxpbmVkRW1iZWRDb250ZW50UmVzcG9uc2VzJ10gPSBvYmpbJ2lubGluZWRSZXNwb25zZXMnXTtcbiAgICAgICAgZGVsZXRlIG9ialsnaW5saW5lZFJlc3BvbnNlcyddO1xuICAgIH1cbiAgICAvLyBDYXN0IHRoZSAocG90ZW50aWFsbHkpIG1vZGlmaWVkIG9iamVjdCB0byB0aGUgdGFyZ2V0IHR5cGUuXG4gICAgcmV0dXJuIGRlc3Q7XG59XG5mdW5jdGlvbiB0QmF0Y2hKb2JOYW1lKGFwaUNsaWVudCwgbmFtZSkge1xuICAgIGNvbnN0IG5hbWVTdHJpbmcgPSBuYW1lO1xuICAgIGlmICghYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICBjb25zdCBtbGRldlBhdHRlcm4gPSAvYmF0Y2hlc1xcL1teL10rJC87XG4gICAgICAgIGlmIChtbGRldlBhdHRlcm4udGVzdChuYW1lU3RyaW5nKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5hbWVTdHJpbmcuc3BsaXQoJy8nKS5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBiYXRjaCBqb2IgbmFtZTogJHtuYW1lU3RyaW5nfS5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB2ZXJ0ZXhQYXR0ZXJuID0gL15wcm9qZWN0c1xcL1teL10rXFwvbG9jYXRpb25zXFwvW14vXStcXC9iYXRjaFByZWRpY3Rpb25Kb2JzXFwvW14vXSskLztcbiAgICBpZiAodmVydGV4UGF0dGVybi50ZXN0KG5hbWVTdHJpbmcpKSB7XG4gICAgICAgIHJldHVybiBuYW1lU3RyaW5nLnNwbGl0KCcvJykucG9wKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKC9eXFxkKyQvLnRlc3QobmFtZVN0cmluZykpIHtcbiAgICAgICAgcmV0dXJuIG5hbWVTdHJpbmc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYmF0Y2ggam9iIG5hbWU6ICR7bmFtZVN0cmluZ30uYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gdEpvYlN0YXRlKHN0YXRlKSB7XG4gICAgY29uc3Qgc3RhdGVTdHJpbmcgPSBzdGF0ZTtcbiAgICBpZiAoc3RhdGVTdHJpbmcgPT09ICdCQVRDSF9TVEFURV9VTlNQRUNJRklFRCcpIHtcbiAgICAgICAgcmV0dXJuICdKT0JfU1RBVEVfVU5TUEVDSUZJRUQnO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdGF0ZVN0cmluZyA9PT0gJ0JBVENIX1NUQVRFX1BFTkRJTkcnKSB7XG4gICAgICAgIHJldHVybiAnSk9CX1NUQVRFX1BFTkRJTkcnO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdGF0ZVN0cmluZyA9PT0gJ0JBVENIX1NUQVRFX1JVTk5JTkcnKSB7XG4gICAgICAgIHJldHVybiAnSk9CX1NUQVRFX1JVTk5JTkcnO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdGF0ZVN0cmluZyA9PT0gJ0JBVENIX1NUQVRFX1NVQ0NFRURFRCcpIHtcbiAgICAgICAgcmV0dXJuICdKT0JfU1RBVEVfU1VDQ0VFREVEJztcbiAgICB9XG4gICAgZWxzZSBpZiAoc3RhdGVTdHJpbmcgPT09ICdCQVRDSF9TVEFURV9GQUlMRUQnKSB7XG4gICAgICAgIHJldHVybiAnSk9CX1NUQVRFX0ZBSUxFRCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHN0YXRlU3RyaW5nID09PSAnQkFUQ0hfU1RBVEVfQ0FOQ0VMTEVEJykge1xuICAgICAgICByZXR1cm4gJ0pPQl9TVEFURV9DQU5DRUxMRUQnO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdGF0ZVN0cmluZyA9PT0gJ0JBVENIX1NUQVRFX0VYUElSRUQnKSB7XG4gICAgICAgIHJldHVybiAnSk9CX1NUQVRFX0VYUElSRUQnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlU3RyaW5nO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuZnVuY3Rpb24gYmF0Y2hKb2JEZXN0aW5hdGlvbkZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRmlsZU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc3BvbnNlc0ZpbGUnXSk7XG4gICAgaWYgKGZyb21GaWxlTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVOYW1lJ10sIGZyb21GaWxlTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmxpbmVkUmVzcG9uc2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW5saW5lZFJlc3BvbnNlcycsXG4gICAgICAgICdpbmxpbmVkUmVzcG9uc2VzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUlubGluZWRSZXNwb25zZXMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUlubGluZWRSZXNwb25zZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5saW5lZFJlc3BvbnNlRnJvbU1sZGV2KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5saW5lZFJlc3BvbnNlcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5saW5lZEVtYmVkQ29udGVudFJlc3BvbnNlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2lubGluZWRFbWJlZENvbnRlbnRSZXNwb25zZXMnLFxuICAgICAgICAnaW5saW5lZFJlc3BvbnNlcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21JbmxpbmVkRW1iZWRDb250ZW50UmVzcG9uc2VzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21JbmxpbmVkRW1iZWRDb250ZW50UmVzcG9uc2VzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbmxpbmVkRW1iZWRDb250ZW50UmVzcG9uc2VzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGJhdGNoSm9iRGVzdGluYXRpb25Gcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Gb3JtYXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ByZWRpY3Rpb25zRm9ybWF0J10pO1xuICAgIGlmIChmcm9tRm9ybWF0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZm9ybWF0J10sIGZyb21Gb3JtYXQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR2NzVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ2NzRGVzdGluYXRpb24nLFxuICAgICAgICAnb3V0cHV0VXJpUHJlZml4JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdjc1VyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2djc1VyaSddLCBmcm9tR2NzVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUJpZ3F1ZXJ5VXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYmlncXVlcnlEZXN0aW5hdGlvbicsXG4gICAgICAgICdvdXRwdXRVcmknLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQmlncXVlcnlVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydiaWdxdWVyeVVyaSddLCBmcm9tQmlncXVlcnlVcmkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBiYXRjaEpvYkRlc3RpbmF0aW9uVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZvcm1hdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZm9ybWF0J10pO1xuICAgIGlmIChmcm9tRm9ybWF0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJlZGljdGlvbnNGb3JtYXQnXSwgZnJvbUZvcm1hdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HY3NVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2djc1VyaSddKTtcbiAgICBpZiAoZnJvbUdjc1VyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2djc0Rlc3RpbmF0aW9uJywgJ291dHB1dFVyaVByZWZpeCddLCBmcm9tR2NzVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUJpZ3F1ZXJ5VXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydiaWdxdWVyeVVyaSddKTtcbiAgICBpZiAoZnJvbUJpZ3F1ZXJ5VXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYmlncXVlcnlEZXN0aW5hdGlvbicsICdvdXRwdXRVcmknXSwgZnJvbUJpZ3F1ZXJ5VXJpKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZU5hbWUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpbGVOYW1lIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW5saW5lZFJlc3BvbnNlcyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW5saW5lZFJlc3BvbnNlcyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lubGluZWRFbWJlZENvbnRlbnRSZXNwb25zZXMnXSkgIT09XG4gICAgICAgIHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lubGluZWRFbWJlZENvbnRlbnRSZXNwb25zZXMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBiYXRjaEpvYkZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWV0YWRhdGEnLFxuICAgICAgICAnZGlzcGxheU5hbWUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RhdGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21ldGFkYXRhJywgJ3N0YXRlJ10pO1xuICAgIGlmIChmcm9tU3RhdGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGF0ZSddLCB0Sm9iU3RhdGUoZnJvbVN0YXRlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DcmVhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWV0YWRhdGEnLFxuICAgICAgICAnY3JlYXRlVGltZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DcmVhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY3JlYXRlVGltZSddLCBmcm9tQ3JlYXRlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmRUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWV0YWRhdGEnLFxuICAgICAgICAnZW5kVGltZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FbmRUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5kVGltZSddLCBmcm9tRW5kVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcGRhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWV0YWRhdGEnLFxuICAgICAgICAndXBkYXRlVGltZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21VcGRhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXBkYXRlVGltZSddLCBmcm9tVXBkYXRlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWV0YWRhdGEnLCAnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGVsJ10sIGZyb21Nb2RlbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXN0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZXRhZGF0YScsICdvdXRwdXQnXSk7XG4gICAgaWYgKGZyb21EZXN0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVzdCddLCBiYXRjaEpvYkRlc3RpbmF0aW9uRnJvbU1sZGV2KHRSZWN2QmF0Y2hKb2JEZXN0aW5hdGlvbihmcm9tRGVzdCkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYmF0Y2hKb2JGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RhdGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N0YXRlJ10pO1xuICAgIGlmIChmcm9tU3RhdGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGF0ZSddLCB0Sm9iU3RhdGUoZnJvbVN0YXRlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FcnJvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXJyb3InXSk7XG4gICAgaWYgKGZyb21FcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vycm9yJ10sIGZyb21FcnJvcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DcmVhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjcmVhdGVUaW1lJ10pO1xuICAgIGlmIChmcm9tQ3JlYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSwgZnJvbUNyZWF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RhcnRUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdGFydFRpbWUnXSk7XG4gICAgaWYgKGZyb21TdGFydFRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGFydFRpbWUnXSwgZnJvbVN0YXJ0VGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmRUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmRUaW1lJ10pO1xuICAgIGlmIChmcm9tRW5kVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuZFRpbWUnXSwgZnJvbUVuZFRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXBkYXRlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXBkYXRlVGltZSddKTtcbiAgICBpZiAoZnJvbVVwZGF0ZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cGRhdGVUaW1lJ10sIGZyb21VcGRhdGVUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZWwnXSwgZnJvbU1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNyYyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW5wdXRDb25maWcnXSk7XG4gICAgaWYgKGZyb21TcmMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzcmMnXSwgYmF0Y2hKb2JTb3VyY2VGcm9tVmVydGV4KGZyb21TcmMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlc3QgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ291dHB1dENvbmZpZyddKTtcbiAgICBpZiAoZnJvbURlc3QgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZXN0J10sIGJhdGNoSm9iRGVzdGluYXRpb25Gcm9tVmVydGV4KHRSZWN2QmF0Y2hKb2JEZXN0aW5hdGlvbihmcm9tRGVzdCkpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbXBsZXRpb25TdGF0cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvbXBsZXRpb25TdGF0cycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db21wbGV0aW9uU3RhdHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb21wbGV0aW9uU3RhdHMnXSwgZnJvbUNvbXBsZXRpb25TdGF0cyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGJhdGNoSm9iU291cmNlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRm9ybWF0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbnN0YW5jZXNGb3JtYXQnXSk7XG4gICAgaWYgKGZyb21Gb3JtYXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmb3JtYXQnXSwgZnJvbUZvcm1hdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HY3NVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2djc1NvdXJjZScsICd1cmlzJ10pO1xuICAgIGlmIChmcm9tR2NzVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2NzVXJpJ10sIGZyb21HY3NVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQmlncXVlcnlVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdiaWdxdWVyeVNvdXJjZScsXG4gICAgICAgICdpbnB1dFVyaScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21CaWdxdWVyeVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2JpZ3F1ZXJ5VXJpJ10sIGZyb21CaWdxdWVyeVVyaSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGJhdGNoSm9iU291cmNlVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Zvcm1hdCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZm9ybWF0IHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2djc1VyaSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZ2NzVXJpIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2JpZ3F1ZXJ5VXJpJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiaWdxdWVyeVVyaSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVOYW1lJ10pO1xuICAgIGlmIChmcm9tRmlsZU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlTmFtZSddLCBmcm9tRmlsZU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5saW5lZFJlcXVlc3RzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW5saW5lZFJlcXVlc3RzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUlubGluZWRSZXF1ZXN0cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tSW5saW5lZFJlcXVlc3RzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlubGluZWRSZXF1ZXN0VG9NbGRldihhcGlDbGllbnQsIGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVxdWVzdHMnLCAncmVxdWVzdHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYmF0Y2hKb2JTb3VyY2VUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRm9ybWF0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmb3JtYXQnXSk7XG4gICAgaWYgKGZyb21Gb3JtYXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbnN0YW5jZXNGb3JtYXQnXSwgZnJvbUZvcm1hdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HY3NVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2djc1VyaSddKTtcbiAgICBpZiAoZnJvbUdjc1VyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2djc1NvdXJjZScsICd1cmlzJ10sIGZyb21HY3NVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQmlncXVlcnlVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2JpZ3F1ZXJ5VXJpJ10pO1xuICAgIGlmIChmcm9tQmlncXVlcnlVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydiaWdxdWVyeVNvdXJjZScsICdpbnB1dFVyaSddLCBmcm9tQmlncXVlcnlVcmkpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlTmFtZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZmlsZU5hbWUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbmxpbmVkUmVxdWVzdHMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lubGluZWRSZXF1ZXN0cyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGJsb2JUb01sZGV2JDQoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RhdGEnXSk7XG4gICAgaWYgKGZyb21EYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGF0YSddLCBmcm9tRGF0YSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaXNwbGF5TmFtZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjYW5jZWxCYXRjaEpvYlBhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIHRCYXRjaEpvYk5hbWUoYXBpQ2xpZW50LCBmcm9tTmFtZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjYW5jZWxCYXRjaEpvYlBhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0QmF0Y2hKb2JOYW1lKGFwaUNsaWVudCwgZnJvbU5hbWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY2FuZGlkYXRlRnJvbU1sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNvbnRlbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnQnXSk7XG4gICAgaWYgKGZyb21Db250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29udGVudCddLCBmcm9tQ29udGVudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DaXRhdGlvbk1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2l0YXRpb25NZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DaXRhdGlvbk1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2l0YXRpb25NZXRhZGF0YSddLCBjaXRhdGlvbk1ldGFkYXRhRnJvbU1sZGV2JDEoZnJvbUNpdGF0aW9uTWV0YWRhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRva2VuQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rva2VuQ291bnQnXSk7XG4gICAgaWYgKGZyb21Ub2tlbkNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9rZW5Db3VudCddLCBmcm9tVG9rZW5Db3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaW5pc2hSZWFzb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbmlzaFJlYXNvbiddKTtcbiAgICBpZiAoZnJvbUZpbmlzaFJlYXNvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbmlzaFJlYXNvbiddLCBmcm9tRmluaXNoUmVhc29uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUF2Z0xvZ3Byb2JzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhdmdMb2dwcm9icyddKTtcbiAgICBpZiAoZnJvbUF2Z0xvZ3Byb2JzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXZnTG9ncHJvYnMnXSwgZnJvbUF2Z0xvZ3Byb2JzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdyb3VuZGluZ01ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ3JvdW5kaW5nTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR3JvdW5kaW5nTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydncm91bmRpbmdNZXRhZGF0YSddLCBmcm9tR3JvdW5kaW5nTWV0YWRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5kZXggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2luZGV4J10pO1xuICAgIGlmIChmcm9tSW5kZXggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbmRleCddLCBmcm9tSW5kZXgpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTG9ncHJvYnNSZXN1bHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdsb2dwcm9ic1Jlc3VsdCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Mb2dwcm9ic1Jlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xvZ3Byb2JzUmVzdWx0J10sIGZyb21Mb2dwcm9ic1Jlc3VsdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TYWZldHlSYXRpbmdzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2FmZXR5UmF0aW5ncycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TYWZldHlSYXRpbmdzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21TYWZldHlSYXRpbmdzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzYWZldHlSYXRpbmdzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcmxDb250ZXh0TWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd1cmxDb250ZXh0TWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVXJsQ29udGV4dE1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJsQ29udGV4dE1ldGFkYXRhJ10sIGZyb21VcmxDb250ZXh0TWV0YWRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjaXRhdGlvbk1ldGFkYXRhRnJvbU1sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNpdGF0aW9ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY2l0YXRpb25Tb3VyY2VzJ10pO1xuICAgIGlmIChmcm9tQ2l0YXRpb25zICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21DaXRhdGlvbnM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NpdGF0aW9ucyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb250ZW50VG9NbGRldiQ0KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYXJ0cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFydHMnXSk7XG4gICAgaWYgKGZyb21QYXJ0cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tUGFydHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydFRvTWxkZXYkNChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Sb2xlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyb2xlJ10pO1xuICAgIGlmIChmcm9tUm9sZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JvbGUnXSwgZnJvbVJvbGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVCYXRjaEpvYkNvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnYmF0Y2gnLCAnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzdCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGVzdCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVCYXRjaEpvYkNvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10sIGZyb21EaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXN0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXN0J10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRGVzdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydvdXRwdXRDb25maWcnXSwgYmF0Y2hKb2JEZXN0aW5hdGlvblRvVmVydGV4KHRCYXRjaEpvYkRlc3RpbmF0aW9uKGZyb21EZXN0KSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVCYXRjaEpvYlBhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNyYyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3JjJ10pO1xuICAgIGlmIChmcm9tU3JjICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYmF0Y2gnLCAnaW5wdXRDb25maWcnXSwgYmF0Y2hKb2JTb3VyY2VUb01sZGV2KGFwaUNsaWVudCwgdEJhdGNoSm9iU291cmNlKGFwaUNsaWVudCwgZnJvbVNyYykpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgY3JlYXRlQmF0Y2hKb2JDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlQmF0Y2hKb2JQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNyYyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3JjJ10pO1xuICAgIGlmIChmcm9tU3JjICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5wdXRDb25maWcnXSwgYmF0Y2hKb2JTb3VyY2VUb1ZlcnRleCh0QmF0Y2hKb2JTb3VyY2UoYXBpQ2xpZW50LCBmcm9tU3JjKSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBjcmVhdGVCYXRjaEpvYkNvbmZpZ1RvVmVydGV4KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlRW1iZWRkaW5nc0JhdGNoSm9iQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21EaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydiYXRjaCcsICdkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVFbWJlZGRpbmdzQmF0Y2hKb2JQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TcmMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NyYyddKTtcbiAgICBpZiAoZnJvbVNyYyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2JhdGNoJywgJ2lucHV0Q29uZmlnJ10sIGVtYmVkZGluZ3NCYXRjaEpvYlNvdXJjZVRvTWxkZXYoYXBpQ2xpZW50LCBmcm9tU3JjKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGNyZWF0ZUVtYmVkZGluZ3NCYXRjaEpvYkNvbmZpZ1RvTWxkZXYoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkZWxldGVCYXRjaEpvYlBhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIHRCYXRjaEpvYk5hbWUoYXBpQ2xpZW50LCBmcm9tTmFtZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkZWxldGVCYXRjaEpvYlBhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0QmF0Y2hKb2JOYW1lKGFwaUNsaWVudCwgZnJvbU5hbWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZGVsZXRlUmVzb3VyY2VKb2JGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRG9uZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZG9uZSddKTtcbiAgICBpZiAoZnJvbURvbmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkb25lJ10sIGZyb21Eb25lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVycm9yID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlcnJvciddKTtcbiAgICBpZiAoZnJvbUVycm9yICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXJyb3InXSwgZnJvbUVycm9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZGVsZXRlUmVzb3VyY2VKb2JGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURvbmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RvbmUnXSk7XG4gICAgaWYgKGZyb21Eb25lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZG9uZSddLCBmcm9tRG9uZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FcnJvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXJyb3InXSk7XG4gICAgaWYgKGZyb21FcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vycm9yJ10sIGZyb21FcnJvcik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGVtYmVkQ29udGVudEJhdGNoVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Db250ZW50cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udGVudHMnXSk7XG4gICAgaWYgKGZyb21Db250ZW50cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0Q29udGVudHNGb3JFbWJlZChhcGlDbGllbnQsIGZyb21Db250ZW50cyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JlcXVlc3RzW10nLCAncmVxdWVzdCcsICdjb250ZW50J10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ19zZWxmJ10sIGVtYmVkQ29udGVudENvbmZpZ1RvTWxkZXYkMShmcm9tQ29uZmlnLCB0b09iamVjdCkpO1xuICAgICAgICBtb3ZlVmFsdWVCeVBhdGgodG9PYmplY3QsIHsgJ3JlcXVlc3RzW10uKic6ICdyZXF1ZXN0c1tdLnJlcXVlc3QuKicgfSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGVtYmVkQ29udGVudENvbmZpZ1RvTWxkZXYkMShmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UYXNrVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGFza1R5cGUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UYXNrVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydyZXF1ZXN0c1tdJywgJ3Rhc2tUeXBlJ10sIGZyb21UYXNrVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaXRsZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGl0bGUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UaXRsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydyZXF1ZXN0c1tdJywgJ3RpdGxlJ10sIGZyb21UaXRsZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXREaW1lbnNpb25hbGl0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dERpbWVuc2lvbmFsaXR5JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dERpbWVuc2lvbmFsaXR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3JlcXVlc3RzW10nLCAnb3V0cHV0RGltZW5zaW9uYWxpdHknXSwgZnJvbU91dHB1dERpbWVuc2lvbmFsaXR5KTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pbWVUeXBlIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2F1dG9UcnVuY2F0ZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYXV0b1RydW5jYXRlIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGVtYmVkZGluZ3NCYXRjaEpvYlNvdXJjZVRvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRmlsZU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVOYW1lJ10pO1xuICAgIGlmIChmcm9tRmlsZU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlX25hbWUnXSwgZnJvbUZpbGVOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUlubGluZWRSZXF1ZXN0cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2lubGluZWRSZXF1ZXN0cycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21JbmxpbmVkUmVxdWVzdHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXF1ZXN0cyddLCBlbWJlZENvbnRlbnRCYXRjaFRvTWxkZXYoYXBpQ2xpZW50LCBmcm9tSW5saW5lZFJlcXVlc3RzKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZpbGVEYXRhVG9NbGRldiQ0KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaXNwbGF5TmFtZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZVVyaSddKTtcbiAgICBpZiAoZnJvbUZpbGVVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlVXJpJ10sIGZyb21GaWxlVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25DYWxsVG9NbGRldiQ0KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21JZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaWQnXSk7XG4gICAgaWYgKGZyb21JZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lkJ10sIGZyb21JZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BcmdzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhcmdzJ10pO1xuICAgIGlmIChmcm9tQXJncyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FyZ3MnXSwgZnJvbUFyZ3MpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFydGlhbEFyZ3MnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhcnRpYWxBcmdzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3dpbGxDb250aW51ZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignd2lsbENvbnRpbnVlIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ1RvTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZSddKTtcbiAgICBpZiAoZnJvbU1vZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlJ10sIGZyb21Nb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFsbG93ZWRGdW5jdGlvbk5hbWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYWxsb3dlZEZ1bmN0aW9uTmFtZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQWxsb3dlZEZ1bmN0aW9uTmFtZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhbGxvd2VkRnVuY3Rpb25OYW1lcyddLCBmcm9tQWxsb3dlZEZ1bmN0aW9uTmFtZXMpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdHJlYW1GdW5jdGlvbkNhbGxBcmd1bWVudHMnXSkgIT09XG4gICAgICAgIHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0cmVhbUZ1bmN0aW9uQ2FsbEFyZ3VtZW50cyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUNvbnRlbnRDb25maWdUb01sZGV2JDEoYXBpQ2xpZW50LCBmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TeXN0ZW1JbnN0cnVjdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N5c3RlbUluc3RydWN0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVN5c3RlbUluc3RydWN0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3N5c3RlbUluc3RydWN0aW9uJ10sIGNvbnRlbnRUb01sZGV2JDQodENvbnRlbnQoZnJvbVN5c3RlbUluc3RydWN0aW9uKSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGVtcGVyYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RlbXBlcmF0dXJlJ10pO1xuICAgIGlmIChmcm9tVGVtcGVyYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZW1wZXJhdHVyZSddLCBmcm9tVGVtcGVyYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wUCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wUCddKTtcbiAgICBpZiAoZnJvbVRvcFAgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b3BQJ10sIGZyb21Ub3BQKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvcEsgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvcEsnXSk7XG4gICAgaWYgKGZyb21Ub3BLICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9wSyddLCBmcm9tVG9wSyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYW5kaWRhdGVDb3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NhbmRpZGF0ZUNvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNhbmRpZGF0ZUNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2FuZGlkYXRlQ291bnQnXSwgZnJvbUNhbmRpZGF0ZUNvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1heE91dHB1dFRva2VucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21heE91dHB1dFRva2VucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NYXhPdXRwdXRUb2tlbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtYXhPdXRwdXRUb2tlbnMnXSwgZnJvbU1heE91dHB1dFRva2Vucyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdG9wU2VxdWVuY2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3RvcFNlcXVlbmNlcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TdG9wU2VxdWVuY2VzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RvcFNlcXVlbmNlcyddLCBmcm9tU3RvcFNlcXVlbmNlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZUxvZ3Byb2JzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VMb2dwcm9icycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZUxvZ3Byb2JzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VMb2dwcm9icyddLCBmcm9tUmVzcG9uc2VMb2dwcm9icyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Mb2dwcm9icyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbG9ncHJvYnMnXSk7XG4gICAgaWYgKGZyb21Mb2dwcm9icyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xvZ3Byb2JzJ10sIGZyb21Mb2dwcm9icyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QcmVzZW5jZVBlbmFsdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVzZW5jZVBlbmFsdHknLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJlc2VuY2VQZW5hbHR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJlc2VuY2VQZW5hbHR5J10sIGZyb21QcmVzZW5jZVBlbmFsdHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnJlcXVlbmN5UGVuYWx0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2ZyZXF1ZW5jeVBlbmFsdHknLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnJlcXVlbmN5UGVuYWx0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZyZXF1ZW5jeVBlbmFsdHknXSwgZnJvbUZyZXF1ZW5jeVBlbmFsdHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2VlZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc2VlZCddKTtcbiAgICBpZiAoZnJvbVNlZWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZWVkJ10sIGZyb21TZWVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZU1pbWVUeXBlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZU1pbWVUeXBlJ10sIGZyb21SZXNwb25zZU1pbWVUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VTY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VTY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZVNjaGVtYSddLCB0U2NoZW1hKGZyb21SZXNwb25zZVNjaGVtYSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VKc29uU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlSnNvblNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlSnNvblNjaGVtYSddLCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncm91dGluZ0NvbmZpZyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncm91dGluZ0NvbmZpZyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbFNlbGVjdGlvbkNvbmZpZyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbW9kZWxTZWxlY3Rpb25Db25maWcgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNhZmV0eVNldHRpbmdzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2FmZXR5U2V0dGluZ3MnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2FmZXR5U2V0dGluZ3MgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVNhZmV0eVNldHRpbmdzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNhZmV0eVNldHRpbmdUb01sZGV2JDEoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2FmZXR5U2V0dGluZ3MnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29scyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvb2xzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRUb29scyhmcm9tVG9vbHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvb2xUb01sZGV2JDQodFRvb2woaXRlbSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3Rvb2xzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29sQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29sQ29uZmlnJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9vbENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0b29sQ29uZmlnJ10sIHRvb2xDb25maWdUb01sZGV2JDIoZnJvbVRvb2xDb25maWcpKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFiZWxzJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsYWJlbHMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNhY2hlZENvbnRlbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYWNoZWRDb250ZW50JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUNhY2hlZENvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnY2FjaGVkQ29udGVudCddLCB0Q2FjaGVkQ29udGVudE5hbWUoYXBpQ2xpZW50LCBmcm9tQ2FjaGVkQ29udGVudCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VNb2RhbGl0aWVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlTW9kYWxpdGllcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlTW9kYWxpdGllcyddLCBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1lZGlhUmVzb2x1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21lZGlhUmVzb2x1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NZWRpYVJlc29sdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZWRpYVJlc29sdXRpb24nXSwgZnJvbU1lZGlhUmVzb2x1dGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TcGVlY2hDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NwZWVjaENvbmZpZyddKTtcbiAgICBpZiAoZnJvbVNwZWVjaENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NwZWVjaENvbmZpZyddLCB0U3BlZWNoQ29uZmlnKGZyb21TcGVlY2hDb25maWcpKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXVkaW9UaW1lc3RhbXAnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2F1ZGlvVGltZXN0YW1wIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaGlua2luZ0NvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RoaW5raW5nQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRoaW5raW5nQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhpbmtpbmdDb25maWcnXSwgZnJvbVRoaW5raW5nQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUltYWdlQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZUNvbmZpZyddKTtcbiAgICBpZiAoZnJvbUltYWdlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW1hZ2VDb25maWcnXSwgaW1hZ2VDb25maWdUb01sZGV2JDEoZnJvbUltYWdlQ29uZmlnKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlQ29udGVudFJlc3BvbnNlRnJvbU1sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYW5kaWRhdGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjYW5kaWRhdGVzJ10pO1xuICAgIGlmIChmcm9tQ2FuZGlkYXRlcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tQ2FuZGlkYXRlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYW5kaWRhdGVGcm9tTWxkZXYkMShpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhbmRpZGF0ZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1vZGVsVmVyc2lvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWxWZXJzaW9uJ10pO1xuICAgIGlmIChmcm9tTW9kZWxWZXJzaW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZWxWZXJzaW9uJ10sIGZyb21Nb2RlbFZlcnNpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvbXB0RmVlZGJhY2sgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcm9tcHRGZWVkYmFjaycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Qcm9tcHRGZWVkYmFjayAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Byb21wdEZlZWRiYWNrJ10sIGZyb21Qcm9tcHRGZWVkYmFjayk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZUlkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNwb25zZUlkJ10pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VJZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlSWQnXSwgZnJvbVJlc3BvbnNlSWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXNhZ2VNZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3VzYWdlTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVXNhZ2VNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VzYWdlTWV0YWRhdGEnXSwgZnJvbVVzYWdlTWV0YWRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZXRCYXRjaEpvYlBhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIHRCYXRjaEpvYk5hbWUoYXBpQ2xpZW50LCBmcm9tTmFtZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZXRCYXRjaEpvYlBhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0QmF0Y2hKb2JOYW1lKGFwaUNsaWVudCwgZnJvbU5hbWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ29vZ2xlTWFwc1RvTWxkZXYkNChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhdXRoQ29uZmlnJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhdXRoQ29uZmlnIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmFibGVXaWRnZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuYWJsZVdpZGdldCddKTtcbiAgICBpZiAoZnJvbUVuYWJsZVdpZGdldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuYWJsZVdpZGdldCddLCBmcm9tRW5hYmxlV2lkZ2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ29vZ2xlU2VhcmNoVG9NbGRldiQ0KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2V4Y2x1ZGVEb21haW5zJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleGNsdWRlRG9tYWlucyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydibG9ja2luZ0NvbmZpZGVuY2UnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Jsb2NraW5nQ29uZmlkZW5jZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGltZVJhbmdlRmlsdGVyID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGltZVJhbmdlRmlsdGVyJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRpbWVSYW5nZUZpbHRlciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RpbWVSYW5nZUZpbHRlciddLCBmcm9tVGltZVJhbmdlRmlsdGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gaW1hZ2VDb25maWdUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUFzcGVjdFJhdGlvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhc3BlY3RSYXRpbyddKTtcbiAgICBpZiAoZnJvbUFzcGVjdFJhdGlvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXNwZWN0UmF0aW8nXSwgZnJvbUFzcGVjdFJhdGlvKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUltYWdlU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW1hZ2VTaXplJ10pO1xuICAgIGlmIChmcm9tSW1hZ2VTaXplICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW1hZ2VTaXplJ10sIGZyb21JbWFnZVNpemUpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydvdXRwdXRNaW1lVHlwZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignb3V0cHV0TWltZVR5cGUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnb3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5J10pICE9PVxuICAgICAgICB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvdXRwdXRDb21wcmVzc2lvblF1YWxpdHkgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gaW5saW5lZFJlcXVlc3RUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVxdWVzdCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbnRlbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb250ZW50cyddKTtcbiAgICBpZiAoZnJvbUNvbnRlbnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRDb250ZW50cyhmcm9tQ29udGVudHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRUb01sZGV2JDQoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXF1ZXN0JywgJ2NvbnRlbnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWV0YWRhdGEnXSk7XG4gICAgaWYgKGZyb21NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21ldGFkYXRhJ10sIGZyb21NZXRhZGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JlcXVlc3QnLCAnZ2VuZXJhdGlvbkNvbmZpZyddLCBnZW5lcmF0ZUNvbnRlbnRDb25maWdUb01sZGV2JDEoYXBpQ2xpZW50LCBmcm9tQ29uZmlnLCBnZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXF1ZXN0J10sIHt9KSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBpbmxpbmVkUmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNwb25zZSddKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2UnXSwgZ2VuZXJhdGVDb250ZW50UmVzcG9uc2VGcm9tTWxkZXYkMShmcm9tUmVzcG9uc2UpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVycm9yID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlcnJvciddKTtcbiAgICBpZiAoZnJvbUVycm9yICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXJyb3InXSwgZnJvbUVycm9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdEJhdGNoSm9ic0NvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFnZVNpemUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VTaXplJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVNpemUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VTaXplJ10sIGZyb21QYWdlU2l6ZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VUb2tlbiddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVRva2VuJ10sIGZyb21QYWdlVG9rZW4pO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWx0ZXInXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpbHRlciBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0QmF0Y2hKb2JzQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFnZVNpemUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VTaXplJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVNpemUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VTaXplJ10sIGZyb21QYWdlU2l6ZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VUb2tlbiddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVRva2VuJ10sIGZyb21QYWdlVG9rZW4pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsdGVyID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWx0ZXInXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21GaWx0ZXIgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ2ZpbHRlciddLCBmcm9tRmlsdGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdEJhdGNoSm9ic1BhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGxpc3RCYXRjaEpvYnNDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdEJhdGNoSm9ic1BhcmFtZXRlcnNUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBsaXN0QmF0Y2hKb2JzQ29uZmlnVG9WZXJ0ZXgoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0QmF0Y2hKb2JzUmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OZXh0UGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbmV4dFBhZ2VUb2tlbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21OZXh0UGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmV4dFBhZ2VUb2tlbiddLCBmcm9tTmV4dFBhZ2VUb2tlbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21CYXRjaEpvYnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ29wZXJhdGlvbnMnXSk7XG4gICAgaWYgKGZyb21CYXRjaEpvYnMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUJhdGNoSm9icztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBiYXRjaEpvYkZyb21NbGRldihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2JhdGNoSm9icyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0QmF0Y2hKb2JzUmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmV4dFBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ25leHRQYWdlVG9rZW4nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTmV4dFBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25leHRQYWdlVG9rZW4nXSwgZnJvbU5leHRQYWdlVG9rZW4pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQmF0Y2hKb2JzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYmF0Y2hQcmVkaWN0aW9uSm9icycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21CYXRjaEpvYnMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUJhdGNoSm9icztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBiYXRjaEpvYkZyb21WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydiYXRjaEpvYnMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcGFydFRvTWxkZXYkNChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTWVkaWFSZXNvbHV0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWVkaWFSZXNvbHV0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1lZGlhUmVzb2x1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21lZGlhUmVzb2x1dGlvbiddLCBmcm9tTWVkaWFSZXNvbHV0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb2RlRXhlY3V0aW9uUmVzdWx0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb2RlRXhlY3V0aW9uUmVzdWx0J10sIGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4ZWN1dGFibGVDb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZXhlY3V0YWJsZUNvZGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRXhlY3V0YWJsZUNvZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleGVjdXRhYmxlQ29kZSddLCBmcm9tRXhlY3V0YWJsZUNvZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVEYXRhJ10pO1xuICAgIGlmIChmcm9tRmlsZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlRGF0YSddLCBmaWxlRGF0YVRvTWxkZXYkNChmcm9tRmlsZURhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uQ2FsbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZnVuY3Rpb25DYWxsJ10pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25DYWxsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25DYWxsJ10sIGZ1bmN0aW9uQ2FsbFRvTWxkZXYkNChmcm9tRnVuY3Rpb25DYWxsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvblJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25SZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvblJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25SZXNwb25zZSddLCBmcm9tRnVuY3Rpb25SZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmxpbmVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbmxpbmVEYXRhJ10pO1xuICAgIGlmIChmcm9tSW5saW5lRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lubGluZURhdGEnXSwgYmxvYlRvTWxkZXYkNChmcm9tSW5saW5lRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGV4dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGV4dCddKTtcbiAgICBpZiAoZnJvbVRleHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZXh0J10sIGZyb21UZXh0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rob3VnaHQnXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhvdWdodCddLCBmcm9tVGhvdWdodCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaG91Z2h0U2lnbmF0dXJlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGhvdWdodFNpZ25hdHVyZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0U2lnbmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhvdWdodFNpZ25hdHVyZSddLCBmcm9tVGhvdWdodFNpZ25hdHVyZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21WaWRlb01ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndmlkZW9NZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21WaWRlb01ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW9NZXRhZGF0YSddLCBmcm9tVmlkZW9NZXRhZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNhZmV0eVNldHRpbmdUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNhdGVnb3J5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjYXRlZ29yeSddKTtcbiAgICBpZiAoZnJvbUNhdGVnb3J5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2F0ZWdvcnknXSwgZnJvbUNhdGVnb3J5KTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWV0aG9kJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtZXRob2QgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRocmVzaG9sZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGhyZXNob2xkJ10pO1xuICAgIGlmIChmcm9tVGhyZXNob2xkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhyZXNob2xkJ10sIGZyb21UaHJlc2hvbGQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0b29sQ29uZmlnVG9NbGRldiQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GdW5jdGlvbkNhbGxpbmdDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvbkNhbGxpbmdDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25DYWxsaW5nQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25DYWxsaW5nQ29uZmlnJ10sIGZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ1RvTWxkZXYkMihmcm9tRnVuY3Rpb25DYWxsaW5nQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXRyaWV2YWxDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXRyaWV2YWxDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmV0cmlldmFsQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmV0cmlldmFsQ29uZmlnJ10sIGZyb21SZXRyaWV2YWxDb25maWcpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0b29sVG9NbGRldiQ0KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25EZWNsYXJhdGlvbnMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmV0cmlldmFsJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXRyaWV2YWwgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2hSZXRyaWV2YWwnXSwgZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db21wdXRlclVzZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29tcHV0ZXJVc2UnXSk7XG4gICAgaWYgKGZyb21Db21wdXRlclVzZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbXB1dGVyVXNlJ10sIGZyb21Db21wdXRlclVzZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlU2VhcmNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlU2VhcmNoJ10pO1xuICAgIGlmIChmcm9tRmlsZVNlYXJjaCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVTZWFyY2gnXSwgZnJvbUZpbGVTZWFyY2gpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb24nXSwgZnJvbUNvZGVFeGVjdXRpb24pO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbnRlcnByaXNlV2ViU2VhcmNoJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlbnRlcnByaXNlV2ViU2VhcmNoIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVNYXBzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVNYXBzJ10pO1xuICAgIGlmIChmcm9tR29vZ2xlTWFwcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZU1hcHMnXSwgZ29vZ2xlTWFwc1RvTWxkZXYkNChmcm9tR29vZ2xlTWFwcykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVTZWFyY2gnXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2ggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2gnXSwgZ29vZ2xlU2VhcmNoVG9NbGRldiQ0KGZyb21Hb29nbGVTZWFyY2gpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVybENvbnRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VybENvbnRleHQnXSk7XG4gICAgaWYgKGZyb21VcmxDb250ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJsQ29udGV4dCddLCBmcm9tVXJsQ29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xudmFyIFBhZ2VkSXRlbTtcbihmdW5jdGlvbiAoUGFnZWRJdGVtKSB7XG4gICAgUGFnZWRJdGVtW1wiUEFHRURfSVRFTV9CQVRDSF9KT0JTXCJdID0gXCJiYXRjaEpvYnNcIjtcbiAgICBQYWdlZEl0ZW1bXCJQQUdFRF9JVEVNX01PREVMU1wiXSA9IFwibW9kZWxzXCI7XG4gICAgUGFnZWRJdGVtW1wiUEFHRURfSVRFTV9UVU5JTkdfSk9CU1wiXSA9IFwidHVuaW5nSm9ic1wiO1xuICAgIFBhZ2VkSXRlbVtcIlBBR0VEX0lURU1fRklMRVNcIl0gPSBcImZpbGVzXCI7XG4gICAgUGFnZWRJdGVtW1wiUEFHRURfSVRFTV9DQUNIRURfQ09OVEVOVFNcIl0gPSBcImNhY2hlZENvbnRlbnRzXCI7XG4gICAgUGFnZWRJdGVtW1wiUEFHRURfSVRFTV9GSUxFX1NFQVJDSF9TVE9SRVNcIl0gPSBcImZpbGVTZWFyY2hTdG9yZXNcIjtcbiAgICBQYWdlZEl0ZW1bXCJQQUdFRF9JVEVNX0RPQ1VNRU5UU1wiXSA9IFwiZG9jdW1lbnRzXCI7XG59KShQYWdlZEl0ZW0gfHwgKFBhZ2VkSXRlbSA9IHt9KSk7XG4vKipcbiAqIFBhZ2VyIGNsYXNzIGZvciBpdGVyYXRpbmcgdGhyb3VnaCBwYWdpbmF0ZWQgcmVzdWx0cy5cbiAqL1xuY2xhc3MgUGFnZXIge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHJlcXVlc3QsIHJlc3BvbnNlLCBwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5wYWdlSW50ZXJuYWwgPSBbXTtcbiAgICAgICAgdGhpcy5wYXJhbXNJbnRlcm5hbCA9IHt9O1xuICAgICAgICB0aGlzLnJlcXVlc3RJbnRlcm5hbCA9IHJlcXVlc3Q7XG4gICAgICAgIHRoaXMuaW5pdChuYW1lLCByZXNwb25zZSwgcGFyYW1zKTtcbiAgICB9XG4gICAgaW5pdChuYW1lLCByZXNwb25zZSwgcGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHRoaXMubmFtZUludGVybmFsID0gbmFtZTtcbiAgICAgICAgdGhpcy5wYWdlSW50ZXJuYWwgPSByZXNwb25zZVt0aGlzLm5hbWVJbnRlcm5hbF0gfHwgW107XG4gICAgICAgIHRoaXMuc2RrSHR0cFJlc3BvbnNlSW50ZXJuYWwgPSByZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlO1xuICAgICAgICB0aGlzLmlkeEludGVybmFsID0gMDtcbiAgICAgICAgbGV0IHJlcXVlc3RQYXJhbXMgPSB7IGNvbmZpZzoge30gfTtcbiAgICAgICAgaWYgKCFwYXJhbXMgfHwgT2JqZWN0LmtleXMocGFyYW1zKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJlcXVlc3RQYXJhbXMgPSB7IGNvbmZpZzoge30gfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgcGFyYW1zID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmVxdWVzdFBhcmFtcyA9IE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXF1ZXN0UGFyYW1zID0gcGFyYW1zO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXF1ZXN0UGFyYW1zWydjb25maWcnXSkge1xuICAgICAgICAgICAgcmVxdWVzdFBhcmFtc1snY29uZmlnJ11bJ3BhZ2VUb2tlbiddID0gcmVzcG9uc2VbJ25leHRQYWdlVG9rZW4nXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcmFtc0ludGVybmFsID0gcmVxdWVzdFBhcmFtcztcbiAgICAgICAgdGhpcy5wYWdlSW50ZXJuYWxTaXplID1cbiAgICAgICAgICAgIChfYiA9IChfYSA9IHJlcXVlc3RQYXJhbXNbJ2NvbmZpZyddKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbJ3BhZ2VTaXplJ10pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRoaXMucGFnZUludGVybmFsLmxlbmd0aDtcbiAgICB9XG4gICAgaW5pdE5leHRQYWdlKHJlc3BvbnNlKSB7XG4gICAgICAgIHRoaXMuaW5pdCh0aGlzLm5hbWVJbnRlcm5hbCwgcmVzcG9uc2UsIHRoaXMucGFyYW1zSW50ZXJuYWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHBhZ2UsIHdoaWNoIGlzIGEgbGlzdCBvZiBpdGVtcy5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVGhlIGZpcnN0IHBhZ2UgaXMgcmV0cmlldmVkIHdoZW4gdGhlIHBhZ2VyIGlzIGNyZWF0ZWQuIFRoZSByZXR1cm5lZCBsaXN0IG9mXG4gICAgICogaXRlbXMgY291bGQgYmUgYSBzdWJzZXQgb2YgdGhlIGVudGlyZSBsaXN0LlxuICAgICAqL1xuICAgIGdldCBwYWdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYWdlSW50ZXJuYWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHR5cGUgb2YgcGFnZWQgaXRlbSAoZm9yIGV4YW1wbGUsIGBgYmF0Y2hfam9ic2BgKS5cbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZUludGVybmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIHBhZ2UgZmV0Y2hlZCBlYWNoIHRpbWUgYnkgdGhpcyBwYWdlci5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVGhlIG51bWJlciBvZiBpdGVtcyBpbiB0aGUgcGFnZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHBhZ2UgbGVuZ3RoLlxuICAgICAqL1xuICAgIGdldCBwYWdlU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFnZUludGVybmFsU2l6ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaGVhZGVycyBvZiB0aGUgQVBJIHJlc3BvbnNlLlxuICAgICAqL1xuICAgIGdldCBzZGtIdHRwUmVzcG9uc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNka0h0dHBSZXNwb25zZUludGVybmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwYXJhbWV0ZXJzIHdoZW4gbWFraW5nIHRoZSBBUEkgcmVxdWVzdCBmb3IgdGhlIG5leHQgcGFnZS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogUGFyYW1ldGVycyBjb250YWluIGEgc2V0IG9mIG9wdGlvbmFsIGNvbmZpZ3MgdGhhdCBjYW4gYmVcbiAgICAgKiB1c2VkIHRvIGN1c3RvbWl6ZSB0aGUgQVBJIHJlcXVlc3QuIEZvciBleGFtcGxlLCB0aGUgYHBhZ2VUb2tlbmAgcGFyYW1ldGVyXG4gICAgICogY29udGFpbnMgdGhlIHRva2VuIHRvIHJlcXVlc3QgdGhlIG5leHQgcGFnZS5cbiAgICAgKi9cbiAgICBnZXQgcGFyYW1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJhbXNJbnRlcm5hbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdG90YWwgbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBjdXJyZW50IHBhZ2UuXG4gICAgICovXG4gICAgZ2V0IHBhZ2VMZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhZ2VJbnRlcm5hbC5sZW5ndGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGl0ZW0gYXQgdGhlIGdpdmVuIGluZGV4LlxuICAgICAqL1xuICAgIGdldEl0ZW0oaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFnZUludGVybmFsW2luZGV4XTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhc3luYyBpdGVyYXRvciB0aGF0IHN1cHBvcnQgaXRlcmF0aW5nIHRocm91Z2ggYWxsIGl0ZW1zXG4gICAgICogcmV0cmlldmVkIGZyb20gdGhlIEFQSS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVGhlIGl0ZXJhdG9yIHdpbGwgYXV0b21hdGljYWxseSBmZXRjaCB0aGUgbmV4dCBwYWdlIGlmIHRoZXJlIGFyZSBtb3JlIGl0ZW1zXG4gICAgICogdG8gZmV0Y2ggZnJvbSB0aGUgQVBJLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgcGFnZXIgPSBhd2FpdCBhaS5maWxlcy5saXN0KHtjb25maWc6IHtwYWdlU2l6ZTogMTB9fSk7XG4gICAgICogZm9yIGF3YWl0IChjb25zdCBmaWxlIG9mIHBhZ2VyKSB7XG4gICAgICogICBjb25zb2xlLmxvZyhmaWxlLm5hbWUpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmV4dDogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkeEludGVybmFsID49IHRoaXMucGFnZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNOZXh0UGFnZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLm5leHRQYWdlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuZ2V0SXRlbSh0aGlzLmlkeEludGVybmFsKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkeEludGVybmFsICs9IDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGl0ZW0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmV0dXJuOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyB0aGUgbmV4dCBwYWdlIG9mIGl0ZW1zLiBUaGlzIG1ha2VzIGEgbmV3IEFQSSByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZXJlIGFyZSBubyBtb3JlIHBhZ2VzIHRvIGZldGNoLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgcGFnZXIgPSBhd2FpdCBhaS5maWxlcy5saXN0KHtjb25maWc6IHtwYWdlU2l6ZTogMTB9fSk7XG4gICAgICogbGV0IHBhZ2UgPSBwYWdlci5wYWdlO1xuICAgICAqIHdoaWxlICh0cnVlKSB7XG4gICAgICogICBmb3IgKGNvbnN0IGZpbGUgb2YgcGFnZSkge1xuICAgICAqICAgICBjb25zb2xlLmxvZyhmaWxlLm5hbWUpO1xuICAgICAqICAgfVxuICAgICAqICAgaWYgKCFwYWdlci5oYXNOZXh0UGFnZSgpKSB7XG4gICAgICogICAgIGJyZWFrO1xuICAgICAqICAgfVxuICAgICAqICAgcGFnZSA9IGF3YWl0IHBhZ2VyLm5leHRQYWdlKCk7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIG5leHRQYWdlKCkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzTmV4dFBhZ2UoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBtb3JlIHBhZ2VzIHRvIGZldGNoLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5yZXF1ZXN0SW50ZXJuYWwodGhpcy5wYXJhbXMpO1xuICAgICAgICB0aGlzLmluaXROZXh0UGFnZShyZXNwb25zZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhZ2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGVyZSBhcmUgbW9yZSBwYWdlcyB0byBmZXRjaCBmcm9tIHRoZSBBUEkuXG4gICAgICovXG4gICAgaGFzTmV4dFBhZ2UoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCgoX2EgPSB0aGlzLnBhcmFtc1snY29uZmlnJ10pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVsncGFnZVRva2VuJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmNsYXNzIEJhdGNoZXMgZXh0ZW5kcyBCYXNlTW9kdWxlIHtcbiAgICBjb25zdHJ1Y3RvcihhcGlDbGllbnQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBhcGlDbGllbnQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYmF0Y2ggam9iLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIGNyZWF0ZSBiYXRjaCBqb2IgcmVxdWVzdC5cbiAgICAgICAgICogQHJldHVybiBUaGUgY3JlYXRlZCBiYXRjaCBqb2IuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkuYmF0Y2hlcy5jcmVhdGUoe1xuICAgICAgICAgKiAgIG1vZGVsOiAnZ2VtaW5pLTIuMC1mbGFzaCcsXG4gICAgICAgICAqICAgc3JjOiB7Z2NzVXJpOiAnZ3M6Ly9idWNrZXQvcGF0aC90by9maWxlLmpzb25sJywgZm9ybWF0OiAnanNvbmwnfSxcbiAgICAgICAgICogICBjb25maWc6IHtcbiAgICAgICAgICogICAgIGRlc3Q6IHtnY3NVcmk6ICdnczovL2J1Y2tldC9wYXRoL291dHB1dC9kaXJlY3RvcnknLCBmb3JtYXQ6ICdqc29ubCd9LFxuICAgICAgICAgKiAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlKTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNyZWF0ZSA9IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBGb3JtYXQgZGVzdGluYXRpb24gaWYgbm90IHByb3ZpZGVkXG4gICAgICAgICAgICAgICAgLy8gQ2FzdCBwYXJhbXMuc3JjIGFzIFZlcnRleCBBSSBwYXRoIGRvZXMgbm90IGhhbmRsZSBJbmxpbmVkUmVxdWVzdFtdXG4gICAgICAgICAgICAgICAgcGFyYW1zLmNvbmZpZyA9IHRoaXMuZm9ybWF0RGVzdGluYXRpb24ocGFyYW1zLnNyYywgcGFyYW1zLmNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVJbnRlcm5hbChwYXJhbXMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogKipFeHBlcmltZW50YWwqKiBDcmVhdGVzIGFuIGVtYmVkZGluZyBiYXRjaCBqb2IuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgY3JlYXRlIGVtYmVkZGluZyBiYXRjaCBqb2IgcmVxdWVzdC5cbiAgICAgICAgICogQHJldHVybiBUaGUgY3JlYXRlZCBiYXRjaCBqb2IuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkuYmF0Y2hlcy5jcmVhdGVFbWJlZGRpbmdzKHtcbiAgICAgICAgICogICBtb2RlbDogJ3RleHQtZW1iZWRkaW5nLTAwNCcsXG4gICAgICAgICAqICAgc3JjOiB7ZmlsZU5hbWU6ICdmaWxlcy9teV9lbWJlZGRpbmdfaW5wdXQnfSxcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlKTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNyZWF0ZUVtYmVkZGluZ3MgPSBhc3luYyAocGFyYW1zKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ2JhdGNoZXMuY3JlYXRlRW1iZWRkaW5ncygpIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZSB3aXRob3V0IG5vdGljZS4nKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZlcnRleCBBSSBkb2VzIG5vdCBzdXBwb3J0IGJhdGNoZXMuY3JlYXRlRW1iZWRkaW5ncy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVtYmVkZGluZ3NJbnRlcm5hbChwYXJhbXMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdHMgYmF0Y2ggam9iIGNvbmZpZ3VyYXRpb25zLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBsaXN0IHJlcXVlc3QuXG4gICAgICAgICAqIEByZXR1cm4gVGhlIHBhZ2luYXRlZCByZXN1bHRzIG9mIHRoZSBsaXN0IG9mIGJhdGNoIGpvYnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIGNvbnN0IGJhdGNoSm9icyA9IGF3YWl0IGFpLmJhdGNoZXMubGlzdCh7Y29uZmlnOiB7J3BhZ2VTaXplJzogMn19KTtcbiAgICAgICAgICogZm9yIGF3YWl0IChjb25zdCBiYXRjaEpvYiBvZiBiYXRjaEpvYnMpIHtcbiAgICAgICAgICogICBjb25zb2xlLmxvZyhiYXRjaEpvYik7XG4gICAgICAgICAqIH1cbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxpc3QgPSBhc3luYyAocGFyYW1zID0ge30pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGFnZXIoUGFnZWRJdGVtLlBBR0VEX0lURU1fQkFUQ0hfSk9CUywgKHgpID0+IHRoaXMubGlzdEludGVybmFsKHgpLCBhd2FpdCB0aGlzLmxpc3RJbnRlcm5hbChwYXJhbXMpLCBwYXJhbXMpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gaGFuZGxlIGlubGluZWQgZ2VuZXJhdGUgY29udGVudCByZXF1ZXN0c1xuICAgIGNyZWF0ZUlubGluZWRHZW5lcmF0ZUNvbnRlbnRSZXF1ZXN0KHBhcmFtcykge1xuICAgICAgICBjb25zdCBib2R5ID0gY3JlYXRlQmF0Y2hKb2JQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgLy8gVXNlIGluc3RhbmNlIGFwaUNsaWVudFxuICAgICAgICBwYXJhbXMpO1xuICAgICAgICBjb25zdCB1cmxQYXJhbXMgPSBib2R5WydfdXJsJ107XG4gICAgICAgIGNvbnN0IHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06YmF0Y2hHZW5lcmF0ZUNvbnRlbnQnLCB1cmxQYXJhbXMpO1xuICAgICAgICBjb25zdCBiYXRjaCA9IGJvZHlbJ2JhdGNoJ107XG4gICAgICAgIGNvbnN0IGlucHV0Q29uZmlnID0gYmF0Y2hbJ2lucHV0Q29uZmlnJ107XG4gICAgICAgIGNvbnN0IHJlcXVlc3RzV3JhcHBlciA9IGlucHV0Q29uZmlnWydyZXF1ZXN0cyddO1xuICAgICAgICBjb25zdCByZXF1ZXN0cyA9IHJlcXVlc3RzV3JhcHBlclsncmVxdWVzdHMnXTtcbiAgICAgICAgY29uc3QgbmV3UmVxdWVzdHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCByZXF1ZXN0IG9mIHJlcXVlc3RzKSB7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0RGljdCA9IE9iamVjdC5hc3NpZ24oe30sIHJlcXVlc3QpOyAvLyBDbG9uZVxuICAgICAgICAgICAgaWYgKHJlcXVlc3REaWN0WydzeXN0ZW1JbnN0cnVjdGlvbiddKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3lzdGVtSW5zdHJ1Y3Rpb25WYWx1ZSA9IHJlcXVlc3REaWN0WydzeXN0ZW1JbnN0cnVjdGlvbiddO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0RGljdFsnc3lzdGVtSW5zdHJ1Y3Rpb24nXTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0Q29udGVudCA9IHJlcXVlc3REaWN0WydyZXF1ZXN0J107XG4gICAgICAgICAgICAgICAgcmVxdWVzdENvbnRlbnRbJ3N5c3RlbUluc3RydWN0aW9uJ10gPSBzeXN0ZW1JbnN0cnVjdGlvblZhbHVlO1xuICAgICAgICAgICAgICAgIHJlcXVlc3REaWN0WydyZXF1ZXN0J10gPSByZXF1ZXN0Q29udGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld1JlcXVlc3RzLnB1c2gocmVxdWVzdERpY3QpO1xuICAgICAgICB9XG4gICAgICAgIHJlcXVlc3RzV3JhcHBlclsncmVxdWVzdHMnXSA9IG5ld1JlcXVlc3RzO1xuICAgICAgICBkZWxldGUgYm9keVsnY29uZmlnJ107XG4gICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgcmV0dXJuIHsgcGF0aCwgYm9keSB9O1xuICAgIH1cbiAgICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBmaXJzdCBHQ1MgVVJJXG4gICAgZ2V0R2NzVXJpKHNyYykge1xuICAgICAgICBpZiAodHlwZW9mIHNyYyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBzcmMuc3RhcnRzV2l0aCgnZ3M6Ly8nKSA/IHNyYyA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc3JjKSAmJiBzcmMuZ2NzVXJpICYmIHNyYy5nY3NVcmkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHNyYy5nY3NVcmlbMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgQmlnUXVlcnkgVVJJXG4gICAgZ2V0QmlncXVlcnlVcmkoc3JjKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3JjID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHNyYy5zdGFydHNXaXRoKCdicTovLycpID8gc3JjIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzcmMpKSB7XG4gICAgICAgICAgICByZXR1cm4gc3JjLmJpZ3F1ZXJ5VXJpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vIEZ1bmN0aW9uIHRvIGZvcm1hdCB0aGUgZGVzdGluYXRpb24gY29uZmlndXJhdGlvbiBmb3IgVmVydGV4IEFJXG4gICAgZm9ybWF0RGVzdGluYXRpb24oc3JjLCBjb25maWcpIHtcbiAgICAgICAgY29uc3QgbmV3Q29uZmlnID0gY29uZmlnID8gT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnKSA6IHt9O1xuICAgICAgICBjb25zdCB0aW1lc3RhbXBTdHIgPSBEYXRlLm5vdygpLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmICghbmV3Q29uZmlnLmRpc3BsYXlOYW1lKSB7XG4gICAgICAgICAgICBuZXdDb25maWcuZGlzcGxheU5hbWUgPSBgZ2VuYWlCYXRjaEpvYl8ke3RpbWVzdGFtcFN0cn1gO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdDb25maWcuZGVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBnY3NVcmkgPSB0aGlzLmdldEdjc1VyaShzcmMpO1xuICAgICAgICAgICAgY29uc3QgYmlncXVlcnlVcmkgPSB0aGlzLmdldEJpZ3F1ZXJ5VXJpKHNyYyk7XG4gICAgICAgICAgICBpZiAoZ2NzVXJpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdjc1VyaS5lbmRzV2l0aCgnLmpzb25sJykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIC5qc29ubCBmaWxlcywgcmVtb3ZlIHN1ZmZpeCBhbmQgYWRkIC9kZXN0XG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbmZpZy5kZXN0ID0gYCR7Z2NzVXJpLnNsaWNlKDAsIC02KX0vZGVzdGA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBGYWxsYmFjayBmb3Igb3RoZXIgR0NTIFVSSXNcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29uZmlnLmRlc3QgPSBgJHtnY3NVcml9X2Rlc3RfJHt0aW1lc3RhbXBTdHJ9YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiaWdxdWVyeVVyaSkge1xuICAgICAgICAgICAgICAgIG5ld0NvbmZpZy5kZXN0ID0gYCR7YmlncXVlcnlVcml9X2Rlc3RfJHt0aW1lc3RhbXBTdHJ9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgc291cmNlIGZvciBWZXJ0ZXggQUk6IE5vIEdDUyBvciBCaWdRdWVyeSBVUkkgZm91bmQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0NvbmZpZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgbWV0aG9kIHRvIGNyZWF0ZSBiYXRjaCBqb2IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIGNyZWF0ZSBiYXRjaCBqb2IgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIFRoZSBjcmVhdGVkIGJhdGNoIGpvYi5cbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBjcmVhdGVCYXRjaEpvYlBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2JhdGNoUHJlZGljdGlvbkpvYnMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGJhdGNoSm9iRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBjcmVhdGVCYXRjaEpvYlBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpiYXRjaEdlbmVyYXRlQ29udGVudCcsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gYmF0Y2hKb2JGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgbWV0aG9kIHRvIGNyZWF0ZSBiYXRjaCBqb2IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIGNyZWF0ZSBiYXRjaCBqb2IgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIFRoZSBjcmVhdGVkIGJhdGNoIGpvYi5cbiAgICAgKlxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUVtYmVkZGluZ3NJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgR2VtaW5pIERldmVsb3BlciBBUEkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gY3JlYXRlRW1iZWRkaW5nc0JhdGNoSm9iUGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OmFzeW5jQmF0Y2hFbWJlZENvbnRlbnQnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGJhdGNoSm9iRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYmF0Y2ggam9iIGNvbmZpZ3VyYXRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgZ2V0IHJlcXVlc3QuXG4gICAgICogQHJldHVybiBUaGUgYmF0Y2ggam9iLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGF3YWl0IGFpLmJhdGNoZXMuZ2V0KHtuYW1lOiAnLi4uJ30pOyAvLyBUaGUgc2VydmVyLWdlbmVyYXRlZCByZXNvdXJjZSBuYW1lLlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGdldChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2V0QmF0Y2hKb2JQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCdiYXRjaFByZWRpY3Rpb25Kb2JzL3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBiYXRjaEpvYkZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2V0QmF0Y2hKb2JQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2JhdGNoZXMve25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGJhdGNoSm9iRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbmNlbHMgYSBiYXRjaCBqb2IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBjYW5jZWwgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIFRoZSBlbXB0eSByZXNwb25zZSByZXR1cm5lZCBieSB0aGUgQVBJLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGF3YWl0IGFpLmJhdGNoZXMuY2FuY2VsKHtuYW1lOiAnLi4uJ30pOyAvLyBUaGUgc2VydmVyLWdlbmVyYXRlZCByZXNvdXJjZSBuYW1lLlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGNhbmNlbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGNhbmNlbEJhdGNoSm9iUGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnYmF0Y2hQcmVkaWN0aW9uSm9icy97bmFtZX06Y2FuY2VsJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5hcGlDbGllbnQucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGNhbmNlbEJhdGNoSm9iUGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCdiYXRjaGVzL3tuYW1lfTpjYW5jZWwnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFwaUNsaWVudC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgbGlzdEludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBsaXN0QmF0Y2hKb2JzUGFyYW1ldGVyc1RvVmVydGV4KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCdiYXRjaFByZWRpY3Rpb25Kb2JzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBsaXN0QmF0Y2hKb2JzUmVzcG9uc2VGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgTGlzdEJhdGNoSm9ic1Jlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBsaXN0QmF0Y2hKb2JzUGFyYW1ldGVyc1RvTWxkZXYocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2JhdGNoZXMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGxpc3RCYXRjaEpvYnNSZXNwb25zZUZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IExpc3RCYXRjaEpvYnNSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBhIGJhdGNoIGpvYi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIGRlbGV0ZSByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4gVGhlIGVtcHR5IHJlc3BvbnNlIHJldHVybmVkIGJ5IHRoZSBBUEkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogYXdhaXQgYWkuYmF0Y2hlcy5kZWxldGUoe25hbWU6ICcuLi4nfSk7IC8vIFRoZSBzZXJ2ZXItZ2VuZXJhdGVkIHJlc291cmNlIG5hbWUuXG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBkZWxldGVCYXRjaEpvYlBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2JhdGNoUHJlZGljdGlvbkpvYnMve25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBkZWxldGVSZXNvdXJjZUpvYkZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZGVsZXRlQmF0Y2hKb2JQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2JhdGNoZXMve25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBkZWxldGVSZXNvdXJjZUpvYkZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuZnVuY3Rpb24gYmxvYlRvTWxkZXYkMyhmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGF0YSddKTtcbiAgICBpZiAoZnJvbURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkYXRhJ10sIGZyb21EYXRhKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Rpc3BsYXlOYW1lIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbnRlbnRUb01sZGV2JDMoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhcnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXJ0cyddKTtcbiAgICBpZiAoZnJvbVBhcnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21QYXJ0cztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0VG9NbGRldiQzKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFydHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJvbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JvbGUnXSk7XG4gICAgaWYgKGZyb21Sb2xlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncm9sZSddLCBmcm9tUm9sZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlZENvbnRlbnRDb25maWdUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVR0bCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndHRsJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVHRsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3R0bCddLCBmcm9tVHRsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4cGlyZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2V4cGlyZVRpbWUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FeHBpcmVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2V4cGlyZVRpbWUnXSwgZnJvbUV4cGlyZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbnRlbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb250ZW50cyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUNvbnRlbnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRDb250ZW50cyhmcm9tQ29udGVudHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRUb01sZGV2JDMoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnY29udGVudHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN5c3RlbUluc3RydWN0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3lzdGVtSW5zdHJ1Y3Rpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc3lzdGVtSW5zdHJ1Y3Rpb24nXSwgY29udGVudFRvTWxkZXYkMyh0Q29udGVudChmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24pKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29scyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub29scyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tVG9vbHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9vbFRvTWxkZXYkMyhpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0b29scyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbENvbmZpZyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvb2xDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndG9vbENvbmZpZyddLCB0b29sQ29uZmlnVG9NbGRldiQxKGZyb21Ub29sQ29uZmlnKSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ttc0tleU5hbWUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ttc0tleU5hbWUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlQ2FjaGVkQ29udGVudENvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVR0bCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndHRsJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVHRsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3R0bCddLCBmcm9tVHRsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4cGlyZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2V4cGlyZVRpbWUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FeHBpcmVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2V4cGlyZVRpbWUnXSwgZnJvbUV4cGlyZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbnRlbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb250ZW50cyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUNvbnRlbnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRDb250ZW50cyhmcm9tQ29udGVudHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnY29udGVudHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN5c3RlbUluc3RydWN0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3lzdGVtSW5zdHJ1Y3Rpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc3lzdGVtSW5zdHJ1Y3Rpb24nXSwgdENvbnRlbnQoZnJvbVN5c3RlbUluc3RydWN0aW9uKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29scyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub29scyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tVG9vbHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9vbFRvVmVydGV4JDIoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndG9vbHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rvb2xDb25maWcnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub29sQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3Rvb2xDb25maWcnXSwgZnJvbVRvb2xDb25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tS21zS2V5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsna21zS2V5TmFtZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUttc0tleU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZW5jcnlwdGlvbl9zcGVjJywgJ2ttc0tleU5hbWUnXSwgZnJvbUttc0tleU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlbCddLCB0Q2FjaGVzTW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgY3JlYXRlQ2FjaGVkQ29udGVudENvbmZpZ1RvTWxkZXYoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZWwnXSwgdENhY2hlc01vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGNyZWF0ZUNhY2hlZENvbnRlbnRDb25maWdUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGRlbGV0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0Q2FjaGVkQ29udGVudE5hbWUoYXBpQ2xpZW50LCBmcm9tTmFtZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkZWxldGVDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIHRDYWNoZWRDb250ZW50TmFtZShhcGlDbGllbnQsIGZyb21OYW1lKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGRlbGV0ZUNhY2hlZENvbnRlbnRSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZGVsZXRlQ2FjaGVkQ29udGVudFJlc3BvbnNlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZmlsZURhdGFUb01sZGV2JDMoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Rpc3BsYXlOYW1lIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlVXJpJ10pO1xuICAgIGlmIChmcm9tRmlsZVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVVcmknXSwgZnJvbUZpbGVVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkNhbGxUb01sZGV2JDMoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUlkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpZCddKTtcbiAgICBpZiAoZnJvbUlkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaWQnXSwgZnJvbUlkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFyZ3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FyZ3MnXSk7XG4gICAgaWYgKGZyb21BcmdzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXJncyddLCBmcm9tQXJncyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXJ0aWFsQXJncyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFydGlhbEFyZ3MgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnd2lsbENvbnRpbnVlJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd3aWxsQ29udGludWUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25DYWxsaW5nQ29uZmlnVG9NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlJ10pO1xuICAgIGlmIChmcm9tTW9kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGUnXSwgZnJvbU1vZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQWxsb3dlZEZ1bmN0aW9uTmFtZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdhbGxvd2VkRnVuY3Rpb25OYW1lcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21BbGxvd2VkRnVuY3Rpb25OYW1lcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FsbG93ZWRGdW5jdGlvbk5hbWVzJ10sIGZyb21BbGxvd2VkRnVuY3Rpb25OYW1lcyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N0cmVhbUZ1bmN0aW9uQ2FsbEFyZ3VtZW50cyddKSAhPT1cbiAgICAgICAgdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc3RyZWFtRnVuY3Rpb25DYWxsQXJndW1lbnRzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uRGVjbGFyYXRpb25Ub1ZlcnRleCQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2JlaGF2aW9yJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiZWhhdmlvciBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzY3JpcHRpb24nXSk7XG4gICAgaWYgKGZyb21EZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10sIGZyb21EZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFyYW1ldGVycyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFyYW1ldGVycyddKTtcbiAgICBpZiAoZnJvbVBhcmFtZXRlcnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJhbWV0ZXJzJ10sIGZyb21QYXJhbWV0ZXJzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhcmFtZXRlcnNKc29uU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncGFyYW1ldGVyc0pzb25TY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUGFyYW1ldGVyc0pzb25TY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJhbWV0ZXJzSnNvblNjaGVtYSddLCBmcm9tUGFyYW1ldGVyc0pzb25TY2hlbWEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc3BvbnNlJ10pO1xuICAgIGlmIChmcm9tUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZSddLCBmcm9tUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VKc29uU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlSnNvblNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlSnNvblNjaGVtYSddLCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2V0Q2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIHRDYWNoZWRDb250ZW50TmFtZShhcGlDbGllbnQsIGZyb21OYW1lKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdldENhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgdENhY2hlZENvbnRlbnROYW1lKGFwaUNsaWVudCwgZnJvbU5hbWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ29vZ2xlTWFwc1RvTWxkZXYkMyhmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhdXRoQ29uZmlnJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhdXRoQ29uZmlnIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmFibGVXaWRnZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuYWJsZVdpZGdldCddKTtcbiAgICBpZiAoZnJvbUVuYWJsZVdpZGdldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuYWJsZVdpZGdldCddLCBmcm9tRW5hYmxlV2lkZ2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ29vZ2xlU2VhcmNoVG9NbGRldiQzKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2V4Y2x1ZGVEb21haW5zJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleGNsdWRlRG9tYWlucyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydibG9ja2luZ0NvbmZpZGVuY2UnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Jsb2NraW5nQ29uZmlkZW5jZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGltZVJhbmdlRmlsdGVyID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGltZVJhbmdlRmlsdGVyJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRpbWVSYW5nZUZpbHRlciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RpbWVSYW5nZUZpbHRlciddLCBmcm9tVGltZVJhbmdlRmlsdGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdENhY2hlZENvbnRlbnRzQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYWdlU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVNpemUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVNpemUnXSwgZnJvbVBhZ2VTaXplKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVRva2VuJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlVG9rZW4nXSwgZnJvbVBhZ2VUb2tlbik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RDYWNoZWRDb250ZW50c0NvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhZ2VTaXplID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlU2l6ZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VTaXplICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlU2l6ZSddLCBmcm9tUGFnZVNpemUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlVG9rZW4nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VUb2tlbiddLCBmcm9tUGFnZVRva2VuKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdENhY2hlZENvbnRlbnRzUGFyYW1ldGVyc1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgbGlzdENhY2hlZENvbnRlbnRzQ29uZmlnVG9NbGRldihmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RDYWNoZWRDb250ZW50c1BhcmFtZXRlcnNUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBsaXN0Q2FjaGVkQ29udGVudHNDb25maWdUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RDYWNoZWRDb250ZW50c1Jlc3BvbnNlRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmV4dFBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ25leHRQYWdlVG9rZW4nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTmV4dFBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25leHRQYWdlVG9rZW4nXSwgZnJvbU5leHRQYWdlVG9rZW4pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FjaGVkQ29udGVudHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYWNoZWRDb250ZW50cycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DYWNoZWRDb250ZW50cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tQ2FjaGVkQ29udGVudHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhY2hlZENvbnRlbnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RDYWNoZWRDb250ZW50c1Jlc3BvbnNlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5leHRQYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICduZXh0UGFnZVRva2VuJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU5leHRQYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduZXh0UGFnZVRva2VuJ10sIGZyb21OZXh0UGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNhY2hlZENvbnRlbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2FjaGVkQ29udGVudHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ2FjaGVkQ29udGVudHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUNhY2hlZENvbnRlbnRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYWNoZWRDb250ZW50cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBwYXJ0VG9NbGRldiQzKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21NZWRpYVJlc29sdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtZWRpYVJlc29sdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTWVkaWFSZXNvbHV0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWVkaWFSZXNvbHV0aW9uJ10sIGZyb21NZWRpYVJlc29sdXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb25SZXN1bHQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb25SZXN1bHQnXSwgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhlY3V0YWJsZUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdleGVjdXRhYmxlQ29kZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FeGVjdXRhYmxlQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4ZWN1dGFibGVDb2RlJ10sIGZyb21FeGVjdXRhYmxlQ29kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZURhdGEnXSk7XG4gICAgaWYgKGZyb21GaWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVEYXRhJ10sIGZpbGVEYXRhVG9NbGRldiQzKGZyb21GaWxlRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25DYWxsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmdW5jdGlvbkNhbGwnXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkNhbGwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkNhbGwnXSwgZnVuY3Rpb25DYWxsVG9NbGRldiQzKGZyb21GdW5jdGlvbkNhbGwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvblJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvblJlc3BvbnNlJ10sIGZyb21GdW5jdGlvblJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUlubGluZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lubGluZURhdGEnXSk7XG4gICAgaWYgKGZyb21JbmxpbmVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5saW5lRGF0YSddLCBibG9iVG9NbGRldiQzKGZyb21JbmxpbmVEYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZXh0J10pO1xuICAgIGlmIChmcm9tVGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RleHQnXSwgZnJvbVRleHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGhvdWdodCddKTtcbiAgICBpZiAoZnJvbVRob3VnaHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0J10sIGZyb21UaG91Z2h0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHRTaWduYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aG91Z2h0U2lnbmF0dXJlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRob3VnaHRTaWduYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0U2lnbmF0dXJlJ10sIGZyb21UaG91Z2h0U2lnbmF0dXJlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZpZGVvTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd2aWRlb01ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVZpZGVvTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlb01ldGFkYXRhJ10sIGZyb21WaWRlb01ldGFkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdG9vbENvbmZpZ1RvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnVuY3Rpb25DYWxsaW5nQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25DYWxsaW5nQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uQ2FsbGluZ0NvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbGluZ0NvbmZpZyddLCBmdW5jdGlvbkNhbGxpbmdDb25maWdUb01sZGV2JDEoZnJvbUZ1bmN0aW9uQ2FsbGluZ0NvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmV0cmlldmFsQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmV0cmlldmFsQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJldHJpZXZhbENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JldHJpZXZhbENvbmZpZyddLCBmcm9tUmV0cmlldmFsQ29uZmlnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdG9vbFRvTWxkZXYkMyhmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvbkRlY2xhcmF0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JldHJpZXZhbCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmV0cmlldmFsIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdnb29nbGVTZWFyY2hSZXRyaWV2YWwnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlU2VhcmNoUmV0cmlldmFsJ10sIGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29tcHV0ZXJVc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbXB1dGVyVXNlJ10pO1xuICAgIGlmIChmcm9tQ29tcHV0ZXJVc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb21wdXRlclVzZSddLCBmcm9tQ29tcHV0ZXJVc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZVNlYXJjaCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZVNlYXJjaCddKTtcbiAgICBpZiAoZnJvbUZpbGVTZWFyY2ggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlU2VhcmNoJ10sIGZyb21GaWxlU2VhcmNoKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGVFeGVjdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb2RlRXhlY3V0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNvZGVFeGVjdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb2RlRXhlY3V0aW9uJ10sIGZyb21Db2RlRXhlY3V0aW9uKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW50ZXJwcmlzZVdlYlNlYXJjaCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZW50ZXJwcmlzZVdlYlNlYXJjaCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlTWFwcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ29vZ2xlTWFwcyddKTtcbiAgICBpZiAoZnJvbUdvb2dsZU1hcHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVNYXBzJ10sIGdvb2dsZU1hcHNUb01sZGV2JDMoZnJvbUdvb2dsZU1hcHMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlYXJjaCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ29vZ2xlU2VhcmNoJ10pO1xuICAgIGlmIChmcm9tR29vZ2xlU2VhcmNoICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlU2VhcmNoJ10sIGdvb2dsZVNlYXJjaFRvTWxkZXYkMyhmcm9tR29vZ2xlU2VhcmNoKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcmxDb250ZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cmxDb250ZXh0J10pO1xuICAgIGlmIChmcm9tVXJsQ29udGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VybENvbnRleHQnXSwgZnJvbVVybENvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0b29sVG9WZXJ0ZXgkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvbkRlY2xhcmF0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb25EZWNsYXJhdGlvblRvVmVydGV4JDIoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkRlY2xhcmF0aW9ucyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmV0cmlldmFsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXRyaWV2YWwnXSk7XG4gICAgaWYgKGZyb21SZXRyaWV2YWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXRyaWV2YWwnXSwgZnJvbVJldHJpZXZhbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdnb29nbGVTZWFyY2hSZXRyaWV2YWwnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlU2VhcmNoUmV0cmlldmFsJ10sIGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29tcHV0ZXJVc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbXB1dGVyVXNlJ10pO1xuICAgIGlmIChmcm9tQ29tcHV0ZXJVc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb21wdXRlclVzZSddLCBmcm9tQ29tcHV0ZXJVc2UpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlU2VhcmNoJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaWxlU2VhcmNoIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGVFeGVjdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb2RlRXhlY3V0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNvZGVFeGVjdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb2RlRXhlY3V0aW9uJ10sIGZyb21Db2RlRXhlY3V0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVudGVycHJpc2VXZWJTZWFyY2ggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbnRlcnByaXNlV2ViU2VhcmNoJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUVudGVycHJpc2VXZWJTZWFyY2ggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbnRlcnByaXNlV2ViU2VhcmNoJ10sIGZyb21FbnRlcnByaXNlV2ViU2VhcmNoKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZU1hcHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvb2dsZU1hcHMnXSk7XG4gICAgaWYgKGZyb21Hb29nbGVNYXBzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlTWFwcyddLCBmcm9tR29vZ2xlTWFwcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVTZWFyY2ggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaCddKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaCddLCBmcm9tR29vZ2xlU2VhcmNoKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVybENvbnRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VybENvbnRleHQnXSk7XG4gICAgaWYgKGZyb21VcmxDb250ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJsQ29udGV4dCddLCBmcm9tVXJsQ29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUNhY2hlZENvbnRlbnRDb25maWdUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVR0bCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndHRsJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVHRsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3R0bCddLCBmcm9tVHRsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4cGlyZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2V4cGlyZVRpbWUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FeHBpcmVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2V4cGlyZVRpbWUnXSwgZnJvbUV4cGlyZVRpbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cGRhdGVDYWNoZWRDb250ZW50Q29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVHRsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0dGwnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UdGwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndHRsJ10sIGZyb21UdGwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhwaXJlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhwaXJlVGltZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUV4cGlyZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZXhwaXJlVGltZSddLCBmcm9tRXhwaXJlVGltZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0Q2FjaGVkQ29udGVudE5hbWUoYXBpQ2xpZW50LCBmcm9tTmFtZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICB1cGRhdGVDYWNoZWRDb250ZW50Q29uZmlnVG9NbGRldihmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgdENhY2hlZENvbnRlbnROYW1lKGFwaUNsaWVudCwgZnJvbU5hbWUpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgdXBkYXRlQ2FjaGVkQ29udGVudENvbmZpZ1RvVmVydGV4KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jbGFzcyBDYWNoZXMgZXh0ZW5kcyBCYXNlTW9kdWxlIHtcbiAgICBjb25zdHJ1Y3RvcihhcGlDbGllbnQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBhcGlDbGllbnQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0cyBjYWNoZWQgY29udGVudCBjb25maWd1cmF0aW9ucy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgbGlzdCByZXF1ZXN0LlxuICAgICAgICAgKiBAcmV0dXJuIFRoZSBwYWdpbmF0ZWQgcmVzdWx0cyBvZiB0aGUgbGlzdCBvZiBjYWNoZWQgY29udGVudHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIGNvbnN0IGNhY2hlZENvbnRlbnRzID0gYXdhaXQgYWkuY2FjaGVzLmxpc3Qoe2NvbmZpZzogeydwYWdlU2l6ZSc6IDJ9fSk7XG4gICAgICAgICAqIGZvciBhd2FpdCAoY29uc3QgY2FjaGVkQ29udGVudCBvZiBjYWNoZWRDb250ZW50cykge1xuICAgICAgICAgKiAgIGNvbnNvbGUubG9nKGNhY2hlZENvbnRlbnQpO1xuICAgICAgICAgKiB9XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5saXN0ID0gYXN5bmMgKHBhcmFtcyA9IHt9KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhZ2VyKFBhZ2VkSXRlbS5QQUdFRF9JVEVNX0NBQ0hFRF9DT05URU5UUywgKHgpID0+IHRoaXMubGlzdEludGVybmFsKHgpLCBhd2FpdCB0aGlzLmxpc3RJbnRlcm5hbChwYXJhbXMpLCBwYXJhbXMpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2FjaGVkIGNvbnRlbnRzIHJlc291cmNlLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBDb250ZXh0IGNhY2hpbmcgaXMgb25seSBzdXBwb3J0ZWQgZm9yIHNwZWNpZmljIG1vZGVscy4gU2VlIFtHZW1pbmlcbiAgICAgKiBEZXZlbG9wZXIgQVBJIHJlZmVyZW5jZV0oaHR0cHM6Ly9haS5nb29nbGUuZGV2L2dlbWluaS1hcGkvZG9jcy9jYWNoaW5nP2xhbmc9bm9kZS9jb250ZXh0LWNhYylcbiAgICAgKiBhbmQgW1ZlcnRleCBBSSByZWZlcmVuY2VdKGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS92ZXJ0ZXgtYWkvZ2VuZXJhdGl2ZS1haS9kb2NzL2NvbnRleHQtY2FjaGUvY29udGV4dC1jYWNoZS1vdmVydmlldyNzdXBwb3J0ZWRfbW9kZWxzKVxuICAgICAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgY3JlYXRlIHJlcXVlc3QuXG4gICAgICogQHJldHVybiBUaGUgY3JlYXRlZCBjYWNoZWQgY29udGVudC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBjb250ZW50cyA9IC4uLjsgLy8gSW5pdGlhbGl6ZSB0aGUgY29udGVudCB0byBjYWNoZS5cbiAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLmNhY2hlcy5jcmVhdGUoe1xuICAgICAqICAgbW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoLTAwMScsXG4gICAgICogICBjb25maWc6IHtcbiAgICAgKiAgICAnY29udGVudHMnOiBjb250ZW50cyxcbiAgICAgKiAgICAnZGlzcGxheU5hbWUnOiAndGVzdCBjYWNoZScsXG4gICAgICogICAgJ3N5c3RlbUluc3RydWN0aW9uJzogJ1doYXQgaXMgdGhlIHN1bSBvZiB0aGUgdHdvIHBkZnM/JyxcbiAgICAgKiAgICAndHRsJzogJzg2NDAwcycsXG4gICAgICogIH1cbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGUocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGNyZWF0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCdjYWNoZWRDb250ZW50cycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigocmVzcCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gY3JlYXRlQ2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnY2FjaGVkQ29udGVudHMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKHJlc3ApID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgY2FjaGVkIGNvbnRlbnQgY29uZmlndXJhdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBnZXQgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIFRoZSBjYWNoZWQgY29udGVudC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBhd2FpdCBhaS5jYWNoZXMuZ2V0KHtuYW1lOiAnLi4uJ30pOyAvLyBUaGUgc2VydmVyLWdlbmVyYXRlZCByZXNvdXJjZSBuYW1lLlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGdldChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2V0Q2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChyZXNwKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZXRDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigocmVzcCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBjYWNoZWQgY29udGVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIGRlbGV0ZSByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4gVGhlIGVtcHR5IHJlc3BvbnNlIHJldHVybmVkIGJ5IHRoZSBBUEkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogYXdhaXQgYWkuY2FjaGVzLmRlbGV0ZSh7bmFtZTogJy4uLid9KTsgLy8gVGhlIHNlcnZlci1nZW5lcmF0ZWQgcmVzb3VyY2UgbmFtZS5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGUocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGRlbGV0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGRlbGV0ZUNhY2hlZENvbnRlbnRSZXNwb25zZUZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBEZWxldGVDYWNoZWRDb250ZW50UmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGRlbGV0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZGVsZXRlQ2FjaGVkQ29udGVudFJlc3BvbnNlRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgRGVsZXRlQ2FjaGVkQ29udGVudFJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGNhY2hlZCBjb250ZW50IGNvbmZpZ3VyYXRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgdXBkYXRlIHJlcXVlc3QuXG4gICAgICogQHJldHVybiBUaGUgdXBkYXRlZCBjYWNoZWQgY29udGVudC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLmNhY2hlcy51cGRhdGUoe1xuICAgICAqICAgbmFtZTogJy4uLicsICAvLyBUaGUgc2VydmVyLWdlbmVyYXRlZCByZXNvdXJjZSBuYW1lLlxuICAgICAqICAgY29uZmlnOiB7J3R0bCc6ICc3NjAwcyd9XG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSB1cGRhdGVDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUEFUQ0gnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigocmVzcCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gdXBkYXRlQ2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUEFUQ0gnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigocmVzcCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgbGlzdEludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBsaXN0Q2FjaGVkQ29udGVudHNQYXJhbWV0ZXJzVG9WZXJ0ZXgocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2NhY2hlZENvbnRlbnRzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBsaXN0Q2FjaGVkQ29udGVudHNSZXNwb25zZUZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBMaXN0Q2FjaGVkQ29udGVudHNSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gbGlzdENhY2hlZENvbnRlbnRzUGFyYW1ldGVyc1RvTWxkZXYocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2NhY2hlZENvbnRlbnRzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBsaXN0Q2FjaGVkQ29udGVudHNSZXNwb25zZUZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IExpc3RDYWNoZWRDb250ZW50c1Jlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlLCBTdXBwcmVzc2VkRXJyb3IsIFN5bWJvbCwgSXRlcmF0b3IgKi9cclxuXHJcblxyXG5mdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgcmV0dXJuIGkgPSBPYmplY3QuY3JlYXRlKCh0eXBlb2YgQXN5bmNJdGVyYXRvciA9PT0gXCJmdW5jdGlvblwiID8gQXN5bmNJdGVyYXRvciA6IE9iamVjdCkucHJvdG90eXBlKSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiLCBhd2FpdFJldHVybiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIGF3YWl0UmV0dXJuKGYpIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUodikudGhlbihmLCByZWplY3QpOyB9OyB9XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaWYgKGdbbl0pIHsgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgaWYgKGYpIGlbbl0gPSBmKGlbbl0pOyB9IH1cclxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxyXG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xyXG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxyXG59XHJcblxyXG50eXBlb2YgU3VwcHJlc3NlZEVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IsIHN1cHByZXNzZWQsIG1lc3NhZ2UpIHtcclxuICAgIHZhciBlID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgcmV0dXJuIGUubmFtZSA9IFwiU3VwcHJlc3NlZEVycm9yXCIsIGUuZXJyb3IgPSBlcnJvciwgZS5zdXBwcmVzc2VkID0gc3VwcHJlc3NlZCwgZTtcclxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHJlc3BvbnNlIGlzIHZhbGlkLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRSZXNwb25zZShyZXNwb25zZSkge1xuICAgIHZhciBfYTtcbiAgICBpZiAocmVzcG9uc2UuY2FuZGlkYXRlcyA9PSB1bmRlZmluZWQgfHwgcmVzcG9uc2UuY2FuZGlkYXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBjb250ZW50ID0gKF9hID0gcmVzcG9uc2UuY2FuZGlkYXRlc1swXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbnRlbnQ7XG4gICAgaWYgKGNvbnRlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBpc1ZhbGlkQ29udGVudChjb250ZW50KTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRDb250ZW50KGNvbnRlbnQpIHtcbiAgICBpZiAoY29udGVudC5wYXJ0cyA9PT0gdW5kZWZpbmVkIHx8IGNvbnRlbnQucGFydHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBwYXJ0IG9mIGNvbnRlbnQucGFydHMpIHtcbiAgICAgICAgaWYgKHBhcnQgPT09IHVuZGVmaW5lZCB8fCBPYmplY3Qua2V5cyhwYXJ0KS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogVmFsaWRhdGVzIHRoZSBoaXN0b3J5IGNvbnRhaW5zIHRoZSBjb3JyZWN0IHJvbGVzLlxuICpcbiAqIEB0aHJvd3MgRXJyb3IgaWYgdGhlIGhpc3RvcnkgZG9lcyBub3Qgc3RhcnQgd2l0aCBhIHVzZXIgdHVybi5cbiAqIEB0aHJvd3MgRXJyb3IgaWYgdGhlIGhpc3RvcnkgY29udGFpbnMgYW4gaW52YWxpZCByb2xlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUhpc3RvcnkoaGlzdG9yeSkge1xuICAgIC8vIEVtcHR5IGhpc3RvcnkgaXMgdmFsaWQuXG4gICAgaWYgKGhpc3RvcnkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBjb250ZW50IG9mIGhpc3RvcnkpIHtcbiAgICAgICAgaWYgKGNvbnRlbnQucm9sZSAhPT0gJ3VzZXInICYmIGNvbnRlbnQucm9sZSAhPT0gJ21vZGVsJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSb2xlIG11c3QgYmUgdXNlciBvciBtb2RlbCwgYnV0IGdvdCAke2NvbnRlbnQucm9sZX0uYCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEV4dHJhY3RzIHRoZSBjdXJhdGVkICh2YWxpZCkgaGlzdG9yeSBmcm9tIGEgY29tcHJlaGVuc2l2ZSBoaXN0b3J5LlxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGUgbW9kZWwgbWF5IHNvbWV0aW1lcyBnZW5lcmF0ZSBpbnZhbGlkIG9yIGVtcHR5IGNvbnRlbnRzKGUuZy4sIGR1ZSB0byBzYWZ0eVxuICogZmlsdGVycyBvciByZWNpdGF0aW9uKS4gRXh0cmFjdGluZyB2YWxpZCB0dXJucyBmcm9tIHRoZSBoaXN0b3J5XG4gKiBlbnN1cmVzIHRoYXQgc3Vic2VxdWVudCByZXF1ZXN0cyBjb3VsZCBiZSBhY2NwZXRlZCBieSB0aGUgbW9kZWwuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RDdXJhdGVkSGlzdG9yeShjb21wcmVoZW5zaXZlSGlzdG9yeSkge1xuICAgIGlmIChjb21wcmVoZW5zaXZlSGlzdG9yeSA9PT0gdW5kZWZpbmVkIHx8IGNvbXByZWhlbnNpdmVIaXN0b3J5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IGN1cmF0ZWRIaXN0b3J5ID0gW107XG4gICAgY29uc3QgbGVuZ3RoID0gY29tcHJlaGVuc2l2ZUhpc3RvcnkubGVuZ3RoO1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgICAgICBpZiAoY29tcHJlaGVuc2l2ZUhpc3RvcnlbaV0ucm9sZSA9PT0gJ3VzZXInKSB7XG4gICAgICAgICAgICBjdXJhdGVkSGlzdG9yeS5wdXNoKGNvbXByZWhlbnNpdmVIaXN0b3J5W2ldKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG1vZGVsT3V0cHV0ID0gW107XG4gICAgICAgICAgICBsZXQgaXNWYWxpZCA9IHRydWU7XG4gICAgICAgICAgICB3aGlsZSAoaSA8IGxlbmd0aCAmJiBjb21wcmVoZW5zaXZlSGlzdG9yeVtpXS5yb2xlID09PSAnbW9kZWwnKSB7XG4gICAgICAgICAgICAgICAgbW9kZWxPdXRwdXQucHVzaChjb21wcmVoZW5zaXZlSGlzdG9yeVtpXSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzVmFsaWQgJiYgIWlzVmFsaWRDb250ZW50KGNvbXByZWhlbnNpdmVIaXN0b3J5W2ldKSkge1xuICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgY3VyYXRlZEhpc3RvcnkucHVzaCguLi5tb2RlbE91dHB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGxhc3QgdXNlciBpbnB1dCB3aGVuIG1vZGVsIGNvbnRlbnQgaXMgaW52YWxpZC5cbiAgICAgICAgICAgICAgICBjdXJhdGVkSGlzdG9yeS5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3VyYXRlZEhpc3Rvcnk7XG59XG4vKipcbiAqIEEgdXRpbGl0eSBjbGFzcyB0byBjcmVhdGUgYSBjaGF0IHNlc3Npb24uXG4gKi9cbmNsYXNzIENoYXRzIHtcbiAgICBjb25zdHJ1Y3Rvcihtb2RlbHNNb2R1bGUsIGFwaUNsaWVudCkge1xuICAgICAgICB0aGlzLm1vZGVsc01vZHVsZSA9IG1vZGVsc01vZHVsZTtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBhcGlDbGllbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgY2hhdCBzZXNzaW9uLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGUgY29uZmlnIGluIHRoZSBwYXJhbXMgd2lsbCBiZSB1c2VkIGZvciBhbGwgcmVxdWVzdHMgd2l0aGluIHRoZSBjaGF0XG4gICAgICogc2Vzc2lvbiB1bmxlc3Mgb3ZlcnJpZGRlbiBieSBhIHBlci1yZXF1ZXN0IGBjb25maWdgIGluXG4gICAgICogQHNlZSB7QGxpbmsgdHlwZXMuU2VuZE1lc3NhZ2VQYXJhbWV0ZXJzI2NvbmZpZ30uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gUGFyYW1ldGVycyBmb3IgY3JlYXRpbmcgYSBjaGF0IHNlc3Npb24uXG4gICAgICogQHJldHVybnMgQSBuZXcgY2hhdCBzZXNzaW9uLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IGNoYXQgPSBhaS5jaGF0cy5jcmVhdGUoe1xuICAgICAqICAgbW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoJ1xuICAgICAqICAgY29uZmlnOiB7XG4gICAgICogICAgIHRlbXBlcmF0dXJlOiAwLjUsXG4gICAgICogICAgIG1heE91dHB1dFRva2VuczogMTAyNCxcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBjcmVhdGUocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2hhdCh0aGlzLmFwaUNsaWVudCwgdGhpcy5tb2RlbHNNb2R1bGUsIHBhcmFtcy5tb2RlbCwgcGFyYW1zLmNvbmZpZywgXG4gICAgICAgIC8vIERlZXAgY29weSB0aGUgaGlzdG9yeSB0byBhdm9pZCBtdXRhdGluZyB0aGUgaGlzdG9yeSBvdXRzaWRlIG9mIHRoZVxuICAgICAgICAvLyBjaGF0IHNlc3Npb24uXG4gICAgICAgIHN0cnVjdHVyZWRDbG9uZShwYXJhbXMuaGlzdG9yeSkpO1xuICAgIH1cbn1cbi8qKlxuICogQ2hhdCBzZXNzaW9uIHRoYXQgZW5hYmxlcyBzZW5kaW5nIG1lc3NhZ2VzIHRvIHRoZSBtb2RlbCB3aXRoIHByZXZpb3VzXG4gKiBjb252ZXJzYXRpb24gY29udGV4dC5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhlIHNlc3Npb24gbWFpbnRhaW5zIGFsbCB0aGUgdHVybnMgYmV0d2VlbiB1c2VyIGFuZCBtb2RlbC5cbiAqL1xuY2xhc3MgQ2hhdCB7XG4gICAgY29uc3RydWN0b3IoYXBpQ2xpZW50LCBtb2RlbHNNb2R1bGUsIG1vZGVsLCBjb25maWcgPSB7fSwgaGlzdG9yeSA9IFtdKSB7XG4gICAgICAgIHRoaXMuYXBpQ2xpZW50ID0gYXBpQ2xpZW50O1xuICAgICAgICB0aGlzLm1vZGVsc01vZHVsZSA9IG1vZGVsc01vZHVsZTtcbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5oaXN0b3J5ID0gaGlzdG9yeTtcbiAgICAgICAgLy8gQSBwcm9taXNlIHRvIHJlcHJlc2VudCB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgbWVzc2FnZSBiZWluZyBzZW50IHRvIHRoZVxuICAgICAgICAvLyBtb2RlbC5cbiAgICAgICAgdGhpcy5zZW5kUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB2YWxpZGF0ZUhpc3RvcnkoaGlzdG9yeSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgbWVzc2FnZSB0byB0aGUgbW9kZWwgYW5kIHJldHVybnMgdGhlIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIHdhaXQgZm9yIHRoZSBwcmV2aW91cyBtZXNzYWdlIHRvIGJlIHByb2Nlc3NlZCBiZWZvcmVcbiAgICAgKiBzZW5kaW5nIHRoZSBuZXh0IG1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBDaGF0I3NlbmRNZXNzYWdlU3RyZWFtfSBmb3Igc3RyZWFtaW5nIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gcGFyYW1ldGVycyBmb3Igc2VuZGluZyBtZXNzYWdlcyB3aXRoaW4gYSBjaGF0IHNlc3Npb24uXG4gICAgICogQHJldHVybnMgVGhlIG1vZGVsJ3MgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgY2hhdCA9IGFpLmNoYXRzLmNyZWF0ZSh7bW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoJ30pO1xuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2hhdC5zZW5kTWVzc2FnZSh7XG4gICAgICogICBtZXNzYWdlOiAnV2h5IGlzIHRoZSBza3kgYmx1ZT8nXG4gICAgICogfSk7XG4gICAgICogY29uc29sZS5sb2cocmVzcG9uc2UudGV4dCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgc2VuZE1lc3NhZ2UocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kUHJvbWlzZTtcbiAgICAgICAgY29uc3QgaW5wdXRDb250ZW50ID0gdENvbnRlbnQocGFyYW1zLm1lc3NhZ2UpO1xuICAgICAgICBjb25zdCByZXNwb25zZVByb21pc2UgPSB0aGlzLm1vZGVsc01vZHVsZS5nZW5lcmF0ZUNvbnRlbnQoe1xuICAgICAgICAgICAgbW9kZWw6IHRoaXMubW9kZWwsXG4gICAgICAgICAgICBjb250ZW50czogdGhpcy5nZXRIaXN0b3J5KHRydWUpLmNvbmNhdChpbnB1dENvbnRlbnQpLFxuICAgICAgICAgICAgY29uZmlnOiAoX2EgPSBwYXJhbXMuY29uZmlnKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLmNvbmZpZyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2VuZFByb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlc3BvbnNlUHJvbWlzZTtcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dENvbnRlbnQgPSAoX2IgPSAoX2EgPSByZXNwb25zZS5jYW5kaWRhdGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jb250ZW50O1xuICAgICAgICAgICAgLy8gQmVjYXVzZSB0aGUgQUZDIGlucHV0IGNvbnRhaW5zIHRoZSBlbnRpcmUgY3VyYXRlZCBjaGF0IGhpc3RvcnkgaW5cbiAgICAgICAgICAgIC8vIGFkZGl0aW9uIHRvIHRoZSBuZXcgdXNlciBpbnB1dCwgd2UgbmVlZCB0byB0cnVuY2F0ZSB0aGUgQUZDIGhpc3RvcnlcbiAgICAgICAgICAgIC8vIHRvIGRlZHVwbGljYXRlIHRoZSBleGlzdGluZyBjaGF0IGhpc3RvcnkuXG4gICAgICAgICAgICBjb25zdCBmdWxsQXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeSA9IHJlc3BvbnNlLmF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZ0hpc3Rvcnk7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuZ2V0SGlzdG9yeSh0cnVlKS5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeSA9IFtdO1xuICAgICAgICAgICAgaWYgKGZ1bGxBdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmdIaXN0b3J5ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmdIaXN0b3J5ID1cbiAgICAgICAgICAgICAgICAgICAgKF9jID0gZnVsbEF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZ0hpc3Rvcnkuc2xpY2UoaW5kZXgpKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1vZGVsT3V0cHV0ID0gb3V0cHV0Q29udGVudCA/IFtvdXRwdXRDb250ZW50XSA6IFtdO1xuICAgICAgICAgICAgdGhpcy5yZWNvcmRIaXN0b3J5KGlucHV0Q29udGVudCwgbW9kZWxPdXRwdXQsIGF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZ0hpc3RvcnkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9KSgpO1xuICAgICAgICBhd2FpdCB0aGlzLnNlbmRQcm9taXNlLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgIC8vIFJlc2V0cyBzZW5kUHJvbWlzZSB0byBhdm9pZCBzdWJzZXF1ZW50IGNhbGxzIGZhaWxpbmdcbiAgICAgICAgICAgIHRoaXMuc2VuZFByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZVByb21pc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgbWVzc2FnZSB0byB0aGUgbW9kZWwgYW5kIHJldHVybnMgdGhlIHJlc3BvbnNlIGluIGNodW5rcy5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCB3YWl0IGZvciB0aGUgcHJldmlvdXMgbWVzc2FnZSB0byBiZSBwcm9jZXNzZWQgYmVmb3JlXG4gICAgICogc2VuZGluZyB0aGUgbmV4dCBtZXNzYWdlLlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgQ2hhdCNzZW5kTWVzc2FnZX0gZm9yIG5vbi1zdHJlYW1pbmcgbWV0aG9kLlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBwYXJhbWV0ZXJzIGZvciBzZW5kaW5nIHRoZSBtZXNzYWdlLlxuICAgICAqIEByZXR1cm4gVGhlIG1vZGVsJ3MgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgY2hhdCA9IGFpLmNoYXRzLmNyZWF0ZSh7bW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoJ30pO1xuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2hhdC5zZW5kTWVzc2FnZVN0cmVhbSh7XG4gICAgICogICBtZXNzYWdlOiAnV2h5IGlzIHRoZSBza3kgYmx1ZT8nXG4gICAgICogfSk7XG4gICAgICogZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiByZXNwb25zZSkge1xuICAgICAqICAgY29uc29sZS5sb2coY2h1bmsudGV4dCk7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIHNlbmRNZXNzYWdlU3RyZWFtKHBhcmFtcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZFByb21pc2U7XG4gICAgICAgIGNvbnN0IGlucHV0Q29udGVudCA9IHRDb250ZW50KHBhcmFtcy5tZXNzYWdlKTtcbiAgICAgICAgY29uc3Qgc3RyZWFtUmVzcG9uc2UgPSB0aGlzLm1vZGVsc01vZHVsZS5nZW5lcmF0ZUNvbnRlbnRTdHJlYW0oe1xuICAgICAgICAgICAgbW9kZWw6IHRoaXMubW9kZWwsXG4gICAgICAgICAgICBjb250ZW50czogdGhpcy5nZXRIaXN0b3J5KHRydWUpLmNvbmNhdChpbnB1dENvbnRlbnQpLFxuICAgICAgICAgICAgY29uZmlnOiAoX2EgPSBwYXJhbXMuY29uZmlnKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLmNvbmZpZyxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFJlc29sdmUgdGhlIGludGVybmFsIHRyYWNraW5nIG9mIHNlbmQgY29tcGxldGlvbiBwcm9taXNlIC0gYHNlbmRQcm9taXNlYFxuICAgICAgICAvLyBmb3IgYm90aCBzdWNjZXNzIGFuZCBmYWlsdXJlIHJlc3BvbnNlLiBUaGUgYWN0dWFsIGZhaWx1cmUgaXMgc3RpbGxcbiAgICAgICAgLy8gcHJvcGFnYXRlZCBieSB0aGUgYGF3YWl0IHN0cmVhbVJlc3BvbnNlYC5cbiAgICAgICAgdGhpcy5zZW5kUHJvbWlzZSA9IHN0cmVhbVJlc3BvbnNlXG4gICAgICAgICAgICAudGhlbigoKSA9PiB1bmRlZmluZWQpXG4gICAgICAgICAgICAuY2F0Y2goKCkgPT4gdW5kZWZpbmVkKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzdHJlYW1SZXNwb25zZTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5wcm9jZXNzU3RyZWFtUmVzcG9uc2UocmVzcG9uc2UsIGlucHV0Q29udGVudCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNoYXQgaGlzdG9yeS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVGhlIGhpc3RvcnkgaXMgYSBsaXN0IG9mIGNvbnRlbnRzIGFsdGVybmF0aW5nIGJldHdlZW4gdXNlciBhbmQgbW9kZWwuXG4gICAgICpcbiAgICAgKiBUaGVyZSBhcmUgdHdvIHR5cGVzIG9mIGhpc3Rvcnk6XG4gICAgICogLSBUaGUgYGN1cmF0ZWQgaGlzdG9yeWAgY29udGFpbnMgb25seSB0aGUgdmFsaWQgdHVybnMgYmV0d2VlbiB1c2VyIGFuZFxuICAgICAqIG1vZGVsLCB3aGljaCB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSBzdWJzZXF1ZW50IHJlcXVlc3RzIHNlbnQgdG8gdGhlIG1vZGVsLlxuICAgICAqIC0gVGhlIGBjb21wcmVoZW5zaXZlIGhpc3RvcnlgIGNvbnRhaW5zIGFsbCB0dXJucywgaW5jbHVkaW5nIGludmFsaWQgb3JcbiAgICAgKiAgIGVtcHR5IG1vZGVsIG91dHB1dHMsIHByb3ZpZGluZyBhIGNvbXBsZXRlIHJlY29yZCBvZiB0aGUgaGlzdG9yeS5cbiAgICAgKlxuICAgICAqIFRoZSBoaXN0b3J5IGlzIHVwZGF0ZWQgYWZ0ZXIgcmVjZWl2aW5nIHRoZSByZXNwb25zZSBmcm9tIHRoZSBtb2RlbCxcbiAgICAgKiBmb3Igc3RyZWFtaW5nIHJlc3BvbnNlLCBpdCBtZWFucyByZWNlaXZpbmcgdGhlIGxhc3QgY2h1bmsgb2YgdGhlIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogVGhlIGBjb21wcmVoZW5zaXZlIGhpc3RvcnlgIGlzIHJldHVybmVkIGJ5IGRlZmF1bHQuIFRvIGdldCB0aGUgYGN1cmF0ZWRcbiAgICAgKiBoaXN0b3J5YCwgc2V0IHRoZSBgY3VyYXRlZGAgcGFyYW1ldGVyIHRvIGB0cnVlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjdXJhdGVkIC0gd2hldGhlciB0byByZXR1cm4gdGhlIGN1cmF0ZWQgaGlzdG9yeSBvciB0aGUgY29tcHJlaGVuc2l2ZVxuICAgICAqICAgICBoaXN0b3J5LlxuICAgICAqIEByZXR1cm4gSGlzdG9yeSBjb250ZW50cyBhbHRlcm5hdGluZyBiZXR3ZWVuIHVzZXIgYW5kIG1vZGVsIGZvciB0aGUgZW50aXJlXG4gICAgICogICAgIGNoYXQgc2Vzc2lvbi5cbiAgICAgKi9cbiAgICBnZXRIaXN0b3J5KGN1cmF0ZWQgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBoaXN0b3J5ID0gY3VyYXRlZFxuICAgICAgICAgICAgPyBleHRyYWN0Q3VyYXRlZEhpc3RvcnkodGhpcy5oaXN0b3J5KVxuICAgICAgICAgICAgOiB0aGlzLmhpc3Rvcnk7XG4gICAgICAgIC8vIERlZXAgY29weSB0aGUgaGlzdG9yeSB0byBhdm9pZCBtdXRhdGluZyB0aGUgaGlzdG9yeSBvdXRzaWRlIG9mIHRoZVxuICAgICAgICAvLyBjaGF0IHNlc3Npb24uXG4gICAgICAgIHJldHVybiBzdHJ1Y3R1cmVkQ2xvbmUoaGlzdG9yeSk7XG4gICAgfVxuICAgIHByb2Nlc3NTdHJlYW1SZXNwb25zZShzdHJlYW1SZXNwb25zZSwgaW5wdXRDb250ZW50KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qIHByb2Nlc3NTdHJlYW1SZXNwb25zZV8xKCkge1xuICAgICAgICAgICAgdmFyIF9jLCBlXzEsIF9kLCBfZTtcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dENvbnRlbnQgPSBbXTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2YgPSB0cnVlLCBzdHJlYW1SZXNwb25zZV8xID0gX19hc3luY1ZhbHVlcyhzdHJlYW1SZXNwb25zZSksIHN0cmVhbVJlc3BvbnNlXzFfMTsgc3RyZWFtUmVzcG9uc2VfMV8xID0geWllbGQgX19hd2FpdChzdHJlYW1SZXNwb25zZV8xLm5leHQoKSksIF9jID0gc3RyZWFtUmVzcG9uc2VfMV8xLmRvbmUsICFfYzsgX2YgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIF9lID0gc3RyZWFtUmVzcG9uc2VfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBfZiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IF9lO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZFJlc3BvbnNlKGNodW5rKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGVudCA9IChfYiA9IChfYSA9IGNodW5rLmNhbmRpZGF0ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0Q29udGVudC5wdXNoKGNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQoY2h1bmspO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV9mICYmICFfYyAmJiAoX2QgPSBzdHJlYW1SZXNwb25zZV8xLnJldHVybikpIHlpZWxkIF9fYXdhaXQoX2QuY2FsbChzdHJlYW1SZXNwb25zZV8xKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVjb3JkSGlzdG9yeShpbnB1dENvbnRlbnQsIG91dHB1dENvbnRlbnQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVjb3JkSGlzdG9yeSh1c2VySW5wdXQsIG1vZGVsT3V0cHV0LCBhdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmdIaXN0b3J5KSB7XG4gICAgICAgIGxldCBvdXRwdXRDb250ZW50cyA9IFtdO1xuICAgICAgICBpZiAobW9kZWxPdXRwdXQubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgbW9kZWxPdXRwdXQuZXZlcnkoKGNvbnRlbnQpID0+IGNvbnRlbnQucm9sZSAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgb3V0cHV0Q29udGVudHMgPSBtb2RlbE91dHB1dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEFwcGVuZHMgYW4gZW1wdHkgY29udGVudCB3aGVuIG1vZGVsIHJldHVybnMgZW1wdHkgcmVzcG9uc2UsIHNvIHRoYXQgdGhlXG4gICAgICAgICAgICAvLyBoaXN0b3J5IGlzIGFsd2F5cyBhbHRlcm5hdGluZyBiZXR3ZWVuIHVzZXIgYW5kIG1vZGVsLlxuICAgICAgICAgICAgb3V0cHV0Q29udGVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgcm9sZTogJ21vZGVsJyxcbiAgICAgICAgICAgICAgICBwYXJ0czogW10sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeSAmJlxuICAgICAgICAgICAgYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmhpc3RvcnkucHVzaCguLi5leHRyYWN0Q3VyYXRlZEhpc3RvcnkoYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oaXN0b3J5LnB1c2godXNlcklucHV0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhpc3RvcnkucHVzaCguLi5vdXRwdXRDb250ZW50cyk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG4vKipcbiAqIEFQSSBlcnJvcnMgcmFpc2VkIGJ5IHRoZSBHZW5BSSBBUEkuXG4gKi9cbmNsYXNzIEFwaUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucy5tZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0FwaUVycm9yJztcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBvcHRpb25zLnN0YXR1cztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIEFwaUVycm9yLnByb3RvdHlwZSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG4vLyBDb2RlIGdlbmVyYXRlZCBieSB0aGUgR29vZ2xlIEdlbiBBSSBTREsgZ2VuZXJhdG9yIERPIE5PVCBFRElULlxuZnVuY3Rpb24gY3JlYXRlRmlsZVBhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GaWxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlJ10pO1xuICAgIGlmIChmcm9tRmlsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGUnXSwgZnJvbUZpbGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWxlUmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGRlbGV0ZUZpbGVQYXJhbWV0ZXJzVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ2ZpbGUnXSwgdEZpbGVOYW1lKGZyb21OYW1lKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGRlbGV0ZUZpbGVSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2V0RmlsZVBhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnZmlsZSddLCB0RmlsZU5hbWUoZnJvbU5hbWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdEZpbGVzQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYWdlU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVNpemUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVNpemUnXSwgZnJvbVBhZ2VTaXplKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVRva2VuJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlVG9rZW4nXSwgZnJvbVBhZ2VUb2tlbik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RGaWxlc1BhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGxpc3RGaWxlc0NvbmZpZ1RvTWxkZXYoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0RmlsZXNSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5leHRQYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICduZXh0UGFnZVRva2VuJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU5leHRQYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduZXh0UGFnZVRva2VuJ10sIGZyb21OZXh0UGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlcyddKTtcbiAgICBpZiAoZnJvbUZpbGVzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21GaWxlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jbGFzcyBGaWxlcyBleHRlbmRzIEJhc2VNb2R1bGUge1xuICAgIGNvbnN0cnVjdG9yKGFwaUNsaWVudCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IGFwaUNsaWVudDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3RzIGFsbCBjdXJyZW50IHByb2plY3QgZmlsZXMgZnJvbSB0aGUgc2VydmljZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgbGlzdCByZXF1ZXN0XG4gICAgICAgICAqIEByZXR1cm4gVGhlIHBhZ2luYXRlZCByZXN1bHRzIG9mIHRoZSBsaXN0IG9mIGZpbGVzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIFRoZSBmb2xsb3dpbmcgY29kZSBwcmludHMgdGhlIG5hbWVzIG9mIGFsbCBmaWxlcyBmcm9tIHRoZSBzZXJ2aWNlLCB0aGVcbiAgICAgICAgICogc2l6ZSBvZiBlYWNoIHBhZ2UgaXMgMTAuXG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIGNvbnN0IGxpc3RSZXNwb25zZSA9IGF3YWl0IGFpLmZpbGVzLmxpc3Qoe2NvbmZpZzogeydwYWdlU2l6ZSc6IDEwfX0pO1xuICAgICAgICAgKiBmb3IgYXdhaXQgKGNvbnN0IGZpbGUgb2YgbGlzdFJlc3BvbnNlKSB7XG4gICAgICAgICAqICAgY29uc29sZS5sb2coZmlsZS5uYW1lKTtcbiAgICAgICAgICogfVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGlzdCA9IGFzeW5jIChwYXJhbXMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYWdlcihQYWdlZEl0ZW0uUEFHRURfSVRFTV9GSUxFUywgKHgpID0+IHRoaXMubGlzdEludGVybmFsKHgpLCBhd2FpdCB0aGlzLmxpc3RJbnRlcm5hbChwYXJhbXMpLCBwYXJhbXMpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGxvYWRzIGEgZmlsZSBhc3luY2hyb25vdXNseSB0byB0aGUgR2VtaW5pIEFQSS5cbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBub3QgYXZhaWxhYmxlIGluIFZlcnRleCBBSS5cbiAgICAgKiBTdXBwb3J0ZWQgdXBsb2FkIHNvdXJjZXM6XG4gICAgICogLSBOb2RlLmpzOiBGaWxlIHBhdGggKHN0cmluZykgb3IgQmxvYiBvYmplY3QuXG4gICAgICogLSBCcm93c2VyOiBCbG9iIG9iamVjdCAoZS5nLiwgRmlsZSkuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFRoZSBgbWltZVR5cGVgIGNhbiBiZSBzcGVjaWZpZWQgaW4gdGhlIGBjb25maWdgIHBhcmFtZXRlci4gSWYgb21pdHRlZDpcbiAgICAgKiAgLSBGb3IgZmlsZSBwYXRoIChzdHJpbmcpIGlucHV0cywgdGhlIGBtaW1lVHlwZWAgd2lsbCBiZSBpbmZlcnJlZCBmcm9tIHRoZVxuICAgICAqICAgICBmaWxlIGV4dGVuc2lvbi5cbiAgICAgKiAgLSBGb3IgQmxvYiBvYmplY3QgaW5wdXRzLCB0aGUgYG1pbWVUeXBlYCB3aWxsIGJlIHNldCB0byB0aGUgQmxvYidzIGB0eXBlYFxuICAgICAqICAgICBwcm9wZXJ0eS5cbiAgICAgKiBTb21leCBlYW1wbGVzIGZvciBmaWxlIGV4dGVuc2lvbiB0byBtaW1lVHlwZSBtYXBwaW5nOlxuICAgICAqIC50eHQgLT4gdGV4dC9wbGFpblxuICAgICAqIC5qc29uIC0+IGFwcGxpY2F0aW9uL2pzb25cbiAgICAgKiAuanBnICAtPiBpbWFnZS9qcGVnXG4gICAgICogLnBuZyAtPiBpbWFnZS9wbmdcbiAgICAgKiAubXAzIC0+IGF1ZGlvL21wZWdcbiAgICAgKiAubXA0IC0+IHZpZGVvL21wNFxuICAgICAqXG4gICAgICogVGhpcyBzZWN0aW9uIGNhbiBjb250YWluIG11bHRpcGxlIHBhcmFncmFwaHMgYW5kIGNvZGUgZXhhbXBsZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gT3B0aW9uYWwgcGFyYW1ldGVycyBzcGVjaWZpZWQgaW4gdGhlXG4gICAgICogICAgICAgIGB0eXBlcy5VcGxvYWRGaWxlUGFyYW1ldGVyc2AgaW50ZXJmYWNlLlxuICAgICAqICAgICAgICAgQHNlZSB7QGxpbmsgdHlwZXMuVXBsb2FkRmlsZVBhcmFtZXRlcnMjY29uZmlnfSBmb3IgdGhlIG9wdGlvbmFsXG4gICAgICogICAgICAgICBjb25maWcgaW4gdGhlIHBhcmFtZXRlcnMuXG4gICAgICogQHJldHVybiBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGB0eXBlcy5GaWxlYCBvYmplY3QuXG4gICAgICogQHRocm93cyBBbiBlcnJvciBpZiBjYWxsZWQgb24gYSBWZXJ0ZXggQUkgY2xpZW50LlxuICAgICAqIEB0aHJvd3MgQW4gZXJyb3IgaWYgdGhlIGBtaW1lVHlwZWAgaXMgbm90IHByb3ZpZGVkIGFuZCBjYW4gbm90IGJlIGluZmVycmVkLFxuICAgICAqIHRoZSBgbWltZVR5cGVgIGNhbiBiZSBwcm92aWRlZCBpbiB0aGUgYHBhcmFtcy5jb25maWdgIHBhcmFtZXRlci5cbiAgICAgKiBAdGhyb3dzIEFuIGVycm9yIG9jY3VycyBpZiBhIHN1aXRhYmxlIHVwbG9hZCBsb2NhdGlvbiBjYW5ub3QgYmUgZXN0YWJsaXNoZWQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIFRoZSBmb2xsb3dpbmcgY29kZSB1cGxvYWRzIGEgZmlsZSB0byBHZW1pbmkgQVBJLlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBmaWxlID0gYXdhaXQgYWkuZmlsZXMudXBsb2FkKHtmaWxlOiAnZmlsZS50eHQnLCBjb25maWc6IHtcbiAgICAgKiAgIG1pbWVUeXBlOiAndGV4dC9wbGFpbicsXG4gICAgICogfX0pO1xuICAgICAqIGNvbnNvbGUubG9nKGZpbGUubmFtZSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgdXBsb2FkKHBhcmFtcykge1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZlcnRleCBBSSBkb2VzIG5vdCBzdXBwb3J0IHVwbG9hZGluZyBmaWxlcy4gWW91IGNhbiBzaGFyZSBmaWxlcyB0aHJvdWdoIGEgR0NTIGJ1Y2tldC4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgIC51cGxvYWRGaWxlKHBhcmFtcy5maWxlLCBwYXJhbXMuY29uZmlnKVxuICAgICAgICAgICAgLnRoZW4oKHJlc3ApID0+IHtcbiAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRG93bmxvYWRzIGEgcmVtb3RlbHkgc3RvcmVkIGZpbGUgYXN5bmNocm9ub3VzbHkgdG8gYSBsb2NhdGlvbiBzcGVjaWZpZWQgaW5cbiAgICAgKiB0aGUgYHBhcmFtc2Agb2JqZWN0LiBUaGlzIG1ldGhvZCBvbmx5IHdvcmtzIG9uIE5vZGUgZW52aXJvbm1lbnQsIHRvXG4gICAgICogZG93bmxvYWQgZmlsZXMgaW4gdGhlIGJyb3dzZXIsIHVzZSBhIGJyb3dzZXIgY29tcGxpYW50IG1ldGhvZCBsaWtlIGFuIDxhPlxuICAgICAqIHRhZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIGRvd25sb2FkIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIFRoZSBmb2xsb3dpbmcgY29kZSBkb3dubG9hZHMgYW4gZXhhbXBsZSBmaWxlIG5hbWVkIFwiZmlsZXMvbWVob3pweGY4NzdkXCIgYXNcbiAgICAgKiBcImZpbGUudHh0XCIuXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIGF3YWl0IGFpLmZpbGVzLmRvd25sb2FkKHtmaWxlOiBmaWxlLm5hbWUsIGRvd25sb2FkUGF0aDogJ2ZpbGUudHh0J30pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGRvd25sb2FkKHBhcmFtcykge1xuICAgICAgICBhd2FpdCB0aGlzLmFwaUNsaWVudC5kb3dubG9hZEZpbGUocGFyYW1zKTtcbiAgICB9XG4gICAgYXN5bmMgbGlzdEludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBHZW1pbmkgRGV2ZWxvcGVyIEFQSS4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBsaXN0RmlsZXNQYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnZmlsZXMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGxpc3RGaWxlc1Jlc3BvbnNlRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgTGlzdEZpbGVzUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZUludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBHZW1pbmkgRGV2ZWxvcGVyIEFQSS4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBjcmVhdGVGaWxlUGFyYW1ldGVyc1RvTWxkZXYocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3VwbG9hZC92MWJldGEvZmlsZXMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGNyZWF0ZUZpbGVSZXNwb25zZUZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IENyZWF0ZUZpbGVSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBmaWxlIGluZm9ybWF0aW9uIGZyb20gdGhlIHNlcnZpY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBnZXQgcmVxdWVzdFxuICAgICAqIEByZXR1cm4gVGhlIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgdHlwZXMuRmlsZSBvYmplY3QgcmVxdWVzdGVkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IGNvbmZpZzogR2V0RmlsZVBhcmFtZXRlcnMgPSB7XG4gICAgICogICBuYW1lOiBmaWxlTmFtZSxcbiAgICAgKiB9O1xuICAgICAqIGZpbGUgPSBhd2FpdCBhaS5maWxlcy5nZXQoY29uZmlnKTtcbiAgICAgKiBjb25zb2xlLmxvZyhmaWxlLm5hbWUpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGdldChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgR2VtaW5pIERldmVsb3BlciBBUEkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2V0RmlsZVBhcmFtZXRlcnNUb01sZGV2KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCdmaWxlcy97ZmlsZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigocmVzcCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBhIHJlbW90ZWx5IHN0b3JlZCBmaWxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgZGVsZXRlIHJlcXVlc3QuXG4gICAgICogQHJldHVybiBUaGUgRGVsZXRlRmlsZVJlc3BvbnNlLCB0aGUgcmVzcG9uc2UgZm9yIHRoZSBkZWxldGUgbWV0aG9kLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBUaGUgZm9sbG93aW5nIGNvZGUgZGVsZXRlcyBhbiBleGFtcGxlIGZpbGUgbmFtZWQgXCJmaWxlcy9tZWhvenB4Zjg3N2RcIi5cbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogYXdhaXQgYWkuZmlsZXMuZGVsZXRlKHtuYW1lOiBmaWxlLm5hbWV9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGUocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIEdlbWluaSBEZXZlbG9wZXIgQVBJLicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGRlbGV0ZUZpbGVQYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnZmlsZXMve2ZpbGV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBkZWxldGVGaWxlUmVzcG9uc2VGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBEZWxldGVGaWxlUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5mdW5jdGlvbiBibG9iVG9NbGRldiQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkYXRhJ10pO1xuICAgIGlmIChmcm9tRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RhdGEnXSwgZnJvbURhdGEpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGlzcGxheU5hbWUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29udGVudFRvTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFydHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcnRzJ10pO1xuICAgIGlmIChmcm9tUGFydHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVBhcnRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnRUb01sZGV2JDIoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJ0cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUm9sZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncm9sZSddKTtcbiAgICBpZiAoZnJvbVJvbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyb2xlJ10sIGZyb21Sb2xlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZmlsZURhdGFUb01sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Rpc3BsYXlOYW1lIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlVXJpJ10pO1xuICAgIGlmIChmcm9tRmlsZVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVVcmknXSwgZnJvbUZpbGVVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkNhbGxUb01sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUlkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpZCddKTtcbiAgICBpZiAoZnJvbUlkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaWQnXSwgZnJvbUlkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFyZ3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FyZ3MnXSk7XG4gICAgaWYgKGZyb21BcmdzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXJncyddLCBmcm9tQXJncyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXJ0aWFsQXJncyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFydGlhbEFyZ3MgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnd2lsbENvbnRpbnVlJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd3aWxsQ29udGludWUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25EZWNsYXJhdGlvblRvVmVydGV4JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmVoYXZpb3InXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JlaGF2aW9yIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXNjcmlwdGlvbiddKTtcbiAgICBpZiAoZnJvbURlc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVzY3JpcHRpb24nXSwgZnJvbURlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYXJhbWV0ZXJzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXJhbWV0ZXJzJ10pO1xuICAgIGlmIChmcm9tUGFyYW1ldGVycyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcmFtZXRlcnMnXSwgZnJvbVBhcmFtZXRlcnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFyYW1ldGVyc0pzb25TY2hlbWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwYXJhbWV0ZXJzSnNvblNjaGVtYScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21QYXJhbWV0ZXJzSnNvblNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcmFtZXRlcnNKc29uU2NoZW1hJ10sIGZyb21QYXJhbWV0ZXJzSnNvblNjaGVtYSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVzcG9uc2UnXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlJ10sIGZyb21SZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZUpzb25TY2hlbWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZUpzb25TY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VKc29uU2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VKc29uU2NoZW1hJ10sIGZyb21SZXNwb25zZUpzb25TY2hlbWEpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0aW9uQ29uZmlnVG9WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWxTZWxlY3Rpb25Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtb2RlbFNlbGVjdGlvbkNvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Nb2RlbFNlbGVjdGlvbkNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGVsQ29uZmlnJ10sIGZyb21Nb2RlbFNlbGVjdGlvbkNvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZUpzb25TY2hlbWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZUpzb25TY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VKc29uU2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VKc29uU2NoZW1hJ10sIGZyb21SZXNwb25zZUpzb25TY2hlbWEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXVkaW9UaW1lc3RhbXAgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdhdWRpb1RpbWVzdGFtcCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21BdWRpb1RpbWVzdGFtcCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2F1ZGlvVGltZXN0YW1wJ10sIGZyb21BdWRpb1RpbWVzdGFtcCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYW5kaWRhdGVDb3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NhbmRpZGF0ZUNvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNhbmRpZGF0ZUNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2FuZGlkYXRlQ291bnQnXSwgZnJvbUNhbmRpZGF0ZUNvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuYWJsZUFmZmVjdGl2ZURpYWxvZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2VuYWJsZUFmZmVjdGl2ZURpYWxvZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FbmFibGVBZmZlY3RpdmVEaWFsb2cgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmFibGVBZmZlY3RpdmVEaWFsb2cnXSwgZnJvbUVuYWJsZUFmZmVjdGl2ZURpYWxvZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GcmVxdWVuY3lQZW5hbHR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnJlcXVlbmN5UGVuYWx0eScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GcmVxdWVuY3lQZW5hbHR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnJlcXVlbmN5UGVuYWx0eSddLCBmcm9tRnJlcXVlbmN5UGVuYWx0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Mb2dwcm9icyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbG9ncHJvYnMnXSk7XG4gICAgaWYgKGZyb21Mb2dwcm9icyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xvZ3Byb2JzJ10sIGZyb21Mb2dwcm9icyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXhPdXRwdXRUb2tlbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtYXhPdXRwdXRUb2tlbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTWF4T3V0cHV0VG9rZW5zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWF4T3V0cHV0VG9rZW5zJ10sIGZyb21NYXhPdXRwdXRUb2tlbnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWVkaWFSZXNvbHV0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWVkaWFSZXNvbHV0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1lZGlhUmVzb2x1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21lZGlhUmVzb2x1dGlvbiddLCBmcm9tTWVkaWFSZXNvbHV0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByZXNlbmNlUGVuYWx0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ByZXNlbmNlUGVuYWx0eScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21QcmVzZW5jZVBlbmFsdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcmVzZW5jZVBlbmFsdHknXSwgZnJvbVByZXNlbmNlUGVuYWx0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZUxvZ3Byb2JzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VMb2dwcm9icycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZUxvZ3Byb2JzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VMb2dwcm9icyddLCBmcm9tUmVzcG9uc2VMb2dwcm9icyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VNaW1lVHlwZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VNaW1lVHlwZSddLCBmcm9tUmVzcG9uc2VNaW1lVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZU1vZGFsaXRpZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZU1vZGFsaXRpZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VNb2RhbGl0aWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VNb2RhbGl0aWVzJ10sIGZyb21SZXNwb25zZU1vZGFsaXRpZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VTY2hlbWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZVNjaGVtYScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZVNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlU2NoZW1hJ10sIGZyb21SZXNwb25zZVNjaGVtYSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Sb3V0aW5nQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncm91dGluZ0NvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Sb3V0aW5nQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncm91dGluZ0NvbmZpZyddLCBmcm9tUm91dGluZ0NvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZWVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzZWVkJ10pO1xuICAgIGlmIChmcm9tU2VlZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NlZWQnXSwgZnJvbVNlZWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3BlZWNoQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzcGVlY2hDb25maWcnXSk7XG4gICAgaWYgKGZyb21TcGVlY2hDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzcGVlY2hDb25maWcnXSwgc3BlZWNoQ29uZmlnVG9WZXJ0ZXgkMShmcm9tU3BlZWNoQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdG9wU2VxdWVuY2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3RvcFNlcXVlbmNlcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TdG9wU2VxdWVuY2VzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RvcFNlcXVlbmNlcyddLCBmcm9tU3RvcFNlcXVlbmNlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZW1wZXJhdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGVtcGVyYXR1cmUnXSk7XG4gICAgaWYgKGZyb21UZW1wZXJhdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RlbXBlcmF0dXJlJ10sIGZyb21UZW1wZXJhdHVyZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaGlua2luZ0NvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RoaW5raW5nQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRoaW5raW5nQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhpbmtpbmdDb25maWcnXSwgZnJvbVRoaW5raW5nQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvcEsgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvcEsnXSk7XG4gICAgaWYgKGZyb21Ub3BLICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9wSyddLCBmcm9tVG9wSyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3BQID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3BQJ10pO1xuICAgIGlmIChmcm9tVG9wUCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RvcFAnXSwgZnJvbVRvcFApO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmFibGVFbmhhbmNlZENpdmljQW5zd2VycyddKSAhPT1cbiAgICAgICAgdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZW5hYmxlRW5oYW5jZWRDaXZpY0Fuc3dlcnMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnb29nbGVNYXBzVG9NbGRldiQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2F1dGhDb25maWcnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2F1dGhDb25maWcgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuYWJsZVdpZGdldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5hYmxlV2lkZ2V0J10pO1xuICAgIGlmIChmcm9tRW5hYmxlV2lkZ2V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5hYmxlV2lkZ2V0J10sIGZyb21FbmFibGVXaWRnZXQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnb29nbGVTZWFyY2hUb01sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhjbHVkZURvbWFpbnMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4Y2x1ZGVEb21haW5zIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Jsb2NraW5nQ29uZmlkZW5jZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmxvY2tpbmdDb25maWRlbmNlIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaW1lUmFuZ2VGaWx0ZXIgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aW1lUmFuZ2VGaWx0ZXInLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGltZVJhbmdlRmlsdGVyICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGltZVJhbmdlRmlsdGVyJ10sIGZyb21UaW1lUmFuZ2VGaWx0ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlQ29ubmVjdENvbmZpZ1RvTWxkZXYkMShmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21HZW5lcmF0aW9uQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ2VuZXJhdGlvbkNvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21HZW5lcmF0aW9uQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnXSwgZnJvbUdlbmVyYXRpb25Db25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VNb2RhbGl0aWVzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVJlc3BvbnNlTW9kYWxpdGllcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3Jlc3BvbnNlTW9kYWxpdGllcyddLCBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRlbXBlcmF0dXJlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZW1wZXJhdHVyZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRlbXBlcmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAndGVtcGVyYXR1cmUnXSwgZnJvbVRlbXBlcmF0dXJlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvcFAgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvcFAnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub3BQICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAndG9wUCddLCBmcm9tVG9wUCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3BLID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3BLJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9wSyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3RvcEsnXSwgZnJvbVRvcEspO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWF4T3V0cHV0VG9rZW5zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWF4T3V0cHV0VG9rZW5zJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU1heE91dHB1dFRva2VucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ21heE91dHB1dFRva2VucyddLCBmcm9tTWF4T3V0cHV0VG9rZW5zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1lZGlhUmVzb2x1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21lZGlhUmVzb2x1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21NZWRpYVJlc29sdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdtZWRpYVJlc29sdXRpb24nXSwgZnJvbU1lZGlhUmVzb2x1dGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZWVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzZWVkJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2VlZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3NlZWQnXSwgZnJvbVNlZWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3BlZWNoQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzcGVlY2hDb25maWcnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TcGVlY2hDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdzcGVlY2hDb25maWcnXSwgdExpdmVTcGVlY2hDb25maWcoZnJvbVNwZWVjaENvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhpbmtpbmdDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aGlua2luZ0NvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UaGlua2luZ0NvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3RoaW5raW5nQ29uZmlnJ10sIGZyb21UaGlua2luZ0NvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmFibGVBZmZlY3RpdmVEaWFsb2cgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbmFibGVBZmZlY3RpdmVEaWFsb2cnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRW5hYmxlQWZmZWN0aXZlRGlhbG9nICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAnZW5hYmxlQWZmZWN0aXZlRGlhbG9nJ10sIGZyb21FbmFibGVBZmZlY3RpdmVEaWFsb2cpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzeXN0ZW1JbnN0cnVjdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TeXN0ZW1JbnN0cnVjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdzeXN0ZW1JbnN0cnVjdGlvbiddLCBjb250ZW50VG9NbGRldiQyKHRDb250ZW50KGZyb21TeXN0ZW1JbnN0cnVjdGlvbikpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29scyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvb2xzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRUb29scyhmcm9tVG9vbHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvb2xUb01sZGV2JDIodFRvb2woaXRlbSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3Rvb2xzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZXNzaW9uUmVzdW1wdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nlc3Npb25SZXN1bXB0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNlc3Npb25SZXN1bXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3Nlc3Npb25SZXN1bXB0aW9uJ10sIHNlc3Npb25SZXN1bXB0aW9uQ29uZmlnVG9NbGRldiQxKGZyb21TZXNzaW9uUmVzdW1wdGlvbikpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5wdXRBdWRpb1RyYW5zY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21JbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdpbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbiddLCBmcm9tSW5wdXRBdWRpb1RyYW5zY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0QXVkaW9UcmFuc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0QXVkaW9UcmFuc2NyaXB0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dEF1ZGlvVHJhbnNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdvdXRwdXRBdWRpb1RyYW5zY3JpcHRpb24nXSwgZnJvbU91dHB1dEF1ZGlvVHJhbnNjcmlwdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZWFsdGltZUlucHV0Q29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVhbHRpbWVJbnB1dENvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21SZWFsdGltZUlucHV0Q29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3JlYWx0aW1lSW5wdXRDb25maWcnXSwgZnJvbVJlYWx0aW1lSW5wdXRDb25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGV4dFdpbmRvd0NvbXByZXNzaW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29udGV4dFdpbmRvd0NvbXByZXNzaW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUNvbnRleHRXaW5kb3dDb21wcmVzc2lvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdjb250ZXh0V2luZG93Q29tcHJlc3Npb24nXSwgZnJvbUNvbnRleHRXaW5kb3dDb21wcmVzc2lvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qcm9hY3Rpdml0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHJvYWN0aXZpdHknXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Qcm9hY3Rpdml0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdwcm9hY3Rpdml0eSddLCBmcm9tUHJvYWN0aXZpdHkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlQ29ubmVjdENvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUdlbmVyYXRpb25Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdnZW5lcmF0aW9uQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUdlbmVyYXRpb25Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZyddLCBnZW5lcmF0aW9uQ29uZmlnVG9WZXJ0ZXgkMShmcm9tR2VuZXJhdGlvbkNvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VNb2RhbGl0aWVzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVJlc3BvbnNlTW9kYWxpdGllcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3Jlc3BvbnNlTW9kYWxpdGllcyddLCBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRlbXBlcmF0dXJlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZW1wZXJhdHVyZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRlbXBlcmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAndGVtcGVyYXR1cmUnXSwgZnJvbVRlbXBlcmF0dXJlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvcFAgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvcFAnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub3BQICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAndG9wUCddLCBmcm9tVG9wUCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3BLID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3BLJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9wSyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3RvcEsnXSwgZnJvbVRvcEspO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWF4T3V0cHV0VG9rZW5zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWF4T3V0cHV0VG9rZW5zJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU1heE91dHB1dFRva2VucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ21heE91dHB1dFRva2VucyddLCBmcm9tTWF4T3V0cHV0VG9rZW5zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1lZGlhUmVzb2x1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21lZGlhUmVzb2x1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21NZWRpYVJlc29sdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdtZWRpYVJlc29sdXRpb24nXSwgZnJvbU1lZGlhUmVzb2x1dGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZWVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzZWVkJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2VlZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3NlZWQnXSwgZnJvbVNlZWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3BlZWNoQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzcGVlY2hDb25maWcnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TcGVlY2hDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdzcGVlY2hDb25maWcnXSwgc3BlZWNoQ29uZmlnVG9WZXJ0ZXgkMSh0TGl2ZVNwZWVjaENvbmZpZyhmcm9tU3BlZWNoQ29uZmlnKSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhpbmtpbmdDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aGlua2luZ0NvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UaGlua2luZ0NvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3RoaW5raW5nQ29uZmlnJ10sIGZyb21UaGlua2luZ0NvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmFibGVBZmZlY3RpdmVEaWFsb2cgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbmFibGVBZmZlY3RpdmVEaWFsb2cnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRW5hYmxlQWZmZWN0aXZlRGlhbG9nICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAnZW5hYmxlQWZmZWN0aXZlRGlhbG9nJ10sIGZyb21FbmFibGVBZmZlY3RpdmVEaWFsb2cpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzeXN0ZW1JbnN0cnVjdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TeXN0ZW1JbnN0cnVjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdzeXN0ZW1JbnN0cnVjdGlvbiddLCB0Q29udGVudChmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24pKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29scyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvb2xzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRUb29scyhmcm9tVG9vbHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvb2xUb1ZlcnRleCQxKHRUb29sKGl0ZW0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICd0b29scyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2Vzc2lvblJlc3VtcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZXNzaW9uUmVzdW1wdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TZXNzaW9uUmVzdW1wdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdzZXNzaW9uUmVzdW1wdGlvbiddLCBmcm9tU2Vzc2lvblJlc3VtcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5wdXRBdWRpb1RyYW5zY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21JbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdpbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbiddLCBmcm9tSW5wdXRBdWRpb1RyYW5zY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0QXVkaW9UcmFuc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0QXVkaW9UcmFuc2NyaXB0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dEF1ZGlvVHJhbnNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdvdXRwdXRBdWRpb1RyYW5zY3JpcHRpb24nXSwgZnJvbU91dHB1dEF1ZGlvVHJhbnNjcmlwdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZWFsdGltZUlucHV0Q29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVhbHRpbWVJbnB1dENvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21SZWFsdGltZUlucHV0Q29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3JlYWx0aW1lSW5wdXRDb25maWcnXSwgZnJvbVJlYWx0aW1lSW5wdXRDb25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGV4dFdpbmRvd0NvbXByZXNzaW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29udGV4dFdpbmRvd0NvbXByZXNzaW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUNvbnRleHRXaW5kb3dDb21wcmVzc2lvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdjb250ZXh0V2luZG93Q29tcHJlc3Npb24nXSwgZnJvbUNvbnRleHRXaW5kb3dDb21wcmVzc2lvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qcm9hY3Rpdml0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHJvYWN0aXZpdHknXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Qcm9hY3Rpdml0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdwcm9hY3Rpdml0eSddLCBmcm9tUHJvYWN0aXZpdHkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlQ29ubmVjdFBhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2V0dXAnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbmZpZyddLCBsaXZlQ29ubmVjdENvbmZpZ1RvTWxkZXYkMShmcm9tQ29uZmlnLCB0b09iamVjdCkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlQ29ubmVjdFBhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NldHVwJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb25maWcnXSwgbGl2ZUNvbm5lY3RDb25maWdUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlTXVzaWNTZXRDb25maWdQYXJhbWV0ZXJzVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTXVzaWNHZW5lcmF0aW9uQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbXVzaWNHZW5lcmF0aW9uQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU11c2ljR2VuZXJhdGlvbkNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ211c2ljR2VuZXJhdGlvbkNvbmZpZyddLCBmcm9tTXVzaWNHZW5lcmF0aW9uQ29uZmlnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZU11c2ljU2V0V2VpZ2h0ZWRQcm9tcHRzUGFyYW1ldGVyc1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVdlaWdodGVkUHJvbXB0cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3dlaWdodGVkUHJvbXB0cycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21XZWlnaHRlZFByb21wdHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVdlaWdodGVkUHJvbXB0cztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnd2VpZ2h0ZWRQcm9tcHRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVTZW5kUmVhbHRpbWVJbnB1dFBhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21NZWRpYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWVkaWEnXSk7XG4gICAgaWYgKGZyb21NZWRpYSAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0QmxvYnMoZnJvbU1lZGlhKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBibG9iVG9NbGRldiQyKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWVkaWFDaHVua3MnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUF1ZGlvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhdWRpbyddKTtcbiAgICBpZiAoZnJvbUF1ZGlvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXVkaW8nXSwgYmxvYlRvTWxkZXYkMih0QXVkaW9CbG9iKGZyb21BdWRpbykpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUF1ZGlvU3RyZWFtRW5kID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYXVkaW9TdHJlYW1FbmQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQXVkaW9TdHJlYW1FbmQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhdWRpb1N0cmVhbUVuZCddLCBmcm9tQXVkaW9TdHJlYW1FbmQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmlkZW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZpZGVvJ10pO1xuICAgIGlmIChmcm9tVmlkZW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlbyddLCBibG9iVG9NbGRldiQyKHRJbWFnZUJsb2IoZnJvbVZpZGVvKSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGV4dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGV4dCddKTtcbiAgICBpZiAoZnJvbVRleHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZXh0J10sIGZyb21UZXh0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFjdGl2aXR5U3RhcnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdhY3Rpdml0eVN0YXJ0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUFjdGl2aXR5U3RhcnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhY3Rpdml0eVN0YXJ0J10sIGZyb21BY3Rpdml0eVN0YXJ0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFjdGl2aXR5RW5kID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhY3Rpdml0eUVuZCddKTtcbiAgICBpZiAoZnJvbUFjdGl2aXR5RW5kICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYWN0aXZpdHlFbmQnXSwgZnJvbUFjdGl2aXR5RW5kKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZVNlbmRSZWFsdGltZUlucHV0UGFyYW1ldGVyc1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21NZWRpYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWVkaWEnXSk7XG4gICAgaWYgKGZyb21NZWRpYSAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0QmxvYnMoZnJvbU1lZGlhKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWVkaWFDaHVua3MnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUF1ZGlvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhdWRpbyddKTtcbiAgICBpZiAoZnJvbUF1ZGlvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXVkaW8nXSwgdEF1ZGlvQmxvYihmcm9tQXVkaW8pKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUF1ZGlvU3RyZWFtRW5kID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYXVkaW9TdHJlYW1FbmQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQXVkaW9TdHJlYW1FbmQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhdWRpb1N0cmVhbUVuZCddLCBmcm9tQXVkaW9TdHJlYW1FbmQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmlkZW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZpZGVvJ10pO1xuICAgIGlmIChmcm9tVmlkZW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlbyddLCB0SW1hZ2VCbG9iKGZyb21WaWRlbykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGV4dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGV4dCddKTtcbiAgICBpZiAoZnJvbVRleHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZXh0J10sIGZyb21UZXh0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFjdGl2aXR5U3RhcnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdhY3Rpdml0eVN0YXJ0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUFjdGl2aXR5U3RhcnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhY3Rpdml0eVN0YXJ0J10sIGZyb21BY3Rpdml0eVN0YXJ0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFjdGl2aXR5RW5kID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhY3Rpdml0eUVuZCddKTtcbiAgICBpZiAoZnJvbUFjdGl2aXR5RW5kICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYWN0aXZpdHlFbmQnXSwgZnJvbUFjdGl2aXR5RW5kKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZVNlcnZlck1lc3NhZ2VGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZXR1cENvbXBsZXRlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2V0dXBDb21wbGV0ZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZXR1cENvbXBsZXRlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2V0dXBDb21wbGV0ZSddLCBmcm9tU2V0dXBDb21wbGV0ZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZXJ2ZXJDb250ZW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2VydmVyQ29udGVudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZXJ2ZXJDb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2VydmVyQ29udGVudCddLCBmcm9tU2VydmVyQ29udGVudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29sQ2FsbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbENhbGwnXSk7XG4gICAgaWYgKGZyb21Ub29sQ2FsbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rvb2xDYWxsJ10sIGZyb21Ub29sQ2FsbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29sQ2FsbENhbmNlbGxhdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Rvb2xDYWxsQ2FuY2VsbGF0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRvb2xDYWxsQ2FuY2VsbGF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9vbENhbGxDYW5jZWxsYXRpb24nXSwgZnJvbVRvb2xDYWxsQ2FuY2VsbGF0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVzYWdlTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd1c2FnZU1ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVVzYWdlTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1c2FnZU1ldGFkYXRhJ10sIHVzYWdlTWV0YWRhdGFGcm9tVmVydGV4KGZyb21Vc2FnZU1ldGFkYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb0F3YXkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvQXdheSddKTtcbiAgICBpZiAoZnJvbUdvQXdheSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvQXdheSddLCBmcm9tR29Bd2F5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlc3Npb25SZXN1bXB0aW9uVXBkYXRlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2Vzc2lvblJlc3VtcHRpb25VcGRhdGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2Vzc2lvblJlc3VtcHRpb25VcGRhdGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZXNzaW9uUmVzdW1wdGlvblVwZGF0ZSddLCBmcm9tU2Vzc2lvblJlc3VtcHRpb25VcGRhdGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBwYXJ0VG9NbGRldiQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21NZWRpYVJlc29sdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtZWRpYVJlc29sdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTWVkaWFSZXNvbHV0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWVkaWFSZXNvbHV0aW9uJ10sIGZyb21NZWRpYVJlc29sdXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb25SZXN1bHQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb25SZXN1bHQnXSwgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhlY3V0YWJsZUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdleGVjdXRhYmxlQ29kZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FeGVjdXRhYmxlQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4ZWN1dGFibGVDb2RlJ10sIGZyb21FeGVjdXRhYmxlQ29kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZURhdGEnXSk7XG4gICAgaWYgKGZyb21GaWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVEYXRhJ10sIGZpbGVEYXRhVG9NbGRldiQyKGZyb21GaWxlRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25DYWxsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmdW5jdGlvbkNhbGwnXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkNhbGwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkNhbGwnXSwgZnVuY3Rpb25DYWxsVG9NbGRldiQyKGZyb21GdW5jdGlvbkNhbGwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvblJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvblJlc3BvbnNlJ10sIGZyb21GdW5jdGlvblJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUlubGluZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lubGluZURhdGEnXSk7XG4gICAgaWYgKGZyb21JbmxpbmVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5saW5lRGF0YSddLCBibG9iVG9NbGRldiQyKGZyb21JbmxpbmVEYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZXh0J10pO1xuICAgIGlmIChmcm9tVGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RleHQnXSwgZnJvbVRleHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGhvdWdodCddKTtcbiAgICBpZiAoZnJvbVRob3VnaHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0J10sIGZyb21UaG91Z2h0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHRTaWduYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aG91Z2h0U2lnbmF0dXJlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRob3VnaHRTaWduYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0U2lnbmF0dXJlJ10sIGZyb21UaG91Z2h0U2lnbmF0dXJlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZpZGVvTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd2aWRlb01ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVZpZGVvTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlb01ldGFkYXRhJ10sIGZyb21WaWRlb01ldGFkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc2Vzc2lvblJlc3VtcHRpb25Db25maWdUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUhhbmRsZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaGFuZGxlJ10pO1xuICAgIGlmIChmcm9tSGFuZGxlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaGFuZGxlJ10sIGZyb21IYW5kbGUpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0cmFuc3BhcmVudCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndHJhbnNwYXJlbnQgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc3BlZWNoQ29uZmlnVG9WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTGFuZ3VhZ2VDb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYW5ndWFnZUNvZGUnXSk7XG4gICAgaWYgKGZyb21MYW5ndWFnZUNvZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsYW5ndWFnZUNvZGUnXSwgZnJvbUxhbmd1YWdlQ29kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Wb2ljZUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndm9pY2VDb25maWcnXSk7XG4gICAgaWYgKGZyb21Wb2ljZUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZvaWNlQ29uZmlnJ10sIGZyb21Wb2ljZUNvbmZpZyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ211bHRpU3BlYWtlclZvaWNlQ29uZmlnJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtdWx0aVNwZWFrZXJWb2ljZUNvbmZpZyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRvb2xUb01sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25EZWNsYXJhdGlvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkRlY2xhcmF0aW9ucyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXRyaWV2YWwnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JldHJpZXZhbCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ29vZ2xlU2VhcmNoUmV0cmlldmFsJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCddLCBmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbXB1dGVyVXNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb21wdXRlclVzZSddKTtcbiAgICBpZiAoZnJvbUNvbXB1dGVyVXNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29tcHV0ZXJVc2UnXSwgZnJvbUNvbXB1dGVyVXNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVTZWFyY2ggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVTZWFyY2gnXSk7XG4gICAgaWYgKGZyb21GaWxlU2VhcmNoICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZVNlYXJjaCddLCBmcm9tRmlsZVNlYXJjaCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvbiddLCBmcm9tQ29kZUV4ZWN1dGlvbik7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VudGVycHJpc2VXZWJTZWFyY2gnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VudGVycHJpc2VXZWJTZWFyY2ggcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZU1hcHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvb2dsZU1hcHMnXSk7XG4gICAgaWYgKGZyb21Hb29nbGVNYXBzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlTWFwcyddLCBnb29nbGVNYXBzVG9NbGRldiQyKGZyb21Hb29nbGVNYXBzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVTZWFyY2ggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaCddKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaCddLCBnb29nbGVTZWFyY2hUb01sZGV2JDIoZnJvbUdvb2dsZVNlYXJjaCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXJsQ29udGV4dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXJsQ29udGV4dCddKTtcbiAgICBpZiAoZnJvbVVybENvbnRleHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cmxDb250ZXh0J10sIGZyb21VcmxDb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdG9vbFRvVmVydGV4JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25EZWNsYXJhdGlvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uRGVjbGFyYXRpb25Ub1ZlcnRleCQxKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25EZWNsYXJhdGlvbnMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJldHJpZXZhbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmV0cmlldmFsJ10pO1xuICAgIGlmIChmcm9tUmV0cmlldmFsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmV0cmlldmFsJ10sIGZyb21SZXRyaWV2YWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ29vZ2xlU2VhcmNoUmV0cmlldmFsJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCddLCBmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbXB1dGVyVXNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb21wdXRlclVzZSddKTtcbiAgICBpZiAoZnJvbUNvbXB1dGVyVXNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29tcHV0ZXJVc2UnXSwgZnJvbUNvbXB1dGVyVXNlKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZVNlYXJjaCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZmlsZVNlYXJjaCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvbiddLCBmcm9tQ29kZUV4ZWN1dGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbnRlcnByaXNlV2ViU2VhcmNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZW50ZXJwcmlzZVdlYlNlYXJjaCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FbnRlcnByaXNlV2ViU2VhcmNoICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW50ZXJwcmlzZVdlYlNlYXJjaCddLCBmcm9tRW50ZXJwcmlzZVdlYlNlYXJjaCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVNYXBzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVNYXBzJ10pO1xuICAgIGlmIChmcm9tR29vZ2xlTWFwcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZU1hcHMnXSwgZnJvbUdvb2dsZU1hcHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVTZWFyY2gnXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2ggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2gnXSwgZnJvbUdvb2dsZVNlYXJjaCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcmxDb250ZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cmxDb250ZXh0J10pO1xuICAgIGlmIChmcm9tVXJsQ29udGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VybENvbnRleHQnXSwgZnJvbVVybENvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1c2FnZU1ldGFkYXRhRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUHJvbXB0VG9rZW5Db3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Byb21wdFRva2VuQ291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJvbXB0VG9rZW5Db3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Byb21wdFRva2VuQ291bnQnXSwgZnJvbVByb21wdFRva2VuQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FjaGVkQ29udGVudFRva2VuQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYWNoZWRDb250ZW50VG9rZW5Db3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DYWNoZWRDb250ZW50VG9rZW5Db3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhY2hlZENvbnRlbnRUb2tlbkNvdW50J10sIGZyb21DYWNoZWRDb250ZW50VG9rZW5Db3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZVRva2VuQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYW5kaWRhdGVzVG9rZW5Db3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZVRva2VuQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZVRva2VuQ291bnQnXSwgZnJvbVJlc3BvbnNlVG9rZW5Db3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29sVXNlUHJvbXB0VG9rZW5Db3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Rvb2xVc2VQcm9tcHRUb2tlbkNvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRvb2xVc2VQcm9tcHRUb2tlbkNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9vbFVzZVByb21wdFRva2VuQ291bnQnXSwgZnJvbVRvb2xVc2VQcm9tcHRUb2tlbkNvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHRzVG9rZW5Db3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Rob3VnaHRzVG9rZW5Db3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0c1Rva2VuQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0c1Rva2VuQ291bnQnXSwgZnJvbVRob3VnaHRzVG9rZW5Db3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3RhbFRva2VuQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0b3RhbFRva2VuQ291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVG90YWxUb2tlbkNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG90YWxUb2tlbkNvdW50J10sIGZyb21Ub3RhbFRva2VuQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvbXB0VG9rZW5zRGV0YWlscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Byb21wdFRva2Vuc0RldGFpbHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJvbXB0VG9rZW5zRGV0YWlscyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tUHJvbXB0VG9rZW5zRGV0YWlscztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJvbXB0VG9rZW5zRGV0YWlscyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FjaGVUb2tlbnNEZXRhaWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2FjaGVUb2tlbnNEZXRhaWxzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNhY2hlVG9rZW5zRGV0YWlscyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tQ2FjaGVUb2tlbnNEZXRhaWxzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYWNoZVRva2Vuc0RldGFpbHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlVG9rZW5zRGV0YWlscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NhbmRpZGF0ZXNUb2tlbnNEZXRhaWxzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlVG9rZW5zRGV0YWlscyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tUmVzcG9uc2VUb2tlbnNEZXRhaWxzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZVRva2Vuc0RldGFpbHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xVc2VQcm9tcHRUb2tlbnNEZXRhaWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndG9vbFVzZVByb21wdFRva2Vuc0RldGFpbHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVG9vbFVzZVByb21wdFRva2Vuc0RldGFpbHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVRvb2xVc2VQcm9tcHRUb2tlbnNEZXRhaWxzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b29sVXNlUHJvbXB0VG9rZW5zRGV0YWlscyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVHJhZmZpY1R5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RyYWZmaWNUeXBlJ10pO1xuICAgIGlmIChmcm9tVHJhZmZpY1R5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0cmFmZmljVHlwZSddLCBmcm9tVHJhZmZpY1R5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmZ1bmN0aW9uIGJsb2JUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RhdGEnXSk7XG4gICAgaWYgKGZyb21EYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGF0YSddLCBmcm9tRGF0YSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaXNwbGF5TmFtZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjYW5kaWRhdGVGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNvbnRlbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnQnXSk7XG4gICAgaWYgKGZyb21Db250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29udGVudCddLCBmcm9tQ29udGVudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DaXRhdGlvbk1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2l0YXRpb25NZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DaXRhdGlvbk1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2l0YXRpb25NZXRhZGF0YSddLCBjaXRhdGlvbk1ldGFkYXRhRnJvbU1sZGV2KGZyb21DaXRhdGlvbk1ldGFkYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub2tlbkNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b2tlbkNvdW50J10pO1xuICAgIGlmIChmcm9tVG9rZW5Db3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rva2VuQ291bnQnXSwgZnJvbVRva2VuQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmluaXNoUmVhc29uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaW5pc2hSZWFzb24nXSk7XG4gICAgaWYgKGZyb21GaW5pc2hSZWFzb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaW5pc2hSZWFzb24nXSwgZnJvbUZpbmlzaFJlYXNvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BdmdMb2dwcm9icyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXZnTG9ncHJvYnMnXSk7XG4gICAgaWYgKGZyb21BdmdMb2dwcm9icyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2F2Z0xvZ3Byb2JzJ10sIGZyb21BdmdMb2dwcm9icyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hcm91bmRpbmdNZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dyb3VuZGluZ01ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdyb3VuZGluZ01ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ3JvdW5kaW5nTWV0YWRhdGEnXSwgZnJvbUdyb3VuZGluZ01ldGFkYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUluZGV4ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbmRleCddKTtcbiAgICBpZiAoZnJvbUluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5kZXgnXSwgZnJvbUluZGV4KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxvZ3Byb2JzUmVzdWx0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbG9ncHJvYnNSZXN1bHQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTG9ncHJvYnNSZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsb2dwcm9ic1Jlc3VsdCddLCBmcm9tTG9ncHJvYnNSZXN1bHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2FmZXR5UmF0aW5ncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NhZmV0eVJhdGluZ3MnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2FmZXR5UmF0aW5ncyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tU2FmZXR5UmF0aW5ncztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2FmZXR5UmF0aW5ncyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXJsQ29udGV4dE1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndXJsQ29udGV4dE1ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVVybENvbnRleHRNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VybENvbnRleHRNZXRhZGF0YSddLCBmcm9tVXJsQ29udGV4dE1ldGFkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY2l0YXRpb25NZXRhZGF0YUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ2l0YXRpb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjaXRhdGlvblNvdXJjZXMnXSk7XG4gICAgaWYgKGZyb21DaXRhdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUNpdGF0aW9ucztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2l0YXRpb25zJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVUb2tlbnNQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGVudHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnRzJ10pO1xuICAgIGlmIChmcm9tQ29udGVudHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdENvbnRlbnRzKGZyb21Db250ZW50cyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbnRlbnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVUb2tlbnNSZXNwb25zZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub2tlbnNJbmZvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b2tlbnNJbmZvJ10pO1xuICAgIGlmIChmcm9tVG9rZW5zSW5mbyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tVG9rZW5zSW5mbztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9rZW5zSW5mbyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb250ZW50RW1iZWRkaW5nRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVmFsdWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2YWx1ZXMnXSk7XG4gICAgaWYgKGZyb21WYWx1ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2YWx1ZXMnXSwgZnJvbVZhbHVlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdGF0aXN0aWNzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdGF0aXN0aWNzJ10pO1xuICAgIGlmIChmcm9tU3RhdGlzdGljcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXRpc3RpY3MnXSwgY29udGVudEVtYmVkZGluZ1N0YXRpc3RpY3NGcm9tVmVydGV4KGZyb21TdGF0aXN0aWNzKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbnRlbnRFbWJlZGRpbmdTdGF0aXN0aWNzRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVHJ1bmNhdGVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0cnVuY2F0ZWQnXSk7XG4gICAgaWYgKGZyb21UcnVuY2F0ZWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0cnVuY2F0ZWQnXSwgZnJvbVRydW5jYXRlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub2tlbkNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b2tlbl9jb3VudCddKTtcbiAgICBpZiAoZnJvbVRva2VuQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b2tlbkNvdW50J10sIGZyb21Ub2tlbkNvdW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29udGVudFRvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFydHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcnRzJ10pO1xuICAgIGlmIChmcm9tUGFydHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVBhcnRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnRUb01sZGV2JDEoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJ0cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUm9sZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncm9sZSddKTtcbiAgICBpZiAoZnJvbVJvbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyb2xlJ10sIGZyb21Sb2xlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29udHJvbFJlZmVyZW5jZUNvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Db250cm9sVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udHJvbFR5cGUnXSk7XG4gICAgaWYgKGZyb21Db250cm9sVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbnRyb2xUeXBlJ10sIGZyb21Db250cm9sVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmFibGVDb250cm9sSW1hZ2VDb21wdXRhdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2VuYWJsZUNvbnRyb2xJbWFnZUNvbXB1dGF0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUVuYWJsZUNvbnRyb2xJbWFnZUNvbXB1dGF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29tcHV0ZUNvbnRyb2wnXSwgZnJvbUVuYWJsZUNvbnRyb2xJbWFnZUNvbXB1dGF0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY291bnRUb2tlbnNDb25maWdUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N5c3RlbUluc3RydWN0aW9uJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzeXN0ZW1JbnN0cnVjdGlvbiBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29scyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndG9vbHMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ2VuZXJhdGlvbkNvbmZpZyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZ2VuZXJhdGlvbkNvbmZpZyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb3VudFRva2Vuc0NvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVN5c3RlbUluc3RydWN0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3lzdGVtSW5zdHJ1Y3Rpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc3lzdGVtSW5zdHJ1Y3Rpb24nXSwgdENvbnRlbnQoZnJvbVN5c3RlbUluc3RydWN0aW9uKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29scyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub29scyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tVG9vbHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9vbFRvVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3Rvb2xzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HZW5lcmF0aW9uQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ2VuZXJhdGlvbkNvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21HZW5lcmF0aW9uQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2dlbmVyYXRpb25Db25maWcnXSwgZ2VuZXJhdGlvbkNvbmZpZ1RvVmVydGV4KGZyb21HZW5lcmF0aW9uQ29uZmlnKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvdW50VG9rZW5zUGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGVudHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnRzJ10pO1xuICAgIGlmIChmcm9tQ29udGVudHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdENvbnRlbnRzKGZyb21Db250ZW50cyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudFRvTWxkZXYkMShpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbnRlbnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGNvdW50VG9rZW5zQ29uZmlnVG9NbGRldihmcm9tQ29uZmlnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY291bnRUb2tlbnNQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGVudHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnRzJ10pO1xuICAgIGlmIChmcm9tQ29udGVudHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdENvbnRlbnRzKGZyb21Db250ZW50cyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbnRlbnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGNvdW50VG9rZW5zQ29uZmlnVG9WZXJ0ZXgoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb3VudFRva2Vuc1Jlc3BvbnNlRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG90YWxUb2tlbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvdGFsVG9rZW5zJ10pO1xuICAgIGlmIChmcm9tVG90YWxUb2tlbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b3RhbFRva2VucyddLCBmcm9tVG90YWxUb2tlbnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FjaGVkQ29udGVudFRva2VuQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYWNoZWRDb250ZW50VG9rZW5Db3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DYWNoZWRDb250ZW50VG9rZW5Db3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhY2hlZENvbnRlbnRUb2tlbkNvdW50J10sIGZyb21DYWNoZWRDb250ZW50VG9rZW5Db3VudCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvdW50VG9rZW5zUmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG90YWxUb2tlbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvdGFsVG9rZW5zJ10pO1xuICAgIGlmIChmcm9tVG90YWxUb2tlbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b3RhbFRva2VucyddLCBmcm9tVG90YWxUb2tlbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkZWxldGVNb2RlbFBhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkZWxldGVNb2RlbFBhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZGVsZXRlTW9kZWxSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZGVsZXRlTW9kZWxSZXNwb25zZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGVkaXRJbWFnZUNvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU91dHB1dEdjc1VyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnb3V0cHV0R2NzVXJpJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0R2NzVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc3RvcmFnZVVyaSddLCBmcm9tT3V0cHV0R2NzVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5lZ2F0aXZlUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbmVnYXRpdmVQcm9tcHQnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTmVnYXRpdmVQcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICduZWdhdGl2ZVByb21wdCddLCBmcm9tTmVnYXRpdmVQcm9tcHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTnVtYmVyT2ZJbWFnZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdudW1iZXJPZkltYWdlcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21OdW1iZXJPZkltYWdlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NhbXBsZUNvdW50J10sIGZyb21OdW1iZXJPZkltYWdlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Bc3BlY3RSYXRpbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXNwZWN0UmF0aW8nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Bc3BlY3RSYXRpbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2FzcGVjdFJhdGlvJ10sIGZyb21Bc3BlY3RSYXRpbyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HdWlkYW5jZVNjYWxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ3VpZGFuY2VTY2FsZScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21HdWlkYW5jZVNjYWxlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnZ3VpZGFuY2VTY2FsZSddLCBmcm9tR3VpZGFuY2VTY2FsZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZWVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzZWVkJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2VlZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NlZWQnXSwgZnJvbVNlZWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2FmZXR5RmlsdGVyTGV2ZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzYWZldHlGaWx0ZXJMZXZlbCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TYWZldHlGaWx0ZXJMZXZlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NhZmV0eVNldHRpbmcnXSwgZnJvbVNhZmV0eUZpbHRlckxldmVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBlcnNvbkdlbmVyYXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwZXJzb25HZW5lcmF0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBlcnNvbkdlbmVyYXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdwZXJzb25HZW5lcmF0aW9uJ10sIGZyb21QZXJzb25HZW5lcmF0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUluY2x1ZGVTYWZldHlBdHRyaWJ1dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tSW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdpbmNsdWRlU2FmZXR5QXR0cmlidXRlcyddLCBmcm9tSW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5jbHVkZVJhaVJlYXNvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2luY2x1ZGVSYWlSZWFzb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tSW5jbHVkZVJhaVJlYXNvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2luY2x1ZGVSYWlSZWFzb24nXSwgZnJvbUluY2x1ZGVSYWlSZWFzb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFuZ3VhZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhbmd1YWdlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTGFuZ3VhZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdsYW5ndWFnZSddLCBmcm9tTGFuZ3VhZ2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0TWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXRNaW1lVHlwZScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRNaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ291dHB1dE9wdGlvbnMnLCAnbWltZVR5cGUnXSwgZnJvbU91dHB1dE1pbWVUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dENvbXByZXNzaW9uUXVhbGl0eScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRDb21wcmVzc2lvblF1YWxpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdvdXRwdXRPcHRpb25zJywgJ2NvbXByZXNzaW9uUXVhbGl0eSddLCBmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFkZFdhdGVybWFyayA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYWRkV2F0ZXJtYXJrJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQWRkV2F0ZXJtYXJrICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnYWRkV2F0ZXJtYXJrJ10sIGZyb21BZGRXYXRlcm1hcmspO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFiZWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYWJlbHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21MYWJlbHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnbGFiZWxzJ10sIGZyb21MYWJlbHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRWRpdE1vZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VkaXRNb2RlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRWRpdE1vZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdlZGl0TW9kZSddLCBmcm9tRWRpdE1vZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQmFzZVN0ZXBzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydiYXNlU3RlcHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21CYXNlU3RlcHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdlZGl0Q29uZmlnJywgJ2Jhc2VTdGVwcyddLCBmcm9tQmFzZVN0ZXBzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZWRpdEltYWdlUGFyYW1ldGVyc0ludGVybmFsVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcm9tcHQnXSk7XG4gICAgaWYgKGZyb21Qcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAncHJvbXB0J10sIGZyb21Qcm9tcHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVmZXJlbmNlSW1hZ2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVmZXJlbmNlSW1hZ2VzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlZmVyZW5jZUltYWdlcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tUmVmZXJlbmNlSW1hZ2VzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZmVyZW5jZUltYWdlQVBJSW50ZXJuYWxUb1ZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdyZWZlcmVuY2VJbWFnZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgZWRpdEltYWdlQ29uZmlnVG9WZXJ0ZXgoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBlZGl0SW1hZ2VSZXNwb25zZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HZW5lcmF0ZWRJbWFnZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVkaWN0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21HZW5lcmF0ZWRJbWFnZXMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUdlbmVyYXRlZEltYWdlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZWRJbWFnZUZyb21WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnZW5lcmF0ZWRJbWFnZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZW1iZWRDb250ZW50Q29uZmlnVG9NbGRldihmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UYXNrVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGFza1R5cGUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UYXNrVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydyZXF1ZXN0c1tdJywgJ3Rhc2tUeXBlJ10sIGZyb21UYXNrVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaXRsZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGl0bGUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UaXRsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydyZXF1ZXN0c1tdJywgJ3RpdGxlJ10sIGZyb21UaXRsZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXREaW1lbnNpb25hbGl0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dERpbWVuc2lvbmFsaXR5JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dERpbWVuc2lvbmFsaXR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3JlcXVlc3RzW10nLCAnb3V0cHV0RGltZW5zaW9uYWxpdHknXSwgZnJvbU91dHB1dERpbWVuc2lvbmFsaXR5KTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pbWVUeXBlIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2F1dG9UcnVuY2F0ZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYXV0b1RydW5jYXRlIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGVtYmVkQ29udGVudENvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVRhc2tUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0YXNrVHlwZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRhc2tUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2luc3RhbmNlc1tdJywgJ3Rhc2tfdHlwZSddLCBmcm9tVGFza1R5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGl0bGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RpdGxlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVGl0bGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnaW5zdGFuY2VzW10nLCAndGl0bGUnXSwgZnJvbVRpdGxlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dERpbWVuc2lvbmFsaXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0RGltZW5zaW9uYWxpdHknLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0RGltZW5zaW9uYWxpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdvdXRwdXREaW1lbnNpb25hbGl0eSddLCBmcm9tT3V0cHV0RGltZW5zaW9uYWxpdHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnaW5zdGFuY2VzW10nLCAnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUF1dG9UcnVuY2F0ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXV0b1RydW5jYXRlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQXV0b1RydW5jYXRlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnYXV0b1RydW5jYXRlJ10sIGZyb21BdXRvVHJ1bmNhdGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBlbWJlZENvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250ZW50cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udGVudHMnXSk7XG4gICAgaWYgKGZyb21Db250ZW50cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0Q29udGVudHNGb3JFbWJlZChhcGlDbGllbnQsIGZyb21Db250ZW50cyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JlcXVlc3RzW10nLCAnY29udGVudCddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBlbWJlZENvbnRlbnRDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1vZGVsRm9yRW1iZWRDb250ZW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsRm9yRW1iZWRDb250ZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVxdWVzdHNbXScsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWxGb3JFbWJlZENvbnRlbnQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZW1iZWRDb250ZW50UGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbnRlbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb250ZW50cyddKTtcbiAgICBpZiAoZnJvbUNvbnRlbnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRDb250ZW50c0ZvckVtYmVkKGFwaUNsaWVudCwgZnJvbUNvbnRlbnRzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5zdGFuY2VzW10nLCAnY29udGVudCddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBlbWJlZENvbnRlbnRDb25maWdUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGVtYmVkQ29udGVudFJlc3BvbnNlRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW1iZWRkaW5ncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW1iZWRkaW5ncyddKTtcbiAgICBpZiAoZnJvbUVtYmVkZGluZ3MgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUVtYmVkZGluZ3M7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VtYmVkZGluZ3MnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZXRhZGF0YSddKTtcbiAgICBpZiAoZnJvbU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWV0YWRhdGEnXSwgZnJvbU1ldGFkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZW1iZWRDb250ZW50UmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW1iZWRkaW5ncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ByZWRpY3Rpb25zW10nLFxuICAgICAgICAnZW1iZWRkaW5ncycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FbWJlZGRpbmdzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21FbWJlZGRpbmdzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRFbWJlZGRpbmdGcm9tVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW1iZWRkaW5ncyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21ldGFkYXRhJ10pO1xuICAgIGlmIChmcm9tTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZXRhZGF0YSddLCBmcm9tTWV0YWRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBlbmRwb2ludEZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuZHBvaW50J10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVwbG95ZWRNb2RlbElkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZGVwbG95ZWRNb2RlbElkJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbURlcGxveWVkTW9kZWxJZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RlcGxveWVkTW9kZWxJZCddLCBmcm9tRGVwbG95ZWRNb2RlbElkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZmlsZURhdGFUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Rpc3BsYXlOYW1lIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlVXJpJ10pO1xuICAgIGlmIChmcm9tRmlsZVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVVcmknXSwgZnJvbUZpbGVVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkNhbGxUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUlkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpZCddKTtcbiAgICBpZiAoZnJvbUlkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaWQnXSwgZnJvbUlkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFyZ3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FyZ3MnXSk7XG4gICAgaWYgKGZyb21BcmdzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXJncyddLCBmcm9tQXJncyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXJ0aWFsQXJncyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFydGlhbEFyZ3MgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnd2lsbENvbnRpbnVlJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd3aWxsQ29udGludWUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25DYWxsaW5nQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZSddKTtcbiAgICBpZiAoZnJvbU1vZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlJ10sIGZyb21Nb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFsbG93ZWRGdW5jdGlvbk5hbWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYWxsb3dlZEZ1bmN0aW9uTmFtZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQWxsb3dlZEZ1bmN0aW9uTmFtZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhbGxvd2VkRnVuY3Rpb25OYW1lcyddLCBmcm9tQWxsb3dlZEZ1bmN0aW9uTmFtZXMpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdHJlYW1GdW5jdGlvbkNhbGxBcmd1bWVudHMnXSkgIT09XG4gICAgICAgIHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0cmVhbUZ1bmN0aW9uQ2FsbEFyZ3VtZW50cyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkRlY2xhcmF0aW9uVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmVoYXZpb3InXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JlaGF2aW9yIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXNjcmlwdGlvbiddKTtcbiAgICBpZiAoZnJvbURlc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVzY3JpcHRpb24nXSwgZnJvbURlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYXJhbWV0ZXJzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXJhbWV0ZXJzJ10pO1xuICAgIGlmIChmcm9tUGFyYW1ldGVycyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcmFtZXRlcnMnXSwgZnJvbVBhcmFtZXRlcnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFyYW1ldGVyc0pzb25TY2hlbWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwYXJhbWV0ZXJzSnNvblNjaGVtYScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21QYXJhbWV0ZXJzSnNvblNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcmFtZXRlcnNKc29uU2NoZW1hJ10sIGZyb21QYXJhbWV0ZXJzSnNvblNjaGVtYSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVzcG9uc2UnXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlJ10sIGZyb21SZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZUpzb25TY2hlbWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZUpzb25TY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VKc29uU2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VKc29uU2NoZW1hJ10sIGZyb21SZXNwb25zZUpzb25TY2hlbWEpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUNvbnRlbnRDb25maWdUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzeXN0ZW1JbnN0cnVjdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TeXN0ZW1JbnN0cnVjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzeXN0ZW1JbnN0cnVjdGlvbiddLCBjb250ZW50VG9NbGRldiQxKHRDb250ZW50KGZyb21TeXN0ZW1JbnN0cnVjdGlvbikpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRlbXBlcmF0dXJlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZW1wZXJhdHVyZSddKTtcbiAgICBpZiAoZnJvbVRlbXBlcmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGVtcGVyYXR1cmUnXSwgZnJvbVRlbXBlcmF0dXJlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvcFAgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvcFAnXSk7XG4gICAgaWYgKGZyb21Ub3BQICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9wUCddLCBmcm9tVG9wUCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3BLID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3BLJ10pO1xuICAgIGlmIChmcm9tVG9wSyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RvcEsnXSwgZnJvbVRvcEspO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FuZGlkYXRlQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYW5kaWRhdGVDb3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DYW5kaWRhdGVDb3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhbmRpZGF0ZUNvdW50J10sIGZyb21DYW5kaWRhdGVDb3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXhPdXRwdXRUb2tlbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtYXhPdXRwdXRUb2tlbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTWF4T3V0cHV0VG9rZW5zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWF4T3V0cHV0VG9rZW5zJ10sIGZyb21NYXhPdXRwdXRUb2tlbnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RvcFNlcXVlbmNlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N0b3BTZXF1ZW5jZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU3RvcFNlcXVlbmNlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0b3BTZXF1ZW5jZXMnXSwgZnJvbVN0b3BTZXF1ZW5jZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VMb2dwcm9icyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlTG9ncHJvYnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VMb2dwcm9icyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlTG9ncHJvYnMnXSwgZnJvbVJlc3BvbnNlTG9ncHJvYnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTG9ncHJvYnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xvZ3Byb2JzJ10pO1xuICAgIGlmIChmcm9tTG9ncHJvYnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsb2dwcm9icyddLCBmcm9tTG9ncHJvYnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJlc2VuY2VQZW5hbHR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJlc2VuY2VQZW5hbHR5JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByZXNlbmNlUGVuYWx0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ByZXNlbmNlUGVuYWx0eSddLCBmcm9tUHJlc2VuY2VQZW5hbHR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZyZXF1ZW5jeVBlbmFsdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmcmVxdWVuY3lQZW5hbHR5JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZyZXF1ZW5jeVBlbmFsdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmcmVxdWVuY3lQZW5hbHR5J10sIGZyb21GcmVxdWVuY3lQZW5hbHR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NlZWQnXSk7XG4gICAgaWYgKGZyb21TZWVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2VlZCddLCBmcm9tU2VlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VNaW1lVHlwZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VNaW1lVHlwZSddLCBmcm9tUmVzcG9uc2VNaW1lVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZVNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlU2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VTY2hlbWEnXSwgdFNjaGVtYShmcm9tUmVzcG9uc2VTY2hlbWEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlSnNvblNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlSnNvblNjaGVtYScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZUpzb25TY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZUpzb25TY2hlbWEnXSwgZnJvbVJlc3BvbnNlSnNvblNjaGVtYSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JvdXRpbmdDb25maWcnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JvdXRpbmdDb25maWcgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWxTZWxlY3Rpb25Db25maWcnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21vZGVsU2VsZWN0aW9uQ29uZmlnIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TYWZldHlTZXR0aW5ncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NhZmV0eVNldHRpbmdzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNhZmV0eVNldHRpbmdzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21TYWZldHlTZXR0aW5ncztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBzYWZldHlTZXR0aW5nVG9NbGRldihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzYWZldHlTZXR0aW5ncyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rvb2xzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9vbHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdFRvb2xzKGZyb21Ub29scyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9vbFRvTWxkZXYkMSh0VG9vbChpdGVtKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndG9vbHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rvb2xDb25maWcnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub29sQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3Rvb2xDb25maWcnXSwgdG9vbENvbmZpZ1RvTWxkZXYoZnJvbVRvb2xDb25maWcpKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFiZWxzJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsYWJlbHMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNhY2hlZENvbnRlbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYWNoZWRDb250ZW50JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUNhY2hlZENvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnY2FjaGVkQ29udGVudCddLCB0Q2FjaGVkQ29udGVudE5hbWUoYXBpQ2xpZW50LCBmcm9tQ2FjaGVkQ29udGVudCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VNb2RhbGl0aWVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlTW9kYWxpdGllcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlTW9kYWxpdGllcyddLCBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1lZGlhUmVzb2x1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21lZGlhUmVzb2x1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NZWRpYVJlc29sdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZWRpYVJlc29sdXRpb24nXSwgZnJvbU1lZGlhUmVzb2x1dGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TcGVlY2hDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NwZWVjaENvbmZpZyddKTtcbiAgICBpZiAoZnJvbVNwZWVjaENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NwZWVjaENvbmZpZyddLCB0U3BlZWNoQ29uZmlnKGZyb21TcGVlY2hDb25maWcpKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXVkaW9UaW1lc3RhbXAnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2F1ZGlvVGltZXN0YW1wIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaGlua2luZ0NvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RoaW5raW5nQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRoaW5raW5nQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhpbmtpbmdDb25maWcnXSwgZnJvbVRoaW5raW5nQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUltYWdlQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZUNvbmZpZyddKTtcbiAgICBpZiAoZnJvbUltYWdlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW1hZ2VDb25maWcnXSwgaW1hZ2VDb25maWdUb01sZGV2KGZyb21JbWFnZUNvbmZpZykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUNvbnRlbnRDb25maWdUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVN5c3RlbUluc3RydWN0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3lzdGVtSW5zdHJ1Y3Rpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc3lzdGVtSW5zdHJ1Y3Rpb24nXSwgdENvbnRlbnQoZnJvbVN5c3RlbUluc3RydWN0aW9uKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZW1wZXJhdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGVtcGVyYXR1cmUnXSk7XG4gICAgaWYgKGZyb21UZW1wZXJhdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RlbXBlcmF0dXJlJ10sIGZyb21UZW1wZXJhdHVyZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3BQID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3BQJ10pO1xuICAgIGlmIChmcm9tVG9wUCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RvcFAnXSwgZnJvbVRvcFApO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wSyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wSyddKTtcbiAgICBpZiAoZnJvbVRvcEsgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b3BLJ10sIGZyb21Ub3BLKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNhbmRpZGF0ZUNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2FuZGlkYXRlQ291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ2FuZGlkYXRlQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYW5kaWRhdGVDb3VudCddLCBmcm9tQ2FuZGlkYXRlQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWF4T3V0cHV0VG9rZW5zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWF4T3V0cHV0VG9rZW5zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1heE91dHB1dFRva2VucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21heE91dHB1dFRva2VucyddLCBmcm9tTWF4T3V0cHV0VG9rZW5zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0b3BTZXF1ZW5jZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzdG9wU2VxdWVuY2VzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVN0b3BTZXF1ZW5jZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdG9wU2VxdWVuY2VzJ10sIGZyb21TdG9wU2VxdWVuY2VzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlTG9ncHJvYnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZUxvZ3Byb2JzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlTG9ncHJvYnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZUxvZ3Byb2JzJ10sIGZyb21SZXNwb25zZUxvZ3Byb2JzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxvZ3Byb2JzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsb2dwcm9icyddKTtcbiAgICBpZiAoZnJvbUxvZ3Byb2JzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbG9ncHJvYnMnXSwgZnJvbUxvZ3Byb2JzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByZXNlbmNlUGVuYWx0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ByZXNlbmNlUGVuYWx0eScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21QcmVzZW5jZVBlbmFsdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcmVzZW5jZVBlbmFsdHknXSwgZnJvbVByZXNlbmNlUGVuYWx0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GcmVxdWVuY3lQZW5hbHR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnJlcXVlbmN5UGVuYWx0eScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GcmVxdWVuY3lQZW5hbHR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnJlcXVlbmN5UGVuYWx0eSddLCBmcm9tRnJlcXVlbmN5UGVuYWx0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZWVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzZWVkJ10pO1xuICAgIGlmIChmcm9tU2VlZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NlZWQnXSwgZnJvbVNlZWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VNaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlTWltZVR5cGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VNaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlTWltZVR5cGUnXSwgZnJvbVJlc3BvbnNlTWltZVR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VTY2hlbWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZVNjaGVtYScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZVNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlU2NoZW1hJ10sIHRTY2hlbWEoZnJvbVJlc3BvbnNlU2NoZW1hKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZUpzb25TY2hlbWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZUpzb25TY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VKc29uU2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VKc29uU2NoZW1hJ10sIGZyb21SZXNwb25zZUpzb25TY2hlbWEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUm91dGluZ0NvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JvdXRpbmdDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUm91dGluZ0NvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JvdXRpbmdDb25maWcnXSwgZnJvbVJvdXRpbmdDb25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTW9kZWxTZWxlY3Rpb25Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtb2RlbFNlbGVjdGlvbkNvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Nb2RlbFNlbGVjdGlvbkNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGVsQ29uZmlnJ10sIGZyb21Nb2RlbFNlbGVjdGlvbkNvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TYWZldHlTZXR0aW5ncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NhZmV0eVNldHRpbmdzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNhZmV0eVNldHRpbmdzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21TYWZldHlTZXR0aW5ncztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NhZmV0eVNldHRpbmdzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29scyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub29scyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0VG9vbHMoZnJvbVRvb2xzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b29sVG9WZXJ0ZXgodFRvb2woaXRlbSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3Rvb2xzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29sQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29sQ29uZmlnJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9vbENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0b29sQ29uZmlnJ10sIGZyb21Ub29sQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxhYmVscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFiZWxzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTGFiZWxzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2xhYmVscyddLCBmcm9tTGFiZWxzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNhY2hlZENvbnRlbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYWNoZWRDb250ZW50JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUNhY2hlZENvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnY2FjaGVkQ29udGVudCddLCB0Q2FjaGVkQ29udGVudE5hbWUoYXBpQ2xpZW50LCBmcm9tQ2FjaGVkQ29udGVudCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VNb2RhbGl0aWVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlTW9kYWxpdGllcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlTW9kYWxpdGllcyddLCBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1lZGlhUmVzb2x1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21lZGlhUmVzb2x1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NZWRpYVJlc29sdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZWRpYVJlc29sdXRpb24nXSwgZnJvbU1lZGlhUmVzb2x1dGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TcGVlY2hDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NwZWVjaENvbmZpZyddKTtcbiAgICBpZiAoZnJvbVNwZWVjaENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NwZWVjaENvbmZpZyddLCBzcGVlY2hDb25maWdUb1ZlcnRleCh0U3BlZWNoQ29uZmlnKGZyb21TcGVlY2hDb25maWcpKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BdWRpb1RpbWVzdGFtcCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2F1ZGlvVGltZXN0YW1wJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUF1ZGlvVGltZXN0YW1wICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXVkaW9UaW1lc3RhbXAnXSwgZnJvbUF1ZGlvVGltZXN0YW1wKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRoaW5raW5nQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGhpbmtpbmdDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGhpbmtpbmdDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aGlua2luZ0NvbmZpZyddLCBmcm9tVGhpbmtpbmdDb25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW1hZ2VDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ltYWdlQ29uZmlnJ10pO1xuICAgIGlmIChmcm9tSW1hZ2VDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbWFnZUNvbmZpZyddLCBpbWFnZUNvbmZpZ1RvVmVydGV4KGZyb21JbWFnZUNvbmZpZykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUNvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250ZW50cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udGVudHMnXSk7XG4gICAgaWYgKGZyb21Db250ZW50cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0Q29udGVudHMoZnJvbUNvbnRlbnRzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50VG9NbGRldiQxKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29udGVudHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2VuZXJhdGlvbkNvbmZpZyddLCBnZW5lcmF0ZUNvbnRlbnRDb25maWdUb01sZGV2KGFwaUNsaWVudCwgZnJvbUNvbmZpZywgdG9PYmplY3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVDb250ZW50UGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbnRlbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb250ZW50cyddKTtcbiAgICBpZiAoZnJvbUNvbnRlbnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRDb250ZW50cyhmcm9tQ29udGVudHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb250ZW50cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnZW5lcmF0aW9uQ29uZmlnJ10sIGdlbmVyYXRlQ29udGVudENvbmZpZ1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbUNvbmZpZywgdG9PYmplY3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVDb250ZW50UmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYW5kaWRhdGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjYW5kaWRhdGVzJ10pO1xuICAgIGlmIChmcm9tQ2FuZGlkYXRlcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tQ2FuZGlkYXRlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYW5kaWRhdGVGcm9tTWxkZXYoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYW5kaWRhdGVzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Nb2RlbFZlcnNpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsVmVyc2lvbiddKTtcbiAgICBpZiAoZnJvbU1vZGVsVmVyc2lvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGVsVmVyc2lvbiddLCBmcm9tTW9kZWxWZXJzaW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByb21wdEZlZWRiYWNrID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJvbXB0RmVlZGJhY2snLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJvbXB0RmVlZGJhY2sgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcm9tcHRGZWVkYmFjayddLCBmcm9tUHJvbXB0RmVlZGJhY2spO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VJZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVzcG9uc2VJZCddKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlSWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZUlkJ10sIGZyb21SZXNwb25zZUlkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVzYWdlTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd1c2FnZU1ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVVzYWdlTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1c2FnZU1ldGFkYXRhJ10sIGZyb21Vc2FnZU1ldGFkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVDb250ZW50UmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FuZGlkYXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY2FuZGlkYXRlcyddKTtcbiAgICBpZiAoZnJvbUNhbmRpZGF0ZXMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUNhbmRpZGF0ZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhbmRpZGF0ZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNyZWF0ZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSk7XG4gICAgaWYgKGZyb21DcmVhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY3JlYXRlVGltZSddLCBmcm9tQ3JlYXRlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Nb2RlbFZlcnNpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsVmVyc2lvbiddKTtcbiAgICBpZiAoZnJvbU1vZGVsVmVyc2lvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGVsVmVyc2lvbiddLCBmcm9tTW9kZWxWZXJzaW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByb21wdEZlZWRiYWNrID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJvbXB0RmVlZGJhY2snLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJvbXB0RmVlZGJhY2sgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcm9tcHRGZWVkYmFjayddLCBmcm9tUHJvbXB0RmVlZGJhY2spO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VJZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVzcG9uc2VJZCddKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlSWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZUlkJ10sIGZyb21SZXNwb25zZUlkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVzYWdlTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd1c2FnZU1ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVVzYWdlTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1c2FnZU1ldGFkYXRhJ10sIGZyb21Vc2FnZU1ldGFkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVJbWFnZXNDb25maWdUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnb3V0cHV0R2NzVXJpJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvdXRwdXRHY3NVcmkgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmVnYXRpdmVQcm9tcHQnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25lZ2F0aXZlUHJvbXB0IHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OdW1iZXJPZkltYWdlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ251bWJlck9mSW1hZ2VzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU51bWJlck9mSW1hZ2VzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2FtcGxlQ291bnQnXSwgZnJvbU51bWJlck9mSW1hZ2VzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFzcGVjdFJhdGlvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhc3BlY3RSYXRpbyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUFzcGVjdFJhdGlvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnYXNwZWN0UmF0aW8nXSwgZnJvbUFzcGVjdFJhdGlvKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUd1aWRhbmNlU2NhbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdndWlkYW5jZVNjYWxlJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUd1aWRhbmNlU2NhbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdndWlkYW5jZVNjYWxlJ10sIGZyb21HdWlkYW5jZVNjYWxlKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc2VlZCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2VlZCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2FmZXR5RmlsdGVyTGV2ZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzYWZldHlGaWx0ZXJMZXZlbCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TYWZldHlGaWx0ZXJMZXZlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NhZmV0eVNldHRpbmcnXSwgZnJvbVNhZmV0eUZpbHRlckxldmVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBlcnNvbkdlbmVyYXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwZXJzb25HZW5lcmF0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBlcnNvbkdlbmVyYXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdwZXJzb25HZW5lcmF0aW9uJ10sIGZyb21QZXJzb25HZW5lcmF0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUluY2x1ZGVTYWZldHlBdHRyaWJ1dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tSW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdpbmNsdWRlU2FmZXR5QXR0cmlidXRlcyddLCBmcm9tSW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5jbHVkZVJhaVJlYXNvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2luY2x1ZGVSYWlSZWFzb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tSW5jbHVkZVJhaVJlYXNvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2luY2x1ZGVSYWlSZWFzb24nXSwgZnJvbUluY2x1ZGVSYWlSZWFzb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFuZ3VhZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhbmd1YWdlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTGFuZ3VhZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdsYW5ndWFnZSddLCBmcm9tTGFuZ3VhZ2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0TWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXRNaW1lVHlwZScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRNaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ291dHB1dE9wdGlvbnMnLCAnbWltZVR5cGUnXSwgZnJvbU91dHB1dE1pbWVUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dENvbXByZXNzaW9uUXVhbGl0eScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRDb21wcmVzc2lvblF1YWxpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdvdXRwdXRPcHRpb25zJywgJ2NvbXByZXNzaW9uUXVhbGl0eSddLCBmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5KTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYWRkV2F0ZXJtYXJrJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhZGRXYXRlcm1hcmsgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFiZWxzJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsYWJlbHMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUltYWdlU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW1hZ2VTaXplJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tSW1hZ2VTaXplICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2FtcGxlSW1hZ2VTaXplJ10sIGZyb21JbWFnZVNpemUpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmhhbmNlUHJvbXB0J10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlbmhhbmNlUHJvbXB0IHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlSW1hZ2VzQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tT3V0cHV0R2NzVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydvdXRwdXRHY3NVcmknXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRHY3NVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzdG9yYWdlVXJpJ10sIGZyb21PdXRwdXRHY3NVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmVnYXRpdmVQcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICduZWdhdGl2ZVByb21wdCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21OZWdhdGl2ZVByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ25lZ2F0aXZlUHJvbXB0J10sIGZyb21OZWdhdGl2ZVByb21wdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OdW1iZXJPZkltYWdlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ251bWJlck9mSW1hZ2VzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU51bWJlck9mSW1hZ2VzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2FtcGxlQ291bnQnXSwgZnJvbU51bWJlck9mSW1hZ2VzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFzcGVjdFJhdGlvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhc3BlY3RSYXRpbyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUFzcGVjdFJhdGlvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnYXNwZWN0UmF0aW8nXSwgZnJvbUFzcGVjdFJhdGlvKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUd1aWRhbmNlU2NhbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdndWlkYW5jZVNjYWxlJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUd1aWRhbmNlU2NhbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdndWlkYW5jZVNjYWxlJ10sIGZyb21HdWlkYW5jZVNjYWxlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NlZWQnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TZWVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2VlZCddLCBmcm9tU2VlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TYWZldHlGaWx0ZXJMZXZlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NhZmV0eUZpbHRlckxldmVsJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNhZmV0eUZpbHRlckxldmVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2FmZXR5U2V0dGluZyddLCBmcm9tU2FmZXR5RmlsdGVyTGV2ZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGVyc29uR2VuZXJhdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3BlcnNvbkdlbmVyYXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGVyc29uR2VuZXJhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3BlcnNvbkdlbmVyYXRpb24nXSwgZnJvbVBlcnNvbkdlbmVyYXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbmNsdWRlU2FmZXR5QXR0cmlidXRlcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21JbmNsdWRlU2FmZXR5QXR0cmlidXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2luY2x1ZGVTYWZldHlBdHRyaWJ1dGVzJ10sIGZyb21JbmNsdWRlU2FmZXR5QXR0cmlidXRlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmNsdWRlUmFpUmVhc29uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW5jbHVkZVJhaVJlYXNvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21JbmNsdWRlUmFpUmVhc29uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnaW5jbHVkZVJhaVJlYXNvbiddLCBmcm9tSW5jbHVkZVJhaVJlYXNvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYW5ndWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFuZ3VhZ2UnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21MYW5ndWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2xhbmd1YWdlJ10sIGZyb21MYW5ndWFnZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRNaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dE1pbWVUeXBlJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dE1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnb3V0cHV0T3B0aW9ucycsICdtaW1lVHlwZSddLCBmcm9tT3V0cHV0TWltZVR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ291dHB1dE9wdGlvbnMnLCAnY29tcHJlc3Npb25RdWFsaXR5J10sIGZyb21PdXRwdXRDb21wcmVzc2lvblF1YWxpdHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQWRkV2F0ZXJtYXJrID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhZGRXYXRlcm1hcmsnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21BZGRXYXRlcm1hcmsgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdhZGRXYXRlcm1hcmsnXSwgZnJvbUFkZFdhdGVybWFyayk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYWJlbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhYmVscyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUxhYmVscyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydsYWJlbHMnXSwgZnJvbUxhYmVscyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbWFnZVNpemUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ltYWdlU2l6ZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUltYWdlU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NhbXBsZUltYWdlU2l6ZSddLCBmcm9tSW1hZ2VTaXplKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuaGFuY2VQcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbmhhbmNlUHJvbXB0JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUVuaGFuY2VQcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdlbmhhbmNlUHJvbXB0J10sIGZyb21FbmhhbmNlUHJvbXB0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVJbWFnZXNQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Byb21wdCddKTtcbiAgICBpZiAoZnJvbVByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdwcm9tcHQnXSwgZnJvbVByb21wdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGdlbmVyYXRlSW1hZ2VzQ29uZmlnVG9NbGRldihmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlSW1hZ2VzUGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByb21wdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHJvbXB0J10pO1xuICAgIGlmIChmcm9tUHJvbXB0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ3Byb21wdCddLCBmcm9tUHJvbXB0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgZ2VuZXJhdGVJbWFnZXNDb25maWdUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlSW1hZ2VzUmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HZW5lcmF0ZWRJbWFnZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVkaWN0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21HZW5lcmF0ZWRJbWFnZXMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUdlbmVyYXRlZEltYWdlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZWRJbWFnZUZyb21NbGRldihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dlbmVyYXRlZEltYWdlcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUG9zaXRpdmVQcm9tcHRTYWZldHlBdHRyaWJ1dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncG9zaXRpdmVQcm9tcHRTYWZldHlBdHRyaWJ1dGVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVBvc2l0aXZlUHJvbXB0U2FmZXR5QXR0cmlidXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Bvc2l0aXZlUHJvbXB0U2FmZXR5QXR0cmlidXRlcyddLCBzYWZldHlBdHRyaWJ1dGVzRnJvbU1sZGV2KGZyb21Qb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVJbWFnZXNSZXNwb25zZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HZW5lcmF0ZWRJbWFnZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVkaWN0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21HZW5lcmF0ZWRJbWFnZXMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUdlbmVyYXRlZEltYWdlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZWRJbWFnZUZyb21WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnZW5lcmF0ZWRJbWFnZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBvc2l0aXZlUHJvbXB0U2FmZXR5QXR0cmlidXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Bvc2l0aXZlUHJvbXB0U2FmZXR5QXR0cmlidXRlcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Qb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXMnXSwgc2FmZXR5QXR0cmlidXRlc0Zyb21WZXJ0ZXgoZnJvbVBvc2l0aXZlUHJvbXB0U2FmZXR5QXR0cmlidXRlcykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVZpZGVvc0NvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTnVtYmVyT2ZWaWRlb3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdudW1iZXJPZlZpZGVvcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21OdW1iZXJPZlZpZGVvcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NhbXBsZUNvdW50J10sIGZyb21OdW1iZXJPZlZpZGVvcyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ291dHB1dEdjc1VyaSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignb3V0cHV0R2NzVXJpIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZwcyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZnBzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EdXJhdGlvblNlY29uZHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdkdXJhdGlvblNlY29uZHMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRHVyYXRpb25TZWNvbmRzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnZHVyYXRpb25TZWNvbmRzJ10sIGZyb21EdXJhdGlvblNlY29uZHMpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzZWVkJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZWVkIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Bc3BlY3RSYXRpbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXNwZWN0UmF0aW8nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Bc3BlY3RSYXRpbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2FzcGVjdFJhdGlvJ10sIGZyb21Bc3BlY3RSYXRpbyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNvbHV0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNvbHV0aW9uJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUmVzb2x1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3Jlc29sdXRpb24nXSwgZnJvbVJlc29sdXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGVyc29uR2VuZXJhdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3BlcnNvbkdlbmVyYXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGVyc29uR2VuZXJhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3BlcnNvbkdlbmVyYXRpb24nXSwgZnJvbVBlcnNvbkdlbmVyYXRpb24pO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwdWJzdWJUb3BpYyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncHVic3ViVG9waWMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5lZ2F0aXZlUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbmVnYXRpdmVQcm9tcHQnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTmVnYXRpdmVQcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICduZWdhdGl2ZVByb21wdCddLCBmcm9tTmVnYXRpdmVQcm9tcHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5oYW5jZVByb21wdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2VuaGFuY2VQcm9tcHQnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRW5oYW5jZVByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2VuaGFuY2VQcm9tcHQnXSwgZnJvbUVuaGFuY2VQcm9tcHQpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnZW5lcmF0ZUF1ZGlvJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnZW5lcmF0ZUF1ZGlvIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYXN0RnJhbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhc3RGcmFtZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUxhc3RGcmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAnbGFzdEZyYW1lJ10sIGltYWdlVG9NbGRldihmcm9tTGFzdEZyYW1lKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZWZlcmVuY2VJbWFnZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZWZlcmVuY2VJbWFnZXMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUmVmZXJlbmNlSW1hZ2VzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21SZWZlcmVuY2VJbWFnZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlkZW9HZW5lcmF0aW9uUmVmZXJlbmNlSW1hZ2VUb01sZGV2KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdyZWZlcmVuY2VJbWFnZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWFzayddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWFzayBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb21wcmVzc2lvblF1YWxpdHknXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbXByZXNzaW9uUXVhbGl0eSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVZpZGVvc0NvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU51bWJlck9mVmlkZW9zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbnVtYmVyT2ZWaWRlb3MnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTnVtYmVyT2ZWaWRlb3MgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzYW1wbGVDb3VudCddLCBmcm9tTnVtYmVyT2ZWaWRlb3MpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0R2NzVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydvdXRwdXRHY3NVcmknXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRHY3NVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzdG9yYWdlVXJpJ10sIGZyb21PdXRwdXRHY3NVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnBzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmcHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21GcHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdmcHMnXSwgZnJvbUZwcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EdXJhdGlvblNlY29uZHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdkdXJhdGlvblNlY29uZHMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRHVyYXRpb25TZWNvbmRzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnZHVyYXRpb25TZWNvbmRzJ10sIGZyb21EdXJhdGlvblNlY29uZHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2VlZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc2VlZCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNlZWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzZWVkJ10sIGZyb21TZWVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFzcGVjdFJhdGlvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhc3BlY3RSYXRpbyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUFzcGVjdFJhdGlvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnYXNwZWN0UmF0aW8nXSwgZnJvbUFzcGVjdFJhdGlvKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc29sdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc29sdXRpb24nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21SZXNvbHV0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAncmVzb2x1dGlvbiddLCBmcm9tUmVzb2x1dGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QZXJzb25HZW5lcmF0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncGVyc29uR2VuZXJhdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QZXJzb25HZW5lcmF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAncGVyc29uR2VuZXJhdGlvbiddLCBmcm9tUGVyc29uR2VuZXJhdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QdWJzdWJUb3BpYyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHVic3ViVG9waWMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QdWJzdWJUb3BpYyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3B1YnN1YlRvcGljJ10sIGZyb21QdWJzdWJUb3BpYyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OZWdhdGl2ZVByb21wdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ25lZ2F0aXZlUHJvbXB0JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU5lZ2F0aXZlUHJvbXB0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnbmVnYXRpdmVQcm9tcHQnXSwgZnJvbU5lZ2F0aXZlUHJvbXB0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuaGFuY2VQcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbmhhbmNlUHJvbXB0JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUVuaGFuY2VQcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdlbmhhbmNlUHJvbXB0J10sIGZyb21FbmhhbmNlUHJvbXB0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdlbmVyYXRlQXVkaW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdnZW5lcmF0ZUF1ZGlvJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUdlbmVyYXRlQXVkaW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdnZW5lcmF0ZUF1ZGlvJ10sIGZyb21HZW5lcmF0ZUF1ZGlvKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxhc3RGcmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFzdEZyYW1lJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTGFzdEZyYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdsYXN0RnJhbWUnXSwgaW1hZ2VUb1ZlcnRleChmcm9tTGFzdEZyYW1lKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZWZlcmVuY2VJbWFnZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZWZlcmVuY2VJbWFnZXMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUmVmZXJlbmNlSW1hZ2VzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21SZWZlcmVuY2VJbWFnZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlkZW9HZW5lcmF0aW9uUmVmZXJlbmNlSW1hZ2VUb1ZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAncmVmZXJlbmNlSW1hZ2VzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXNrID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtYXNrJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTWFzayAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAnbWFzayddLCB2aWRlb0dlbmVyYXRpb25NYXNrVG9WZXJ0ZXgoZnJvbU1hc2spKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbXByZXNzaW9uUXVhbGl0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvbXByZXNzaW9uUXVhbGl0eScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Db21wcmVzc2lvblF1YWxpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdjb21wcmVzc2lvblF1YWxpdHknXSwgZnJvbUNvbXByZXNzaW9uUXVhbGl0eSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVmlkZW9zT3BlcmF0aW9uRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21ldGFkYXRhJ10pO1xuICAgIGlmIChmcm9tTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZXRhZGF0YSddLCBmcm9tTWV0YWRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRG9uZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZG9uZSddKTtcbiAgICBpZiAoZnJvbURvbmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkb25lJ10sIGZyb21Eb25lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVycm9yID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlcnJvciddKTtcbiAgICBpZiAoZnJvbUVycm9yICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXJyb3InXSwgZnJvbUVycm9yKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2UnLFxuICAgICAgICAnZ2VuZXJhdGVWaWRlb1Jlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2UnXSwgZ2VuZXJhdGVWaWRlb3NSZXNwb25zZUZyb21NbGRldihmcm9tUmVzcG9uc2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVWaWRlb3NPcGVyYXRpb25Gcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21ldGFkYXRhJ10pO1xuICAgIGlmIChmcm9tTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZXRhZGF0YSddLCBmcm9tTWV0YWRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRG9uZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZG9uZSddKTtcbiAgICBpZiAoZnJvbURvbmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkb25lJ10sIGZyb21Eb25lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVycm9yID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlcnJvciddKTtcbiAgICBpZiAoZnJvbUVycm9yICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXJyb3InXSwgZnJvbUVycm9yKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNwb25zZSddKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2UnXSwgZ2VuZXJhdGVWaWRlb3NSZXNwb25zZUZyb21WZXJ0ZXgoZnJvbVJlc3BvbnNlKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVmlkZW9zUGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcm9tcHQnXSk7XG4gICAgaWYgKGZyb21Qcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAncHJvbXB0J10sIGZyb21Qcm9tcHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW1hZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ltYWdlJ10pO1xuICAgIGlmIChmcm9tSW1hZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAnaW1hZ2UnXSwgaW1hZ2VUb01sZGV2KGZyb21JbWFnZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmlkZW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZpZGVvJ10pO1xuICAgIGlmIChmcm9tVmlkZW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAndmlkZW8nXSwgdmlkZW9Ub01sZGV2KGZyb21WaWRlbykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU291cmNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzb3VyY2UnXSk7XG4gICAgaWYgKGZyb21Tb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICBnZW5lcmF0ZVZpZGVvc1NvdXJjZVRvTWxkZXYoZnJvbVNvdXJjZSwgdG9PYmplY3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBnZW5lcmF0ZVZpZGVvc0NvbmZpZ1RvTWxkZXYoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVZpZGVvc1BhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Byb21wdCddKTtcbiAgICBpZiAoZnJvbVByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdwcm9tcHQnXSwgZnJvbVByb21wdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW1hZ2UnXSk7XG4gICAgaWYgKGZyb21JbWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdpbWFnZSddLCBpbWFnZVRvVmVydGV4KGZyb21JbWFnZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmlkZW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZpZGVvJ10pO1xuICAgIGlmIChmcm9tVmlkZW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAndmlkZW8nXSwgdmlkZW9Ub1ZlcnRleChmcm9tVmlkZW8pKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNvdXJjZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc291cmNlJ10pO1xuICAgIGlmIChmcm9tU291cmNlICE9IG51bGwpIHtcbiAgICAgICAgZ2VuZXJhdGVWaWRlb3NTb3VyY2VUb1ZlcnRleChmcm9tU291cmNlLCB0b09iamVjdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGdlbmVyYXRlVmlkZW9zQ29uZmlnVG9WZXJ0ZXgoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVZpZGVvc1Jlc3BvbnNlRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21HZW5lcmF0ZWRWaWRlb3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdnZW5lcmF0ZWRTYW1wbGVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdlbmVyYXRlZFZpZGVvcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tR2VuZXJhdGVkVmlkZW9zO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlZFZpZGVvRnJvbU1sZGV2KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2VuZXJhdGVkVmlkZW9zJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SYWlNZWRpYUZpbHRlcmVkQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyYWlNZWRpYUZpbHRlcmVkQ291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmFpTWVkaWFGaWx0ZXJlZENvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmFpTWVkaWFGaWx0ZXJlZENvdW50J10sIGZyb21SYWlNZWRpYUZpbHRlcmVkQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyYWlNZWRpYUZpbHRlcmVkUmVhc29ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SYWlNZWRpYUZpbHRlcmVkUmVhc29ucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JhaU1lZGlhRmlsdGVyZWRSZWFzb25zJ10sIGZyb21SYWlNZWRpYUZpbHRlcmVkUmVhc29ucyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVmlkZW9zUmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21HZW5lcmF0ZWRWaWRlb3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZpZGVvcyddKTtcbiAgICBpZiAoZnJvbUdlbmVyYXRlZFZpZGVvcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tR2VuZXJhdGVkVmlkZW9zO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlZFZpZGVvRnJvbVZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dlbmVyYXRlZFZpZGVvcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmFpTWVkaWFGaWx0ZXJlZENvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmFpTWVkaWFGaWx0ZXJlZENvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJhaU1lZGlhRmlsdGVyZWRDb3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JhaU1lZGlhRmlsdGVyZWRDb3VudCddLCBmcm9tUmFpTWVkaWFGaWx0ZXJlZENvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJhaU1lZGlhRmlsdGVyZWRSZWFzb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyYWlNZWRpYUZpbHRlcmVkUmVhc29ucyddLCBmcm9tUmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVZpZGVvc1NvdXJjZVRvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcm9tcHQnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Qcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ3Byb21wdCddLCBmcm9tUHJvbXB0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUltYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUltYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdpbWFnZSddLCBpbWFnZVRvTWxkZXYoZnJvbUltYWdlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21WaWRlbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmlkZW8nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21WaWRlbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAndmlkZW8nXSwgdmlkZW9Ub01sZGV2KGZyb21WaWRlbykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVZpZGVvc1NvdXJjZVRvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVByb21wdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHJvbXB0J10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUHJvbXB0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdwcm9tcHQnXSwgZnJvbVByb21wdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW1hZ2UnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21JbWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAnaW1hZ2UnXSwgaW1hZ2VUb1ZlcnRleChmcm9tSW1hZ2UpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZpZGVvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2aWRlbyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVZpZGVvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICd2aWRlbyddLCB2aWRlb1RvVmVydGV4KGZyb21WaWRlbykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZWRJbWFnZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSW1hZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ19zZWxmJ10pO1xuICAgIGlmIChmcm9tSW1hZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbWFnZSddLCBpbWFnZUZyb21NbGRldihmcm9tSW1hZ2UpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJhaUZpbHRlcmVkUmVhc29uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmFpRmlsdGVyZWRSZWFzb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmFpRmlsdGVyZWRSZWFzb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyYWlGaWx0ZXJlZFJlYXNvbiddLCBmcm9tUmFpRmlsdGVyZWRSZWFzb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2FmZXR5QXR0cmlidXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnX3NlbGYnXSk7XG4gICAgaWYgKGZyb21TYWZldHlBdHRyaWJ1dGVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2FmZXR5QXR0cmlidXRlcyddLCBzYWZldHlBdHRyaWJ1dGVzRnJvbU1sZGV2KGZyb21TYWZldHlBdHRyaWJ1dGVzKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlZEltYWdlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSW1hZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ19zZWxmJ10pO1xuICAgIGlmIChmcm9tSW1hZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbWFnZSddLCBpbWFnZUZyb21WZXJ0ZXgoZnJvbUltYWdlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SYWlGaWx0ZXJlZFJlYXNvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JhaUZpbHRlcmVkUmVhc29uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJhaUZpbHRlcmVkUmVhc29uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmFpRmlsdGVyZWRSZWFzb24nXSwgZnJvbVJhaUZpbHRlcmVkUmVhc29uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNhZmV0eUF0dHJpYnV0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ19zZWxmJ10pO1xuICAgIGlmIChmcm9tU2FmZXR5QXR0cmlidXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NhZmV0eUF0dHJpYnV0ZXMnXSwgc2FmZXR5QXR0cmlidXRlc0Zyb21WZXJ0ZXgoZnJvbVNhZmV0eUF0dHJpYnV0ZXMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuaGFuY2VkUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcm9tcHQnXSk7XG4gICAgaWYgKGZyb21FbmhhbmNlZFByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuaGFuY2VkUHJvbXB0J10sIGZyb21FbmhhbmNlZFByb21wdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlZEltYWdlTWFza0Zyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1hc2sgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ19zZWxmJ10pO1xuICAgIGlmIChmcm9tTWFzayAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21hc2snXSwgaW1hZ2VGcm9tVmVydGV4KGZyb21NYXNrKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYWJlbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhYmVscyddKTtcbiAgICBpZiAoZnJvbUxhYmVscyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tTGFiZWxzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsYWJlbHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVkVmlkZW9Gcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVZpZGVvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2aWRlbyddKTtcbiAgICBpZiAoZnJvbVZpZGVvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW8nXSwgdmlkZW9Gcm9tTWxkZXYoZnJvbVZpZGVvKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlZFZpZGVvRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVmlkZW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ19zZWxmJ10pO1xuICAgIGlmIChmcm9tVmlkZW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlbyddLCB2aWRlb0Zyb21WZXJ0ZXgoZnJvbVZpZGVvKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRpb25Db25maWdUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWxTZWxlY3Rpb25Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtb2RlbFNlbGVjdGlvbkNvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Nb2RlbFNlbGVjdGlvbkNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGVsQ29uZmlnJ10sIGZyb21Nb2RlbFNlbGVjdGlvbkNvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZUpzb25TY2hlbWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZUpzb25TY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VKc29uU2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VKc29uU2NoZW1hJ10sIGZyb21SZXNwb25zZUpzb25TY2hlbWEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXVkaW9UaW1lc3RhbXAgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdhdWRpb1RpbWVzdGFtcCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21BdWRpb1RpbWVzdGFtcCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2F1ZGlvVGltZXN0YW1wJ10sIGZyb21BdWRpb1RpbWVzdGFtcCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYW5kaWRhdGVDb3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NhbmRpZGF0ZUNvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNhbmRpZGF0ZUNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2FuZGlkYXRlQ291bnQnXSwgZnJvbUNhbmRpZGF0ZUNvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuYWJsZUFmZmVjdGl2ZURpYWxvZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2VuYWJsZUFmZmVjdGl2ZURpYWxvZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FbmFibGVBZmZlY3RpdmVEaWFsb2cgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmFibGVBZmZlY3RpdmVEaWFsb2cnXSwgZnJvbUVuYWJsZUFmZmVjdGl2ZURpYWxvZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GcmVxdWVuY3lQZW5hbHR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnJlcXVlbmN5UGVuYWx0eScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GcmVxdWVuY3lQZW5hbHR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnJlcXVlbmN5UGVuYWx0eSddLCBmcm9tRnJlcXVlbmN5UGVuYWx0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Mb2dwcm9icyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbG9ncHJvYnMnXSk7XG4gICAgaWYgKGZyb21Mb2dwcm9icyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xvZ3Byb2JzJ10sIGZyb21Mb2dwcm9icyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXhPdXRwdXRUb2tlbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtYXhPdXRwdXRUb2tlbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTWF4T3V0cHV0VG9rZW5zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWF4T3V0cHV0VG9rZW5zJ10sIGZyb21NYXhPdXRwdXRUb2tlbnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWVkaWFSZXNvbHV0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWVkaWFSZXNvbHV0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1lZGlhUmVzb2x1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21lZGlhUmVzb2x1dGlvbiddLCBmcm9tTWVkaWFSZXNvbHV0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByZXNlbmNlUGVuYWx0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ByZXNlbmNlUGVuYWx0eScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21QcmVzZW5jZVBlbmFsdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcmVzZW5jZVBlbmFsdHknXSwgZnJvbVByZXNlbmNlUGVuYWx0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZUxvZ3Byb2JzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VMb2dwcm9icycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZUxvZ3Byb2JzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VMb2dwcm9icyddLCBmcm9tUmVzcG9uc2VMb2dwcm9icyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VNaW1lVHlwZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VNaW1lVHlwZSddLCBmcm9tUmVzcG9uc2VNaW1lVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZU1vZGFsaXRpZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZU1vZGFsaXRpZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VNb2RhbGl0aWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VNb2RhbGl0aWVzJ10sIGZyb21SZXNwb25zZU1vZGFsaXRpZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VTY2hlbWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZVNjaGVtYScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZVNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlU2NoZW1hJ10sIGZyb21SZXNwb25zZVNjaGVtYSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Sb3V0aW5nQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncm91dGluZ0NvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Sb3V0aW5nQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncm91dGluZ0NvbmZpZyddLCBmcm9tUm91dGluZ0NvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZWVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzZWVkJ10pO1xuICAgIGlmIChmcm9tU2VlZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NlZWQnXSwgZnJvbVNlZWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3BlZWNoQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzcGVlY2hDb25maWcnXSk7XG4gICAgaWYgKGZyb21TcGVlY2hDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzcGVlY2hDb25maWcnXSwgc3BlZWNoQ29uZmlnVG9WZXJ0ZXgoZnJvbVNwZWVjaENvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RvcFNlcXVlbmNlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N0b3BTZXF1ZW5jZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU3RvcFNlcXVlbmNlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0b3BTZXF1ZW5jZXMnXSwgZnJvbVN0b3BTZXF1ZW5jZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGVtcGVyYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RlbXBlcmF0dXJlJ10pO1xuICAgIGlmIChmcm9tVGVtcGVyYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZW1wZXJhdHVyZSddLCBmcm9tVGVtcGVyYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhpbmtpbmdDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aGlua2luZ0NvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaGlua2luZ0NvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RoaW5raW5nQ29uZmlnJ10sIGZyb21UaGlua2luZ0NvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3BLID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3BLJ10pO1xuICAgIGlmIChmcm9tVG9wSyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RvcEsnXSwgZnJvbVRvcEspO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wUCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wUCddKTtcbiAgICBpZiAoZnJvbVRvcFAgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b3BQJ10sIGZyb21Ub3BQKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5hYmxlRW5oYW5jZWRDaXZpY0Fuc3dlcnMnXSkgIT09XG4gICAgICAgIHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VuYWJsZUVuaGFuY2VkQ2l2aWNBbnN3ZXJzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2V0TW9kZWxQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2V0TW9kZWxQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdvb2dsZU1hcHNUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXV0aENvbmZpZyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYXV0aENvbmZpZyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5hYmxlV2lkZ2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmFibGVXaWRnZXQnXSk7XG4gICAgaWYgKGZyb21FbmFibGVXaWRnZXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmFibGVXaWRnZXQnXSwgZnJvbUVuYWJsZVdpZGdldCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdvb2dsZVNlYXJjaFRvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydleGNsdWRlRG9tYWlucyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhjbHVkZURvbWFpbnMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmxvY2tpbmdDb25maWRlbmNlJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdibG9ja2luZ0NvbmZpZGVuY2UgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRpbWVSYW5nZUZpbHRlciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RpbWVSYW5nZUZpbHRlcicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaW1lUmFuZ2VGaWx0ZXIgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aW1lUmFuZ2VGaWx0ZXInXSwgZnJvbVRpbWVSYW5nZUZpbHRlcik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGltYWdlQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQXNwZWN0UmF0aW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FzcGVjdFJhdGlvJ10pO1xuICAgIGlmIChmcm9tQXNwZWN0UmF0aW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhc3BlY3RSYXRpbyddLCBmcm9tQXNwZWN0UmF0aW8pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW1hZ2VTaXplID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZVNpemUnXSk7XG4gICAgaWYgKGZyb21JbWFnZVNpemUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbWFnZVNpemUnXSwgZnJvbUltYWdlU2l6ZSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ291dHB1dE1pbWVUeXBlJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvdXRwdXRNaW1lVHlwZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydvdXRwdXRDb21wcmVzc2lvblF1YWxpdHknXSkgIT09XG4gICAgICAgIHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ291dHB1dENvbXByZXNzaW9uUXVhbGl0eSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBpbWFnZUNvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Bc3BlY3RSYXRpbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXNwZWN0UmF0aW8nXSk7XG4gICAgaWYgKGZyb21Bc3BlY3RSYXRpbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FzcGVjdFJhdGlvJ10sIGZyb21Bc3BlY3RSYXRpbyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbWFnZVNpemUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ltYWdlU2l6ZSddKTtcbiAgICBpZiAoZnJvbUltYWdlU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ltYWdlU2l6ZSddLCBmcm9tSW1hZ2VTaXplKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dE1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0TWltZVR5cGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tT3V0cHV0TWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbWFnZU91dHB1dE9wdGlvbnMnLCAnbWltZVR5cGUnXSwgZnJvbU91dHB1dE1pbWVUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dENvbXByZXNzaW9uUXVhbGl0eScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21PdXRwdXRDb21wcmVzc2lvblF1YWxpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbWFnZU91dHB1dE9wdGlvbnMnLCAnY29tcHJlc3Npb25RdWFsaXR5J10sIGZyb21PdXRwdXRDb21wcmVzc2lvblF1YWxpdHkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBpbWFnZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSW1hZ2VCeXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2J5dGVzQmFzZTY0RW5jb2RlZCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21JbWFnZUJ5dGVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW1hZ2VCeXRlcyddLCB0Qnl0ZXMoZnJvbUltYWdlQnl0ZXMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gaW1hZ2VGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21HY3NVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2djc1VyaSddKTtcbiAgICBpZiAoZnJvbUdjc1VyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2djc1VyaSddLCBmcm9tR2NzVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUltYWdlQnl0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdieXRlc0Jhc2U2NEVuY29kZWQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tSW1hZ2VCeXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ltYWdlQnl0ZXMnXSwgdEJ5dGVzKGZyb21JbWFnZUJ5dGVzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGltYWdlVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnY3NVcmknXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2djc1VyaSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW1hZ2VCeXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW1hZ2VCeXRlcyddKTtcbiAgICBpZiAoZnJvbUltYWdlQnl0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydieXRlc0Jhc2U2NEVuY29kZWQnXSwgdEJ5dGVzKGZyb21JbWFnZUJ5dGVzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGltYWdlVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUdjc1VyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ2NzVXJpJ10pO1xuICAgIGlmIChmcm9tR2NzVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2NzVXJpJ10sIGZyb21HY3NVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW1hZ2VCeXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW1hZ2VCeXRlcyddKTtcbiAgICBpZiAoZnJvbUltYWdlQnl0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydieXRlc0Jhc2U2NEVuY29kZWQnXSwgdEJ5dGVzKGZyb21JbWFnZUJ5dGVzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RNb2RlbHNDb25maWdUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFnZVNpemUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VTaXplJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVNpemUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VTaXplJ10sIGZyb21QYWdlU2l6ZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VUb2tlbiddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVRva2VuJ10sIGZyb21QYWdlVG9rZW4pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsdGVyID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWx0ZXInXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21GaWx0ZXIgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ2ZpbHRlciddLCBmcm9tRmlsdGVyKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVF1ZXJ5QmFzZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncXVlcnlCYXNlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUXVlcnlCYXNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ191cmwnLCAnbW9kZWxzX3VybCddLCB0TW9kZWxzVXJsKGFwaUNsaWVudCwgZnJvbVF1ZXJ5QmFzZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0TW9kZWxzQ29uZmlnVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYWdlU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVNpemUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVNpemUnXSwgZnJvbVBhZ2VTaXplKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVRva2VuJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlVG9rZW4nXSwgZnJvbVBhZ2VUb2tlbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWx0ZXIgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbHRlciddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUZpbHRlciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAnZmlsdGVyJ10sIGZyb21GaWx0ZXIpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUXVlcnlCYXNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydxdWVyeUJhc2UnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21RdWVyeUJhc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3VybCcsICdtb2RlbHNfdXJsJ10sIHRNb2RlbHNVcmwoYXBpQ2xpZW50LCBmcm9tUXVlcnlCYXNlKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RNb2RlbHNQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGxpc3RNb2RlbHNDb25maWdUb01sZGV2KGFwaUNsaWVudCwgZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0TW9kZWxzUGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgbGlzdE1vZGVsc0NvbmZpZ1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0TW9kZWxzUmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OZXh0UGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbmV4dFBhZ2VUb2tlbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21OZXh0UGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmV4dFBhZ2VUb2tlbiddLCBmcm9tTmV4dFBhZ2VUb2tlbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Nb2RlbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ19zZWxmJ10pO1xuICAgIGlmIChmcm9tTW9kZWxzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRFeHRyYWN0TW9kZWxzKGZyb21Nb2RlbHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZGVsRnJvbU1sZGV2KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZWxzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RNb2RlbHNSZXNwb25zZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OZXh0UGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbmV4dFBhZ2VUb2tlbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21OZXh0UGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmV4dFBhZ2VUb2tlbiddLCBmcm9tTmV4dFBhZ2VUb2tlbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Nb2RlbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ19zZWxmJ10pO1xuICAgIGlmIChmcm9tTW9kZWxzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRFeHRyYWN0TW9kZWxzKGZyb21Nb2RlbHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZGVsRnJvbVZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGVscyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBtYXNrUmVmZXJlbmNlQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1hc2tNb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtYXNrTW9kZSddKTtcbiAgICBpZiAoZnJvbU1hc2tNb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWFza01vZGUnXSwgZnJvbU1hc2tNb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlZ21lbnRhdGlvbkNsYXNzZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZWdtZW50YXRpb25DbGFzc2VzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNlZ21lbnRhdGlvbkNsYXNzZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtYXNrQ2xhc3NlcyddLCBmcm9tU2VnbWVudGF0aW9uQ2xhc3Nlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXNrRGlsYXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21hc2tEaWxhdGlvbiddKTtcbiAgICBpZiAoZnJvbU1hc2tEaWxhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RpbGF0aW9uJ10sIGZyb21NYXNrRGlsYXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBtb2RlbEZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAoZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXNjcmlwdGlvbiddKTtcbiAgICBpZiAoZnJvbURlc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVzY3JpcHRpb24nXSwgZnJvbURlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZlcnNpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZlcnNpb24nXSk7XG4gICAgaWYgKGZyb21WZXJzaW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmVyc2lvbiddLCBmcm9tVmVyc2lvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UdW5lZE1vZGVsSW5mbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnX3NlbGYnXSk7XG4gICAgaWYgKGZyb21UdW5lZE1vZGVsSW5mbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3R1bmVkTW9kZWxJbmZvJ10sIHR1bmVkTW9kZWxJbmZvRnJvbU1sZGV2KGZyb21UdW5lZE1vZGVsSW5mbykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5wdXRUb2tlbkxpbWl0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW5wdXRUb2tlbkxpbWl0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUlucHV0VG9rZW5MaW1pdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lucHV0VG9rZW5MaW1pdCddLCBmcm9tSW5wdXRUb2tlbkxpbWl0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dFRva2VuTGltaXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXRUb2tlbkxpbWl0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU91dHB1dFRva2VuTGltaXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydvdXRwdXRUb2tlbkxpbWl0J10sIGZyb21PdXRwdXRUb2tlbkxpbWl0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN1cHBvcnRlZEFjdGlvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzdXBwb3J0ZWRHZW5lcmF0aW9uTWV0aG9kcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TdXBwb3J0ZWRBY3Rpb25zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3VwcG9ydGVkQWN0aW9ucyddLCBmcm9tU3VwcG9ydGVkQWN0aW9ucyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZW1wZXJhdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGVtcGVyYXR1cmUnXSk7XG4gICAgaWYgKGZyb21UZW1wZXJhdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RlbXBlcmF0dXJlJ10sIGZyb21UZW1wZXJhdHVyZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXhUZW1wZXJhdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21heFRlbXBlcmF0dXJlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1heFRlbXBlcmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWF4VGVtcGVyYXR1cmUnXSwgZnJvbU1heFRlbXBlcmF0dXJlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvcFAgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvcFAnXSk7XG4gICAgaWYgKGZyb21Ub3BQICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9wUCddLCBmcm9tVG9wUCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3BLID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3BLJ10pO1xuICAgIGlmIChmcm9tVG9wSyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RvcEsnXSwgZnJvbVRvcEspO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhpbmtpbmcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RoaW5raW5nJ10pO1xuICAgIGlmIChmcm9tVGhpbmtpbmcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aGlua2luZyddLCBmcm9tVGhpbmtpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBtb2RlbEZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSk7XG4gICAgaWYgKGZyb21EaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10sIGZyb21EaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzY3JpcHRpb24nXSk7XG4gICAgaWYgKGZyb21EZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10sIGZyb21EZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21WZXJzaW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2ZXJzaW9uSWQnXSk7XG4gICAgaWYgKGZyb21WZXJzaW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmVyc2lvbiddLCBmcm9tVmVyc2lvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmRwb2ludHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RlcGxveWVkTW9kZWxzJ10pO1xuICAgIGlmIChmcm9tRW5kcG9pbnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21FbmRwb2ludHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kcG9pbnRGcm9tVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5kcG9pbnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYWJlbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhYmVscyddKTtcbiAgICBpZiAoZnJvbUxhYmVscyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xhYmVscyddLCBmcm9tTGFiZWxzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVR1bmVkTW9kZWxJbmZvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydfc2VsZiddKTtcbiAgICBpZiAoZnJvbVR1bmVkTW9kZWxJbmZvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHVuZWRNb2RlbEluZm8nXSwgdHVuZWRNb2RlbEluZm9Gcm9tVmVydGV4KGZyb21UdW5lZE1vZGVsSW5mbykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVmYXVsdENoZWNrcG9pbnRJZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2RlZmF1bHRDaGVja3BvaW50SWQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRGVmYXVsdENoZWNrcG9pbnRJZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RlZmF1bHRDaGVja3BvaW50SWQnXSwgZnJvbURlZmF1bHRDaGVja3BvaW50SWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2hlY2twb2ludHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NoZWNrcG9pbnRzJ10pO1xuICAgIGlmIChmcm9tQ2hlY2twb2ludHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUNoZWNrcG9pbnRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjaGVja3BvaW50cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBwYXJ0VG9NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21NZWRpYVJlc29sdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtZWRpYVJlc29sdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTWVkaWFSZXNvbHV0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWVkaWFSZXNvbHV0aW9uJ10sIGZyb21NZWRpYVJlc29sdXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb25SZXN1bHQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb25SZXN1bHQnXSwgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhlY3V0YWJsZUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdleGVjdXRhYmxlQ29kZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FeGVjdXRhYmxlQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4ZWN1dGFibGVDb2RlJ10sIGZyb21FeGVjdXRhYmxlQ29kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZURhdGEnXSk7XG4gICAgaWYgKGZyb21GaWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVEYXRhJ10sIGZpbGVEYXRhVG9NbGRldiQxKGZyb21GaWxlRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25DYWxsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmdW5jdGlvbkNhbGwnXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkNhbGwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkNhbGwnXSwgZnVuY3Rpb25DYWxsVG9NbGRldiQxKGZyb21GdW5jdGlvbkNhbGwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvblJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvblJlc3BvbnNlJ10sIGZyb21GdW5jdGlvblJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUlubGluZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lubGluZURhdGEnXSk7XG4gICAgaWYgKGZyb21JbmxpbmVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5saW5lRGF0YSddLCBibG9iVG9NbGRldiQxKGZyb21JbmxpbmVEYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZXh0J10pO1xuICAgIGlmIChmcm9tVGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RleHQnXSwgZnJvbVRleHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGhvdWdodCddKTtcbiAgICBpZiAoZnJvbVRob3VnaHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0J10sIGZyb21UaG91Z2h0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHRTaWduYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aG91Z2h0U2lnbmF0dXJlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRob3VnaHRTaWduYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0U2lnbmF0dXJlJ10sIGZyb21UaG91Z2h0U2lnbmF0dXJlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZpZGVvTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd2aWRlb01ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVZpZGVvTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlb01ldGFkYXRhJ10sIGZyb21WaWRlb01ldGFkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcHJvZHVjdEltYWdlVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVByb2R1Y3RJbWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHJvZHVjdEltYWdlJ10pO1xuICAgIGlmIChmcm9tUHJvZHVjdEltYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW1hZ2UnXSwgaW1hZ2VUb1ZlcnRleChmcm9tUHJvZHVjdEltYWdlKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHJlY29udGV4dEltYWdlQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTnVtYmVyT2ZJbWFnZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdudW1iZXJPZkltYWdlcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21OdW1iZXJPZkltYWdlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NhbXBsZUNvdW50J10sIGZyb21OdW1iZXJPZkltYWdlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21CYXNlU3RlcHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Jhc2VTdGVwcyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUJhc2VTdGVwcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2Jhc2VTdGVwcyddLCBmcm9tQmFzZVN0ZXBzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dEdjc1VyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnb3V0cHV0R2NzVXJpJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0R2NzVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc3RvcmFnZVVyaSddLCBmcm9tT3V0cHV0R2NzVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NlZWQnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TZWVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2VlZCddLCBmcm9tU2VlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TYWZldHlGaWx0ZXJMZXZlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NhZmV0eUZpbHRlckxldmVsJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNhZmV0eUZpbHRlckxldmVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2FmZXR5U2V0dGluZyddLCBmcm9tU2FmZXR5RmlsdGVyTGV2ZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGVyc29uR2VuZXJhdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3BlcnNvbkdlbmVyYXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGVyc29uR2VuZXJhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3BlcnNvbkdlbmVyYXRpb24nXSwgZnJvbVBlcnNvbkdlbmVyYXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQWRkV2F0ZXJtYXJrID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhZGRXYXRlcm1hcmsnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21BZGRXYXRlcm1hcmsgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdhZGRXYXRlcm1hcmsnXSwgZnJvbUFkZFdhdGVybWFyayk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRNaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dE1pbWVUeXBlJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dE1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnb3V0cHV0T3B0aW9ucycsICdtaW1lVHlwZSddLCBmcm9tT3V0cHV0TWltZVR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ291dHB1dE9wdGlvbnMnLCAnY29tcHJlc3Npb25RdWFsaXR5J10sIGZyb21PdXRwdXRDb21wcmVzc2lvblF1YWxpdHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5oYW5jZVByb21wdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2VuaGFuY2VQcm9tcHQnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRW5oYW5jZVByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2VuaGFuY2VQcm9tcHQnXSwgZnJvbUVuaGFuY2VQcm9tcHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFiZWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYWJlbHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21MYWJlbHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnbGFiZWxzJ10sIGZyb21MYWJlbHMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiByZWNvbnRleHRJbWFnZVBhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Tb3VyY2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NvdXJjZSddKTtcbiAgICBpZiAoZnJvbVNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgIHJlY29udGV4dEltYWdlU291cmNlVG9WZXJ0ZXgoZnJvbVNvdXJjZSwgdG9PYmplY3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICByZWNvbnRleHRJbWFnZUNvbmZpZ1RvVmVydGV4KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcmVjb250ZXh0SW1hZ2VSZXNwb25zZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUdlbmVyYXRlZEltYWdlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ByZWRpY3Rpb25zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdlbmVyYXRlZEltYWdlcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tR2VuZXJhdGVkSW1hZ2VzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlZEltYWdlRnJvbVZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dlbmVyYXRlZEltYWdlcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiByZWNvbnRleHRJbWFnZVNvdXJjZVRvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVByb21wdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHJvbXB0J10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUHJvbXB0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdwcm9tcHQnXSwgZnJvbVByb21wdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QZXJzb25JbWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGVyc29uSW1hZ2UnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QZXJzb25JbWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAncGVyc29uSW1hZ2UnLCAnaW1hZ2UnXSwgaW1hZ2VUb1ZlcnRleChmcm9tUGVyc29uSW1hZ2UpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByb2R1Y3RJbWFnZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcm9kdWN0SW1hZ2VzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVByb2R1Y3RJbWFnZXMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVByb2R1Y3RJbWFnZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvZHVjdEltYWdlVG9WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ3Byb2R1Y3RJbWFnZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcmVmZXJlbmNlSW1hZ2VBUElJbnRlcm5hbFRvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21SZWZlcmVuY2VJbWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JlZmVyZW5jZUltYWdlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlZmVyZW5jZUltYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVmZXJlbmNlSW1hZ2UnXSwgaW1hZ2VUb1ZlcnRleChmcm9tUmVmZXJlbmNlSW1hZ2UpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlZmVyZW5jZUlkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZWZlcmVuY2VJZCddKTtcbiAgICBpZiAoZnJvbVJlZmVyZW5jZUlkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVmZXJlbmNlSWQnXSwgZnJvbVJlZmVyZW5jZUlkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlZmVyZW5jZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZWZlcmVuY2VUeXBlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlZmVyZW5jZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZWZlcmVuY2VUeXBlJ10sIGZyb21SZWZlcmVuY2VUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1hc2tJbWFnZUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21hc2tJbWFnZUNvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NYXNrSW1hZ2VDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtYXNrSW1hZ2VDb25maWcnXSwgbWFza1JlZmVyZW5jZUNvbmZpZ1RvVmVydGV4KGZyb21NYXNrSW1hZ2VDb25maWcpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbnRyb2xJbWFnZUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvbnRyb2xJbWFnZUNvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db250cm9sSW1hZ2VDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb250cm9sSW1hZ2VDb25maWcnXSwgY29udHJvbFJlZmVyZW5jZUNvbmZpZ1RvVmVydGV4KGZyb21Db250cm9sSW1hZ2VDb25maWcpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0eWxlSW1hZ2VDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzdHlsZUltYWdlQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVN0eWxlSW1hZ2VDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdHlsZUltYWdlQ29uZmlnJ10sIGZyb21TdHlsZUltYWdlQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN1YmplY3RJbWFnZUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N1YmplY3RJbWFnZUNvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TdWJqZWN0SW1hZ2VDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdWJqZWN0SW1hZ2VDb25maWcnXSwgZnJvbVN1YmplY3RJbWFnZUNvbmZpZyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNhZmV0eUF0dHJpYnV0ZXNGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNhdGVnb3JpZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzYWZldHlBdHRyaWJ1dGVzJyxcbiAgICAgICAgJ2NhdGVnb3JpZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ2F0ZWdvcmllcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhdGVnb3JpZXMnXSwgZnJvbUNhdGVnb3JpZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2NvcmVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2FmZXR5QXR0cmlidXRlcycsXG4gICAgICAgICdzY29yZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2NvcmVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2NvcmVzJ10sIGZyb21TY29yZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGVudFR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnRUeXBlJ10pO1xuICAgIGlmIChmcm9tQ29udGVudFR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb250ZW50VHlwZSddLCBmcm9tQ29udGVudFR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzYWZldHlBdHRyaWJ1dGVzRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ2F0ZWdvcmllcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NhZmV0eUF0dHJpYnV0ZXMnLFxuICAgICAgICAnY2F0ZWdvcmllcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DYXRlZ29yaWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2F0ZWdvcmllcyddLCBmcm9tQ2F0ZWdvcmllcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TY29yZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzYWZldHlBdHRyaWJ1dGVzJyxcbiAgICAgICAgJ3Njb3JlcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TY29yZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzY29yZXMnXSwgZnJvbVNjb3Jlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250ZW50VHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udGVudFR5cGUnXSk7XG4gICAgaWYgKGZyb21Db250ZW50VHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbnRlbnRUeXBlJ10sIGZyb21Db250ZW50VHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNhZmV0eVNldHRpbmdUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21DYXRlZ29yeSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY2F0ZWdvcnknXSk7XG4gICAgaWYgKGZyb21DYXRlZ29yeSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhdGVnb3J5J10sIGZyb21DYXRlZ29yeSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21ldGhvZCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWV0aG9kIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaHJlc2hvbGQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RocmVzaG9sZCddKTtcbiAgICBpZiAoZnJvbVRocmVzaG9sZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RocmVzaG9sZCddLCBmcm9tVGhyZXNob2xkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc2NyaWJibGVJbWFnZVRvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21JbWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW1hZ2UnXSk7XG4gICAgaWYgKGZyb21JbWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ltYWdlJ10sIGltYWdlVG9WZXJ0ZXgoZnJvbUltYWdlKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNlZ21lbnRJbWFnZUNvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Nb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnbW9kZSddLCBmcm9tTW9kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXhQcmVkaWN0aW9ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21heFByZWRpY3Rpb25zJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU1heFByZWRpY3Rpb25zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnbWF4UHJlZGljdGlvbnMnXSwgZnJvbU1heFByZWRpY3Rpb25zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZGVuY2VUaHJlc2hvbGQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb25maWRlbmNlVGhyZXNob2xkJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUNvbmZpZGVuY2VUaHJlc2hvbGQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdjb25maWRlbmNlVGhyZXNob2xkJ10sIGZyb21Db25maWRlbmNlVGhyZXNob2xkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1hc2tEaWxhdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWFza0RpbGF0aW9uJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTWFza0RpbGF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnbWFza0RpbGF0aW9uJ10sIGZyb21NYXNrRGlsYXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQmluYXJ5Q29sb3JUaHJlc2hvbGQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdiaW5hcnlDb2xvclRocmVzaG9sZCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21CaW5hcnlDb2xvclRocmVzaG9sZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2JpbmFyeUNvbG9yVGhyZXNob2xkJ10sIGZyb21CaW5hcnlDb2xvclRocmVzaG9sZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYWJlbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhYmVscyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUxhYmVscyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydsYWJlbHMnXSwgZnJvbUxhYmVscyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNlZ21lbnRJbWFnZVBhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Tb3VyY2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NvdXJjZSddKTtcbiAgICBpZiAoZnJvbVNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgIHNlZ21lbnRJbWFnZVNvdXJjZVRvVmVydGV4KGZyb21Tb3VyY2UsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2VnbWVudEltYWdlQ29uZmlnVG9WZXJ0ZXgoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzZWdtZW50SW1hZ2VSZXNwb25zZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUdlbmVyYXRlZE1hc2tzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcmVkaWN0aW9ucyddKTtcbiAgICBpZiAoZnJvbUdlbmVyYXRlZE1hc2tzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21HZW5lcmF0ZWRNYXNrcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZWRJbWFnZU1hc2tGcm9tVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2VuZXJhdGVkTWFza3MnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc2VnbWVudEltYWdlU291cmNlVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcm9tcHQnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Qcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ3Byb21wdCddLCBmcm9tUHJvbXB0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUltYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUltYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdpbWFnZSddLCBpbWFnZVRvVmVydGV4KGZyb21JbWFnZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2NyaWJibGVJbWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NjcmliYmxlSW1hZ2UnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2NyaWJibGVJbWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAnc2NyaWJibGUnXSwgc2NyaWJibGVJbWFnZVRvVmVydGV4KGZyb21TY3JpYmJsZUltYWdlKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNwZWVjaENvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21MYW5ndWFnZUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhbmd1YWdlQ29kZSddKTtcbiAgICBpZiAoZnJvbUxhbmd1YWdlQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xhbmd1YWdlQ29kZSddLCBmcm9tTGFuZ3VhZ2VDb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZvaWNlQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2b2ljZUNvbmZpZyddKTtcbiAgICBpZiAoZnJvbVZvaWNlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndm9pY2VDb25maWcnXSwgZnJvbVZvaWNlQ29uZmlnKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbXVsdGlTcGVha2VyVm9pY2VDb25maWcnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ211bHRpU3BlYWtlclZvaWNlQ29uZmlnIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdG9vbENvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uQ2FsbGluZ0NvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uQ2FsbGluZ0NvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkNhbGxpbmdDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkNhbGxpbmdDb25maWcnXSwgZnVuY3Rpb25DYWxsaW5nQ29uZmlnVG9NbGRldihmcm9tRnVuY3Rpb25DYWxsaW5nQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXRyaWV2YWxDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXRyaWV2YWxDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmV0cmlldmFsQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmV0cmlldmFsQ29uZmlnJ10sIGZyb21SZXRyaWV2YWxDb25maWcpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0b29sVG9NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25EZWNsYXJhdGlvbnMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmV0cmlldmFsJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXRyaWV2YWwgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2hSZXRyaWV2YWwnXSwgZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db21wdXRlclVzZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29tcHV0ZXJVc2UnXSk7XG4gICAgaWYgKGZyb21Db21wdXRlclVzZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbXB1dGVyVXNlJ10sIGZyb21Db21wdXRlclVzZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlU2VhcmNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlU2VhcmNoJ10pO1xuICAgIGlmIChmcm9tRmlsZVNlYXJjaCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVTZWFyY2gnXSwgZnJvbUZpbGVTZWFyY2gpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb24nXSwgZnJvbUNvZGVFeGVjdXRpb24pO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbnRlcnByaXNlV2ViU2VhcmNoJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlbnRlcnByaXNlV2ViU2VhcmNoIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVNYXBzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVNYXBzJ10pO1xuICAgIGlmIChmcm9tR29vZ2xlTWFwcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZU1hcHMnXSwgZ29vZ2xlTWFwc1RvTWxkZXYkMShmcm9tR29vZ2xlTWFwcykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVTZWFyY2gnXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2ggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2gnXSwgZ29vZ2xlU2VhcmNoVG9NbGRldiQxKGZyb21Hb29nbGVTZWFyY2gpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVybENvbnRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VybENvbnRleHQnXSk7XG4gICAgaWYgKGZyb21VcmxDb250ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJsQ29udGV4dCddLCBmcm9tVXJsQ29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRvb2xUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvbkRlY2xhcmF0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb25EZWNsYXJhdGlvblRvVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25EZWNsYXJhdGlvbnMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJldHJpZXZhbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmV0cmlldmFsJ10pO1xuICAgIGlmIChmcm9tUmV0cmlldmFsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmV0cmlldmFsJ10sIGZyb21SZXRyaWV2YWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ29vZ2xlU2VhcmNoUmV0cmlldmFsJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCddLCBmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbXB1dGVyVXNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb21wdXRlclVzZSddKTtcbiAgICBpZiAoZnJvbUNvbXB1dGVyVXNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29tcHV0ZXJVc2UnXSwgZnJvbUNvbXB1dGVyVXNlKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZVNlYXJjaCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZmlsZVNlYXJjaCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvbiddLCBmcm9tQ29kZUV4ZWN1dGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbnRlcnByaXNlV2ViU2VhcmNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZW50ZXJwcmlzZVdlYlNlYXJjaCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FbnRlcnByaXNlV2ViU2VhcmNoICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW50ZXJwcmlzZVdlYlNlYXJjaCddLCBmcm9tRW50ZXJwcmlzZVdlYlNlYXJjaCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVNYXBzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVNYXBzJ10pO1xuICAgIGlmIChmcm9tR29vZ2xlTWFwcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZU1hcHMnXSwgZnJvbUdvb2dsZU1hcHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVTZWFyY2gnXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2ggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2gnXSwgZnJvbUdvb2dsZVNlYXJjaCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcmxDb250ZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cmxDb250ZXh0J10pO1xuICAgIGlmIChmcm9tVXJsQ29udGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VybENvbnRleHQnXSwgZnJvbVVybENvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0dW5lZE1vZGVsSW5mb0Zyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQmFzZU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydiYXNlTW9kZWwnXSk7XG4gICAgaWYgKGZyb21CYXNlTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydiYXNlTW9kZWwnXSwgZnJvbUJhc2VNb2RlbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DcmVhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjcmVhdGVUaW1lJ10pO1xuICAgIGlmIChmcm9tQ3JlYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSwgZnJvbUNyZWF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXBkYXRlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXBkYXRlVGltZSddKTtcbiAgICBpZiAoZnJvbVVwZGF0ZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cGRhdGVUaW1lJ10sIGZyb21VcGRhdGVUaW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdHVuZWRNb2RlbEluZm9Gcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21CYXNlTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdsYWJlbHMnLFxuICAgICAgICAnZ29vZ2xlLXZlcnRleC1sbG0tdHVuaW5nLWJhc2UtbW9kZWwtaWQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQmFzZU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYmFzZU1vZGVsJ10sIGZyb21CYXNlTW9kZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ3JlYXRlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY3JlYXRlVGltZSddKTtcbiAgICBpZiAoZnJvbUNyZWF0ZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjcmVhdGVUaW1lJ10sIGZyb21DcmVhdGVUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVwZGF0ZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VwZGF0ZVRpbWUnXSk7XG4gICAgaWYgKGZyb21VcGRhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXBkYXRlVGltZSddLCBmcm9tVXBkYXRlVGltZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZU1vZGVsQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21EaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRGVzY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZGVzY3JpcHRpb24nXSwgZnJvbURlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlZmF1bHRDaGVja3BvaW50SWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdkZWZhdWx0Q2hlY2twb2ludElkJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbURlZmF1bHRDaGVja3BvaW50SWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZGVmYXVsdENoZWNrcG9pbnRJZCddLCBmcm9tRGVmYXVsdENoZWNrcG9pbnRJZCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZU1vZGVsQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXNjcmlwdGlvbiddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbURlc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10sIGZyb21EZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZWZhdWx0Q2hlY2twb2ludElkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZGVmYXVsdENoZWNrcG9pbnRJZCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21EZWZhdWx0Q2hlY2twb2ludElkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2RlZmF1bHRDaGVja3BvaW50SWQnXSwgZnJvbURlZmF1bHRDaGVja3BvaW50SWQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cGRhdGVNb2RlbFBhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICB1cGRhdGVNb2RlbENvbmZpZ1RvTWxkZXYoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cGRhdGVNb2RlbFBhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHVwZGF0ZU1vZGVsQ29uZmlnVG9WZXJ0ZXgoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cHNjYWxlSW1hZ2VBUElDb25maWdJbnRlcm5hbFRvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU91dHB1dEdjc1VyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnb3V0cHV0R2NzVXJpJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0R2NzVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc3RvcmFnZVVyaSddLCBmcm9tT3V0cHV0R2NzVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNhZmV0eUZpbHRlckxldmVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2FmZXR5RmlsdGVyTGV2ZWwnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2FmZXR5RmlsdGVyTGV2ZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzYWZldHlTZXR0aW5nJ10sIGZyb21TYWZldHlGaWx0ZXJMZXZlbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QZXJzb25HZW5lcmF0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncGVyc29uR2VuZXJhdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QZXJzb25HZW5lcmF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAncGVyc29uR2VuZXJhdGlvbiddLCBmcm9tUGVyc29uR2VuZXJhdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmNsdWRlUmFpUmVhc29uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW5jbHVkZVJhaVJlYXNvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21JbmNsdWRlUmFpUmVhc29uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnaW5jbHVkZVJhaVJlYXNvbiddLCBmcm9tSW5jbHVkZVJhaVJlYXNvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRNaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dE1pbWVUeXBlJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dE1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnb3V0cHV0T3B0aW9ucycsICdtaW1lVHlwZSddLCBmcm9tT3V0cHV0TWltZVR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ291dHB1dE9wdGlvbnMnLCAnY29tcHJlc3Npb25RdWFsaXR5J10sIGZyb21PdXRwdXRDb21wcmVzc2lvblF1YWxpdHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5oYW5jZUlucHV0SW1hZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbmhhbmNlSW5wdXRJbWFnZScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FbmhhbmNlSW5wdXRJbWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3Vwc2NhbGVDb25maWcnLCAnZW5oYW5jZUlucHV0SW1hZ2UnXSwgZnJvbUVuaGFuY2VJbnB1dEltYWdlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUltYWdlUHJlc2VydmF0aW9uRmFjdG9yID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW1hZ2VQcmVzZXJ2YXRpb25GYWN0b3InLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tSW1hZ2VQcmVzZXJ2YXRpb25GYWN0b3IgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICd1cHNjYWxlQ29uZmlnJywgJ2ltYWdlUHJlc2VydmF0aW9uRmFjdG9yJ10sIGZyb21JbWFnZVByZXNlcnZhdGlvbkZhY3Rvcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYWJlbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhYmVscyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUxhYmVscyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydsYWJlbHMnXSwgZnJvbUxhYmVscyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OdW1iZXJPZkltYWdlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ251bWJlck9mSW1hZ2VzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU51bWJlck9mSW1hZ2VzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2FtcGxlQ291bnQnXSwgZnJvbU51bWJlck9mSW1hZ2VzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1vZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Nb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnbW9kZSddLCBmcm9tTW9kZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVwc2NhbGVJbWFnZUFQSVBhcmFtZXRlcnNJbnRlcm5hbFRvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUltYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZSddKTtcbiAgICBpZiAoZnJvbUltYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ2ltYWdlJ10sIGltYWdlVG9WZXJ0ZXgoZnJvbUltYWdlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcHNjYWxlRmFjdG9yID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndXBzY2FsZUZhY3RvcicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21VcHNjYWxlRmFjdG9yICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFyYW1ldGVycycsICd1cHNjYWxlQ29uZmlnJywgJ3Vwc2NhbGVGYWN0b3InXSwgZnJvbVVwc2NhbGVGYWN0b3IpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICB1cHNjYWxlSW1hZ2VBUElDb25maWdJbnRlcm5hbFRvVmVydGV4KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXBzY2FsZUltYWdlUmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR2VuZXJhdGVkSW1hZ2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJlZGljdGlvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR2VuZXJhdGVkSW1hZ2VzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21HZW5lcmF0ZWRJbWFnZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVkSW1hZ2VGcm9tVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2VuZXJhdGVkSW1hZ2VzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZpZGVvRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21VcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VyaSddKTtcbiAgICBpZiAoZnJvbVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VyaSddLCBmcm9tVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZpZGVvQnl0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuY29kZWRWaWRlbyddKTtcbiAgICBpZiAoZnJvbVZpZGVvQnl0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlb0J5dGVzJ10sIHRCeXRlcyhmcm9tVmlkZW9CeXRlcykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuY29kaW5nJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB2aWRlb0Zyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ2NzVXJpJ10pO1xuICAgIGlmIChmcm9tVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJpJ10sIGZyb21VcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmlkZW9CeXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2J5dGVzQmFzZTY0RW5jb2RlZCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21WaWRlb0J5dGVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW9CeXRlcyddLCB0Qnl0ZXMoZnJvbVZpZGVvQnl0ZXMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdmlkZW9HZW5lcmF0aW9uTWFza1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21JbWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW1hZ2UnXSk7XG4gICAgaWYgKGZyb21JbWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ19zZWxmJ10sIGltYWdlVG9WZXJ0ZXgoZnJvbUltYWdlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXNrTW9kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWFza01vZGUnXSk7XG4gICAgaWYgKGZyb21NYXNrTW9kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21hc2tNb2RlJ10sIGZyb21NYXNrTW9kZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZpZGVvR2VuZXJhdGlvblJlZmVyZW5jZUltYWdlVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSW1hZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ltYWdlJ10pO1xuICAgIGlmIChmcm9tSW1hZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbWFnZSddLCBpbWFnZVRvTWxkZXYoZnJvbUltYWdlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZWZlcmVuY2VUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVmZXJlbmNlVHlwZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZWZlcmVuY2VUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVmZXJlbmNlVHlwZSddLCBmcm9tUmVmZXJlbmNlVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZpZGVvR2VuZXJhdGlvblJlZmVyZW5jZUltYWdlVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUltYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZSddKTtcbiAgICBpZiAoZnJvbUltYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW1hZ2UnXSwgaW1hZ2VUb1ZlcnRleChmcm9tSW1hZ2UpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlZmVyZW5jZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZWZlcmVuY2VUeXBlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlZmVyZW5jZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZWZlcmVuY2VUeXBlJ10sIGZyb21SZWZlcmVuY2VUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdmlkZW9Ub01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21VcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VyaSddKTtcbiAgICBpZiAoZnJvbVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VyaSddLCBmcm9tVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZpZGVvQnl0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZpZGVvQnl0ZXMnXSk7XG4gICAgaWYgKGZyb21WaWRlb0J5dGVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5jb2RlZFZpZGVvJ10sIHRCeXRlcyhmcm9tVmlkZW9CeXRlcykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmNvZGluZyddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB2aWRlb1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21VcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VyaSddKTtcbiAgICBpZiAoZnJvbVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2djc1VyaSddLCBmcm9tVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZpZGVvQnl0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZpZGVvQnl0ZXMnXSk7XG4gICAgaWYgKGZyb21WaWRlb0J5dGVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYnl0ZXNCYXNlNjRFbmNvZGVkJ10sIHRCeXRlcyhmcm9tVmlkZW9CeXRlcykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmNvbnN0IENPTlRFTlRfVFlQRV9IRUFERVIgPSAnQ29udGVudC1UeXBlJztcbmNvbnN0IFNFUlZFUl9USU1FT1VUX0hFQURFUiA9ICdYLVNlcnZlci1UaW1lb3V0JztcbmNvbnN0IFVTRVJfQUdFTlRfSEVBREVSID0gJ1VzZXItQWdlbnQnO1xuY29uc3QgR09PR0xFX0FQSV9DTElFTlRfSEVBREVSID0gJ3gtZ29vZy1hcGktY2xpZW50JztcbmNvbnN0IFNES19WRVJTSU9OID0gJzEuMzAuMCc7IC8vIHgtcmVsZWFzZS1wbGVhc2UtdmVyc2lvblxuY29uc3QgTElCUkFSWV9MQUJFTCA9IGBnb29nbGUtZ2VuYWktc2RrLyR7U0RLX1ZFUlNJT059YDtcbmNvbnN0IFZFUlRFWF9BSV9BUElfREVGQVVMVF9WRVJTSU9OID0gJ3YxYmV0YTEnO1xuY29uc3QgR09PR0xFX0FJX0FQSV9ERUZBVUxUX1ZFUlNJT04gPSAndjFiZXRhJztcbmNvbnN0IHJlc3BvbnNlTGluZVJFID0gL15cXHMqZGF0YTogKC4qKSg/OlxcblxcbnxcXHJcXHJ8XFxyXFxuXFxyXFxuKS87XG4vKipcbiAqIFRoZSBBcGlDbGllbnQgY2xhc3MgaXMgdXNlZCB0byBzZW5kIHJlcXVlc3RzIHRvIHRoZSBHZW1pbmkgQVBJIG9yIFZlcnRleCBBSVxuICogZW5kcG9pbnRzLlxuICovXG5jbGFzcyBBcGlDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdGhpcy5jbGllbnRPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRzKSwgeyBwcm9qZWN0OiBvcHRzLnByb2plY3QsIGxvY2F0aW9uOiBvcHRzLmxvY2F0aW9uLCBhcGlLZXk6IG9wdHMuYXBpS2V5LCB2ZXJ0ZXhhaTogb3B0cy52ZXJ0ZXhhaSB9KTtcbiAgICAgICAgY29uc3QgaW5pdEh0dHBPcHRpb25zID0ge307XG4gICAgICAgIGlmICh0aGlzLmNsaWVudE9wdGlvbnMudmVydGV4YWkpIHtcbiAgICAgICAgICAgIGluaXRIdHRwT3B0aW9ucy5hcGlWZXJzaW9uID1cbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLmNsaWVudE9wdGlvbnMuYXBpVmVyc2lvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogVkVSVEVYX0FJX0FQSV9ERUZBVUxUX1ZFUlNJT047XG4gICAgICAgICAgICBpbml0SHR0cE9wdGlvbnMuYmFzZVVybCA9IHRoaXMuYmFzZVVybEZyb21Qcm9qZWN0TG9jYXRpb24oKTtcbiAgICAgICAgICAgIHRoaXMubm9ybWFsaXplQXV0aFBhcmFtZXRlcnMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEdlbWluaSBBUElcbiAgICAgICAgICAgIGluaXRIdHRwT3B0aW9ucy5hcGlWZXJzaW9uID1cbiAgICAgICAgICAgICAgICAoX2IgPSB0aGlzLmNsaWVudE9wdGlvbnMuYXBpVmVyc2lvbikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogR09PR0xFX0FJX0FQSV9ERUZBVUxUX1ZFUlNJT047XG4gICAgICAgICAgICBpbml0SHR0cE9wdGlvbnMuYmFzZVVybCA9IGBodHRwczovL2dlbmVyYXRpdmVsYW5ndWFnZS5nb29nbGVhcGlzLmNvbS9gO1xuICAgICAgICB9XG4gICAgICAgIGluaXRIdHRwT3B0aW9ucy5oZWFkZXJzID0gdGhpcy5nZXREZWZhdWx0SGVhZGVycygpO1xuICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMgPSBpbml0SHR0cE9wdGlvbnM7XG4gICAgICAgIGlmIChvcHRzLmh0dHBPcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMgPSB0aGlzLnBhdGNoSHR0cE9wdGlvbnMoaW5pdEh0dHBPcHRpb25zLCBvcHRzLmh0dHBPcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHRoZSBiYXNlIFVSTCBmb3IgVmVydGV4IEFJIGJhc2VkIG9uIHByb2plY3QgYW5kIGxvY2F0aW9uLlxuICAgICAqIFVzZXMgdGhlIGdsb2JhbCBlbmRwb2ludCBpZiBsb2NhdGlvbiBpcyAnZ2xvYmFsJyBvciBpZiBwcm9qZWN0L2xvY2F0aW9uXG4gICAgICogYXJlIG5vdCBzcGVjaWZpZWQgKGltcGx5aW5nIEFQSSBrZXkgdXNhZ2UpLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYmFzZVVybEZyb21Qcm9qZWN0TG9jYXRpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmNsaWVudE9wdGlvbnMucHJvamVjdCAmJlxuICAgICAgICAgICAgdGhpcy5jbGllbnRPcHRpb25zLmxvY2F0aW9uICYmXG4gICAgICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMubG9jYXRpb24gIT09ICdnbG9iYWwnKSB7XG4gICAgICAgICAgICAvLyBSZWdpb25hbCBlbmRwb2ludFxuICAgICAgICAgICAgcmV0dXJuIGBodHRwczovLyR7dGhpcy5jbGllbnRPcHRpb25zLmxvY2F0aW9ufS1haXBsYXRmb3JtLmdvb2dsZWFwaXMuY29tL2A7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2xvYmFsIGVuZHBvaW50IChjb3ZlcnMgJ2dsb2JhbCcgbG9jYXRpb24gYW5kIEFQSSBrZXkgdXNhZ2UpXG4gICAgICAgIHJldHVybiBgaHR0cHM6Ly9haXBsYXRmb3JtLmdvb2dsZWFwaXMuY29tL2A7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZXMgYXV0aGVudGljYXRpb24gcGFyYW1ldGVycyBmb3IgVmVydGV4IEFJLlxuICAgICAqIElmIHByb2plY3QgYW5kIGxvY2F0aW9uIGFyZSBwcm92aWRlZCwgQVBJIGtleSBpcyBjbGVhcmVkLlxuICAgICAqIElmIHByb2plY3QgYW5kIGxvY2F0aW9uIGFyZSBub3QgcHJvdmlkZWQgKGltcGx5aW5nIEFQSSBrZXkgdXNhZ2UpLFxuICAgICAqIHByb2plY3QgYW5kIGxvY2F0aW9uIGFyZSBjbGVhcmVkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgbm9ybWFsaXplQXV0aFBhcmFtZXRlcnMoKSB7XG4gICAgICAgIGlmICh0aGlzLmNsaWVudE9wdGlvbnMucHJvamVjdCAmJiB0aGlzLmNsaWVudE9wdGlvbnMubG9jYXRpb24pIHtcbiAgICAgICAgICAgIC8vIFVzaW5nIHByb2plY3QvbG9jYXRpb24gZm9yIGF1dGgsIGNsZWFyIHBvdGVudGlhbCBBUEkga2V5XG4gICAgICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMuYXBpS2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVzaW5nIEFQSSBrZXkgZm9yIGF1dGggKG9yIG5vIGF1dGggcHJvdmlkZWQgeWV0KSwgY2xlYXIgcHJvamVjdC9sb2NhdGlvblxuICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMucHJvamVjdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jbGllbnRPcHRpb25zLmxvY2F0aW9uID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpc1ZlcnRleEFJKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLmNsaWVudE9wdGlvbnMudmVydGV4YWkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlO1xuICAgIH1cbiAgICBnZXRQcm9qZWN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnRPcHRpb25zLnByb2plY3Q7XG4gICAgfVxuICAgIGdldExvY2F0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnRPcHRpb25zLmxvY2F0aW9uO1xuICAgIH1cbiAgICBnZXRBcGlWZXJzaW9uKCkge1xuICAgICAgICBpZiAodGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zICYmXG4gICAgICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMuYXBpVmVyc2lvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zLmFwaVZlcnNpb247XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBUEkgdmVyc2lvbiBpcyBub3Qgc2V0LicpO1xuICAgIH1cbiAgICBnZXRCYXNlVXJsKCkge1xuICAgICAgICBpZiAodGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zICYmXG4gICAgICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMuYmFzZVVybCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zLmJhc2VVcmw7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCYXNlIFVSTCBpcyBub3Qgc2V0LicpO1xuICAgIH1cbiAgICBnZXRSZXF1ZXN0VXJsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRSZXF1ZXN0VXJsSW50ZXJuYWwodGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zKTtcbiAgICB9XG4gICAgZ2V0SGVhZGVycygpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucyAmJlxuICAgICAgICAgICAgdGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zLmhlYWRlcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucy5oZWFkZXJzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIZWFkZXJzIGFyZSBub3Qgc2V0LicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFJlcXVlc3RVcmxJbnRlcm5hbChodHRwT3B0aW9ucykge1xuICAgICAgICBpZiAoIWh0dHBPcHRpb25zIHx8XG4gICAgICAgICAgICBodHRwT3B0aW9ucy5iYXNlVXJsID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIGh0dHBPcHRpb25zLmFwaVZlcnNpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIVFRQIG9wdGlvbnMgYXJlIG5vdCBjb3JyZWN0bHkgc2V0LicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJhc2VVcmwgPSBodHRwT3B0aW9ucy5iYXNlVXJsLmVuZHNXaXRoKCcvJylcbiAgICAgICAgICAgID8gaHR0cE9wdGlvbnMuYmFzZVVybC5zbGljZSgwLCAtMSlcbiAgICAgICAgICAgIDogaHR0cE9wdGlvbnMuYmFzZVVybDtcbiAgICAgICAgY29uc3QgdXJsRWxlbWVudCA9IFtiYXNlVXJsXTtcbiAgICAgICAgaWYgKGh0dHBPcHRpb25zLmFwaVZlcnNpb24gJiYgaHR0cE9wdGlvbnMuYXBpVmVyc2lvbiAhPT0gJycpIHtcbiAgICAgICAgICAgIHVybEVsZW1lbnQucHVzaChodHRwT3B0aW9ucy5hcGlWZXJzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJsRWxlbWVudC5qb2luKCcvJyk7XG4gICAgfVxuICAgIGdldEJhc2VSZXNvdXJjZVBhdGgoKSB7XG4gICAgICAgIHJldHVybiBgcHJvamVjdHMvJHt0aGlzLmNsaWVudE9wdGlvbnMucHJvamVjdH0vbG9jYXRpb25zLyR7dGhpcy5jbGllbnRPcHRpb25zLmxvY2F0aW9ufWA7XG4gICAgfVxuICAgIGdldEFwaUtleSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50T3B0aW9ucy5hcGlLZXk7XG4gICAgfVxuICAgIGdldFdlYnNvY2tldEJhc2VVcmwoKSB7XG4gICAgICAgIGNvbnN0IGJhc2VVcmwgPSB0aGlzLmdldEJhc2VVcmwoKTtcbiAgICAgICAgY29uc3QgdXJsUGFydHMgPSBuZXcgVVJMKGJhc2VVcmwpO1xuICAgICAgICB1cmxQYXJ0cy5wcm90b2NvbCA9IHVybFBhcnRzLnByb3RvY29sID09ICdodHRwOicgPyAnd3MnIDogJ3dzcyc7XG4gICAgICAgIHJldHVybiB1cmxQYXJ0cy50b1N0cmluZygpO1xuICAgIH1cbiAgICBzZXRCYXNlVXJsKHVybCkge1xuICAgICAgICBpZiAodGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMuYmFzZVVybCA9IHVybDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSFRUUCBvcHRpb25zIGFyZSBub3QgY29ycmVjdGx5IHNldC4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdHJ1Y3RVcmwocGF0aCwgaHR0cE9wdGlvbnMsIHByZXBlbmRQcm9qZWN0TG9jYXRpb24pIHtcbiAgICAgICAgY29uc3QgdXJsRWxlbWVudCA9IFt0aGlzLmdldFJlcXVlc3RVcmxJbnRlcm5hbChodHRwT3B0aW9ucyldO1xuICAgICAgICBpZiAocHJlcGVuZFByb2plY3RMb2NhdGlvbikge1xuICAgICAgICAgICAgdXJsRWxlbWVudC5wdXNoKHRoaXMuZ2V0QmFzZVJlc291cmNlUGF0aCgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0aCAhPT0gJycpIHtcbiAgICAgICAgICAgIHVybEVsZW1lbnQucHVzaChwYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGAke3VybEVsZW1lbnQuam9pbignLycpfWApO1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH1cbiAgICBzaG91bGRQcmVwZW5kVmVydGV4UHJvamVjdFBhdGgocmVxdWVzdCkge1xuICAgICAgICBpZiAodGhpcy5jbGllbnRPcHRpb25zLmFwaUtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5jbGllbnRPcHRpb25zLnZlcnRleGFpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcXVlc3QucGF0aC5zdGFydHNXaXRoKCdwcm9qZWN0cy8nKSkge1xuICAgICAgICAgICAgLy8gQXNzdW1lIHRoZSBwYXRoIGFscmVhZHkgc3RhcnRzIHdpdGhcbiAgICAgICAgICAgIC8vIGBwcm9qZWN0cy88cHJvamVjdD4vbG9jYXRpb24vPGxvY2F0aW9uPmAuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcXVlc3QuaHR0cE1ldGhvZCA9PT0gJ0dFVCcgJiZcbiAgICAgICAgICAgIHJlcXVlc3QucGF0aC5zdGFydHNXaXRoKCdwdWJsaXNoZXJzL2dvb2dsZS9tb2RlbHMnKSkge1xuICAgICAgICAgICAgLy8gVGhlc2UgcGF0aHMgYXJlIHVzZWQgYnkgVmVydGV4J3MgbW9kZWxzLmdldCBhbmQgbW9kZWxzLmxpc3RcbiAgICAgICAgICAgIC8vIGNhbGxzLiBGb3IgYmFzZSBtb2RlbHMgVmVydGV4IGRvZXMgbm90IGFjY2VwdCBhIHByb2plY3QvbG9jYXRpb25cbiAgICAgICAgICAgIC8vIHByZWZpeCAoZm9yIHR1bmVkIG1vZGVsIHRoZSBwcmVmaXggaXMgcmVxdWlyZWQpLlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBhc3luYyByZXF1ZXN0KHJlcXVlc3QpIHtcbiAgICAgICAgbGV0IHBhdGNoZWRIdHRwT3B0aW9ucyA9IHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucztcbiAgICAgICAgaWYgKHJlcXVlc3QuaHR0cE9wdGlvbnMpIHtcbiAgICAgICAgICAgIHBhdGNoZWRIdHRwT3B0aW9ucyA9IHRoaXMucGF0Y2hIdHRwT3B0aW9ucyh0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMsIHJlcXVlc3QuaHR0cE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZXBlbmRQcm9qZWN0TG9jYXRpb24gPSB0aGlzLnNob3VsZFByZXBlbmRWZXJ0ZXhQcm9qZWN0UGF0aChyZXF1ZXN0KTtcbiAgICAgICAgY29uc3QgdXJsID0gdGhpcy5jb25zdHJ1Y3RVcmwocmVxdWVzdC5wYXRoLCBwYXRjaGVkSHR0cE9wdGlvbnMsIHByZXBlbmRQcm9qZWN0TG9jYXRpb24pO1xuICAgICAgICBpZiAocmVxdWVzdC5xdWVyeVBhcmFtcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocmVxdWVzdC5xdWVyeVBhcmFtcykpIHtcbiAgICAgICAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIFN0cmluZyh2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCByZXF1ZXN0SW5pdCA9IHt9O1xuICAgICAgICBpZiAocmVxdWVzdC5odHRwTWV0aG9kID09PSAnR0VUJykge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3QuYm9keSAmJiByZXF1ZXN0LmJvZHkgIT09ICd7fScpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVlc3QgYm9keSBzaG91bGQgYmUgZW1wdHkgZm9yIEdFVCByZXF1ZXN0LCBidXQgZ290IG5vbiBlbXB0eSByZXF1ZXN0IGJvZHknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcXVlc3RJbml0LmJvZHkgPSByZXF1ZXN0LmJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdEluaXQgPSBhd2FpdCB0aGlzLmluY2x1ZGVFeHRyYUh0dHBPcHRpb25zVG9SZXF1ZXN0SW5pdChyZXF1ZXN0SW5pdCwgcGF0Y2hlZEh0dHBPcHRpb25zLCB1cmwudG9TdHJpbmcoKSwgcmVxdWVzdC5hYm9ydFNpZ25hbCk7XG4gICAgICAgIHJldHVybiB0aGlzLnVuYXJ5QXBpQ2FsbCh1cmwsIHJlcXVlc3RJbml0LCByZXF1ZXN0Lmh0dHBNZXRob2QpO1xuICAgIH1cbiAgICBwYXRjaEh0dHBPcHRpb25zKGJhc2VIdHRwT3B0aW9ucywgcmVxdWVzdEh0dHBPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHBhdGNoZWRIdHRwT3B0aW9ucyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoYmFzZUh0dHBPcHRpb25zKSk7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHJlcXVlc3RIdHRwT3B0aW9ucykpIHtcbiAgICAgICAgICAgIC8vIFJlY29yZHMgY29tcGlsZSB0byBvYmplY3RzLlxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRTMjM0NVRTNzA1MzogRWxlbWVudCBpbXBsaWNpdGx5IGhhcyBhbiAnYW55JyB0eXBlXG4gICAgICAgICAgICAgICAgLy8gYmVjYXVzZSBleHByZXNzaW9uIG9mIHR5cGUgJ3N0cmluZycgY2FuJ3QgYmUgdXNlZCB0byBpbmRleCB0eXBlXG4gICAgICAgICAgICAgICAgLy8gJ0h0dHBPcHRpb25zJy5cbiAgICAgICAgICAgICAgICBwYXRjaGVkSHR0cE9wdGlvbnNba2V5XSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGF0Y2hlZEh0dHBPcHRpb25zW2tleV0pLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUUzIzNDVUUzcwNTM6IEVsZW1lbnQgaW1wbGljaXRseSBoYXMgYW4gJ2FueScgdHlwZVxuICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgZXhwcmVzc2lvbiBvZiB0eXBlICdzdHJpbmcnIGNhbid0IGJlIHVzZWQgdG8gaW5kZXggdHlwZVxuICAgICAgICAgICAgICAgIC8vICdIdHRwT3B0aW9ucycuXG4gICAgICAgICAgICAgICAgcGF0Y2hlZEh0dHBPcHRpb25zW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0Y2hlZEh0dHBPcHRpb25zO1xuICAgIH1cbiAgICBhc3luYyByZXF1ZXN0U3RyZWFtKHJlcXVlc3QpIHtcbiAgICAgICAgbGV0IHBhdGNoZWRIdHRwT3B0aW9ucyA9IHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucztcbiAgICAgICAgaWYgKHJlcXVlc3QuaHR0cE9wdGlvbnMpIHtcbiAgICAgICAgICAgIHBhdGNoZWRIdHRwT3B0aW9ucyA9IHRoaXMucGF0Y2hIdHRwT3B0aW9ucyh0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMsIHJlcXVlc3QuaHR0cE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZXBlbmRQcm9qZWN0TG9jYXRpb24gPSB0aGlzLnNob3VsZFByZXBlbmRWZXJ0ZXhQcm9qZWN0UGF0aChyZXF1ZXN0KTtcbiAgICAgICAgY29uc3QgdXJsID0gdGhpcy5jb25zdHJ1Y3RVcmwocmVxdWVzdC5wYXRoLCBwYXRjaGVkSHR0cE9wdGlvbnMsIHByZXBlbmRQcm9qZWN0TG9jYXRpb24pO1xuICAgICAgICBpZiAoIXVybC5zZWFyY2hQYXJhbXMuaGFzKCdhbHQnKSB8fCB1cmwuc2VhcmNoUGFyYW1zLmdldCgnYWx0JykgIT09ICdzc2UnKSB7XG4gICAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgnYWx0JywgJ3NzZScpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXF1ZXN0SW5pdCA9IHt9O1xuICAgICAgICByZXF1ZXN0SW5pdC5ib2R5ID0gcmVxdWVzdC5ib2R5O1xuICAgICAgICByZXF1ZXN0SW5pdCA9IGF3YWl0IHRoaXMuaW5jbHVkZUV4dHJhSHR0cE9wdGlvbnNUb1JlcXVlc3RJbml0KHJlcXVlc3RJbml0LCBwYXRjaGVkSHR0cE9wdGlvbnMsIHVybC50b1N0cmluZygpLCByZXF1ZXN0LmFib3J0U2lnbmFsKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtQXBpQ2FsbCh1cmwsIHJlcXVlc3RJbml0LCByZXF1ZXN0Lmh0dHBNZXRob2QpO1xuICAgIH1cbiAgICBhc3luYyBpbmNsdWRlRXh0cmFIdHRwT3B0aW9uc1RvUmVxdWVzdEluaXQocmVxdWVzdEluaXQsIGh0dHBPcHRpb25zLCB1cmwsIGFib3J0U2lnbmFsKSB7XG4gICAgICAgIGlmICgoaHR0cE9wdGlvbnMgJiYgaHR0cE9wdGlvbnMudGltZW91dCkgfHwgYWJvcnRTaWduYWwpIHtcbiAgICAgICAgICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hbCA9IGFib3J0Q29udHJvbGxlci5zaWduYWw7XG4gICAgICAgICAgICBpZiAoaHR0cE9wdGlvbnMudGltZW91dCAmJiAoaHR0cE9wdGlvbnMgPT09IG51bGwgfHwgaHR0cE9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGh0dHBPcHRpb25zLnRpbWVvdXQpID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVvdXRIYW5kbGUgPSBzZXRUaW1lb3V0KCgpID0+IGFib3J0Q29udHJvbGxlci5hYm9ydCgpLCBodHRwT3B0aW9ucy50aW1lb3V0KTtcbiAgICAgICAgICAgICAgICBpZiAodGltZW91dEhhbmRsZSAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgdGltZW91dEhhbmRsZS51bnJlZiA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FsbCB1bnJlZiB0byBwcmV2ZW50IG5vZGVqcyBwcm9jZXNzIGZyb20gaGFuZ2luZywgc2VlXG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvdGltZXJzLmh0bWwjdGltZW91dHVucmVmXG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXRIYW5kbGUudW5yZWYoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWJvcnRTaWduYWwpIHtcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXF1ZXN0SW5pdC5zaWduYWwgPSBzaWduYWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGh0dHBPcHRpb25zICYmIGh0dHBPcHRpb25zLmV4dHJhQm9keSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5jbHVkZUV4dHJhQm9keVRvUmVxdWVzdEluaXQocmVxdWVzdEluaXQsIGh0dHBPcHRpb25zLmV4dHJhQm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdEluaXQuaGVhZGVycyA9IGF3YWl0IHRoaXMuZ2V0SGVhZGVyc0ludGVybmFsKGh0dHBPcHRpb25zLCB1cmwpO1xuICAgICAgICByZXR1cm4gcmVxdWVzdEluaXQ7XG4gICAgfVxuICAgIGFzeW5jIHVuYXJ5QXBpQ2FsbCh1cmwsIHJlcXVlc3RJbml0LCBodHRwTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwaUNhbGwodXJsLnRvU3RyaW5nKCksIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVxdWVzdEluaXQpLCB7IG1ldGhvZDogaHR0cE1ldGhvZCB9KSlcbiAgICAgICAgICAgIC50aGVuKGFzeW5jIChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgdGhyb3dFcnJvcklmTm90T0socmVzcG9uc2UpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBIdHRwUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihKU09OLnN0cmluZ2lmeShlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBzdHJlYW1BcGlDYWxsKHVybCwgcmVxdWVzdEluaXQsIGh0dHBNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBpQ2FsbCh1cmwudG9TdHJpbmcoKSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXF1ZXN0SW5pdCksIHsgbWV0aG9kOiBodHRwTWV0aG9kIH0pKVxuICAgICAgICAgICAgLnRoZW4oYXN5bmMgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCB0aHJvd0Vycm9ySWZOb3RPSyhyZXNwb25zZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzU3RyZWFtUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihKU09OLnN0cmluZ2lmeShlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwcm9jZXNzU3RyZWFtUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiBwcm9jZXNzU3RyZWFtUmVzcG9uc2VfMSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IChfYSA9IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5ib2R5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0UmVhZGVyKCk7XG4gICAgICAgICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCd1dGYtOCcpO1xuICAgICAgICAgICAgaWYgKCFyZWFkZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc3BvbnNlIGJvZHkgaXMgZW1wdHknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IGJ1ZmZlciA9ICcnO1xuICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IHlpZWxkIF9fYXdhaXQocmVhZGVyLnJlYWQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYnVmZmVyLnRyaW0oKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvbXBsZXRlIEpTT04gc2VnbWVudCBhdCB0aGUgZW5kJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVua1N0cmluZyA9IGRlY29kZXIuZGVjb2RlKHZhbHVlLCB7IHN0cmVhbTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgYW5kIHRocm93IGFuIGVycm9yIGlmIHRoZSBjaHVuayBjb250YWlucyBhbiBlcnJvci5cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rSnNvbiA9IEpTT04ucGFyc2UoY2h1bmtTdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCdlcnJvcicgaW4gY2h1bmtKc29uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JKc29uID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShjaHVua0pzb25bJ2Vycm9yJ10pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGF0dXMgPSBlcnJvckpzb25bJ3N0YXR1cyddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBlcnJvckpzb25bJ2NvZGUnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBgZ290IHN0YXR1czogJHtzdGF0dXN9LiAke0pTT04uc3RyaW5naWZ5KGNodW5rSnNvbil9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZSA+PSA0MDAgJiYgY29kZSA8IDYwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhcGlFcnJvciA9IG5ldyBBcGlFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJvck1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IGNvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBhcGlFcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5uYW1lID09PSAnQXBpRXJyb3InKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBidWZmZXIgKz0gY2h1bmtTdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtYXRjaCA9IGJ1ZmZlci5tYXRjaChyZXNwb25zZUxpbmVSRSk7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2VkQ2h1bmtTdHJpbmcgPSBtYXRjaFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFydGlhbFJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKHByb2Nlc3NlZENodW5rU3RyaW5nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQobmV3IEh0dHBSZXNwb25zZShwYXJ0aWFsUmVzcG9uc2UpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UobWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IGJ1ZmZlci5tYXRjaChyZXNwb25zZUxpbmVSRSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhjZXB0aW9uIHBhcnNpbmcgc3RyZWFtIGNodW5rICR7cHJvY2Vzc2VkQ2h1bmtTdHJpbmd9LiAke2V9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICByZWFkZXIucmVsZWFzZUxvY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGFwaUNhbGwodXJsLCByZXF1ZXN0SW5pdCkge1xuICAgICAgICByZXR1cm4gZmV0Y2godXJsLCByZXF1ZXN0SW5pdCkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhjZXB0aW9uICR7ZX0gc2VuZGluZyByZXF1ZXN0YCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXREZWZhdWx0SGVhZGVycygpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHt9O1xuICAgICAgICBjb25zdCB2ZXJzaW9uSGVhZGVyVmFsdWUgPSBMSUJSQVJZX0xBQkVMICsgJyAnICsgdGhpcy5jbGllbnRPcHRpb25zLnVzZXJBZ2VudEV4dHJhO1xuICAgICAgICBoZWFkZXJzW1VTRVJfQUdFTlRfSEVBREVSXSA9IHZlcnNpb25IZWFkZXJWYWx1ZTtcbiAgICAgICAgaGVhZGVyc1tHT09HTEVfQVBJX0NMSUVOVF9IRUFERVJdID0gdmVyc2lvbkhlYWRlclZhbHVlO1xuICAgICAgICBoZWFkZXJzW0NPTlRFTlRfVFlQRV9IRUFERVJdID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICByZXR1cm4gaGVhZGVycztcbiAgICB9XG4gICAgYXN5bmMgZ2V0SGVhZGVyc0ludGVybmFsKGh0dHBPcHRpb25zLCB1cmwpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gICAgICAgIGlmIChodHRwT3B0aW9ucyAmJiBodHRwT3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhodHRwT3B0aW9ucy5oZWFkZXJzKSkge1xuICAgICAgICAgICAgICAgIGhlYWRlcnMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQXBwZW5kIGEgdGltZW91dCBoZWFkZXIgaWYgaXQgaXMgc2V0LCBub3RlIHRoYXQgdGhlIHRpbWVvdXQgb3B0aW9uIGlzXG4gICAgICAgICAgICAvLyBpbiBtaWxsaXNlY29uZHMgYnV0IHRoZSBoZWFkZXIgaXMgaW4gc2Vjb25kcy5cbiAgICAgICAgICAgIGlmIChodHRwT3B0aW9ucy50aW1lb3V0ICYmIGh0dHBPcHRpb25zLnRpbWVvdXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVycy5hcHBlbmQoU0VSVkVSX1RJTUVPVVRfSEVBREVSLCBTdHJpbmcoTWF0aC5jZWlsKGh0dHBPcHRpb25zLnRpbWVvdXQgLyAxMDAwKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMuY2xpZW50T3B0aW9ucy5hdXRoLmFkZEF1dGhIZWFkZXJzKGhlYWRlcnMsIHVybCk7XG4gICAgICAgIHJldHVybiBoZWFkZXJzO1xuICAgIH1cbiAgICBnZXRGaWxlTmFtZShmaWxlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IGZpbGVOYW1lID0gJyc7XG4gICAgICAgIGlmICh0eXBlb2YgZmlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGZpbGVOYW1lID0gZmlsZS5yZXBsYWNlKC9bL1xcXFxdKyQvLCAnJyk7XG4gICAgICAgICAgICBmaWxlTmFtZSA9IChfYSA9IGZpbGVOYW1lLnNwbGl0KC9bL1xcXFxdLykucG9wKCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaWxlTmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBsb2FkcyBhIGZpbGUgYXN5bmNocm9ub3VzbHkgdXNpbmcgR2VtaW5pIEFQSSBvbmx5LCB0aGlzIGlzIG5vdCBzdXBwb3J0ZWRcbiAgICAgKiBpbiBWZXJ0ZXggQUkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmlsZSBUaGUgc3RyaW5nIHBhdGggdG8gdGhlIGZpbGUgdG8gYmUgdXBsb2FkZWQgb3IgYSBCbG9iIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gY29uZmlnIE9wdGlvbmFsIHBhcmFtZXRlcnMgc3BlY2lmaWVkIGluIHRoZSBgVXBsb2FkRmlsZUNvbmZpZ2BcbiAgICAgKiAgICAgaW50ZXJmYWNlLiBAc2VlIHtAbGluayB0eXBlcy5VcGxvYWRGaWxlQ29uZmlnfVxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRmlsZWAgb2JqZWN0LlxuICAgICAqIEB0aHJvd3MgQW4gZXJyb3IgaWYgY2FsbGVkIG9uIGEgVmVydGV4IEFJIGNsaWVudC5cbiAgICAgKiBAdGhyb3dzIEFuIGVycm9yIGlmIHRoZSBgbWltZVR5cGVgIGlzIG5vdCBwcm92aWRlZCBhbmQgY2FuIG5vdCBiZSBpbmZlcnJlZCxcbiAgICAgKi9cbiAgICBhc3luYyB1cGxvYWRGaWxlKGZpbGUsIGNvbmZpZykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGZpbGVUb1VwbG9hZCA9IHt9O1xuICAgICAgICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgICAgIGZpbGVUb1VwbG9hZC5taW1lVHlwZSA9IGNvbmZpZy5taW1lVHlwZTtcbiAgICAgICAgICAgIGZpbGVUb1VwbG9hZC5uYW1lID0gY29uZmlnLm5hbWU7XG4gICAgICAgICAgICBmaWxlVG9VcGxvYWQuZGlzcGxheU5hbWUgPSBjb25maWcuZGlzcGxheU5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbGVUb1VwbG9hZC5uYW1lICYmICFmaWxlVG9VcGxvYWQubmFtZS5zdGFydHNXaXRoKCdmaWxlcy8nKSkge1xuICAgICAgICAgICAgZmlsZVRvVXBsb2FkLm5hbWUgPSBgZmlsZXMvJHtmaWxlVG9VcGxvYWQubmFtZX1gO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVwbG9hZGVyID0gdGhpcy5jbGllbnRPcHRpb25zLnVwbG9hZGVyO1xuICAgICAgICBjb25zdCBmaWxlU3RhdCA9IGF3YWl0IHVwbG9hZGVyLnN0YXQoZmlsZSk7XG4gICAgICAgIGZpbGVUb1VwbG9hZC5zaXplQnl0ZXMgPSBTdHJpbmcoZmlsZVN0YXQuc2l6ZSk7XG4gICAgICAgIGNvbnN0IG1pbWVUeXBlID0gKF9hID0gY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLm1pbWVUeXBlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmaWxlU3RhdC50eXBlO1xuICAgICAgICBpZiAobWltZVR5cGUgPT09IHVuZGVmaW5lZCB8fCBtaW1lVHlwZSA9PT0gJycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBkZXRlcm1pbmUgbWltZVR5cGUuIFBsZWFzZSBwcm92aWRlIG1pbWVUeXBlIGluIHRoZSBjb25maWcuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZmlsZVRvVXBsb2FkLm1pbWVUeXBlID0gbWltZVR5cGU7XG4gICAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgICAgICBmaWxlOiBmaWxlVG9VcGxvYWQsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGZpbGVOYW1lID0gdGhpcy5nZXRGaWxlTmFtZShmaWxlKTtcbiAgICAgICAgY29uc3QgcGF0aCA9IGZvcm1hdE1hcCgndXBsb2FkL3YxYmV0YS9maWxlcycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgIGNvbnN0IHVwbG9hZFVybCA9IGF3YWl0IHRoaXMuZmV0Y2hVcGxvYWRVcmwocGF0aCwgZmlsZVRvVXBsb2FkLnNpemVCeXRlcywgZmlsZVRvVXBsb2FkLm1pbWVUeXBlLCBmaWxlTmFtZSwgYm9keSwgY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLmh0dHBPcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHVwbG9hZGVyLnVwbG9hZChmaWxlLCB1cGxvYWRVcmwsIHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGxvYWRzIGEgZmlsZSB0byBhIGdpdmVuIGZpbGUgc2VhcmNoIHN0b3JlIGFzeW5jaHJvbm91c2x5IHVzaW5nIEdlbWluaSBBUEkgb25seSwgdGhpcyBpcyBub3Qgc3VwcG9ydGVkXG4gICAgICogaW4gVmVydGV4IEFJLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZpbGVTZWFyY2hTdG9yZU5hbWUgVGhlIG5hbWUgb2YgdGhlIGZpbGUgc2VhcmNoIHN0b3JlIHRvIHVwbG9hZCB0aGUgZmlsZSB0by5cbiAgICAgKiBAcGFyYW0gZmlsZSBUaGUgc3RyaW5nIHBhdGggdG8gdGhlIGZpbGUgdG8gYmUgdXBsb2FkZWQgb3IgYSBCbG9iIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gY29uZmlnIE9wdGlvbmFsIHBhcmFtZXRlcnMgc3BlY2lmaWVkIGluIHRoZSBgVXBsb2FkRmlsZUNvbmZpZ2BcbiAgICAgKiAgICAgaW50ZXJmYWNlLiBAc2VlIHtAbGluayBVcGxvYWRGaWxlQ29uZmlnfVxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBgRmlsZWAgb2JqZWN0LlxuICAgICAqIEB0aHJvd3MgQW4gZXJyb3IgaWYgY2FsbGVkIG9uIGEgVmVydGV4IEFJIGNsaWVudC5cbiAgICAgKiBAdGhyb3dzIEFuIGVycm9yIGlmIHRoZSBgbWltZVR5cGVgIGlzIG5vdCBwcm92aWRlZCBhbmQgY2FuIG5vdCBiZSBpbmZlcnJlZCxcbiAgICAgKi9cbiAgICBhc3luYyB1cGxvYWRGaWxlVG9GaWxlU2VhcmNoU3RvcmUoZmlsZVNlYXJjaFN0b3JlTmFtZSwgZmlsZSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgdXBsb2FkZXIgPSB0aGlzLmNsaWVudE9wdGlvbnMudXBsb2FkZXI7XG4gICAgICAgIGNvbnN0IGZpbGVTdGF0ID0gYXdhaXQgdXBsb2FkZXIuc3RhdChmaWxlKTtcbiAgICAgICAgY29uc3Qgc2l6ZUJ5dGVzID0gU3RyaW5nKGZpbGVTdGF0LnNpemUpO1xuICAgICAgICBjb25zdCBtaW1lVHlwZSA9IChfYSA9IGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5taW1lVHlwZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmlsZVN0YXQudHlwZTtcbiAgICAgICAgaWYgKG1pbWVUeXBlID09PSB1bmRlZmluZWQgfHwgbWltZVR5cGUgPT09ICcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgZGV0ZXJtaW5lIG1pbWVUeXBlLiBQbGVhc2UgcHJvdmlkZSBtaW1lVHlwZSBpbiB0aGUgY29uZmlnLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhdGggPSBgdXBsb2FkL3YxYmV0YS8ke2ZpbGVTZWFyY2hTdG9yZU5hbWV9OnVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlYDtcbiAgICAgICAgY29uc3QgZmlsZU5hbWUgPSB0aGlzLmdldEZpbGVOYW1lKGZpbGUpO1xuICAgICAgICBjb25zdCBib2R5ID0ge307XG4gICAgICAgIGlmIChjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcuY3VzdG9tTWV0YWRhdGEpIHtcbiAgICAgICAgICAgIGJvZHlbJ2N1c3RvbU1ldGFkYXRhJ10gPSBjb25maWcuY3VzdG9tTWV0YWRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5jaHVua2luZ0NvbmZpZykge1xuICAgICAgICAgICAgYm9keVsnY2h1bmtpbmdDb25maWcnXSA9IGNvbmZpZy5jaHVua2luZ0NvbmZpZztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cGxvYWRVcmwgPSBhd2FpdCB0aGlzLmZldGNoVXBsb2FkVXJsKHBhdGgsIHNpemVCeXRlcywgbWltZVR5cGUsIGZpbGVOYW1lLCBib2R5LCBjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcuaHR0cE9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdXBsb2FkZXIudXBsb2FkVG9GaWxlU2VhcmNoU3RvcmUoZmlsZSwgdXBsb2FkVXJsLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRG93bmxvYWRzIGEgZmlsZSBhc3luY2hyb25vdXNseSB0byB0aGUgc3BlY2lmaWVkIHBhdGguXG4gICAgICpcbiAgICAgKiBAcGFyYW1zIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgZG93bmxvYWQgcmVxdWVzdCwgc2VlIHtAbGlua1xuICAgICAqIHR5cGVzLkRvd25sb2FkRmlsZVBhcmFtZXRlcnN9XG4gICAgICovXG4gICAgYXN5bmMgZG93bmxvYWRGaWxlKHBhcmFtcykge1xuICAgICAgICBjb25zdCBkb3dubG9hZGVyID0gdGhpcy5jbGllbnRPcHRpb25zLmRvd25sb2FkZXI7XG4gICAgICAgIGF3YWl0IGRvd25sb2FkZXIuZG93bmxvYWQocGFyYW1zLCB0aGlzKTtcbiAgICB9XG4gICAgYXN5bmMgZmV0Y2hVcGxvYWRVcmwocGF0aCwgc2l6ZUJ5dGVzLCBtaW1lVHlwZSwgZmlsZU5hbWUsIGJvZHksIGNvbmZpZ0h0dHBPcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IGh0dHBPcHRpb25zID0ge307XG4gICAgICAgIGlmIChjb25maWdIdHRwT3B0aW9ucykge1xuICAgICAgICAgICAgaHR0cE9wdGlvbnMgPSBjb25maWdIdHRwT3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGh0dHBPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIGFwaVZlcnNpb246ICcnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLCAnWC1Hb29nLVVwbG9hZC1Qcm90b2NvbCc6ICdyZXN1bWFibGUnLCAnWC1Hb29nLVVwbG9hZC1Db21tYW5kJzogJ3N0YXJ0JywgJ1gtR29vZy1VcGxvYWQtSGVhZGVyLUNvbnRlbnQtTGVuZ3RoJzogYCR7c2l6ZUJ5dGVzfWAsICdYLUdvb2ctVXBsb2FkLUhlYWRlci1Db250ZW50LVR5cGUnOiBgJHttaW1lVHlwZX1gIH0sIChmaWxlTmFtZSA/IHsgJ1gtR29vZy1VcGxvYWQtRmlsZS1OYW1lJzogZmlsZU5hbWUgfSA6IHt9KSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGh0dHBSZXNwb25zZSA9IGF3YWl0IHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBodHRwT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghaHR0cFJlc3BvbnNlIHx8ICEoaHR0cFJlc3BvbnNlID09PSBudWxsIHx8IGh0dHBSZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaHR0cFJlc3BvbnNlLmhlYWRlcnMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlcnZlciBkaWQgbm90IHJldHVybiBhbiBIdHRwUmVzcG9uc2Ugb3IgdGhlIHJldHVybmVkIEh0dHBSZXNwb25zZSBkaWQgbm90IGhhdmUgaGVhZGVycy4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cGxvYWRVcmwgPSAoX2EgPSBodHRwUmVzcG9uc2UgPT09IG51bGwgfHwgaHR0cFJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBodHRwUmVzcG9uc2UuaGVhZGVycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWyd4LWdvb2ctdXBsb2FkLXVybCddO1xuICAgICAgICBpZiAodXBsb2FkVXJsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGdldCB1cGxvYWQgdXJsLiBTZXJ2ZXIgZGlkIG5vdCByZXR1cm4gdGhlIHgtZ29vZ2xlLXVwbG9hZC11cmwgaW4gdGhlIGhlYWRlcnMnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXBsb2FkVXJsO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHRocm93RXJyb3JJZk5vdE9LKHJlc3BvbnNlKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChyZXNwb25zZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmVzcG9uc2UgaXMgdW5kZWZpbmVkJyk7XG4gICAgfVxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzO1xuICAgICAgICBsZXQgZXJyb3JCb2R5O1xuICAgICAgICBpZiAoKF9hID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaW5jbHVkZXMoJ2FwcGxpY2F0aW9uL2pzb24nKSkge1xuICAgICAgICAgICAgZXJyb3JCb2R5ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXJyb3JCb2R5ID0ge1xuICAgICAgICAgICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGF3YWl0IHJlc3BvbnNlLnRleHQoKSxcbiAgICAgICAgICAgICAgICAgICAgY29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gSlNPTi5zdHJpbmdpZnkoZXJyb3JCb2R5KTtcbiAgICAgICAgaWYgKHN0YXR1cyA+PSA0MDAgJiYgc3RhdHVzIDwgNjAwKSB7XG4gICAgICAgICAgICBjb25zdCBhcGlFcnJvciA9IG5ldyBBcGlFcnJvcih7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JNZXNzYWdlLFxuICAgICAgICAgICAgICAgIHN0YXR1czogc3RhdHVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aHJvdyBhcGlFcnJvcjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICB9XG59XG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHVwZGF0ZXMgdGhlIGByZXF1ZXN0SW5pdC5ib2R5YCB3aXRoIHZhbHVlcyBmcm9tIGFuIGBleHRyYUJvZHlgIG9iamVjdC5cbiAqXG4gKiBJZiBgcmVxdWVzdEluaXQuYm9keWAgaXMgYSBzdHJpbmcsIGl0J3MgYXNzdW1lZCB0byBiZSBKU09OIGFuZCB3aWxsIGJlIHBhcnNlZC5cbiAqIFRoZSBgZXh0cmFCb2R5YCBpcyB0aGVuIGRlZXBseSBtZXJnZWQgaW50byB0aGlzIHBhcnNlZCBvYmplY3QuXG4gKiBJZiBgcmVxdWVzdEluaXQuYm9keWAgaXMgYSBCbG9iLCBgZXh0cmFCb2R5YCB3aWxsIGJlIGlnbm9yZWQsIGFuZCBhIHdhcm5pbmcgbG9nZ2VkLFxuICogYXMgbWVyZ2luZyBzdHJ1Y3R1cmVkIGRhdGEgaW50byBhbiBvcGFxdWUgQmxvYiBpcyBub3Qgc3VwcG9ydGVkLlxuICpcbiAqIFRoZSBmdW5jdGlvbiBkb2VzIG5vdCBlbmZvcmNlIHRoYXQgdXBkYXRlZCB2YWx1ZXMgZnJvbSBgZXh0cmFCb2R5YCBoYXZlIHRoZVxuICogc2FtZSB0eXBlIGFzIGV4aXN0aW5nIHZhbHVlcyBpbiBgcmVxdWVzdEluaXQuYm9keWAuIFR5cGUgbWlzbWF0Y2hlcyBkdXJpbmdcbiAqIHRoZSBtZXJnZSB3aWxsIHJlc3VsdCBpbiBhIHdhcm5pbmcsIGJ1dCB0aGUgdmFsdWUgZnJvbSBgZXh0cmFCb2R5YCB3aWxsIG92ZXJ3cml0ZVxuICogdGhlIG9yaWdpbmFsLiBgZXh0cmFCb2R5YCB1c2VycyBhcmUgcmVzcG9uc2libGUgZm9yIGVuc3VyaW5nIGBleHRyYUJvZHlgIGhhcyB0aGUgY29ycmVjdCBzdHJ1Y3R1cmUuXG4gKlxuICogQHBhcmFtIHJlcXVlc3RJbml0IFRoZSBSZXF1ZXN0SW5pdCBvYmplY3Qgd2hvc2UgYm9keSB3aWxsIGJlIHVwZGF0ZWQuXG4gKiBAcGFyYW0gZXh0cmFCb2R5IFRoZSBvYmplY3QgY29udGFpbmluZyB1cGRhdGVzIHRvIGJlIG1lcmdlZCBpbnRvIGByZXF1ZXN0SW5pdC5ib2R5YC5cbiAqL1xuZnVuY3Rpb24gaW5jbHVkZUV4dHJhQm9keVRvUmVxdWVzdEluaXQocmVxdWVzdEluaXQsIGV4dHJhQm9keSkge1xuICAgIGlmICghZXh0cmFCb2R5IHx8IE9iamVjdC5rZXlzKGV4dHJhQm9keSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHJlcXVlc3RJbml0LmJvZHkgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignaW5jbHVkZUV4dHJhQm9keVRvUmVxdWVzdEluaXQ6IGV4dHJhQm9keSBwcm92aWRlZCBidXQgY3VycmVudCByZXF1ZXN0IGJvZHkgaXMgYSBCbG9iLiBleHRyYUJvZHkgd2lsbCBiZSBpZ25vcmVkIGFzIG1lcmdpbmcgaXMgbm90IHN1cHBvcnRlZCBmb3IgQmxvYiBib2RpZXMuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGN1cnJlbnRCb2R5T2JqZWN0ID0ge307XG4gICAgLy8gSWYgYWRkaW5nIG5ldyB0eXBlIHRvIEh0dHBSZXF1ZXN0LmJvZHksIHBsZWFzZSBjaGVjayB0aGUgY29kZSBiZWxvdyB0b1xuICAgIC8vIHNlZSBpZiB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgbG9naWMuXG4gICAgaWYgKHR5cGVvZiByZXF1ZXN0SW5pdC5ib2R5ID09PSAnc3RyaW5nJyAmJiByZXF1ZXN0SW5pdC5ib2R5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZEJvZHkgPSBKU09OLnBhcnNlKHJlcXVlc3RJbml0LmJvZHkpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJzZWRCb2R5ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgIHBhcnNlZEJvZHkgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICAhQXJyYXkuaXNBcnJheShwYXJzZWRCb2R5KSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCb2R5T2JqZWN0ID0gcGFyc2VkQm9keTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignaW5jbHVkZUV4dHJhQm9keVRvUmVxdWVzdEluaXQ6IE9yaWdpbmFsIHJlcXVlc3QgYm9keSBpcyB2YWxpZCBKU09OIGJ1dCBub3QgYSBub24tYXJyYXkgb2JqZWN0LiBTa2lwIGFwcGx5aW5nIGV4dHJhQm9keSB0byB0aGUgcmVxdWVzdCBib2R5LicpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qICBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzICovXG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignaW5jbHVkZUV4dHJhQm9keVRvUmVxdWVzdEluaXQ6IE9yaWdpbmFsIHJlcXVlc3QgYm9keSBpcyBub3QgdmFsaWQgSlNPTi4gU2tpcCBhcHBseWluZyBleHRyYUJvZHkgdG8gdGhlIHJlcXVlc3QgYm9keS4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkZWVwTWVyZ2UodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gT2JqZWN0LmFzc2lnbih7fSwgdGFyZ2V0KTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZVZhbHVlID0gc291cmNlW2tleV07XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0VmFsdWUgPSBvdXRwdXRba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlVmFsdWUgJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHNvdXJjZVZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgICAgICAhQXJyYXkuaXNBcnJheShzb3VyY2VWYWx1ZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0VmFsdWUgJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHRhcmdldFZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgICAgICAhQXJyYXkuaXNBcnJheSh0YXJnZXRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W2tleV0gPSBkZWVwTWVyZ2UodGFyZ2V0VmFsdWUsIHNvdXJjZVZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRWYWx1ZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlVmFsdWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiB0YXJnZXRWYWx1ZSAhPT0gdHlwZW9mIHNvdXJjZVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYGluY2x1ZGVFeHRyYUJvZHlUb1JlcXVlc3RJbml0OmRlZXBNZXJnZTogVHlwZSBtaXNtYXRjaCBmb3Iga2V5IFwiJHtrZXl9XCIuIE9yaWdpbmFsIHR5cGU6ICR7dHlwZW9mIHRhcmdldFZhbHVlfSwgTmV3IHR5cGU6ICR7dHlwZW9mIHNvdXJjZVZhbHVlfS4gT3ZlcndyaXRpbmcuYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W2tleV0gPSBzb3VyY2VWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gICAgY29uc3QgbWVyZ2VkQm9keSA9IGRlZXBNZXJnZShjdXJyZW50Qm9keU9iamVjdCwgZXh0cmFCb2R5KTtcbiAgICByZXF1ZXN0SW5pdC5ib2R5ID0gSlNPTi5zdHJpbmdpZnkobWVyZ2VkQm9keSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbi8vIFRPRE86IGIvNDE2MDQxMjI5IC0gRGV0ZXJtaW5lIGhvdyB0byByZXRyaWV2ZSB0aGUgTUNQIHBhY2thZ2UgdmVyc2lvbi5cbmNvbnN0IE1DUF9MQUJFTCA9ICdtY3BfdXNlZC91bmtub3duJztcbi8vIFdoZXRoZXIgTUNQIHRvb2wgdXNhZ2UgaXMgZGV0ZWN0ZWQgZnJvbSBtY3BUb1Rvb2wuIFRoaXMgaXMgdXNlZCBmb3Jcbi8vIHRlbGVtZXRyeS5cbmxldCBoYXNNY3BUb29sVXNhZ2VGcm9tTWNwVG9Ub29sID0gZmFsc2U7XG4vLyBDaGVja3Mgd2hldGhlciB0aGUgbGlzdCBvZiB0b29scyBjb250YWlucyBhbnkgTUNQIHRvb2xzLlxuZnVuY3Rpb24gaGFzTWNwVG9vbFVzYWdlKHRvb2xzKSB7XG4gICAgZm9yIChjb25zdCB0b29sIG9mIHRvb2xzKSB7XG4gICAgICAgIGlmIChpc01jcENhbGxhYmxlVG9vbCh0b29sKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0b29sID09PSAnb2JqZWN0JyAmJiAnaW5wdXRTY2hlbWEnIGluIHRvb2wpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBoYXNNY3BUb29sVXNhZ2VGcm9tTWNwVG9Ub29sO1xufVxuLy8gU2V0cyB0aGUgTUNQIHZlcnNpb24gbGFiZWwgaW4gdGhlIEdvb2dsZSBBUEkgY2xpZW50IGhlYWRlci5cbmZ1bmN0aW9uIHNldE1jcFVzYWdlSGVhZGVyKGhlYWRlcnMpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgZXhpc3RpbmdIZWFkZXIgPSAoX2EgPSBoZWFkZXJzW0dPT0dMRV9BUElfQ0xJRU5UX0hFQURFUl0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnO1xuICAgIGhlYWRlcnNbR09PR0xFX0FQSV9DTElFTlRfSEVBREVSXSA9IChleGlzdGluZ0hlYWRlciArIGAgJHtNQ1BfTEFCRUx9YCkudHJpbVN0YXJ0KCk7XG59XG4vLyBSZXR1cm5zIHRydWUgaWYgdGhlIG9iamVjdCBpcyBhIE1DUCBDYWxsYWJsZVRvb2wsIG90aGVyd2lzZSBmYWxzZS5cbmZ1bmN0aW9uIGlzTWNwQ2FsbGFibGVUb29sKG9iamVjdCkge1xuICAgIHJldHVybiAob2JqZWN0ICE9PSBudWxsICYmXG4gICAgICAgIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICAgIG9iamVjdCBpbnN0YW5jZW9mIE1jcENhbGxhYmxlVG9vbCk7XG59XG4vLyBMaXN0IGFsbCB0b29scyBmcm9tIHRoZSBNQ1AgY2xpZW50LlxuZnVuY3Rpb24gbGlzdEFsbFRvb2xzKG1jcENsaWVudCwgbWF4VG9vbHMgPSAxMDApIHtcbiAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiBsaXN0QWxsVG9vbHNfMSgpIHtcbiAgICAgICAgbGV0IGN1cnNvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IG51bVRvb2xzID0gMDtcbiAgICAgICAgd2hpbGUgKG51bVRvb2xzIDwgbWF4VG9vbHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHQgPSB5aWVsZCBfX2F3YWl0KG1jcENsaWVudC5saXN0VG9vbHMoeyBjdXJzb3IgfSkpO1xuICAgICAgICAgICAgZm9yIChjb25zdCB0b29sIG9mIHQudG9vbHMpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KHRvb2wpO1xuICAgICAgICAgICAgICAgIG51bVRvb2xzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXQubmV4dEN1cnNvcikge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3Vyc29yID0gdC5uZXh0Q3Vyc29yO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vKipcbiAqIE1jcENhbGxhYmxlVG9vbCBjYW4gYmUgdXNlZCBmb3IgbW9kZWwgaW5mZXJlbmNlIGFuZCBpbnZva2luZyBNQ1AgY2xpZW50cyB3aXRoXG4gKiBnaXZlbiBmdW5jdGlvbiBjYWxsIGFyZ3VtZW50cy5cbiAqXG4gKiBAZXhwZXJpbWVudGFsIEJ1aWx0LWluIE1DUCBzdXBwb3J0IGlzIGFuIGV4cGVyaW1lbnRhbCBmZWF0dXJlLCBtYXkgY2hhbmdlIGluIGZ1dHVyZVxuICogdmVyc2lvbnMuXG4gKi9cbmNsYXNzIE1jcENhbGxhYmxlVG9vbCB7XG4gICAgY29uc3RydWN0b3IobWNwQ2xpZW50cyA9IFtdLCBjb25maWcpIHtcbiAgICAgICAgdGhpcy5tY3BUb29scyA9IFtdO1xuICAgICAgICB0aGlzLmZ1bmN0aW9uTmFtZVRvTWNwQ2xpZW50ID0ge307XG4gICAgICAgIHRoaXMubWNwQ2xpZW50cyA9IG1jcENsaWVudHM7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgTWNwQ2FsbGFibGVUb29sLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUobWNwQ2xpZW50cywgY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWNwQ2FsbGFibGVUb29sKG1jcENsaWVudHMsIGNvbmZpZyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyB0aGUgZnVuY3Rpb24gbmFtZXMgYXJlIG5vdCBkdXBsaWNhdGUgYW5kIGluaXRpYWxpemUgdGhlIGZ1bmN0aW9uXG4gICAgICogbmFtZSB0byBNQ1AgY2xpZW50IG1hcHBpbmcuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIE1DUCB0b29scyBmcm9tIHRoZSBNQ1AgY2xpZW50cyBoYXZlIGR1cGxpY2F0ZSB0b29sXG4gICAgICogICAgIG5hbWVzLlxuICAgICAqL1xuICAgIGFzeW5jIGluaXRpYWxpemUoKSB7XG4gICAgICAgIHZhciBfYSwgZV8xLCBfYiwgX2M7XG4gICAgICAgIGlmICh0aGlzLm1jcFRvb2xzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmdW5jdGlvbk1hcCA9IHt9O1xuICAgICAgICBjb25zdCBtY3BUb29scyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IG1jcENsaWVudCBvZiB0aGlzLm1jcENsaWVudHMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2QgPSB0cnVlLCBfZSA9IChlXzEgPSB2b2lkIDAsIF9fYXN5bmNWYWx1ZXMobGlzdEFsbFRvb2xzKG1jcENsaWVudCkpKSwgX2Y7IF9mID0gYXdhaXQgX2UubmV4dCgpLCBfYSA9IF9mLmRvbmUsICFfYTsgX2QgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jID0gX2YudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIF9kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1jcFRvb2wgPSBfYztcbiAgICAgICAgICAgICAgICAgICAgbWNwVG9vbHMucHVzaChtY3BUb29sKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWNwVG9vbE5hbWUgPSBtY3BUb29sLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmdW5jdGlvbk1hcFttY3BUb29sTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGZ1bmN0aW9uIG5hbWUgJHttY3BUb29sTmFtZX0gZm91bmQgaW4gTUNQIHRvb2xzLiBQbGVhc2UgZW5zdXJlIGZ1bmN0aW9uIG5hbWVzIGFyZSB1bmlxdWUuYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25NYXBbbWNwVG9vbE5hbWVdID0gbWNwQ2xpZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV9kICYmICFfYSAmJiAoX2IgPSBfZS5yZXR1cm4pKSBhd2FpdCBfYi5jYWxsKF9lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubWNwVG9vbHMgPSBtY3BUb29scztcbiAgICAgICAgdGhpcy5mdW5jdGlvbk5hbWVUb01jcENsaWVudCA9IGZ1bmN0aW9uTWFwO1xuICAgIH1cbiAgICBhc3luYyB0b29sKCkge1xuICAgICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemUoKTtcbiAgICAgICAgcmV0dXJuIG1jcFRvb2xzVG9HZW1pbmlUb29sKHRoaXMubWNwVG9vbHMsIHRoaXMuY29uZmlnKTtcbiAgICB9XG4gICAgYXN5bmMgY2FsbFRvb2woZnVuY3Rpb25DYWxscykge1xuICAgICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemUoKTtcbiAgICAgICAgY29uc3QgZnVuY3Rpb25DYWxsUmVzcG9uc2VQYXJ0cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGZ1bmN0aW9uQ2FsbCBvZiBmdW5jdGlvbkNhbGxzKSB7XG4gICAgICAgICAgICBpZiAoZnVuY3Rpb25DYWxsLm5hbWUgaW4gdGhpcy5mdW5jdGlvbk5hbWVUb01jcENsaWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1jcENsaWVudCA9IHRoaXMuZnVuY3Rpb25OYW1lVG9NY3BDbGllbnRbZnVuY3Rpb25DYWxsLm5hbWVdO1xuICAgICAgICAgICAgICAgIGxldCByZXF1ZXN0T3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBiLzQyNDIzODY1NCAtIEFkZCBzdXBwb3J0IGZvciBmaW5lciBncmFpbmVkIHRpbWVvdXQgY29udHJvbC5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25maWcudGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0T3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQ6IHRoaXMuY29uZmlnLnRpbWVvdXQsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxUb29sUmVzcG9uc2UgPSBhd2FpdCBtY3BDbGllbnQuY2FsbFRvb2woe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBmdW5jdGlvbkNhbGwubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBmdW5jdGlvbkNhbGwuYXJncyxcbiAgICAgICAgICAgICAgICB9LCBcbiAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIHJlc3VsdCBzY2hlbWEgdG8gdW5kZWZpbmVkIHRvIGFsbG93IE1DUCB0byByZWx5IG9uIHRoZVxuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgc2NoZW1hLlxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCwgcmVxdWVzdE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uQ2FsbFJlc3BvbnNlUGFydHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uUmVzcG9uc2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGZ1bmN0aW9uQ2FsbC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IGNhbGxUb29sUmVzcG9uc2UuaXNFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8geyBlcnJvcjogY2FsbFRvb2xSZXNwb25zZSB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjYWxsVG9vbFJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbkNhbGxSZXNwb25zZVBhcnRzO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzTWNwQ2xpZW50KGNsaWVudCkge1xuICAgIHJldHVybiAoY2xpZW50ICE9PSBudWxsICYmXG4gICAgICAgIHR5cGVvZiBjbGllbnQgPT09ICdvYmplY3QnICYmXG4gICAgICAgICdsaXN0VG9vbHMnIGluIGNsaWVudCAmJlxuICAgICAgICB0eXBlb2YgY2xpZW50Lmxpc3RUb29scyA9PT0gJ2Z1bmN0aW9uJyk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBNY3BDYWxsYWJsZVRvb2wgZnJvbSBNQ1AgY2xpZW50cyBhbmQgYW4gb3B0aW9uYWwgY29uZmlnLlxuICpcbiAqIFRoZSBjYWxsYWJsZSB0b29sIGNhbiBpbnZva2UgdGhlIE1DUCBjbGllbnRzIHdpdGggZ2l2ZW4gZnVuY3Rpb24gY2FsbFxuICogYXJndW1lbnRzLiAob2Z0ZW4gZm9yIGF1dG9tYXRpYyBmdW5jdGlvbiBjYWxsaW5nKS5cbiAqIFVzZSB0aGUgY29uZmlnIHRvIG1vZGlmeSB0b29sIHBhcmFtZXRlcnMgc3VjaCBhcyBiZWhhdmlvci5cbiAqXG4gKiBAZXhwZXJpbWVudGFsIEJ1aWx0LWluIE1DUCBzdXBwb3J0IGlzIGFuIGV4cGVyaW1lbnRhbCBmZWF0dXJlLCBtYXkgY2hhbmdlIGluIGZ1dHVyZVxuICogdmVyc2lvbnMuXG4gKi9cbmZ1bmN0aW9uIG1jcFRvVG9vbCguLi5hcmdzKSB7XG4gICAgLy8gU2V0IE1DUCB1c2FnZSBmb3IgdGVsZW1ldHJ5LlxuICAgIGhhc01jcFRvb2xVc2FnZUZyb21NY3BUb1Rvb2wgPSB0cnVlO1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIE1DUCBjbGllbnRzIHByb3ZpZGVkJyk7XG4gICAgfVxuICAgIGNvbnN0IG1heWJlQ29uZmlnID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICAgIGlmIChpc01jcENsaWVudChtYXliZUNvbmZpZykpIHtcbiAgICAgICAgcmV0dXJuIE1jcENhbGxhYmxlVG9vbC5jcmVhdGUoYXJncywge30pO1xuICAgIH1cbiAgICByZXR1cm4gTWNwQ2FsbGFibGVUb29sLmNyZWF0ZShhcmdzLnNsaWNlKDAsIGFyZ3MubGVuZ3RoIC0gMSksIG1heWJlQ29uZmlnKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuLyoqXG4gKiBIYW5kbGVzIGluY29taW5nIG1lc3NhZ2VzIGZyb20gdGhlIFdlYlNvY2tldC5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhpcyBmdW5jdGlvbiBpcyByZXNwb25zaWJsZSBmb3IgcGFyc2luZyBpbmNvbWluZyBtZXNzYWdlcywgdHJhbnNmb3JtaW5nIHRoZW1cbiAqIGludG8gTGl2ZU11c2ljU2VydmVyTWVzc2FnZSwgYW5kIHRoZW4gY2FsbGluZyB0aGUgb25tZXNzYWdlIGNhbGxiYWNrLlxuICogTm90ZSB0aGF0IHRoZSBmaXJzdCBtZXNzYWdlIHdoaWNoIGlzIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlciBpcyBhXG4gKiBzZXR1cENvbXBsZXRlIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIGFwaUNsaWVudCBUaGUgQXBpQ2xpZW50IGluc3RhbmNlLlxuICogQHBhcmFtIG9ubWVzc2FnZSBUaGUgdXNlci1wcm92aWRlZCBvbm1lc3NhZ2UgY2FsbGJhY2sgKGlmIGFueSkuXG4gKiBAcGFyYW0gZXZlbnQgVGhlIE1lc3NhZ2VFdmVudCBmcm9tIHRoZSBXZWJTb2NrZXQuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZVdlYlNvY2tldE1lc3NhZ2UkMShhcGlDbGllbnQsIG9ubWVzc2FnZSwgZXZlbnQpIHtcbiAgICBjb25zdCBzZXJ2ZXJNZXNzYWdlID0gbmV3IExpdmVNdXNpY1NlcnZlck1lc3NhZ2UoKTtcbiAgICBsZXQgZGF0YTtcbiAgICBpZiAoZXZlbnQuZGF0YSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoYXdhaXQgZXZlbnQuZGF0YS50ZXh0KCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24oc2VydmVyTWVzc2FnZSwgZGF0YSk7XG4gICAgb25tZXNzYWdlKHNlcnZlck1lc3NhZ2UpO1xufVxuLyoqXG4gICBMaXZlTXVzaWMgY2xhc3MgZW5jYXBzdWxhdGVzIHRoZSBjb25maWd1cmF0aW9uIGZvciBsaXZlIG11c2ljXG4gICBnZW5lcmF0aW9uIHZpYSBMeXJpYSBMaXZlIG1vZGVscy5cblxuICAgQGV4cGVyaW1lbnRhbFxuICAqL1xuY2xhc3MgTGl2ZU11c2ljIHtcbiAgICBjb25zdHJ1Y3RvcihhcGlDbGllbnQsIGF1dGgsIHdlYlNvY2tldEZhY3RvcnkpIHtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBhcGlDbGllbnQ7XG4gICAgICAgIHRoaXMuYXV0aCA9IGF1dGg7XG4gICAgICAgIHRoaXMud2ViU29ja2V0RmFjdG9yeSA9IHdlYlNvY2tldEZhY3Rvcnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAgIEVzdGFibGlzaGVzIGEgY29ubmVjdGlvbiB0byB0aGUgc3BlY2lmaWVkIG1vZGVsIGFuZCByZXR1cm5zIGFcbiAgICAgICBMaXZlTXVzaWNTZXNzaW9uIG9iamVjdCByZXByZXNlbnRpbmcgdGhhdCBjb25uZWN0aW9uLlxuICBcbiAgICAgICBAZXhwZXJpbWVudGFsXG4gIFxuICAgICAgIEByZW1hcmtzXG4gIFxuICAgICAgIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgZXN0YWJsaXNoaW5nIGEgY29ubmVjdGlvbiB0byB0aGUgbW9kZWwuXG4gICAgICAgQHJldHVybiBBIGxpdmUgc2Vzc2lvbi5cbiAgXG4gICAgICAgQGV4YW1wbGVcbiAgICAgICBgYGB0c1xuICAgICAgIGxldCBtb2RlbCA9ICdtb2RlbHMvbHlyaWEtcmVhbHRpbWUtZXhwJztcbiAgICAgICBjb25zdCBzZXNzaW9uID0gYXdhaXQgYWkubGl2ZS5tdXNpYy5jb25uZWN0KHtcbiAgICAgICAgIG1vZGVsOiBtb2RlbCxcbiAgICAgICAgIGNhbGxiYWNrczoge1xuICAgICAgICAgICBvbm1lc3NhZ2U6IChlOiBNZXNzYWdlRXZlbnQpID0+IHtcbiAgICAgICAgICAgICBjb25zb2xlLmxvZygnUmVjZWl2ZWQgbWVzc2FnZSBmcm9tIHRoZSBzZXJ2ZXI6ICVzXFxuJywgZGVidWcoZS5kYXRhKSk7XG4gICAgICAgICAgIH0sXG4gICAgICAgICAgIG9uZXJyb3I6IChlOiBFcnJvckV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgY29uc29sZS5sb2coJ0Vycm9yIG9jY3VycmVkOiAlc1xcbicsIGRlYnVnKGUuZXJyb3IpKTtcbiAgICAgICAgICAgfSxcbiAgICAgICAgICAgb25jbG9zZTogKGU6IENsb3NlRXZlbnQpID0+IHtcbiAgICAgICAgICAgICBjb25zb2xlLmxvZygnQ29ubmVjdGlvbiBjbG9zZWQuJyk7XG4gICAgICAgICAgIH0sXG4gICAgICAgICB9LFxuICAgICAgIH0pO1xuICAgICAgIGBgYFxuICAgICAgKi9cbiAgICBhc3luYyBjb25uZWN0KHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xpdmUgbXVzaWMgaXMgbm90IHN1cHBvcnRlZCBmb3IgVmVydGV4IEFJLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUud2FybignTGl2ZSBtdXNpYyBnZW5lcmF0aW9uIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZSBpbiBmdXR1cmUgdmVyc2lvbnMuJyk7XG4gICAgICAgIGNvbnN0IHdlYnNvY2tldEJhc2VVcmwgPSB0aGlzLmFwaUNsaWVudC5nZXRXZWJzb2NrZXRCYXNlVXJsKCk7XG4gICAgICAgIGNvbnN0IGFwaVZlcnNpb24gPSB0aGlzLmFwaUNsaWVudC5nZXRBcGlWZXJzaW9uKCk7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBtYXBUb0hlYWRlcnMkMSh0aGlzLmFwaUNsaWVudC5nZXREZWZhdWx0SGVhZGVycygpKTtcbiAgICAgICAgY29uc3QgYXBpS2V5ID0gdGhpcy5hcGlDbGllbnQuZ2V0QXBpS2V5KCk7XG4gICAgICAgIGNvbnN0IHVybCA9IGAke3dlYnNvY2tldEJhc2VVcmx9L3dzL2dvb2dsZS5haS5nZW5lcmF0aXZlbGFuZ3VhZ2UuJHthcGlWZXJzaW9ufS5HZW5lcmF0aXZlU2VydmljZS5CaWRpR2VuZXJhdGVNdXNpYz9rZXk9JHthcGlLZXl9YDtcbiAgICAgICAgbGV0IG9ub3BlblJlc29sdmUgPSAoKSA9PiB7IH07XG4gICAgICAgIGNvbnN0IG9ub3BlblByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgb25vcGVuUmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSBwYXJhbXMuY2FsbGJhY2tzO1xuICAgICAgICBjb25zdCBvbm9wZW5Bd2FpdGVkQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBvbm9wZW5SZXNvbHZlKHt9KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYXBpQ2xpZW50ID0gdGhpcy5hcGlDbGllbnQ7XG4gICAgICAgIGNvbnN0IHdlYnNvY2tldENhbGxiYWNrcyA9IHtcbiAgICAgICAgICAgIG9ub3Blbjogb25vcGVuQXdhaXRlZENhbGxiYWNrLFxuICAgICAgICAgICAgb25tZXNzYWdlOiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB2b2lkIGhhbmRsZVdlYlNvY2tldE1lc3NhZ2UkMShhcGlDbGllbnQsIGNhbGxiYWNrcy5vbm1lc3NhZ2UsIGV2ZW50KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbmVycm9yOiAoX2EgPSBjYWxsYmFja3MgPT09IG51bGwgfHwgY2FsbGJhY2tzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25lcnJvcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbmNsb3NlOiAoX2IgPSBjYWxsYmFja3MgPT09IG51bGwgfHwgY2FsbGJhY2tzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25jbG9zZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNvbm4gPSB0aGlzLndlYlNvY2tldEZhY3RvcnkuY3JlYXRlKHVybCwgaGVhZGVyc1RvTWFwJDEoaGVhZGVycyksIHdlYnNvY2tldENhbGxiYWNrcyk7XG4gICAgICAgIGNvbm4uY29ubmVjdCgpO1xuICAgICAgICAvLyBXYWl0IGZvciB0aGUgd2Vic29ja2V0IHRvIG9wZW4gYmVmb3JlIHNlbmRpbmcgcmVxdWVzdHMuXG4gICAgICAgIGF3YWl0IG9ub3BlblByb21pc2U7XG4gICAgICAgIGNvbnN0IG1vZGVsID0gdE1vZGVsKHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMubW9kZWwpO1xuICAgICAgICBjb25zdCBzZXR1cCA9IHsgbW9kZWwgfTtcbiAgICAgICAgY29uc3QgY2xpZW50TWVzc2FnZSA9IHsgc2V0dXAgfTtcbiAgICAgICAgY29ubi5zZW5kKEpTT04uc3RyaW5naWZ5KGNsaWVudE1lc3NhZ2UpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBMaXZlTXVzaWNTZXNzaW9uKGNvbm4sIHRoaXMuYXBpQ2xpZW50KTtcbiAgICB9XG59XG4vKipcbiAgIFJlcHJlc2VudHMgYSBjb25uZWN0aW9uIHRvIHRoZSBBUEkuXG5cbiAgIEBleHBlcmltZW50YWxcbiAgKi9cbmNsYXNzIExpdmVNdXNpY1Nlc3Npb24ge1xuICAgIGNvbnN0cnVjdG9yKGNvbm4sIGFwaUNsaWVudCkge1xuICAgICAgICB0aGlzLmNvbm4gPSBjb25uO1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IGFwaUNsaWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICBTZXRzIGlucHV0cyB0byBzdGVlciBtdXNpYyBnZW5lcmF0aW9uLiBVcGRhdGVzIHRoZSBzZXNzaW9uJ3MgY3VycmVudFxuICAgICAgd2VpZ2h0ZWQgcHJvbXB0cy5cbiAgXG4gICAgICBAcGFyYW0gcGFyYW1zIC0gQ29udGFpbnMgb25lIHByb3BlcnR5LCBgd2VpZ2h0ZWRQcm9tcHRzYC5cbiAgXG4gICAgICAgIC0gYHdlaWdodGVkUHJvbXB0c2AgdG8gc2VuZCB0byB0aGUgbW9kZWw7IHdlaWdodHMgYXJlIG5vcm1hbGl6ZWQgdG9cbiAgICAgICAgICBzdW0gdG8gMS4wLlxuICBcbiAgICAgIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICBhc3luYyBzZXRXZWlnaHRlZFByb21wdHMocGFyYW1zKSB7XG4gICAgICAgIGlmICghcGFyYW1zLndlaWdodGVkUHJvbXB0cyB8fFxuICAgICAgICAgICAgT2JqZWN0LmtleXMocGFyYW1zLndlaWdodGVkUHJvbXB0cykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlaWdodGVkIHByb21wdHMgbXVzdCBiZSBzZXQgYW5kIGNvbnRhaW4gYXQgbGVhc3Qgb25lIGVudHJ5LicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNsaWVudENvbnRlbnQgPSBsaXZlTXVzaWNTZXRXZWlnaHRlZFByb21wdHNQYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICB0aGlzLmNvbm4uc2VuZChKU09OLnN0cmluZ2lmeSh7IGNsaWVudENvbnRlbnQgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgIFNldHMgYSBjb25maWd1cmF0aW9uIHRvIHRoZSBtb2RlbC4gVXBkYXRlcyB0aGUgc2Vzc2lvbidzIGN1cnJlbnRcbiAgICAgIG11c2ljIGdlbmVyYXRpb24gY29uZmlnLlxuICBcbiAgICAgIEBwYXJhbSBwYXJhbXMgLSBDb250YWlucyBvbmUgcHJvcGVydHksIGBtdXNpY0dlbmVyYXRpb25Db25maWdgLlxuICBcbiAgICAgICAgLSBgbXVzaWNHZW5lcmF0aW9uQ29uZmlnYCB0byBzZXQgaW4gdGhlIG1vZGVsLiBQYXNzaW5nIGFuIGVtcHR5IG9yXG4gICAgICB1bmRlZmluZWQgY29uZmlnIHRvIHRoZSBtb2RlbCB3aWxsIHJlc2V0IHRoZSBjb25maWcgdG8gZGVmYXVsdHMuXG4gIFxuICAgICAgQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIGFzeW5jIHNldE11c2ljR2VuZXJhdGlvbkNvbmZpZyhwYXJhbXMpIHtcbiAgICAgICAgaWYgKCFwYXJhbXMubXVzaWNHZW5lcmF0aW9uQ29uZmlnKSB7XG4gICAgICAgICAgICBwYXJhbXMubXVzaWNHZW5lcmF0aW9uQ29uZmlnID0ge307XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2V0Q29uZmlnUGFyYW1ldGVycyA9IGxpdmVNdXNpY1NldENvbmZpZ1BhcmFtZXRlcnNUb01sZGV2KHBhcmFtcyk7XG4gICAgICAgIHRoaXMuY29ubi5zZW5kKEpTT04uc3RyaW5naWZ5KHNldENvbmZpZ1BhcmFtZXRlcnMpKTtcbiAgICB9XG4gICAgc2VuZFBsYXliYWNrQ29udHJvbChwbGF5YmFja0NvbnRyb2wpIHtcbiAgICAgICAgY29uc3QgY2xpZW50TWVzc2FnZSA9IHsgcGxheWJhY2tDb250cm9sIH07XG4gICAgICAgIHRoaXMuY29ubi5zZW5kKEpTT04uc3RyaW5naWZ5KGNsaWVudE1lc3NhZ2UpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnQgdGhlIG11c2ljIHN0cmVhbS5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICBwbGF5KCkge1xuICAgICAgICB0aGlzLnNlbmRQbGF5YmFja0NvbnRyb2woTGl2ZU11c2ljUGxheWJhY2tDb250cm9sLlBMQVkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZW1wb3JhcmlseSBoYWx0IHRoZSBtdXNpYyBzdHJlYW0uIFVzZSBgcGxheWAgdG8gcmVzdW1lIGZyb20gdGhlIGN1cnJlbnRcbiAgICAgKiBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICBwYXVzZSgpIHtcbiAgICAgICAgdGhpcy5zZW5kUGxheWJhY2tDb250cm9sKExpdmVNdXNpY1BsYXliYWNrQ29udHJvbC5QQVVTRSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3AgdGhlIG11c2ljIHN0cmVhbSBhbmQgcmVzZXQgdGhlIHN0YXRlLiBSZXRhaW5zIHRoZSBjdXJyZW50IHByb21wdHNcbiAgICAgKiBhbmQgY29uZmlnLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHN0b3AoKSB7XG4gICAgICAgIHRoaXMuc2VuZFBsYXliYWNrQ29udHJvbChMaXZlTXVzaWNQbGF5YmFja0NvbnRyb2wuU1RPUCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgY29udGV4dCBvZiB0aGUgbXVzaWMgZ2VuZXJhdGlvbiB3aXRob3V0IHN0b3BwaW5nIGl0LlxuICAgICAqIFJldGFpbnMgdGhlIGN1cnJlbnQgcHJvbXB0cyBhbmQgY29uZmlnLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHJlc2V0Q29udGV4dCgpIHtcbiAgICAgICAgdGhpcy5zZW5kUGxheWJhY2tDb250cm9sKExpdmVNdXNpY1BsYXliYWNrQ29udHJvbC5SRVNFVF9DT05URVhUKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICAgVGVybWluYXRlcyB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24uXG4gIFxuICAgICAgIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy5jb25uLmNsb3NlKCk7XG4gICAgfVxufVxuLy8gQ29udmVydHMgYW4gaGVhZGVycyBvYmplY3QgdG8gYSBcIm1hcFwiIG9iamVjdCBhcyBleHBlY3RlZCBieSB0aGUgV2ViU29ja2V0XG4vLyBjb25zdHJ1Y3Rvci4gV2UgdXNlIHRoaXMgYXMgdGhlIEF1dGggaW50ZXJmYWNlIHdvcmtzIHdpdGggSGVhZGVycyBvYmplY3RzXG4vLyB3aGlsZSB0aGUgV2ViU29ja2V0IGNvbnN0cnVjdG9yIHRha2VzIGEgbWFwLlxuZnVuY3Rpb24gaGVhZGVyc1RvTWFwJDEoaGVhZGVycykge1xuICAgIGNvbnN0IGhlYWRlck1hcCA9IHt9O1xuICAgIGhlYWRlcnMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICBoZWFkZXJNYXBba2V5XSA9IHZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiBoZWFkZXJNYXA7XG59XG4vLyBDb252ZXJ0cyBhIFwibWFwXCIgb2JqZWN0IHRvIGEgaGVhZGVycyBvYmplY3QuIFdlIHVzZSB0aGlzIGFzIHRoZSBBdXRoXG4vLyBpbnRlcmZhY2Ugd29ya3Mgd2l0aCBIZWFkZXJzIG9iamVjdHMgd2hpbGUgdGhlIEFQSSBjbGllbnQgZGVmYXVsdCBoZWFkZXJzXG4vLyByZXR1cm5zIGEgbWFwLlxuZnVuY3Rpb24gbWFwVG9IZWFkZXJzJDEobWFwKSB7XG4gICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMobWFwKSkge1xuICAgICAgICBoZWFkZXJzLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGhlYWRlcnM7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmNvbnN0IEZVTkNUSU9OX1JFU1BPTlNFX1JFUVVJUkVTX0lEID0gJ0Z1bmN0aW9uUmVzcG9uc2UgcmVxdWVzdCBtdXN0IGhhdmUgYW4gYGlkYCBmaWVsZCBmcm9tIHRoZSByZXNwb25zZSBvZiBhIFRvb2xDYWxsLkZ1bmN0aW9uYWxDYWxscyBpbiBHb29nbGUgQUkuJztcbi8qKlxuICogSGFuZGxlcyBpbmNvbWluZyBtZXNzYWdlcyBmcm9tIHRoZSBXZWJTb2NrZXQuXG4gKlxuICogQHJlbWFya3NcbiAqIFRoaXMgZnVuY3Rpb24gaXMgcmVzcG9uc2libGUgZm9yIHBhcnNpbmcgaW5jb21pbmcgbWVzc2FnZXMsIHRyYW5zZm9ybWluZyB0aGVtXG4gKiBpbnRvIExpdmVTZXJ2ZXJNZXNzYWdlcywgYW5kIHRoZW4gY2FsbGluZyB0aGUgb25tZXNzYWdlIGNhbGxiYWNrLiBOb3RlIHRoYXRcbiAqIHRoZSBmaXJzdCBtZXNzYWdlIHdoaWNoIGlzIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlciBpcyBhIHNldHVwQ29tcGxldGVcbiAqIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIGFwaUNsaWVudCBUaGUgQXBpQ2xpZW50IGluc3RhbmNlLlxuICogQHBhcmFtIG9ubWVzc2FnZSBUaGUgdXNlci1wcm92aWRlZCBvbm1lc3NhZ2UgY2FsbGJhY2sgKGlmIGFueSkuXG4gKiBAcGFyYW0gZXZlbnQgVGhlIE1lc3NhZ2VFdmVudCBmcm9tIHRoZSBXZWJTb2NrZXQuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZVdlYlNvY2tldE1lc3NhZ2UoYXBpQ2xpZW50LCBvbm1lc3NhZ2UsIGV2ZW50KSB7XG4gICAgY29uc3Qgc2VydmVyTWVzc2FnZSA9IG5ldyBMaXZlU2VydmVyTWVzc2FnZSgpO1xuICAgIGxldCBqc29uRGF0YTtcbiAgICBpZiAoZXZlbnQuZGF0YSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAganNvbkRhdGEgPSBhd2FpdCBldmVudC5kYXRhLnRleHQoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXZlbnQuZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIGpzb25EYXRhID0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGV2ZW50LmRhdGEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAganNvbkRhdGEgPSBldmVudC5kYXRhO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShqc29uRGF0YSk7XG4gICAgaWYgKGFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgY29uc3QgcmVzcCA9IGxpdmVTZXJ2ZXJNZXNzYWdlRnJvbVZlcnRleChkYXRhKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihzZXJ2ZXJNZXNzYWdlLCByZXNwKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHJlc3AgPSBkYXRhO1xuICAgICAgICBPYmplY3QuYXNzaWduKHNlcnZlck1lc3NhZ2UsIHJlc3ApO1xuICAgIH1cbiAgICBvbm1lc3NhZ2Uoc2VydmVyTWVzc2FnZSk7XG59XG4vKipcbiAgIExpdmUgY2xhc3MgZW5jYXBzdWxhdGVzIHRoZSBjb25maWd1cmF0aW9uIGZvciBsaXZlIGludGVyYWN0aW9uIHdpdGggdGhlXG4gICBHZW5lcmF0aXZlIExhbmd1YWdlIEFQSS4gSXQgZW1iZWRzIEFwaUNsaWVudCBmb3IgZ2VuZXJhbCBBUEkgc2V0dGluZ3MuXG5cbiAgIEBleHBlcmltZW50YWxcbiAgKi9cbmNsYXNzIExpdmUge1xuICAgIGNvbnN0cnVjdG9yKGFwaUNsaWVudCwgYXV0aCwgd2ViU29ja2V0RmFjdG9yeSkge1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IGFwaUNsaWVudDtcbiAgICAgICAgdGhpcy5hdXRoID0gYXV0aDtcbiAgICAgICAgdGhpcy53ZWJTb2NrZXRGYWN0b3J5ID0gd2ViU29ja2V0RmFjdG9yeTtcbiAgICAgICAgdGhpcy5tdXNpYyA9IG5ldyBMaXZlTXVzaWModGhpcy5hcGlDbGllbnQsIHRoaXMuYXV0aCwgdGhpcy53ZWJTb2NrZXRGYWN0b3J5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICAgRXN0YWJsaXNoZXMgYSBjb25uZWN0aW9uIHRvIHRoZSBzcGVjaWZpZWQgbW9kZWwgd2l0aCB0aGUgZ2l2ZW5cbiAgICAgICBjb25maWd1cmF0aW9uIGFuZCByZXR1cm5zIGEgU2Vzc2lvbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoYXQgY29ubmVjdGlvbi5cbiAgXG4gICAgICAgQGV4cGVyaW1lbnRhbCBCdWlsdC1pbiBNQ1Agc3VwcG9ydCBpcyBhbiBleHBlcmltZW50YWwgZmVhdHVyZSwgbWF5IGNoYW5nZSBpblxuICAgICAgIGZ1dHVyZSB2ZXJzaW9ucy5cbiAgXG4gICAgICAgQHJlbWFya3NcbiAgXG4gICAgICAgQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBlc3RhYmxpc2hpbmcgYSBjb25uZWN0aW9uIHRvIHRoZSBtb2RlbC5cbiAgICAgICBAcmV0dXJuIEEgbGl2ZSBzZXNzaW9uLlxuICBcbiAgICAgICBAZXhhbXBsZVxuICAgICAgIGBgYHRzXG4gICAgICAgbGV0IG1vZGVsOiBzdHJpbmc7XG4gICAgICAgaWYgKEdPT0dMRV9HRU5BSV9VU0VfVkVSVEVYQUkpIHtcbiAgICAgICAgIG1vZGVsID0gJ2dlbWluaS0yLjAtZmxhc2gtbGl2ZS1wcmV2aWV3LTA0LTA5JztcbiAgICAgICB9IGVsc2Uge1xuICAgICAgICAgbW9kZWwgPSAnZ2VtaW5pLWxpdmUtMi41LWZsYXNoLXByZXZpZXcnO1xuICAgICAgIH1cbiAgICAgICBjb25zdCBzZXNzaW9uID0gYXdhaXQgYWkubGl2ZS5jb25uZWN0KHtcbiAgICAgICAgIG1vZGVsOiBtb2RlbCxcbiAgICAgICAgIGNvbmZpZzoge1xuICAgICAgICAgICByZXNwb25zZU1vZGFsaXRpZXM6IFtNb2RhbGl0eS5BVURJT10sXG4gICAgICAgICB9LFxuICAgICAgICAgY2FsbGJhY2tzOiB7XG4gICAgICAgICAgIG9ub3BlbjogKCkgPT4ge1xuICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdDb25uZWN0ZWQgdG8gdGhlIHNvY2tldC4nKTtcbiAgICAgICAgICAgfSxcbiAgICAgICAgICAgb25tZXNzYWdlOiAoZTogTWVzc2FnZUV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgY29uc29sZS5sb2coJ1JlY2VpdmVkIG1lc3NhZ2UgZnJvbSB0aGUgc2VydmVyOiAlc1xcbicsIGRlYnVnKGUuZGF0YSkpO1xuICAgICAgICAgICB9LFxuICAgICAgICAgICBvbmVycm9yOiAoZTogRXJyb3JFdmVudCkgPT4ge1xuICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdFcnJvciBvY2N1cnJlZDogJXNcXG4nLCBkZWJ1ZyhlLmVycm9yKSk7XG4gICAgICAgICAgIH0sXG4gICAgICAgICAgIG9uY2xvc2U6IChlOiBDbG9zZUV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgY29uc29sZS5sb2coJ0Nvbm5lY3Rpb24gY2xvc2VkLicpO1xuICAgICAgICAgICB9LFxuICAgICAgICAgfSxcbiAgICAgICB9KTtcbiAgICAgICBgYGBcbiAgICAgICovXG4gICAgYXN5bmMgY29ubmVjdChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgIC8vIFRPRE86IGIvNDA0OTQ2NzQ2IC0gU3VwcG9ydCBwZXIgcmVxdWVzdCBIVFRQIG9wdGlvbnMuXG4gICAgICAgIGlmIChwYXJhbXMuY29uZmlnICYmIHBhcmFtcy5jb25maWcuaHR0cE9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIExpdmUgbW9kdWxlIGRvZXMgbm90IHN1cHBvcnQgaHR0cE9wdGlvbnMgYXQgcmVxdWVzdC1sZXZlbCBpbicgK1xuICAgICAgICAgICAgICAgICcgTGl2ZUNvbm5lY3RDb25maWcgeWV0LiBQbGVhc2UgdXNlIHRoZSBjbGllbnQtbGV2ZWwgaHR0cE9wdGlvbnMnICtcbiAgICAgICAgICAgICAgICAnIGNvbmZpZ3VyYXRpb24gaW5zdGVhZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3ZWJzb2NrZXRCYXNlVXJsID0gdGhpcy5hcGlDbGllbnQuZ2V0V2Vic29ja2V0QmFzZVVybCgpO1xuICAgICAgICBjb25zdCBhcGlWZXJzaW9uID0gdGhpcy5hcGlDbGllbnQuZ2V0QXBpVmVyc2lvbigpO1xuICAgICAgICBsZXQgdXJsO1xuICAgICAgICBjb25zdCBjbGllbnRIZWFkZXJzID0gdGhpcy5hcGlDbGllbnQuZ2V0SGVhZGVycygpO1xuICAgICAgICBpZiAocGFyYW1zLmNvbmZpZyAmJlxuICAgICAgICAgICAgcGFyYW1zLmNvbmZpZy50b29scyAmJlxuICAgICAgICAgICAgaGFzTWNwVG9vbFVzYWdlKHBhcmFtcy5jb25maWcudG9vbHMpKSB7XG4gICAgICAgICAgICBzZXRNY3BVc2FnZUhlYWRlcihjbGllbnRIZWFkZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZWFkZXJzID0gbWFwVG9IZWFkZXJzKGNsaWVudEhlYWRlcnMpO1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB1cmwgPSBgJHt3ZWJzb2NrZXRCYXNlVXJsfS93cy9nb29nbGUuY2xvdWQuYWlwbGF0Zm9ybS4ke2FwaVZlcnNpb259LkxsbUJpZGlTZXJ2aWNlL0JpZGlHZW5lcmF0ZUNvbnRlbnRgO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5hdXRoLmFkZEF1dGhIZWFkZXJzKGhlYWRlcnMsIHVybCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBhcGlLZXkgPSB0aGlzLmFwaUNsaWVudC5nZXRBcGlLZXkoKTtcbiAgICAgICAgICAgIGxldCBtZXRob2QgPSAnQmlkaUdlbmVyYXRlQ29udGVudCc7XG4gICAgICAgICAgICBsZXQga2V5TmFtZSA9ICdrZXknO1xuICAgICAgICAgICAgaWYgKGFwaUtleSA9PT0gbnVsbCB8fCBhcGlLZXkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFwaUtleS5zdGFydHNXaXRoKCdhdXRoX3Rva2Vucy8nKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignV2FybmluZzogRXBoZW1lcmFsIHRva2VuIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlIGluIGZ1dHVyZSB2ZXJzaW9ucy4nKTtcbiAgICAgICAgICAgICAgICBpZiAoYXBpVmVyc2lvbiAhPT0gJ3YxYWxwaGEnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIldhcm5pbmc6IFRoZSBTREsncyBlcGhlbWVyYWwgdG9rZW4gc3VwcG9ydCBpcyBpbiB2MWFscGhhIG9ubHkuIFBsZWFzZSB1c2UgY29uc3QgYWkgPSBuZXcgR29vZ2xlR2VuQUkoe2FwaUtleTogdG9rZW4ubmFtZSwgaHR0cE9wdGlvbnM6IHsgYXBpVmVyc2lvbjogJ3YxYWxwaGEnIH19KTsgYmVmb3JlIHNlc3Npb24gY29ubmVjdGlvbi5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1ldGhvZCA9ICdCaWRpR2VuZXJhdGVDb250ZW50Q29uc3RyYWluZWQnO1xuICAgICAgICAgICAgICAgIGtleU5hbWUgPSAnYWNjZXNzX3Rva2VuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVybCA9IGAke3dlYnNvY2tldEJhc2VVcmx9L3dzL2dvb2dsZS5haS5nZW5lcmF0aXZlbGFuZ3VhZ2UuJHthcGlWZXJzaW9ufS5HZW5lcmF0aXZlU2VydmljZS4ke21ldGhvZH0/JHtrZXlOYW1lfT0ke2FwaUtleX1gO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvbm9wZW5SZXNvbHZlID0gKCkgPT4geyB9O1xuICAgICAgICBjb25zdCBvbm9wZW5Qcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIG9ub3BlblJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gcGFyYW1zLmNhbGxiYWNrcztcbiAgICAgICAgY29uc3Qgb25vcGVuQXdhaXRlZENhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgKF9hID0gY2FsbGJhY2tzID09PSBudWxsIHx8IGNhbGxiYWNrcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2tzLm9ub3BlbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoY2FsbGJhY2tzKTtcbiAgICAgICAgICAgIG9ub3BlblJlc29sdmUoe30pO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBhcGlDbGllbnQgPSB0aGlzLmFwaUNsaWVudDtcbiAgICAgICAgY29uc3Qgd2Vic29ja2V0Q2FsbGJhY2tzID0ge1xuICAgICAgICAgICAgb25vcGVuOiBvbm9wZW5Bd2FpdGVkQ2FsbGJhY2ssXG4gICAgICAgICAgICBvbm1lc3NhZ2U6IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHZvaWQgaGFuZGxlV2ViU29ja2V0TWVzc2FnZShhcGlDbGllbnQsIGNhbGxiYWNrcy5vbm1lc3NhZ2UsIGV2ZW50KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbmVycm9yOiAoX2EgPSBjYWxsYmFja3MgPT09IG51bGwgfHwgY2FsbGJhY2tzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25lcnJvcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbmNsb3NlOiAoX2IgPSBjYWxsYmFja3MgPT09IG51bGwgfHwgY2FsbGJhY2tzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25jbG9zZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNvbm4gPSB0aGlzLndlYlNvY2tldEZhY3RvcnkuY3JlYXRlKHVybCwgaGVhZGVyc1RvTWFwKGhlYWRlcnMpLCB3ZWJzb2NrZXRDYWxsYmFja3MpO1xuICAgICAgICBjb25uLmNvbm5lY3QoKTtcbiAgICAgICAgLy8gV2FpdCBmb3IgdGhlIHdlYnNvY2tldCB0byBvcGVuIGJlZm9yZSBzZW5kaW5nIHJlcXVlc3RzLlxuICAgICAgICBhd2FpdCBvbm9wZW5Qcm9taXNlO1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRNb2RlbCA9IHRNb2RlbCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zLm1vZGVsKTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSAmJlxuICAgICAgICAgICAgdHJhbnNmb3JtZWRNb2RlbC5zdGFydHNXaXRoKCdwdWJsaXNoZXJzLycpKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9qZWN0ID0gdGhpcy5hcGlDbGllbnQuZ2V0UHJvamVjdCgpO1xuICAgICAgICAgICAgY29uc3QgbG9jYXRpb24gPSB0aGlzLmFwaUNsaWVudC5nZXRMb2NhdGlvbigpO1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRNb2RlbCA9XG4gICAgICAgICAgICAgICAgYHByb2plY3RzLyR7cHJvamVjdH0vbG9jYXRpb25zLyR7bG9jYXRpb259L2AgKyB0cmFuc2Zvcm1lZE1vZGVsO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjbGllbnRNZXNzYWdlID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkgJiZcbiAgICAgICAgICAgICgoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucmVzcG9uc2VNb2RhbGl0aWVzKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBTZXQgZGVmYXVsdCB0byBBVURJTyB0byBhbGlnbiB3aXRoIE1MRGV2IEFQSS5cbiAgICAgICAgICAgIGlmIChwYXJhbXMuY29uZmlnID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMuY29uZmlnID0geyByZXNwb25zZU1vZGFsaXRpZXM6IFtNb2RhbGl0eS5BVURJT10gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5jb25maWcucmVzcG9uc2VNb2RhbGl0aWVzID0gW01vZGFsaXR5LkFVRElPXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmdlbmVyYXRpb25Db25maWcpIHtcbiAgICAgICAgICAgIC8vIFJhaXNlIGRlcHJlY2F0aW9uIHdhcm5pbmcgZm9yIGdlbmVyYXRpb25Db25maWcuXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1NldHRpbmcgYExpdmVDb25uZWN0Q29uZmlnLmdlbmVyYXRpb25fY29uZmlnYCBpcyBkZXByZWNhdGVkLCBwbGVhc2Ugc2V0IHRoZSBmaWVsZHMgb24gYExpdmVDb25uZWN0Q29uZmlnYCBkaXJlY3RseS4gVGhpcyB3aWxsIGJlY29tZSBhbiBlcnJvciBpbiBhIGZ1dHVyZSB2ZXJzaW9uIChub3QgYmVmb3JlIFEzIDIwMjUpLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlucHV0VG9vbHMgPSAoX2YgPSAoX2UgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UudG9vbHMpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IFtdO1xuICAgICAgICBjb25zdCBjb252ZXJ0ZWRUb29scyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHRvb2wgb2YgaW5wdXRUb29scykge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNDYWxsYWJsZVRvb2wodG9vbCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWxsYWJsZVRvb2wgPSB0b29sO1xuICAgICAgICAgICAgICAgIGNvbnZlcnRlZFRvb2xzLnB1c2goYXdhaXQgY2FsbGFibGVUb29sLnRvb2woKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb252ZXJ0ZWRUb29scy5wdXNoKHRvb2wpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb252ZXJ0ZWRUb29scy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBwYXJhbXMuY29uZmlnLnRvb2xzID0gY29udmVydGVkVG9vbHM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGl2ZUNvbm5lY3RQYXJhbWV0ZXJzID0ge1xuICAgICAgICAgICAgbW9kZWw6IHRyYW5zZm9ybWVkTW9kZWwsXG4gICAgICAgICAgICBjb25maWc6IHBhcmFtcy5jb25maWcsXG4gICAgICAgICAgICBjYWxsYmFja3M6IHBhcmFtcy5jYWxsYmFja3MsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNsaWVudE1lc3NhZ2UgPSBsaXZlQ29ubmVjdFBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgbGl2ZUNvbm5lY3RQYXJhbWV0ZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNsaWVudE1lc3NhZ2UgPSBsaXZlQ29ubmVjdFBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBsaXZlQ29ubmVjdFBhcmFtZXRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBjbGllbnRNZXNzYWdlWydjb25maWcnXTtcbiAgICAgICAgY29ubi5zZW5kKEpTT04uc3RyaW5naWZ5KGNsaWVudE1lc3NhZ2UpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTZXNzaW9uKGNvbm4sIHRoaXMuYXBpQ2xpZW50KTtcbiAgICB9XG4gICAgLy8gVE9ETzogYi80MTYwNDEyMjkgLSBBYnN0cmFjdCB0aGlzIG1ldGhvZCB0byBhIGNvbW1vbiBwbGFjZS5cbiAgICBpc0NhbGxhYmxlVG9vbCh0b29sKSB7XG4gICAgICAgIHJldHVybiAnY2FsbFRvb2wnIGluIHRvb2wgJiYgdHlwZW9mIHRvb2wuY2FsbFRvb2wgPT09ICdmdW5jdGlvbic7XG4gICAgfVxufVxuY29uc3QgZGVmYXVsdExpdmVTZW5kQ2xpZW50Q29udGVudFBhcmFtZXJ0ZXJzID0ge1xuICAgIHR1cm5Db21wbGV0ZTogdHJ1ZSxcbn07XG4vKipcbiAgIFJlcHJlc2VudHMgYSBjb25uZWN0aW9uIHRvIHRoZSBBUEkuXG5cbiAgIEBleHBlcmltZW50YWxcbiAgKi9cbmNsYXNzIFNlc3Npb24ge1xuICAgIGNvbnN0cnVjdG9yKGNvbm4sIGFwaUNsaWVudCkge1xuICAgICAgICB0aGlzLmNvbm4gPSBjb25uO1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IGFwaUNsaWVudDtcbiAgICB9XG4gICAgdExpdmVDbGllbnRDb250ZW50KGFwaUNsaWVudCwgcGFyYW1zKSB7XG4gICAgICAgIGlmIChwYXJhbXMudHVybnMgIT09IG51bGwgJiYgcGFyYW1zLnR1cm5zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBjb250ZW50cyA9IFtdO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb250ZW50cyA9IHRDb250ZW50cyhwYXJhbXMudHVybnMpO1xuICAgICAgICAgICAgICAgIGlmICghYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50cyA9IGNvbnRlbnRzLm1hcCgoaXRlbSkgPT4gY29udGVudFRvTWxkZXYkMShpdGVtKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcGFyc2UgY2xpZW50IGNvbnRlbnQgXCJ0dXJuc1wiLCB0eXBlOiAnJHt0eXBlb2YgcGFyYW1zLnR1cm5zfSdgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY2xpZW50Q29udGVudDogeyB0dXJuczogY29udGVudHMsIHR1cm5Db21wbGV0ZTogcGFyYW1zLnR1cm5Db21wbGV0ZSB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2xpZW50Q29udGVudDogeyB0dXJuQ29tcGxldGU6IHBhcmFtcy50dXJuQ29tcGxldGUgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdExpdmVDbGllbnR0VG9vbFJlc3BvbnNlKGFwaUNsaWVudCwgcGFyYW1zKSB7XG4gICAgICAgIGxldCBmdW5jdGlvblJlc3BvbnNlcyA9IFtdO1xuICAgICAgICBpZiAocGFyYW1zLmZ1bmN0aW9uUmVzcG9uc2VzID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZnVuY3Rpb25SZXNwb25zZXMgaXMgcmVxdWlyZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHBhcmFtcy5mdW5jdGlvblJlc3BvbnNlcykpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uUmVzcG9uc2VzID0gW3BhcmFtcy5mdW5jdGlvblJlc3BvbnNlc107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmdW5jdGlvblJlc3BvbnNlcyA9IHBhcmFtcy5mdW5jdGlvblJlc3BvbnNlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnVuY3Rpb25SZXNwb25zZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Z1bmN0aW9uUmVzcG9uc2VzIGlzIHJlcXVpcmVkLicpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZnVuY3Rpb25SZXNwb25zZSBvZiBmdW5jdGlvblJlc3BvbnNlcykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmdW5jdGlvblJlc3BvbnNlICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uUmVzcG9uc2UgPT09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAhKCduYW1lJyBpbiBmdW5jdGlvblJlc3BvbnNlKSB8fFxuICAgICAgICAgICAgICAgICEoJ3Jlc3BvbnNlJyBpbiBmdW5jdGlvblJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IHBhcnNlIGZ1bmN0aW9uIHJlc3BvbnNlLCB0eXBlICcke3R5cGVvZiBmdW5jdGlvblJlc3BvbnNlfScuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWFwaUNsaWVudC5pc1ZlcnRleEFJKCkgJiYgISgnaWQnIGluIGZ1bmN0aW9uUmVzcG9uc2UpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEZVTkNUSU9OX1JFU1BPTlNFX1JFUVVJUkVTX0lEKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjbGllbnRNZXNzYWdlID0ge1xuICAgICAgICAgICAgdG9vbFJlc3BvbnNlOiB7IGZ1bmN0aW9uUmVzcG9uc2VzOiBmdW5jdGlvblJlc3BvbnNlcyB9LFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY2xpZW50TWVzc2FnZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICBTZW5kIGEgbWVzc2FnZSBvdmVyIHRoZSBlc3RhYmxpc2hlZCBjb25uZWN0aW9uLlxuICBcbiAgICAgIEBwYXJhbSBwYXJhbXMgLSBDb250YWlucyB0d28gKipvcHRpb25hbCoqIHByb3BlcnRpZXMsIGB0dXJuc2AgYW5kXG4gICAgICAgICAgYHR1cm5Db21wbGV0ZWAuXG4gIFxuICAgICAgICAtIGB0dXJuc2Agd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYSBgQ29udGVudFtdYFxuICAgICAgICAtIGB0dXJuQ29tcGxldGU6IHRydWVgIFtkZWZhdWx0XSBpbmRpY2F0ZXMgdGhhdCB5b3UgYXJlIGRvbmUgc2VuZGluZ1xuICAgICAgICAgIGNvbnRlbnQgYW5kIGV4cGVjdCBhIHJlc3BvbnNlLiBJZiBgdHVybkNvbXBsZXRlOiBmYWxzZWAsIHRoZSBzZXJ2ZXJcbiAgICAgICAgICB3aWxsIHdhaXQgZm9yIGFkZGl0aW9uYWwgbWVzc2FnZXMgYmVmb3JlIHN0YXJ0aW5nIGdlbmVyYXRpb24uXG4gIFxuICAgICAgQGV4cGVyaW1lbnRhbFxuICBcbiAgICAgIEByZW1hcmtzXG4gICAgICBUaGVyZSBhcmUgdHdvIHdheXMgdG8gc2VuZCBtZXNzYWdlcyB0byB0aGUgbGl2ZSBBUEk6XG4gICAgICBgc2VuZENsaWVudENvbnRlbnRgIGFuZCBgc2VuZFJlYWx0aW1lSW5wdXRgLlxuICBcbiAgICAgIGBzZW5kQ2xpZW50Q29udGVudGAgbWVzc2FnZXMgYXJlIGFkZGVkIHRvIHRoZSBtb2RlbCBjb250ZXh0ICoqaW4gb3JkZXIqKi5cbiAgICAgIEhhdmluZyBhIGNvbnZlcnNhdGlvbiB1c2luZyBgc2VuZENsaWVudENvbnRlbnRgIG1lc3NhZ2VzIGlzIHJvdWdobHlcbiAgICAgIGVxdWl2YWxlbnQgdG8gdXNpbmcgdGhlIGBDaGF0LnNlbmRNZXNzYWdlU3RyZWFtYCwgZXhjZXB0IHRoYXQgdGhlIHN0YXRlIG9mXG4gICAgICB0aGUgYGNoYXRgIGhpc3RvcnkgaXMgc3RvcmVkIG9uIHRoZSBBUEkgc2VydmVyIGluc3RlYWQgb2YgbG9jYWxseS5cbiAgXG4gICAgICBCZWNhdXNlIG9mIGBzZW5kQ2xpZW50Q29udGVudGAncyBvcmRlciBndWFyYW50ZWUsIHRoZSBtb2RlbCBjYW5ub3QgcmVzcG9uc1xuICAgICAgYXMgcXVpY2tseSB0byBgc2VuZENsaWVudENvbnRlbnRgIG1lc3NhZ2VzIGFzIHRvIGBzZW5kUmVhbHRpbWVJbnB1dGBcbiAgICAgIG1lc3NhZ2VzLiBUaGlzIG1ha2VzIHRoZSBiaWdnZXN0IGRpZmZlcmVuY2Ugd2hlbiBzZW5kaW5nIG9iamVjdHMgdGhhdCBoYXZlXG4gICAgICBzaWduaWZpY2FudCBwcmVwcm9jZXNzaW5nIHRpbWUgKHR5cGljYWxseSBpbWFnZXMpLlxuICBcbiAgICAgIFRoZSBgc2VuZENsaWVudENvbnRlbnRgIG1lc3NhZ2Ugc2VuZHMgYSBgQ29udGVudFtdYFxuICAgICAgd2hpY2ggaGFzIG1vcmUgb3B0aW9ucyB0aGFuIHRoZSBgQmxvYmAgc2VudCBieSBgc2VuZFJlYWx0aW1lSW5wdXRgLlxuICBcbiAgICAgIFNvIHRoZSBtYWluIHVzZS1jYXNlcyBmb3IgYHNlbmRDbGllbnRDb250ZW50YCBvdmVyIGBzZW5kUmVhbHRpbWVJbnB1dGAgYXJlOlxuICBcbiAgICAgIC0gU2VuZGluZyBhbnl0aGluZyB0aGF0IGNhbid0IGJlIHJlcHJlc2VudGVkIGFzIGEgYEJsb2JgICh0ZXh0LFxuICAgICAgYHNlbmRDbGllbnRDb250ZW50KHt0dXJucz1cIkhlbGxvP1wifWApKS5cbiAgICAgIC0gTWFuYWdpbmcgdHVybnMgd2hlbiBub3QgdXNpbmcgYXVkaW8gaW5wdXQgYW5kIHZvaWNlIGFjdGl2aXR5IGRldGVjdGlvbi5cbiAgICAgICAgKGBzZW5kQ2xpZW50Q29udGVudCh7dHVybkNvbXBsZXRlOnRydWV9KWAgb3IgdGhlIHNob3J0IGZvcm1cbiAgICAgIGBzZW5kQ2xpZW50Q29udGVudCgpYClcbiAgICAgIC0gUHJlZmlsbGluZyBhIGNvbnZlcnNhdGlvbiBjb250ZXh0XG4gICAgICAgIGBgYFxuICAgICAgICBzZW5kQ2xpZW50Q29udGVudCh7XG4gICAgICAgICAgICB0dXJuczogW1xuICAgICAgICAgICAgICBDb250ZW50KHtyb2xlOnVzZXIsIHBhcnRzOi4uLn0pLFxuICAgICAgICAgICAgICBDb250ZW50KHtyb2xlOnVzZXIsIHBhcnRzOi4uLn0pLFxuICAgICAgICAgICAgICAuLi5cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSlcbiAgICAgICAgYGBgXG4gICAgICBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgc2VuZENsaWVudENvbnRlbnQocGFyYW1zKSB7XG4gICAgICAgIHBhcmFtcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdExpdmVTZW5kQ2xpZW50Q29udGVudFBhcmFtZXJ0ZXJzKSwgcGFyYW1zKTtcbiAgICAgICAgY29uc3QgY2xpZW50TWVzc2FnZSA9IHRoaXMudExpdmVDbGllbnRDb250ZW50KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICB0aGlzLmNvbm4uc2VuZChKU09OLnN0cmluZ2lmeShjbGllbnRNZXNzYWdlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAgU2VuZCBhIHJlYWx0aW1lIG1lc3NhZ2Ugb3ZlciB0aGUgZXN0YWJsaXNoZWQgY29ubmVjdGlvbi5cbiAgXG4gICAgICBAcGFyYW0gcGFyYW1zIC0gQ29udGFpbnMgb25lIHByb3BlcnR5LCBgbWVkaWFgLlxuICBcbiAgICAgICAgLSBgbWVkaWFgIHdpbGwgYmUgY29udmVydGVkIHRvIGEgYEJsb2JgXG4gIFxuICAgICAgQGV4cGVyaW1lbnRhbFxuICBcbiAgICAgIEByZW1hcmtzXG4gICAgICBVc2UgYHNlbmRSZWFsdGltZUlucHV0YCBmb3IgcmVhbHRpbWUgYXVkaW8gY2h1bmtzIGFuZCB2aWRlbyBmcmFtZXMgKGltYWdlcykuXG4gIFxuICAgICAgV2l0aCBgc2VuZFJlYWx0aW1lSW5wdXRgIHRoZSBhcGkgd2lsbCByZXNwb25kIHRvIGF1ZGlvIGF1dG9tYXRpY2FsbHlcbiAgICAgIGJhc2VkIG9uIHZvaWNlIGFjdGl2aXR5IGRldGVjdGlvbiAoVkFEKS5cbiAgXG4gICAgICBgc2VuZFJlYWx0aW1lSW5wdXRgIGlzIG9wdGltaXplZCBmb3IgcmVzcG9uc2l2bmVzcyBhdCB0aGUgZXhwZW5zZSBvZlxuICAgICAgZGV0ZXJtaW5pc3RpYyBvcmRlcmluZyBndWFyYW50ZWVzLiBBdWRpbyBhbmQgdmlkZW8gdG9rZW5zIGFyZSB0byB0aGVcbiAgICAgIGNvbnRleHQgd2hlbiB0aGV5IGJlY29tZSBhdmFpbGFibGUuXG4gIFxuICAgICAgTm90ZTogVGhlIENhbGwgc2lnbmF0dXJlIGV4cGVjdHMgYSBgQmxvYmAgb2JqZWN0LCBidXQgb25seSBhIHN1YnNldFxuICAgICAgb2YgYXVkaW8gYW5kIGltYWdlIG1pbWV0eXBlcyBhcmUgYWxsb3dlZC5cbiAgICAgKi9cbiAgICBzZW5kUmVhbHRpbWVJbnB1dChwYXJhbXMpIHtcbiAgICAgICAgbGV0IGNsaWVudE1lc3NhZ2UgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY2xpZW50TWVzc2FnZSA9IHtcbiAgICAgICAgICAgICAgICAncmVhbHRpbWVJbnB1dCc6IGxpdmVTZW5kUmVhbHRpbWVJbnB1dFBhcmFtZXRlcnNUb1ZlcnRleChwYXJhbXMpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNsaWVudE1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAgJ3JlYWx0aW1lSW5wdXQnOiBsaXZlU2VuZFJlYWx0aW1lSW5wdXRQYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbm4uc2VuZChKU09OLnN0cmluZ2lmeShjbGllbnRNZXNzYWdlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAgU2VuZCBhIGZ1bmN0aW9uIHJlc3BvbnNlIG1lc3NhZ2Ugb3ZlciB0aGUgZXN0YWJsaXNoZWQgY29ubmVjdGlvbi5cbiAgXG4gICAgICBAcGFyYW0gcGFyYW1zIC0gQ29udGFpbnMgcHJvcGVydHkgYGZ1bmN0aW9uUmVzcG9uc2VzYC5cbiAgXG4gICAgICAgIC0gYGZ1bmN0aW9uUmVzcG9uc2VzYCB3aWxsIGJlIGNvbnZlcnRlZCB0byBhIGBmdW5jdGlvblJlc3BvbnNlc1tdYFxuICBcbiAgICAgIEByZW1hcmtzXG4gICAgICBVc2UgYHNlbmRGdW5jdGlvblJlc3BvbnNlYCB0byByZXBseSB0byBgTGl2ZVNlcnZlclRvb2xDYWxsYCBmcm9tIHRoZSBzZXJ2ZXIuXG4gIFxuICAgICAgVXNlIHtAbGluayB0eXBlcy5MaXZlQ29ubmVjdENvbmZpZyN0b29sc30gdG8gY29uZmlndXJlIHRoZSBjYWxsYWJsZSBmdW5jdGlvbnMuXG4gIFxuICAgICAgQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHNlbmRUb29sUmVzcG9uc2UocGFyYW1zKSB7XG4gICAgICAgIGlmIChwYXJhbXMuZnVuY3Rpb25SZXNwb25zZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb29sIHJlc3BvbnNlIHBhcmFtZXRlcnMgYXJlIHJlcXVpcmVkLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNsaWVudE1lc3NhZ2UgPSB0aGlzLnRMaXZlQ2xpZW50dFRvb2xSZXNwb25zZSh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgdGhpcy5jb25uLnNlbmQoSlNPTi5zdHJpbmdpZnkoY2xpZW50TWVzc2FnZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgICBUZXJtaW5hdGVzIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbi5cbiAgXG4gICAgICAgQGV4cGVyaW1lbnRhbFxuICBcbiAgICAgICBAZXhhbXBsZVxuICAgICAgIGBgYHRzXG4gICAgICAgbGV0IG1vZGVsOiBzdHJpbmc7XG4gICAgICAgaWYgKEdPT0dMRV9HRU5BSV9VU0VfVkVSVEVYQUkpIHtcbiAgICAgICAgIG1vZGVsID0gJ2dlbWluaS0yLjAtZmxhc2gtbGl2ZS1wcmV2aWV3LTA0LTA5JztcbiAgICAgICB9IGVsc2Uge1xuICAgICAgICAgbW9kZWwgPSAnZ2VtaW5pLWxpdmUtMi41LWZsYXNoLXByZXZpZXcnO1xuICAgICAgIH1cbiAgICAgICBjb25zdCBzZXNzaW9uID0gYXdhaXQgYWkubGl2ZS5jb25uZWN0KHtcbiAgICAgICAgIG1vZGVsOiBtb2RlbCxcbiAgICAgICAgIGNvbmZpZzoge1xuICAgICAgICAgICByZXNwb25zZU1vZGFsaXRpZXM6IFtNb2RhbGl0eS5BVURJT10sXG4gICAgICAgICB9XG4gICAgICAgfSk7XG4gIFxuICAgICAgIHNlc3Npb24uY2xvc2UoKTtcbiAgICAgICBgYGBcbiAgICAgKi9cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy5jb25uLmNsb3NlKCk7XG4gICAgfVxufVxuLy8gQ29udmVydHMgYW4gaGVhZGVycyBvYmplY3QgdG8gYSBcIm1hcFwiIG9iamVjdCBhcyBleHBlY3RlZCBieSB0aGUgV2ViU29ja2V0XG4vLyBjb25zdHJ1Y3Rvci4gV2UgdXNlIHRoaXMgYXMgdGhlIEF1dGggaW50ZXJmYWNlIHdvcmtzIHdpdGggSGVhZGVycyBvYmplY3RzXG4vLyB3aGlsZSB0aGUgV2ViU29ja2V0IGNvbnN0cnVjdG9yIHRha2VzIGEgbWFwLlxuZnVuY3Rpb24gaGVhZGVyc1RvTWFwKGhlYWRlcnMpIHtcbiAgICBjb25zdCBoZWFkZXJNYXAgPSB7fTtcbiAgICBoZWFkZXJzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgaGVhZGVyTWFwW2tleV0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gaGVhZGVyTWFwO1xufVxuLy8gQ29udmVydHMgYSBcIm1hcFwiIG9iamVjdCB0byBhIGhlYWRlcnMgb2JqZWN0LiBXZSB1c2UgdGhpcyBhcyB0aGUgQXV0aFxuLy8gaW50ZXJmYWNlIHdvcmtzIHdpdGggSGVhZGVycyBvYmplY3RzIHdoaWxlIHRoZSBBUEkgY2xpZW50IGRlZmF1bHQgaGVhZGVyc1xuLy8gcmV0dXJucyBhIG1hcC5cbmZ1bmN0aW9uIG1hcFRvSGVhZGVycyhtYXApIHtcbiAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhtYXApKSB7XG4gICAgICAgIGhlYWRlcnMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gaGVhZGVycztcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY29uc3QgREVGQVVMVF9NQVhfUkVNT1RFX0NBTExTID0gMTA7XG4vKiogUmV0dXJucyB3aGV0aGVyIGF1dG9tYXRpYyBmdW5jdGlvbiBjYWxsaW5nIGlzIGRpc2FibGVkLiAqL1xuZnVuY3Rpb24gc2hvdWxkRGlzYWJsZUFmYyhjb25maWcpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBpZiAoKF9hID0gY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLmF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRpc2FibGUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGxldCBjYWxsYWJsZVRvb2xzUHJlc2VudCA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgdG9vbCBvZiAoX2IgPSBjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcudG9vbHMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdKSB7XG4gICAgICAgIGlmIChpc0NhbGxhYmxlVG9vbCh0b29sKSkge1xuICAgICAgICAgICAgY2FsbGFibGVUb29sc1ByZXNlbnQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFjYWxsYWJsZVRvb2xzUHJlc2VudCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgbWF4Q2FsbHMgPSAoX2MgPSBjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcuYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MubWF4aW11bVJlbW90ZUNhbGxzO1xuICAgIGlmICgobWF4Q2FsbHMgJiYgKG1heENhbGxzIDwgMCB8fCAhTnVtYmVyLmlzSW50ZWdlcihtYXhDYWxscykpKSB8fFxuICAgICAgICBtYXhDYWxscyA9PSAwKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignSW52YWxpZCBtYXhpbXVtUmVtb3RlQ2FsbHMgdmFsdWUgcHJvdmlkZWQgZm9yIGF1dG9tYXRpYyBmdW5jdGlvbiBjYWxsaW5nLiBEaXNhYmxlZCBhdXRvbWF0aWMgZnVuY3Rpb24gY2FsbGluZy4gUGxlYXNlIHByb3ZpZGUgYSB2YWxpZCBpbnRlZ2VyIHZhbHVlIGdyZWF0ZXIgdGhhbiAwLiBtYXhpbXVtUmVtb3RlQ2FsbHMgcHJvdmlkZWQ6JywgbWF4Q2FsbHMpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNDYWxsYWJsZVRvb2wodG9vbCkge1xuICAgIHJldHVybiAnY2FsbFRvb2wnIGluIHRvb2wgJiYgdHlwZW9mIHRvb2wuY2FsbFRvb2wgPT09ICdmdW5jdGlvbic7XG59XG4vLyBDaGVja3Mgd2hldGhlciB0aGUgbGlzdCBvZiB0b29scyBjb250YWlucyBhbnkgQ2FsbGFibGVUb29scy4gV2lsbCByZXR1cm4gdHJ1ZVxuLy8gaWYgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIENhbGxhYmxlVG9vbC5cbmZ1bmN0aW9uIGhhc0NhbGxhYmxlVG9vbHMocGFyYW1zKSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgcmV0dXJuIChfYyA9IChfYiA9IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b29scykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNvbWUoKHRvb2wpID0+IGlzQ2FsbGFibGVUb29sKHRvb2wpKSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogZmFsc2U7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGluZGV4ZXMgb2YgdGhlIHRvb2xzIHRoYXQgYXJlIG5vdCBjb21wYXRpYmxlIHdpdGggQUZDLlxuICovXG5mdW5jdGlvbiBmaW5kQWZjSW5jb21wYXRpYmxlVG9vbEluZGV4ZXMocGFyYW1zKSB7XG4gICAgdmFyIF9hO1xuICAgIC8vIFVzZSBudW1iZXJbXSBmb3IgYW4gYXJyYXkgb2YgbnVtYmVycyBpbiBUeXBlU2NyaXB0XG4gICAgY29uc3QgYWZjSW5jb21wYXRpYmxlVG9vbEluZGV4ZXMgPSBbXTtcbiAgICBpZiAoISgoX2EgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9vbHMpKSB7XG4gICAgICAgIHJldHVybiBhZmNJbmNvbXBhdGlibGVUb29sSW5kZXhlcztcbiAgICB9XG4gICAgcGFyYW1zLmNvbmZpZy50b29scy5mb3JFYWNoKCh0b29sLCBpbmRleCkgPT4ge1xuICAgICAgICBpZiAoaXNDYWxsYWJsZVRvb2wodG9vbCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBnZW1pbmlUb29sID0gdG9vbDtcbiAgICAgICAgaWYgKGdlbWluaVRvb2wuZnVuY3Rpb25EZWNsYXJhdGlvbnMgJiZcbiAgICAgICAgICAgIGdlbWluaVRvb2wuZnVuY3Rpb25EZWNsYXJhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgYWZjSW5jb21wYXRpYmxlVG9vbEluZGV4ZXMucHVzaChpbmRleCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gYWZjSW5jb21wYXRpYmxlVG9vbEluZGV4ZXM7XG59XG4vKipcbiAqIFJldHVybnMgd2hldGhlciB0byBhcHBlbmQgYXV0b21hdGljIGZ1bmN0aW9uIGNhbGxpbmcgaGlzdG9yeSB0byB0aGVcbiAqIHJlc3BvbnNlLlxuICovXG5mdW5jdGlvbiBzaG91bGRBcHBlbmRBZmNIaXN0b3J5KGNvbmZpZykge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gISgoX2EgPSBjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcuYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaWdub3JlQ2FsbEhpc3RvcnkpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jbGFzcyBNb2RlbHMgZXh0ZW5kcyBCYXNlTW9kdWxlIHtcbiAgICBjb25zdHJ1Y3RvcihhcGlDbGllbnQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBhcGlDbGllbnQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYWtlcyBhbiBBUEkgcmVxdWVzdCB0byBnZW5lcmF0ZSBjb250ZW50IHdpdGggYSBnaXZlbiBtb2RlbC5cbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIHRoZSBgbW9kZWxgIHBhcmFtZXRlciwgc3VwcG9ydGVkIGZvcm1hdHMgZm9yIFZlcnRleCBBSSBBUEkgaW5jbHVkZTpcbiAgICAgICAgICogLSBUaGUgR2VtaW5pIG1vZGVsIElELCBmb3IgZXhhbXBsZTogJ2dlbWluaS0yLjAtZmxhc2gnXG4gICAgICAgICAqIC0gVGhlIGZ1bGwgcmVzb3VyY2UgbmFtZSBzdGFydHMgd2l0aCAncHJvamVjdHMvJywgZm9yIGV4YW1wbGU6XG4gICAgICAgICAqICAncHJvamVjdHMvbXktcHJvamVjdC1pZC9sb2NhdGlvbnMvdXMtY2VudHJhbDEvcHVibGlzaGVycy9nb29nbGUvbW9kZWxzL2dlbWluaS0yLjAtZmxhc2gnXG4gICAgICAgICAqIC0gVGhlIHBhcnRpYWwgcmVzb3VyY2UgbmFtZSB3aXRoICdwdWJsaXNoZXJzLycsIGZvciBleGFtcGxlOlxuICAgICAgICAgKiAgJ3B1Ymxpc2hlcnMvZ29vZ2xlL21vZGVscy9nZW1pbmktMi4wLWZsYXNoJyBvclxuICAgICAgICAgKiAgJ3B1Ymxpc2hlcnMvbWV0YS9tb2RlbHMvbGxhbWEtMy4xLTQwNWItaW5zdHJ1Y3QtbWFhcydcbiAgICAgICAgICogLSBgL2Agc2VwYXJhdGVkIHB1Ymxpc2hlciBhbmQgbW9kZWwgbmFtZSwgZm9yIGV4YW1wbGU6XG4gICAgICAgICAqICdnb29nbGUvZ2VtaW5pLTIuMC1mbGFzaCcgb3IgJ21ldGEvbGxhbWEtMy4xLTQwNWItaW5zdHJ1Y3QtbWFhcydcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIHRoZSBgbW9kZWxgIHBhcmFtZXRlciwgc3VwcG9ydGVkIGZvcm1hdHMgZm9yIEdlbWluaSBBUEkgaW5jbHVkZTpcbiAgICAgICAgICogLSBUaGUgR2VtaW5pIG1vZGVsIElELCBmb3IgZXhhbXBsZTogJ2dlbWluaS0yLjAtZmxhc2gnXG4gICAgICAgICAqIC0gVGhlIG1vZGVsIG5hbWUgc3RhcnRzIHdpdGggJ21vZGVscy8nLCBmb3IgZXhhbXBsZTpcbiAgICAgICAgICogICdtb2RlbHMvZ2VtaW5pLTIuMC1mbGFzaCdcbiAgICAgICAgICogLSBGb3IgdHVuZWQgbW9kZWxzLCB0aGUgbW9kZWwgbmFtZSBzdGFydHMgd2l0aCAndHVuZWRNb2RlbHMvJyxcbiAgICAgICAgICogZm9yIGV4YW1wbGU6XG4gICAgICAgICAqICd0dW5lZE1vZGVscy8xMjM0NTY3ODkwMTIzNDU2Nzg5J1xuICAgICAgICAgKlxuICAgICAgICAgKiBTb21lIG1vZGVscyBzdXBwb3J0IG11bHRpbW9kYWwgaW5wdXQgYW5kIG91dHB1dC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBnZW5lcmF0aW5nIGNvbnRlbnQuXG4gICAgICAgICAqIEByZXR1cm4gVGhlIHJlc3BvbnNlIGZyb20gZ2VuZXJhdGluZyBjb250ZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLm1vZGVscy5nZW5lcmF0ZUNvbnRlbnQoe1xuICAgICAgICAgKiAgIG1vZGVsOiAnZ2VtaW5pLTIuMC1mbGFzaCcsXG4gICAgICAgICAqICAgY29udGVudHM6ICd3aHkgaXMgdGhlIHNreSBibHVlPycsXG4gICAgICAgICAqICAgY29uZmlnOiB7XG4gICAgICAgICAqICAgICBjYW5kaWRhdGVDb3VudDogMixcbiAgICAgICAgICogICB9XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZSk7XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZW5lcmF0ZUNvbnRlbnQgPSBhc3luYyAocGFyYW1zKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtZWRQYXJhbXMgPSBhd2FpdCB0aGlzLnByb2Nlc3NQYXJhbXNNYXliZUFkZE1jcFVzYWdlKHBhcmFtcyk7XG4gICAgICAgICAgICB0aGlzLm1heWJlTW92ZVRvUmVzcG9uc2VKc29uU2NoZW0ocGFyYW1zKTtcbiAgICAgICAgICAgIGlmICghaGFzQ2FsbGFibGVUb29scyhwYXJhbXMpIHx8IHNob3VsZERpc2FibGVBZmMocGFyYW1zLmNvbmZpZykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZW5lcmF0ZUNvbnRlbnRJbnRlcm5hbCh0cmFuc2Zvcm1lZFBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpbmNvbXBhdGlibGVUb29sSW5kZXhlcyA9IGZpbmRBZmNJbmNvbXBhdGlibGVUb29sSW5kZXhlcyhwYXJhbXMpO1xuICAgICAgICAgICAgaWYgKGluY29tcGF0aWJsZVRvb2xJbmRleGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmb3JtYXR0ZWRJbmRleGVzID0gaW5jb21wYXRpYmxlVG9vbEluZGV4ZXNcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgoaW5kZXgpID0+IGB0b29sc1ske2luZGV4fV1gKVxuICAgICAgICAgICAgICAgICAgICAuam9pbignLCAnKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEF1dG9tYXRpYyBmdW5jdGlvbiBjYWxsaW5nIHdpdGggQ2FsbGFibGVUb29scyAob3IgTUNQIG9iamVjdHMpIGFuZCBiYXNpYyBGdW5jdGlvbkRlY2xhcmF0aW9ucyBpcyBub3QgeWV0IHN1cHBvcnRlZC4gSW5jb21wYXRpYmxlIHRvb2xzIGZvdW5kIGF0ICR7Zm9ybWF0dGVkSW5kZXhlc30uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgICAgICBsZXQgZnVuY3Rpb25SZXNwb25zZUNvbnRlbnQ7XG4gICAgICAgICAgICBjb25zdCBhdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmdIaXN0b3J5ID0gdENvbnRlbnRzKHRyYW5zZm9ybWVkUGFyYW1zLmNvbnRlbnRzKTtcbiAgICAgICAgICAgIGNvbnN0IG1heFJlbW90ZUNhbGxzID0gKF9jID0gKF9iID0gKF9hID0gdHJhbnNmb3JtZWRQYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubWF4aW11bVJlbW90ZUNhbGxzKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBERUZBVUxUX01BWF9SRU1PVEVfQ0FMTFM7XG4gICAgICAgICAgICBsZXQgcmVtb3RlQ2FsbHMgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKHJlbW90ZUNhbGxzIDwgbWF4UmVtb3RlQ2FsbHMpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMuZ2VuZXJhdGVDb250ZW50SW50ZXJuYWwodHJhbnNmb3JtZWRQYXJhbXMpO1xuICAgICAgICAgICAgICAgIGlmICghcmVzcG9uc2UuZnVuY3Rpb25DYWxscyB8fCByZXNwb25zZS5mdW5jdGlvbkNhbGxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VDb250ZW50ID0gcmVzcG9uc2UuY2FuZGlkYXRlc1swXS5jb250ZW50O1xuICAgICAgICAgICAgICAgIGNvbnN0IGZ1bmN0aW9uUmVzcG9uc2VQYXJ0cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdG9vbCBvZiAoX2UgPSAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QudG9vbHMpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IFtdKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0NhbGxhYmxlVG9vbCh0b29sKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FsbGFibGVUb29sID0gdG9vbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gYXdhaXQgY2FsbGFibGVUb29sLmNhbGxUb29sKHJlc3BvbnNlLmZ1bmN0aW9uQ2FsbHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25SZXNwb25zZVBhcnRzLnB1c2goLi4ucGFydHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlbW90ZUNhbGxzKys7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb25SZXNwb25zZUNvbnRlbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHJvbGU6ICd1c2VyJyxcbiAgICAgICAgICAgICAgICAgICAgcGFydHM6IGZ1bmN0aW9uUmVzcG9uc2VQYXJ0cyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkUGFyYW1zLmNvbnRlbnRzID0gdENvbnRlbnRzKHRyYW5zZm9ybWVkUGFyYW1zLmNvbnRlbnRzKTtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZFBhcmFtcy5jb250ZW50cy5wdXNoKHJlc3BvbnNlQ29udGVudCk7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtZWRQYXJhbXMuY29udGVudHMucHVzaChmdW5jdGlvblJlc3BvbnNlQ29udGVudCk7XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZEFwcGVuZEFmY0hpc3RvcnkodHJhbnNmb3JtZWRQYXJhbXMuY29uZmlnKSkge1xuICAgICAgICAgICAgICAgICAgICBhdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmdIaXN0b3J5LnB1c2gocmVzcG9uc2VDb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeS5wdXNoKGZ1bmN0aW9uUmVzcG9uc2VDb250ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2hvdWxkQXBwZW5kQWZjSGlzdG9yeSh0cmFuc2Zvcm1lZFBhcmFtcy5jb25maWcpKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UuYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeSA9XG4gICAgICAgICAgICAgICAgICAgIGF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZ0hpc3Rvcnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYWtlcyBhbiBBUEkgcmVxdWVzdCB0byBnZW5lcmF0ZSBjb250ZW50IHdpdGggYSBnaXZlbiBtb2RlbCBhbmQgeWllbGRzIHRoZVxuICAgICAgICAgKiByZXNwb25zZSBpbiBjaHVua3MuXG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciB0aGUgYG1vZGVsYCBwYXJhbWV0ZXIsIHN1cHBvcnRlZCBmb3JtYXRzIGZvciBWZXJ0ZXggQUkgQVBJIGluY2x1ZGU6XG4gICAgICAgICAqIC0gVGhlIEdlbWluaSBtb2RlbCBJRCwgZm9yIGV4YW1wbGU6ICdnZW1pbmktMi4wLWZsYXNoJ1xuICAgICAgICAgKiAtIFRoZSBmdWxsIHJlc291cmNlIG5hbWUgc3RhcnRzIHdpdGggJ3Byb2plY3RzLycsIGZvciBleGFtcGxlOlxuICAgICAgICAgKiAgJ3Byb2plY3RzL215LXByb2plY3QtaWQvbG9jYXRpb25zL3VzLWNlbnRyYWwxL3B1Ymxpc2hlcnMvZ29vZ2xlL21vZGVscy9nZW1pbmktMi4wLWZsYXNoJ1xuICAgICAgICAgKiAtIFRoZSBwYXJ0aWFsIHJlc291cmNlIG5hbWUgd2l0aCAncHVibGlzaGVycy8nLCBmb3IgZXhhbXBsZTpcbiAgICAgICAgICogICdwdWJsaXNoZXJzL2dvb2dsZS9tb2RlbHMvZ2VtaW5pLTIuMC1mbGFzaCcgb3JcbiAgICAgICAgICogICdwdWJsaXNoZXJzL21ldGEvbW9kZWxzL2xsYW1hLTMuMS00MDViLWluc3RydWN0LW1hYXMnXG4gICAgICAgICAqIC0gYC9gIHNlcGFyYXRlZCBwdWJsaXNoZXIgYW5kIG1vZGVsIG5hbWUsIGZvciBleGFtcGxlOlxuICAgICAgICAgKiAnZ29vZ2xlL2dlbWluaS0yLjAtZmxhc2gnIG9yICdtZXRhL2xsYW1hLTMuMS00MDViLWluc3RydWN0LW1hYXMnXG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciB0aGUgYG1vZGVsYCBwYXJhbWV0ZXIsIHN1cHBvcnRlZCBmb3JtYXRzIGZvciBHZW1pbmkgQVBJIGluY2x1ZGU6XG4gICAgICAgICAqIC0gVGhlIEdlbWluaSBtb2RlbCBJRCwgZm9yIGV4YW1wbGU6ICdnZW1pbmktMi4wLWZsYXNoJ1xuICAgICAgICAgKiAtIFRoZSBtb2RlbCBuYW1lIHN0YXJ0cyB3aXRoICdtb2RlbHMvJywgZm9yIGV4YW1wbGU6XG4gICAgICAgICAqICAnbW9kZWxzL2dlbWluaS0yLjAtZmxhc2gnXG4gICAgICAgICAqIC0gRm9yIHR1bmVkIG1vZGVscywgdGhlIG1vZGVsIG5hbWUgc3RhcnRzIHdpdGggJ3R1bmVkTW9kZWxzLycsXG4gICAgICAgICAqIGZvciBleGFtcGxlOlxuICAgICAgICAgKiAgJ3R1bmVkTW9kZWxzLzEyMzQ1Njc4OTAxMjM0NTY3ODknXG4gICAgICAgICAqXG4gICAgICAgICAqIFNvbWUgbW9kZWxzIHN1cHBvcnQgbXVsdGltb2RhbCBpbnB1dCBhbmQgb3V0cHV0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIGdlbmVyYXRpbmcgY29udGVudCB3aXRoIHN0cmVhbWluZyByZXNwb25zZS5cbiAgICAgICAgICogQHJldHVybiBUaGUgcmVzcG9uc2UgZnJvbSBnZW5lcmF0aW5nIGNvbnRlbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkubW9kZWxzLmdlbmVyYXRlQ29udGVudFN0cmVhbSh7XG4gICAgICAgICAqICAgbW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoJyxcbiAgICAgICAgICogICBjb250ZW50czogJ3doeSBpcyB0aGUgc2t5IGJsdWU/JyxcbiAgICAgICAgICogICBjb25maWc6IHtcbiAgICAgICAgICogICAgIG1heE91dHB1dFRva2VuczogMjAwLFxuICAgICAgICAgKiAgIH1cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgcmVzcG9uc2UpIHtcbiAgICAgICAgICogICBjb25zb2xlLmxvZyhjaHVuayk7XG4gICAgICAgICAqIH1cbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdlbmVyYXRlQ29udGVudFN0cmVhbSA9IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgICAgICAgICB0aGlzLm1heWJlTW92ZVRvUmVzcG9uc2VKc29uU2NoZW0ocGFyYW1zKTtcbiAgICAgICAgICAgIGlmIChzaG91bGREaXNhYmxlQWZjKHBhcmFtcy5jb25maWcpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtZWRQYXJhbXMgPSBhd2FpdCB0aGlzLnByb2Nlc3NQYXJhbXNNYXliZUFkZE1jcFVzYWdlKHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2VuZXJhdGVDb250ZW50U3RyZWFtSW50ZXJuYWwodHJhbnNmb3JtZWRQYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaW5jb21wYXRpYmxlVG9vbEluZGV4ZXMgPSBmaW5kQWZjSW5jb21wYXRpYmxlVG9vbEluZGV4ZXMocGFyYW1zKTtcbiAgICAgICAgICAgIGlmIChpbmNvbXBhdGlibGVUb29sSW5kZXhlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZm9ybWF0dGVkSW5kZXhlcyA9IGluY29tcGF0aWJsZVRvb2xJbmRleGVzXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKGluZGV4KSA9PiBgdG9vbHNbJHtpbmRleH1dYClcbiAgICAgICAgICAgICAgICAgICAgLmpvaW4oJywgJyk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbmNvbXBhdGlibGUgdG9vbHMgZm91bmQgYXQgJHtmb3JtYXR0ZWRJbmRleGVzfS4gQXV0b21hdGljIGZ1bmN0aW9uIGNhbGxpbmcgd2l0aCBDYWxsYWJsZVRvb2xzIChvciBNQ1Agb2JqZWN0cykgYW5kIGJhc2ljIEZ1bmN0aW9uRGVjbGFyYXRpb25zXCIgaXMgbm90IHlldCBzdXBwb3J0ZWQuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXaXRoIHRvb2wgY29tcGF0aWJpbGl0eSBjb25maXJtZWQsIHZhbGlkYXRlIHRoYXQgdGhlIGNvbmZpZ3VyYXRpb24gYXJlXG4gICAgICAgICAgICAvLyBjb21wYXRpYmxlIHdpdGggZWFjaCBvdGhlciBhbmQgcmFpc2UgYW4gZXJyb3IgaWYgaW52YWxpZC5cbiAgICAgICAgICAgIGNvbnN0IHN0cmVhbUZ1bmN0aW9uQ2FsbCA9IChfYyA9IChfYiA9IChfYSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b29sQ29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZnVuY3Rpb25DYWxsaW5nQ29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Muc3RyZWFtRnVuY3Rpb25DYWxsQXJndW1lbnRzO1xuICAgICAgICAgICAgY29uc3QgZGlzYWJsZUFmYyA9IChfZSA9IChfZCA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmcpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5kaXNhYmxlO1xuICAgICAgICAgICAgaWYgKHN0cmVhbUZ1bmN0aW9uQ2FsbCAmJiAhZGlzYWJsZUFmYykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJ1bm5pbmcgaW4gc3RyZWFtaW5nIG1vZGUgd2l0aCAnc3RyZWFtRnVuY3Rpb25DYWxsQXJndW1lbnRzJyBlbmFibGVkLCBcIiArXG4gICAgICAgICAgICAgICAgICAgICd0aGlzIGZlYXR1cmUgaXMgbm90IGNvbXBhdGlibGUgd2l0aCBhdXRvbWF0aWMgZnVuY3Rpb24gY2FsbGluZyAoQUZDKS4gJyArXG4gICAgICAgICAgICAgICAgICAgIFwiUGxlYXNlIHNldCAnY29uZmlnLmF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZy5kaXNhYmxlJyB0byB0cnVlIHRvIGRpc2FibGUgQUZDIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJvciBsZWF2ZSAnY29uZmlnLnRvb2xDb25maWcuZnVuY3Rpb25DYWxsaW5nQ29uZmlnLnN0cmVhbUZ1bmN0aW9uQ2FsbEFyZ3VtZW50cycgXCIgK1xuICAgICAgICAgICAgICAgICAgICAndG8gYmUgdW5kZWZpbmVkIG9yIHNldCB0byBmYWxzZSB0byBkaXNhYmxlIHN0cmVhbWluZyBmdW5jdGlvbiBjYWxsIGFyZ3VtZW50cyBmZWF0dXJlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJvY2Vzc0FmY1N0cmVhbShwYXJhbXMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2VuZXJhdGVzIGFuIGltYWdlIGJhc2VkIG9uIGEgdGV4dCBkZXNjcmlwdGlvbiBhbmQgY29uZmlndXJhdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBnZW5lcmF0aW5nIGltYWdlcy5cbiAgICAgICAgICogQHJldHVybiBUaGUgcmVzcG9uc2UgZnJvbSB0aGUgQVBJLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNsaWVudC5tb2RlbHMuZ2VuZXJhdGVJbWFnZXMoe1xuICAgICAgICAgKiAgbW9kZWw6ICdpbWFnZW4tMy4wLWdlbmVyYXRlLTAwMicsXG4gICAgICAgICAqICBwcm9tcHQ6ICdSb2JvdCBob2xkaW5nIGEgcmVkIHNrYXRlYm9hcmQnLFxuICAgICAgICAgKiAgY29uZmlnOiB7XG4gICAgICAgICAqICAgIG51bWJlck9mSW1hZ2VzOiAxLFxuICAgICAgICAgKiAgICBpbmNsdWRlUmFpUmVhc29uOiB0cnVlLFxuICAgICAgICAgKiAgfSxcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlPy5nZW5lcmF0ZWRJbWFnZXM/LlswXT8uaW1hZ2U/LmltYWdlQnl0ZXMpO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2VuZXJhdGVJbWFnZXMgPSBhc3luYyAocGFyYW1zKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZW5lcmF0ZUltYWdlc0ludGVybmFsKHBhcmFtcykudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgbGV0IHBvc2l0aXZlUHJvbXB0U2FmZXR5QXR0cmlidXRlcztcbiAgICAgICAgICAgICAgICBjb25zdCBnZW5lcmF0ZWRJbWFnZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAoYXBpUmVzcG9uc2UgPT09IG51bGwgfHwgYXBpUmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFwaVJlc3BvbnNlLmdlbmVyYXRlZEltYWdlcykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGdlbmVyYXRlZEltYWdlIG9mIGFwaVJlc3BvbnNlLmdlbmVyYXRlZEltYWdlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdlbmVyYXRlZEltYWdlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGdlbmVyYXRlZEltYWdlID09PSBudWxsIHx8IGdlbmVyYXRlZEltYWdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBnZW5lcmF0ZWRJbWFnZS5zYWZldHlBdHRyaWJ1dGVzKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoX2EgPSBnZW5lcmF0ZWRJbWFnZSA9PT0gbnVsbCB8fCBnZW5lcmF0ZWRJbWFnZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ2VuZXJhdGVkSW1hZ2Uuc2FmZXR5QXR0cmlidXRlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbnRlbnRUeXBlKSA9PT0gJ1Bvc2l0aXZlIFByb21wdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXMgPSBnZW5lcmF0ZWRJbWFnZSA9PT0gbnVsbCB8fCBnZW5lcmF0ZWRJbWFnZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ2VuZXJhdGVkSW1hZ2Uuc2FmZXR5QXR0cmlidXRlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlZEltYWdlcy5wdXNoKGdlbmVyYXRlZEltYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aXZlUHJvbXB0U2FmZXR5QXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlZEltYWdlczogZ2VuZXJhdGVkSW1hZ2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpdmVQcm9tcHRTYWZldHlBdHRyaWJ1dGVzOiBwb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZGtIdHRwUmVzcG9uc2U6IGFwaVJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVkSW1hZ2VzOiBnZW5lcmF0ZWRJbWFnZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZGtIdHRwUmVzcG9uc2U6IGFwaVJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubGlzdCA9IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRDb25maWcgPSB7XG4gICAgICAgICAgICAgICAgcXVlcnlCYXNlOiB0cnVlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGFjdHVhbENvbmZpZyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdENvbmZpZyksIHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5jb25maWcpO1xuICAgICAgICAgICAgY29uc3QgYWN0dWFsUGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGNvbmZpZzogYWN0dWFsQ29uZmlnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFjdHVhbFBhcmFtcy5jb25maWcucXVlcnlCYXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoX2EgPSBhY3R1YWxQYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpbHRlcmluZyB0dW5lZCBtb2RlbHMgbGlzdCBmb3IgVmVydGV4IEFJIGlzIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWxQYXJhbXMuY29uZmlnLmZpbHRlciA9ICdsYWJlbHMudHVuZS10eXBlOionO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYWdlcihQYWdlZEl0ZW0uUEFHRURfSVRFTV9NT0RFTFMsICh4KSA9PiB0aGlzLmxpc3RJbnRlcm5hbCh4KSwgYXdhaXQgdGhpcy5saXN0SW50ZXJuYWwoYWN0dWFsUGFyYW1zKSwgYWN0dWFsUGFyYW1zKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVkaXRzIGFuIGltYWdlIGJhc2VkIG9uIGEgcHJvbXB0LCBsaXN0IG9mIHJlZmVyZW5jZSBpbWFnZXMsIGFuZCBjb25maWd1cmF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIGVkaXRpbmcgYW4gaW1hZ2UuXG4gICAgICAgICAqIEByZXR1cm4gVGhlIHJlc3BvbnNlIGZyb20gdGhlIEFQSS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjbGllbnQubW9kZWxzLmVkaXRJbWFnZSh7XG4gICAgICAgICAqICBtb2RlbDogJ2ltYWdlbi0zLjAtY2FwYWJpbGl0eS0wMDEnLFxuICAgICAgICAgKiAgcHJvbXB0OiAnR2VuZXJhdGUgYW4gaW1hZ2UgY29udGFpbmluZyBhIG11ZyB3aXRoIHRoZSBwcm9kdWN0IGxvZ28gWzFdIHZpc2libGUgb24gdGhlIHNpZGUgb2YgdGhlIG11Zy4nLFxuICAgICAgICAgKiAgcmVmZXJlbmNlSW1hZ2VzOiBbc3ViamVjdFJlZmVyZW5jZUltYWdlXVxuICAgICAgICAgKiAgY29uZmlnOiB7XG4gICAgICAgICAqICAgIG51bWJlck9mSW1hZ2VzOiAxLFxuICAgICAgICAgKiAgICBpbmNsdWRlUmFpUmVhc29uOiB0cnVlLFxuICAgICAgICAgKiAgfSxcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlPy5nZW5lcmF0ZWRJbWFnZXM/LlswXT8uaW1hZ2U/LmltYWdlQnl0ZXMpO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZWRpdEltYWdlID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGFyYW1zSW50ZXJuYWwgPSB7XG4gICAgICAgICAgICAgICAgbW9kZWw6IHBhcmFtcy5tb2RlbCxcbiAgICAgICAgICAgICAgICBwcm9tcHQ6IHBhcmFtcy5wcm9tcHQsXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlSW1hZ2VzOiBbXSxcbiAgICAgICAgICAgICAgICBjb25maWc6IHBhcmFtcy5jb25maWcsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHBhcmFtcy5yZWZlcmVuY2VJbWFnZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLnJlZmVyZW5jZUltYWdlcykge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXNJbnRlcm5hbC5yZWZlcmVuY2VJbWFnZXMgPSBwYXJhbXMucmVmZXJlbmNlSW1hZ2VzLm1hcCgoaW1nKSA9PiBpbWcudG9SZWZlcmVuY2VJbWFnZUFQSSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5lZGl0SW1hZ2VJbnRlcm5hbChwYXJhbXNJbnRlcm5hbCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcHNjYWxlcyBhbiBpbWFnZSBiYXNlZCBvbiBhbiBpbWFnZSwgdXBzY2FsZSBmYWN0b3IsIGFuZCBjb25maWd1cmF0aW9uLlxuICAgICAgICAgKiBPbmx5IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkgY3VycmVudGx5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHVwc2NhbGluZyBhbiBpbWFnZS5cbiAgICAgICAgICogQHJldHVybiBUaGUgcmVzcG9uc2UgZnJvbSB0aGUgQVBJLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNsaWVudC5tb2RlbHMudXBzY2FsZUltYWdlKHtcbiAgICAgICAgICogIG1vZGVsOiAnaW1hZ2VuLTMuMC1nZW5lcmF0ZS0wMDInLFxuICAgICAgICAgKiAgaW1hZ2U6IGltYWdlLFxuICAgICAgICAgKiAgdXBzY2FsZUZhY3RvcjogJ3gyJyxcbiAgICAgICAgICogIGNvbmZpZzoge1xuICAgICAgICAgKiAgICBpbmNsdWRlUmFpUmVhc29uOiB0cnVlLFxuICAgICAgICAgKiAgfSxcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlPy5nZW5lcmF0ZWRJbWFnZXM/LlswXT8uaW1hZ2U/LmltYWdlQnl0ZXMpO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudXBzY2FsZUltYWdlID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgbGV0IGFwaUNvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICBudW1iZXJPZkltYWdlczogMSxcbiAgICAgICAgICAgICAgICBtb2RlOiAndXBzY2FsZScsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHBhcmFtcy5jb25maWcpIHtcbiAgICAgICAgICAgICAgICBhcGlDb25maWcgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFwaUNvbmZpZyksIHBhcmFtcy5jb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXBpUGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIG1vZGVsOiBwYXJhbXMubW9kZWwsXG4gICAgICAgICAgICAgICAgaW1hZ2U6IHBhcmFtcy5pbWFnZSxcbiAgICAgICAgICAgICAgICB1cHNjYWxlRmFjdG9yOiBwYXJhbXMudXBzY2FsZUZhY3RvcixcbiAgICAgICAgICAgICAgICBjb25maWc6IGFwaUNvbmZpZyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy51cHNjYWxlSW1hZ2VJbnRlcm5hbChhcGlQYXJhbXMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogIEdlbmVyYXRlcyB2aWRlb3MgYmFzZWQgb24gYSB0ZXh0IGRlc2NyaXB0aW9uIGFuZCBjb25maWd1cmF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIGdlbmVyYXRpbmcgdmlkZW9zLlxuICAgICAgICAgKiBAcmV0dXJuIEEgUHJvbWlzZTxHZW5lcmF0ZVZpZGVvc09wZXJhdGlvbj4gd2hpY2ggYWxsb3dzIHlvdSB0byB0cmFjayB0aGUgcHJvZ3Jlc3MgYW5kIGV2ZW50dWFsbHkgcmV0cmlldmUgdGhlIGdlbmVyYXRlZCB2aWRlb3MgdXNpbmcgdGhlIG9wZXJhdGlvbnMuZ2V0IG1ldGhvZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogY29uc3Qgb3BlcmF0aW9uID0gYXdhaXQgYWkubW9kZWxzLmdlbmVyYXRlVmlkZW9zKHtcbiAgICAgICAgICogIG1vZGVsOiAndmVvLTIuMC1nZW5lcmF0ZS0wMDEnLFxuICAgICAgICAgKiAgc291cmNlOiB7XG4gICAgICAgICAqICAgIHByb21wdDogJ0EgbmVvbiBob2xvZ3JhbSBvZiBhIGNhdCBkcml2aW5nIGF0IHRvcCBzcGVlZCcsXG4gICAgICAgICAqICB9LFxuICAgICAgICAgKiAgY29uZmlnOiB7XG4gICAgICAgICAqICAgIG51bWJlck9mVmlkZW9zOiAxXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiB3aGlsZSAoIW9wZXJhdGlvbi5kb25lKSB7XG4gICAgICAgICAqICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDAwKSk7XG4gICAgICAgICAqICAgb3BlcmF0aW9uID0gYXdhaXQgYWkub3BlcmF0aW9ucy5nZXRWaWRlb3NPcGVyYXRpb24oe29wZXJhdGlvbjogb3BlcmF0aW9ufSk7XG4gICAgICAgICAqIH1cbiAgICAgICAgICpcbiAgICAgICAgICogY29uc29sZS5sb2cob3BlcmF0aW9uLnJlc3BvbnNlPy5nZW5lcmF0ZWRWaWRlb3M/LlswXT8udmlkZW8/LnVyaSk7XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZW5lcmF0ZVZpZGVvcyA9IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICAgICAgaWYgKChwYXJhbXMucHJvbXB0IHx8IHBhcmFtcy5pbWFnZSB8fCBwYXJhbXMudmlkZW8pICYmIHBhcmFtcy5zb3VyY2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NvdXJjZSBhbmQgcHJvbXB0L2ltYWdlL3ZpZGVvIGFyZSBtdXR1YWxseSBleGNsdXNpdmUuIFBsZWFzZSBvbmx5IHVzZSBzb3VyY2UuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHZW1pbmkgQVBJIGRvZXMgbm90IHN1cHBvcnQgdmlkZW8gYnl0ZXMuXG4gICAgICAgICAgICBpZiAoIXRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgICAgIGlmICgoKF9hID0gcGFyYW1zLnZpZGVvKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudXJpKSAmJiAoKF9iID0gcGFyYW1zLnZpZGVvKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudmlkZW9CeXRlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnZpZGVvID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJpOiBwYXJhbXMudmlkZW8udXJpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWltZVR5cGU6IHBhcmFtcy52aWRlby5taW1lVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKChfZCA9IChfYyA9IHBhcmFtcy5zb3VyY2UpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy52aWRlbykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnVyaSkgJiZcbiAgICAgICAgICAgICAgICAgICAgKChfZiA9IChfZSA9IHBhcmFtcy5zb3VyY2UpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS52aWRlbykgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLnZpZGVvQnl0ZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5zb3VyY2UudmlkZW8gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmk6IHBhcmFtcy5zb3VyY2UudmlkZW8udXJpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWltZVR5cGU6IHBhcmFtcy5zb3VyY2UudmlkZW8ubWltZVR5cGUsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2VuZXJhdGVWaWRlb3NJbnRlcm5hbChwYXJhbXMpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGxvZ2ljIGlzIG5lZWRlZCBmb3IgR2VuZXJhdGVDb250ZW50Q29uZmlnIG9ubHkuXG4gICAgICogUHJldmlvdXNseSB3ZSBtYWRlIEdlbmVyYXRlQ29udGVudENvbmZpZy5yZXNwb25zZVNjaGVtYSBmaWVsZCB0byBhY2NlcHRcbiAgICAgKiB1bmtub3duLiBTaW5jZSB2MS45LjAsIHdlIHN3aXRjaCB0byB1c2UgYmFja2VuZCBKU09OIHNjaGVtYSBzdXBwb3J0LlxuICAgICAqIFRvIG1haW50YWluIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHdlIG1vdmUgdGhlIGRhdGEgdGhhdCB3YXMgdHJlYXRlZCBhc1xuICAgICAqIEpTT04gc2NoZW1hIGZyb20gdGhlIHJlc3BvbnNlU2NoZW1hIGZpZWxkIHRvIHRoZSByZXNwb25zZUpzb25TY2hlbWEgZmllbGQuXG4gICAgICovXG4gICAgbWF5YmVNb3ZlVG9SZXNwb25zZUpzb25TY2hlbShwYXJhbXMpIHtcbiAgICAgICAgaWYgKHBhcmFtcy5jb25maWcgJiYgcGFyYW1zLmNvbmZpZy5yZXNwb25zZVNjaGVtYSkge1xuICAgICAgICAgICAgaWYgKCFwYXJhbXMuY29uZmlnLnJlc3BvbnNlSnNvblNjaGVtYSkge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhwYXJhbXMuY29uZmlnLnJlc3BvbnNlU2NoZW1hKS5pbmNsdWRlcygnJHNjaGVtYScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5jb25maWcucmVzcG9uc2VKc29uU2NoZW1hID0gcGFyYW1zLmNvbmZpZy5yZXNwb25zZVNjaGVtYTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBhcmFtcy5jb25maWcucmVzcG9uc2VTY2hlbWE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyB0aGUgQ2FsbGFibGVUb29scyBpbiB0aGUgcGFyYW1ldGVycyB0byBiZSBzaW1wbHkgVG9vbHMsIGl0XG4gICAgICogY29waWVzIHRoZSBwYXJhbXMgaW50byBhIG5ldyBvYmplY3QgYW5kIHJlcGxhY2VzIHRoZSB0b29scywgaXQgZG9lcyBub3RcbiAgICAgKiBtb2RpZnkgdGhlIG9yaWdpbmFsIHBhcmFtcy4gQWxzbyBzZXRzIHRoZSBNQ1AgdXNhZ2UgaGVhZGVyIGlmIHRoZXJlIGFyZVxuICAgICAqIE1DUCB0b29scyBpbiB0aGUgcGFyYW1ldGVycy5cbiAgICAgKi9cbiAgICBhc3luYyBwcm9jZXNzUGFyYW1zTWF5YmVBZGRNY3BVc2FnZShwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGNvbnN0IHRvb2xzID0gKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvb2xzO1xuICAgICAgICBpZiAoIXRvb2xzKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkVG9vbHMgPSBhd2FpdCBQcm9taXNlLmFsbCh0b29scy5tYXAoYXN5bmMgKHRvb2wpID0+IHtcbiAgICAgICAgICAgIGlmIChpc0NhbGxhYmxlVG9vbCh0b29sKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxhYmxlVG9vbCA9IHRvb2w7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGNhbGxhYmxlVG9vbC50b29sKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdG9vbDtcbiAgICAgICAgfSkpO1xuICAgICAgICBjb25zdCBuZXdQYXJhbXMgPSB7XG4gICAgICAgICAgICBtb2RlbDogcGFyYW1zLm1vZGVsLFxuICAgICAgICAgICAgY29udGVudHM6IHBhcmFtcy5jb250ZW50cyxcbiAgICAgICAgICAgIGNvbmZpZzogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMuY29uZmlnKSwgeyB0b29sczogdHJhbnNmb3JtZWRUb29scyB9KSxcbiAgICAgICAgfTtcbiAgICAgICAgbmV3UGFyYW1zLmNvbmZpZy50b29scyA9IHRyYW5zZm9ybWVkVG9vbHM7XG4gICAgICAgIGlmIChwYXJhbXMuY29uZmlnICYmXG4gICAgICAgICAgICBwYXJhbXMuY29uZmlnLnRvb2xzICYmXG4gICAgICAgICAgICBoYXNNY3BUb29sVXNhZ2UocGFyYW1zLmNvbmZpZy50b29scykpIHtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSAoX2MgPSAoX2IgPSBwYXJhbXMuY29uZmlnLmh0dHBPcHRpb25zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaGVhZGVycykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDoge307XG4gICAgICAgICAgICBsZXQgbmV3SGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIGhlYWRlcnMpO1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKG5ld0hlYWRlcnMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG5ld0hlYWRlcnMgPSB0aGlzLmFwaUNsaWVudC5nZXREZWZhdWx0SGVhZGVycygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0TWNwVXNhZ2VIZWFkZXIobmV3SGVhZGVycyk7XG4gICAgICAgICAgICBuZXdQYXJhbXMuY29uZmlnLmh0dHBPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMuY29uZmlnLmh0dHBPcHRpb25zKSwgeyBoZWFkZXJzOiBuZXdIZWFkZXJzIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdQYXJhbXM7XG4gICAgfVxuICAgIGFzeW5jIGluaXRBZmNUb29sc01hcChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGNvbnN0IGFmY1Rvb2xzID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGNvbnN0IHRvb2wgb2YgKF9iID0gKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvb2xzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXSkge1xuICAgICAgICAgICAgaWYgKGlzQ2FsbGFibGVUb29sKHRvb2wpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FsbGFibGVUb29sID0gdG9vbDtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29sRGVjbGFyYXRpb24gPSBhd2FpdCBjYWxsYWJsZVRvb2wudG9vbCgpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZGVjbGFyYXRpb24gb2YgKF9jID0gdG9vbERlY2xhcmF0aW9uLmZ1bmN0aW9uRGVjbGFyYXRpb25zKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBbXSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWRlY2xhcmF0aW9uLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRnVuY3Rpb24gZGVjbGFyYXRpb24gbmFtZSBpcyByZXF1aXJlZC4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYWZjVG9vbHMuaGFzKGRlY2xhcmF0aW9uLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSB0b29sIGRlY2xhcmF0aW9uIG5hbWU6ICR7ZGVjbGFyYXRpb24ubmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhZmNUb29scy5zZXQoZGVjbGFyYXRpb24ubmFtZSwgY2FsbGFibGVUb29sKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFmY1Rvb2xzO1xuICAgIH1cbiAgICBhc3luYyBwcm9jZXNzQWZjU3RyZWFtKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgY29uc3QgbWF4UmVtb3RlQ2FsbHMgPSAoX2MgPSAoX2IgPSAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubWF4aW11bVJlbW90ZUNhbGxzKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBERUZBVUxUX01BWF9SRU1PVEVfQ0FMTFM7XG4gICAgICAgIGxldCB3ZXJlRnVuY3Rpb25zQ2FsbGVkID0gZmFsc2U7XG4gICAgICAgIGxldCByZW1vdGVDYWxsQ291bnQgPSAwO1xuICAgICAgICBjb25zdCBhZmNUb29sc01hcCA9IGF3YWl0IHRoaXMuaW5pdEFmY1Rvb2xzTWFwKHBhcmFtcyk7XG4gICAgICAgIHJldHVybiAoZnVuY3Rpb24gKG1vZGVscywgYWZjVG9vbHMsIHBhcmFtcykge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2MsIGVfMSwgX2QsIF9lO1xuICAgICAgICAgICAgICAgIHdoaWxlIChyZW1vdGVDYWxsQ291bnQgPCBtYXhSZW1vdGVDYWxscykge1xuICAgICAgICAgICAgICAgICAgICBpZiAod2VyZUZ1bmN0aW9uc0NhbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3RlQ2FsbENvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ZXJlRnVuY3Rpb25zQ2FsbGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtZWRQYXJhbXMgPSB5aWVsZCBfX2F3YWl0KG1vZGVscy5wcm9jZXNzUGFyYW1zTWF5YmVBZGRNY3BVc2FnZShwYXJhbXMpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCBfX2F3YWl0KG1vZGVscy5nZW5lcmF0ZUNvbnRlbnRTdHJlYW1JbnRlcm5hbCh0cmFuc2Zvcm1lZFBhcmFtcykpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmdW5jdGlvblJlc3BvbnNlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZUNvbnRlbnRzID0gW107XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfZiA9IHRydWUsIHJlc3BvbnNlXzEgPSAoZV8xID0gdm9pZCAwLCBfX2FzeW5jVmFsdWVzKHJlc3BvbnNlKSksIHJlc3BvbnNlXzFfMTsgcmVzcG9uc2VfMV8xID0geWllbGQgX19hd2FpdChyZXNwb25zZV8xLm5leHQoKSksIF9jID0gcmVzcG9uc2VfMV8xLmRvbmUsICFfYzsgX2YgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2UgPSByZXNwb25zZV8xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2YgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IF9lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaHVuay5jYW5kaWRhdGVzICYmICgoX2EgPSBjaHVuay5jYW5kaWRhdGVzWzBdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29udGVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VDb250ZW50cy5wdXNoKGNodW5rLmNhbmRpZGF0ZXNbMF0uY29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcGFydCBvZiAoX2IgPSBjaHVuay5jYW5kaWRhdGVzWzBdLmNvbnRlbnQucGFydHMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVtb3RlQ2FsbENvdW50IDwgbWF4UmVtb3RlQ2FsbHMgJiYgcGFydC5mdW5jdGlvbkNhbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcnQuZnVuY3Rpb25DYWxsLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGdW5jdGlvbiBjYWxsIG5hbWUgd2FzIG5vdCByZXR1cm5lZCBieSB0aGUgbW9kZWwuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYWZjVG9vbHMuaGFzKHBhcnQuZnVuY3Rpb25DYWxsLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQXV0b21hdGljIGZ1bmN0aW9uIGNhbGxpbmcgd2FzIHJlcXVlc3RlZCwgYnV0IG5vdCBhbGwgdGhlIHRvb2xzIHRoZSBtb2RlbCB1c2VkIGltcGxlbWVudCB0aGUgQ2FsbGFibGVUb29sIGludGVyZmFjZS4gQXZhaWxhYmxlIHRvb2xzOiAke2FmY1Rvb2xzLmtleXMoKX0sIG1pc2luZyB0b29sOiAke3BhcnQuZnVuY3Rpb25DYWxsLm5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZVBhcnRzID0geWllbGQgX19hd2FpdChhZmNUb29sc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmdldChwYXJ0LmZ1bmN0aW9uQ2FsbC5uYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNhbGxUb29sKFtwYXJ0LmZ1bmN0aW9uQ2FsbF0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25SZXNwb25zZXMucHVzaCguLi5yZXNwb25zZVBhcnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2YgJiYgIV9jICYmIChfZCA9IHJlc3BvbnNlXzEucmV0dXJuKSkgeWllbGQgX19hd2FpdChfZC5jYWxsKHJlc3BvbnNlXzEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZnVuY3Rpb25SZXNwb25zZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2VyZUZ1bmN0aW9uc0NhbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3BvbnNlQ2h1bmsgPSBuZXcgR2VuZXJhdGVDb250ZW50UmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVkUmVzcG9uc2VDaHVuay5jYW5kaWRhdGVzID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9sZTogJ3VzZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydHM6IGZ1bmN0aW9uUmVzcG9uc2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdCh0eXBlZFJlc3BvbnNlQ2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3Q29udGVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NvbnRlbnRzLnB1c2goLi4ucmVzcG9uc2VDb250ZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDb250ZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb2xlOiAndXNlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydHM6IGZ1bmN0aW9uUmVzcG9uc2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkQ29udGVudHMgPSB0Q29udGVudHMocGFyYW1zLmNvbnRlbnRzKS5jb25jYXQobmV3Q29udGVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmNvbnRlbnRzID0gdXBkYXRlZENvbnRlbnRzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkodGhpcywgYWZjVG9vbHNNYXAsIHBhcmFtcyk7XG4gICAgfVxuICAgIGFzeW5jIGdlbmVyYXRlQ29udGVudEludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZW5lcmF0ZUNvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OmdlbmVyYXRlQ29udGVudCcsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGdlbmVyYXRlQ29udGVudFJlc3BvbnNlRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IEdlbmVyYXRlQ29udGVudFJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZW5lcmF0ZUNvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06Z2VuZXJhdGVDb250ZW50JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZ2VuZXJhdGVDb250ZW50UmVzcG9uc2VGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBHZW5lcmF0ZUNvbnRlbnRSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2VuZXJhdGVDb250ZW50U3RyZWFtSW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdlbmVyYXRlQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06c3RyZWFtR2VuZXJhdGVDb250ZW50P2FsdD1zc2UnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBjb25zdCBhcGlDbGllbnQgPSB0aGlzLmFwaUNsaWVudDtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gYXBpQ2xpZW50LnJlcXVlc3RTdHJlYW0oe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKGZ1bmN0aW9uIChhcGlSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBlXzIsIF9iLCBfYztcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9kID0gdHJ1ZSwgYXBpUmVzcG9uc2VfMSA9IF9fYXN5bmNWYWx1ZXMoYXBpUmVzcG9uc2UpLCBhcGlSZXNwb25zZV8xXzE7IGFwaVJlc3BvbnNlXzFfMSA9IHlpZWxkIF9fYXdhaXQoYXBpUmVzcG9uc2VfMS5uZXh0KCkpLCBfYSA9IGFwaVJlc3BvbnNlXzFfMS5kb25lLCAhX2E7IF9kID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jID0gYXBpUmVzcG9uc2VfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBfYztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZ2VuZXJhdGVDb250ZW50UmVzcG9uc2VGcm9tVmVydGV4KCh5aWVsZCBfX2F3YWl0KGNodW5rLmpzb24oKSkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwWydzZGtIdHRwUmVzcG9uc2UnXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogY2h1bmsuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBHZW5lcmF0ZUNvbnRlbnRSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KHR5cGVkUmVzcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVfMl8xKSB7IGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07IH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2QgJiYgIV9hICYmIChfYiA9IGFwaVJlc3BvbnNlXzEucmV0dXJuKSkgeWllbGQgX19hd2FpdChfYi5jYWxsKGFwaVJlc3BvbnNlXzEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2VuZXJhdGVDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OnN0cmVhbUdlbmVyYXRlQ29udGVudD9hbHQ9c3NlJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgY29uc3QgYXBpQ2xpZW50ID0gdGhpcy5hcGlDbGllbnQ7XG4gICAgICAgICAgICByZXNwb25zZSA9IGFwaUNsaWVudC5yZXF1ZXN0U3RyZWFtKHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbihmdW5jdGlvbiAoYXBpUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYSwgZV8zLCBfYiwgX2M7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfZCA9IHRydWUsIGFwaVJlc3BvbnNlXzIgPSBfX2FzeW5jVmFsdWVzKGFwaVJlc3BvbnNlKSwgYXBpUmVzcG9uc2VfMl8xOyBhcGlSZXNwb25zZV8yXzEgPSB5aWVsZCBfX2F3YWl0KGFwaVJlc3BvbnNlXzIubmV4dCgpKSwgX2EgPSBhcGlSZXNwb25zZV8yXzEuZG9uZSwgIV9hOyBfZCA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYyA9IGFwaVJlc3BvbnNlXzJfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rID0gX2M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGdlbmVyYXRlQ29udGVudFJlc3BvbnNlRnJvbU1sZGV2KCh5aWVsZCBfX2F3YWl0KGNodW5rLmpzb24oKSkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwWydzZGtIdHRwUmVzcG9uc2UnXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogY2h1bmsuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBHZW5lcmF0ZUNvbnRlbnRSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KHR5cGVkUmVzcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVfM18xKSB7IGVfMyA9IHsgZXJyb3I6IGVfM18xIH07IH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2QgJiYgIV9hICYmIChfYiA9IGFwaVJlc3BvbnNlXzIucmV0dXJuKSkgeWllbGQgX19hd2FpdChfYi5jYWxsKGFwaVJlc3BvbnNlXzIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8zKSB0aHJvdyBlXzMuZXJyb3I7IH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyBlbWJlZGRpbmdzIGZvciB0aGUgZ2l2ZW4gY29udGVudHMuIE9ubHkgdGV4dCBpcyBzdXBwb3J0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIGVtYmVkZGluZyBjb250ZW50cy5cbiAgICAgKiBAcmV0dXJuIFRoZSByZXNwb25zZSBmcm9tIHRoZSBBUEkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhaS5tb2RlbHMuZW1iZWRDb250ZW50KHtcbiAgICAgKiAgbW9kZWw6ICd0ZXh0LWVtYmVkZGluZy0wMDQnLFxuICAgICAqICBjb250ZW50czogW1xuICAgICAqICAgICdXaGF0IGlzIHlvdXIgbmFtZT8nLFxuICAgICAqICAgICdXaGF0IGlzIHlvdXIgZmF2b3JpdGUgY29sb3I/JyxcbiAgICAgKiAgXSxcbiAgICAgKiAgY29uZmlnOiB7XG4gICAgICogICAgb3V0cHV0RGltZW5zaW9uYWxpdHk6IDY0LFxuICAgICAqICB9LFxuICAgICAqIH0pO1xuICAgICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBlbWJlZENvbnRlbnQocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGVtYmVkQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06cHJlZGljdCcsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGVtYmVkQ29udGVudFJlc3BvbnNlRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IEVtYmVkQ29udGVudFJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBlbWJlZENvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06YmF0Y2hFbWJlZENvbnRlbnRzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZW1iZWRDb250ZW50UmVzcG9uc2VGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBFbWJlZENvbnRlbnRSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSBtZXRob2QgZm9yIGdlbmVyYXRpbmcgaW1hZ2VzLlxuICAgICAqL1xuICAgIGFzeW5jIGdlbmVyYXRlSW1hZ2VzSW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdlbmVyYXRlSW1hZ2VzUGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpwcmVkaWN0JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZ2VuZXJhdGVJbWFnZXNSZXNwb25zZUZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBHZW5lcmF0ZUltYWdlc1Jlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZW5lcmF0ZUltYWdlc1BhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpwcmVkaWN0JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZ2VuZXJhdGVJbWFnZXNSZXNwb25zZUZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IEdlbmVyYXRlSW1hZ2VzUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByaXZhdGUgbWV0aG9kIGZvciBlZGl0aW5nIGFuIGltYWdlLlxuICAgICAqL1xuICAgIGFzeW5jIGVkaXRJbWFnZUludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZWRpdEltYWdlUGFyYW1ldGVyc0ludGVybmFsVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OnByZWRpY3QnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBlZGl0SW1hZ2VSZXNwb25zZUZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBFZGl0SW1hZ2VSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBWZXJ0ZXggQUkuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSBtZXRob2QgZm9yIHVwc2NhbGluZyBhbiBpbWFnZS5cbiAgICAgKi9cbiAgICBhc3luYyB1cHNjYWxlSW1hZ2VJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IHVwc2NhbGVJbWFnZUFQSVBhcmFtZXRlcnNJbnRlcm5hbFRvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpwcmVkaWN0JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gdXBzY2FsZUltYWdlUmVzcG9uc2VGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgVXBzY2FsZUltYWdlUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgVmVydGV4IEFJLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlY29udGV4dHVhbGl6ZXMgYW4gaW1hZ2UuXG4gICAgICpcbiAgICAgKiBUaGVyZSBhcmUgdHdvIHR5cGVzIG9mIHJlY29udGV4dHVhbGl6YXRpb24gY3VycmVudGx5IHN1cHBvcnRlZDpcbiAgICAgKiAxKSBJbWFnZW4gUHJvZHVjdCBSZWNvbnRleHQgLSBHZW5lcmF0ZSBpbWFnZXMgb2YgcHJvZHVjdHMgaW4gbmV3IHNjZW5lc1xuICAgICAqICAgIGFuZCBjb250ZXh0cy5cbiAgICAgKiAyKSBWaXJ0dWFsIFRyeS1PbjogR2VuZXJhdGUgaW1hZ2VzIG9mIHBlcnNvbnMgbW9kZWxpbmcgZmFzaGlvbiBwcm9kdWN0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgcmVjb250ZXh0dWFsaXppbmcgYW4gaW1hZ2UuXG4gICAgICogQHJldHVybiBUaGUgcmVzcG9uc2UgZnJvbSB0aGUgQVBJLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IHJlc3BvbnNlMSA9IGF3YWl0IGFpLm1vZGVscy5yZWNvbnRleHRJbWFnZSh7XG4gICAgICogIG1vZGVsOiAnaW1hZ2VuLXByb2R1Y3QtcmVjb250ZXh0LXByZXZpZXctMDYtMzAnLFxuICAgICAqICBzb3VyY2U6IHtcbiAgICAgKiAgICBwcm9tcHQ6ICdJbiBhIG1vZGVybiBraXRjaGVuIHNldHRpbmcuJyxcbiAgICAgKiAgICBwcm9kdWN0SW1hZ2VzOiBbcHJvZHVjdEltYWdlXSxcbiAgICAgKiAgfSxcbiAgICAgKiAgY29uZmlnOiB7XG4gICAgICogICAgbnVtYmVyT2ZJbWFnZXM6IDEsXG4gICAgICogIH0sXG4gICAgICogfSk7XG4gICAgICogY29uc29sZS5sb2cocmVzcG9uc2UxPy5nZW5lcmF0ZWRJbWFnZXM/LlswXT8uaW1hZ2U/LmltYWdlQnl0ZXMpO1xuICAgICAqXG4gICAgICogY29uc3QgcmVzcG9uc2UyID0gYXdhaXQgYWkubW9kZWxzLnJlY29udGV4dEltYWdlKHtcbiAgICAgKiAgbW9kZWw6ICd2aXJ0dWFsLXRyeS1vbi1wcmV2aWV3LTA4LTA0JyxcbiAgICAgKiAgc291cmNlOiB7XG4gICAgICogICAgcGVyc29uSW1hZ2U6IHBlcnNvbkltYWdlLFxuICAgICAqICAgIHByb2R1Y3RJbWFnZXM6IFtwcm9kdWN0SW1hZ2VdLFxuICAgICAqICB9LFxuICAgICAqICBjb25maWc6IHtcbiAgICAgKiAgICBudW1iZXJPZkltYWdlczogMSxcbiAgICAgKiAgfSxcbiAgICAgKiB9KTtcbiAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZTI/LmdlbmVyYXRlZEltYWdlcz8uWzBdPy5pbWFnZT8uaW1hZ2VCeXRlcyk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgcmVjb250ZXh0SW1hZ2UocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSByZWNvbnRleHRJbWFnZVBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06cHJlZGljdCcsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gcmVjb250ZXh0SW1hZ2VSZXNwb25zZUZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBSZWNvbnRleHRJbWFnZVJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIFZlcnRleCBBSS4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZWdtZW50cyBhbiBpbWFnZSwgY3JlYXRpbmcgYSBtYXNrIG9mIGEgc3BlY2lmaWVkIGFyZWEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHNlZ21lbnRpbmcgYW4gaW1hZ2UuXG4gICAgICogQHJldHVybiBUaGUgcmVzcG9uc2UgZnJvbSB0aGUgQVBJLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkubW9kZWxzLnNlZ21lbnRJbWFnZSh7XG4gICAgICogIG1vZGVsOiAnaW1hZ2Utc2VnbWVudGF0aW9uLTAwMScsXG4gICAgICogIHNvdXJjZToge1xuICAgICAqICAgIGltYWdlOiBpbWFnZSxcbiAgICAgKiAgfSxcbiAgICAgKiAgY29uZmlnOiB7XG4gICAgICogICAgbW9kZTogJ2ZvcmVncm91bmQnLFxuICAgICAqICB9LFxuICAgICAqIH0pO1xuICAgICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlPy5nZW5lcmF0ZWRNYXNrcz8uWzBdPy5tYXNrPy5pbWFnZUJ5dGVzKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBzZWdtZW50SW1hZ2UocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBzZWdtZW50SW1hZ2VQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OnByZWRpY3QnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IHNlZ21lbnRJbWFnZVJlc3BvbnNlRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IFNlZ21lbnRJbWFnZVJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIFZlcnRleCBBSS4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIGluZm9ybWF0aW9uIGFib3V0IGEgbW9kZWwgYnkgbmFtZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBtb2RlbEluZm8gPSBhd2FpdCBhaS5tb2RlbHMuZ2V0KHttb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gnfSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgZ2V0KHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZXRNb2RlbFBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBtb2RlbEZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2V0TW9kZWxQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBtb2RlbEZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBsaXN0SW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGxpc3RNb2RlbHNQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWxzX3VybH0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGxpc3RNb2RlbHNSZXNwb25zZUZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBMaXN0TW9kZWxzUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGxpc3RNb2RlbHNQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbHNfdXJsfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gbGlzdE1vZGVsc1Jlc3BvbnNlRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgTGlzdE1vZGVsc1Jlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGEgdHVuZWQgbW9kZWwgYnkgaXRzIG5hbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHVwZGF0aW5nIHRoZSBtb2RlbC5cbiAgICAgKiBAcmV0dXJuIFRoZSByZXNwb25zZSBmcm9tIHRoZSBBUEkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhaS5tb2RlbHMudXBkYXRlKHtcbiAgICAgKiAgIG1vZGVsOiAndHVuZWQtbW9kZWwtbmFtZScsXG4gICAgICogICBjb25maWc6IHtcbiAgICAgKiAgICAgZGlzcGxheU5hbWU6ICdOZXcgZGlzcGxheSBuYW1lJyxcbiAgICAgKiAgICAgZGVzY3JpcHRpb246ICdOZXcgZGVzY3JpcHRpb24nLFxuICAgICAqICAgfSxcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGUocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IHVwZGF0ZU1vZGVsUGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BBVENIJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IG1vZGVsRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSB1cGRhdGVNb2RlbFBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUEFUQ0gnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gbW9kZWxGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBhIHR1bmVkIG1vZGVsIGJ5IGl0cyBuYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBkZWxldGluZyB0aGUgbW9kZWwuXG4gICAgICogQHJldHVybiBUaGUgcmVzcG9uc2UgZnJvbSB0aGUgQVBJLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkubW9kZWxzLmRlbGV0ZSh7bW9kZWw6ICd0dW5lZC1tb2RlbC1uYW1lJ30pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZShwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZGVsZXRlTW9kZWxQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGRlbGV0ZU1vZGVsUmVzcG9uc2VGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgRGVsZXRlTW9kZWxSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZGVsZXRlTW9kZWxQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZGVsZXRlTW9kZWxSZXNwb25zZUZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IERlbGV0ZU1vZGVsUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvdW50cyB0aGUgbnVtYmVyIG9mIHRva2VucyBpbiB0aGUgZ2l2ZW4gY29udGVudHMuIE11bHRpbW9kYWwgaW5wdXQgaXNcbiAgICAgKiBzdXBwb3J0ZWQgZm9yIEdlbWluaSBtb2RlbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIGNvdW50aW5nIHRva2Vucy5cbiAgICAgKiBAcmV0dXJuIFRoZSByZXNwb25zZSBmcm9tIHRoZSBBUEkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhaS5tb2RlbHMuY291bnRUb2tlbnMoe1xuICAgICAqICBtb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gnLFxuICAgICAqICBjb250ZW50czogJ1RoZSBxdWljayBicm93biBmb3gganVtcHMgb3ZlciB0aGUgbGF6eSBkb2cuJ1xuICAgICAqIH0pO1xuICAgICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBjb3VudFRva2VucyhwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gY291bnRUb2tlbnNQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OmNvdW50VG9rZW5zJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gY291bnRUb2tlbnNSZXNwb25zZUZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBDb3VudFRva2Vuc1Jlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBjb3VudFRva2Vuc1BhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpjb3VudFRva2VucycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGNvdW50VG9rZW5zUmVzcG9uc2VGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBDb3VudFRva2Vuc1Jlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIGxpc3Qgb2YgY29udGVudHMsIHJldHVybnMgYSBjb3JyZXNwb25kaW5nIFRva2Vuc0luZm8gY29udGFpbmluZ1xuICAgICAqIHRoZSBsaXN0IG9mIHRva2VucyBhbmQgbGlzdCBvZiB0b2tlbiBpZHMuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBHZW1pbmkgRGV2ZWxvcGVyIEFQSS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgY29tcHV0aW5nIHRva2Vucy5cbiAgICAgKiBAcmV0dXJuIFRoZSByZXNwb25zZSBmcm9tIHRoZSBBUEkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhaS5tb2RlbHMuY29tcHV0ZVRva2Vucyh7XG4gICAgICogIG1vZGVsOiAnZ2VtaW5pLTIuMC1mbGFzaCcsXG4gICAgICogIGNvbnRlbnRzOiAnV2hhdCBpcyB5b3VyIG5hbWU/J1xuICAgICAqIH0pO1xuICAgICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBjb21wdXRlVG9rZW5zKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gY29tcHV0ZVRva2Vuc1BhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06Y29tcHV0ZVRva2VucycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGNvbXB1dGVUb2tlbnNSZXNwb25zZUZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBDb21wdXRlVG9rZW5zUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgVmVydGV4IEFJLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByaXZhdGUgbWV0aG9kIGZvciBnZW5lcmF0aW5nIHZpZGVvcy5cbiAgICAgKi9cbiAgICBhc3luYyBnZW5lcmF0ZVZpZGVvc0ludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZW5lcmF0ZVZpZGVvc1BhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06cHJlZGljdExvbmdSdW5uaW5nJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBnZW5lcmF0ZVZpZGVvc09wZXJhdGlvbkZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBHZW5lcmF0ZVZpZGVvc09wZXJhdGlvbigpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2VuZXJhdGVWaWRlb3NQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06cHJlZGljdExvbmdSdW5uaW5nJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBnZW5lcmF0ZVZpZGVvc09wZXJhdGlvbkZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IEdlbmVyYXRlVmlkZW9zT3BlcmF0aW9uKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY2xhc3MgT3BlcmF0aW9ucyBleHRlbmRzIEJhc2VNb2R1bGUge1xuICAgIGNvbnN0cnVjdG9yKGFwaUNsaWVudCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IGFwaUNsaWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc3RhdHVzIG9mIGEgbG9uZy1ydW5uaW5nIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbWV0ZXJzIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgZ2V0IG9wZXJhdGlvbiByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4gVGhlIHVwZGF0ZWQgT3BlcmF0aW9uIG9iamVjdCwgd2l0aCB0aGUgbGF0ZXN0IHN0YXR1cyBvciByZXN1bHQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VmlkZW9zT3BlcmF0aW9uKHBhcmFtZXRlcnMpIHtcbiAgICAgICAgY29uc3Qgb3BlcmF0aW9uID0gcGFyYW1ldGVycy5vcGVyYXRpb247XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHBhcmFtZXRlcnMuY29uZmlnO1xuICAgICAgICBpZiAob3BlcmF0aW9uLm5hbWUgPT09IHVuZGVmaW5lZCB8fCBvcGVyYXRpb24ubmFtZSA9PT0gJycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT3BlcmF0aW9uIG5hbWUgaXMgcmVxdWlyZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgcmVzb3VyY2VOYW1lID0gb3BlcmF0aW9uLm5hbWUuc3BsaXQoJy9vcGVyYXRpb25zLycpWzBdO1xuICAgICAgICAgICAgbGV0IGh0dHBPcHRpb25zID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKGNvbmZpZyAmJiAnaHR0cE9wdGlvbnMnIGluIGNvbmZpZykge1xuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zID0gY29uZmlnLmh0dHBPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmF3T3BlcmF0aW9uID0gYXdhaXQgdGhpcy5mZXRjaFByZWRpY3RWaWRlb3NPcGVyYXRpb25JbnRlcm5hbCh7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uTmFtZTogb3BlcmF0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgcmVzb3VyY2VOYW1lOiByZXNvdXJjZU5hbWUsXG4gICAgICAgICAgICAgICAgY29uZmlnOiB7IGh0dHBPcHRpb25zOiBodHRwT3B0aW9ucyB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gb3BlcmF0aW9uLl9mcm9tQVBJUmVzcG9uc2Uoe1xuICAgICAgICAgICAgICAgIGFwaVJlc3BvbnNlOiByYXdPcGVyYXRpb24sXG4gICAgICAgICAgICAgICAgX2lzVmVydGV4QUk6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHJhd09wZXJhdGlvbiA9IGF3YWl0IHRoaXMuZ2V0VmlkZW9zT3BlcmF0aW9uSW50ZXJuYWwoe1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbk5hbWU6IG9wZXJhdGlvbi5uYW1lLFxuICAgICAgICAgICAgICAgIGNvbmZpZzogY29uZmlnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gb3BlcmF0aW9uLl9mcm9tQVBJUmVzcG9uc2Uoe1xuICAgICAgICAgICAgICAgIGFwaVJlc3BvbnNlOiByYXdPcGVyYXRpb24sXG4gICAgICAgICAgICAgICAgX2lzVmVydGV4QUk6IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc3RhdHVzIG9mIGEgbG9uZy1ydW5uaW5nIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbWV0ZXJzIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgZ2V0IG9wZXJhdGlvbiByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4gVGhlIHVwZGF0ZWQgT3BlcmF0aW9uIG9iamVjdCwgd2l0aCB0aGUgbGF0ZXN0IHN0YXR1cyBvciByZXN1bHQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0KHBhcmFtZXRlcnMpIHtcbiAgICAgICAgY29uc3Qgb3BlcmF0aW9uID0gcGFyYW1ldGVycy5vcGVyYXRpb247XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHBhcmFtZXRlcnMuY29uZmlnO1xuICAgICAgICBpZiAob3BlcmF0aW9uLm5hbWUgPT09IHVuZGVmaW5lZCB8fCBvcGVyYXRpb24ubmFtZSA9PT0gJycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT3BlcmF0aW9uIG5hbWUgaXMgcmVxdWlyZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgcmVzb3VyY2VOYW1lID0gb3BlcmF0aW9uLm5hbWUuc3BsaXQoJy9vcGVyYXRpb25zLycpWzBdO1xuICAgICAgICAgICAgbGV0IGh0dHBPcHRpb25zID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKGNvbmZpZyAmJiAnaHR0cE9wdGlvbnMnIGluIGNvbmZpZykge1xuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zID0gY29uZmlnLmh0dHBPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmF3T3BlcmF0aW9uID0gYXdhaXQgdGhpcy5mZXRjaFByZWRpY3RWaWRlb3NPcGVyYXRpb25JbnRlcm5hbCh7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uTmFtZTogb3BlcmF0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgcmVzb3VyY2VOYW1lOiByZXNvdXJjZU5hbWUsXG4gICAgICAgICAgICAgICAgY29uZmlnOiB7IGh0dHBPcHRpb25zOiBodHRwT3B0aW9ucyB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gb3BlcmF0aW9uLl9mcm9tQVBJUmVzcG9uc2Uoe1xuICAgICAgICAgICAgICAgIGFwaVJlc3BvbnNlOiByYXdPcGVyYXRpb24sXG4gICAgICAgICAgICAgICAgX2lzVmVydGV4QUk6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHJhd09wZXJhdGlvbiA9IGF3YWl0IHRoaXMuZ2V0VmlkZW9zT3BlcmF0aW9uSW50ZXJuYWwoe1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbk5hbWU6IG9wZXJhdGlvbi5uYW1lLFxuICAgICAgICAgICAgICAgIGNvbmZpZzogY29uZmlnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gb3BlcmF0aW9uLl9mcm9tQVBJUmVzcG9uc2Uoe1xuICAgICAgICAgICAgICAgIGFwaVJlc3BvbnNlOiByYXdPcGVyYXRpb24sXG4gICAgICAgICAgICAgICAgX2lzVmVydGV4QUk6IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0VmlkZW9zT3BlcmF0aW9uSW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdldE9wZXJhdGlvblBhcmFtZXRlcnNUb1ZlcnRleChwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne29wZXJhdGlvbk5hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdldE9wZXJhdGlvblBhcmFtZXRlcnNUb01sZGV2KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7b3BlcmF0aW9uTmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZmV0Y2hQcmVkaWN0VmlkZW9zT3BlcmF0aW9uSW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBmZXRjaFByZWRpY3RPcGVyYXRpb25QYXJhbWV0ZXJzVG9WZXJ0ZXgocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tyZXNvdXJjZU5hbWV9OmZldGNoUHJlZGljdE9wZXJhdGlvbicsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBWZXJ0ZXggQUkuJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmZ1bmN0aW9uIGJsb2JUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkYXRhJ10pO1xuICAgIGlmIChmcm9tRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RhdGEnXSwgZnJvbURhdGEpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGlzcGxheU5hbWUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29udGVudFRvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhcnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXJ0cyddKTtcbiAgICBpZiAoZnJvbVBhcnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21QYXJ0cztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0VG9NbGRldihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Sb2xlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyb2xlJ10pO1xuICAgIGlmIChmcm9tUm9sZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JvbGUnXSwgZnJvbVJvbGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVBdXRoVG9rZW5Db25maWdUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRXhwaXJlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhwaXJlVGltZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUV4cGlyZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZXhwaXJlVGltZSddLCBmcm9tRXhwaXJlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OZXdTZXNzaW9uRXhwaXJlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ25ld1Nlc3Npb25FeHBpcmVUaW1lJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU5ld1Nlc3Npb25FeHBpcmVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ25ld1Nlc3Npb25FeHBpcmVUaW1lJ10sIGZyb21OZXdTZXNzaW9uRXhwaXJlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Vc2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1c2VzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVXNlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd1c2VzJ10sIGZyb21Vc2VzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxpdmVDb25uZWN0Q29uc3RyYWludHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdsaXZlQ29ubmVjdENvbnN0cmFpbnRzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUxpdmVDb25uZWN0Q29uc3RyYWludHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnYmlkaUdlbmVyYXRlQ29udGVudFNldHVwJ10sIGxpdmVDb25uZWN0Q29uc3RyYWludHNUb01sZGV2KGFwaUNsaWVudCwgZnJvbUxpdmVDb25uZWN0Q29uc3RyYWludHMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxvY2tBZGRpdGlvbmFsRmllbGRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbG9ja0FkZGl0aW9uYWxGaWVsZHMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTG9ja0FkZGl0aW9uYWxGaWVsZHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZmllbGRNYXNrJ10sIGZyb21Mb2NrQWRkaXRpb25hbEZpZWxkcyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUF1dGhUb2tlblBhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIGNyZWF0ZUF1dGhUb2tlbkNvbmZpZ1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tQ29uZmlnLCB0b09iamVjdCkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmaWxlRGF0YVRvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Rpc3BsYXlOYW1lIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlVXJpJ10pO1xuICAgIGlmIChmcm9tRmlsZVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVVcmknXSwgZnJvbUZpbGVVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkNhbGxUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21JZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaWQnXSk7XG4gICAgaWYgKGZyb21JZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lkJ10sIGZyb21JZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BcmdzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhcmdzJ10pO1xuICAgIGlmIChmcm9tQXJncyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FyZ3MnXSwgZnJvbUFyZ3MpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFydGlhbEFyZ3MnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhcnRpYWxBcmdzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3dpbGxDb250aW51ZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignd2lsbENvbnRpbnVlIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdvb2dsZU1hcHNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2F1dGhDb25maWcnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2F1dGhDb25maWcgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuYWJsZVdpZGdldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5hYmxlV2lkZ2V0J10pO1xuICAgIGlmIChmcm9tRW5hYmxlV2lkZ2V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5hYmxlV2lkZ2V0J10sIGZyb21FbmFibGVXaWRnZXQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnb29nbGVTZWFyY2hUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2V4Y2x1ZGVEb21haW5zJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleGNsdWRlRG9tYWlucyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydibG9ja2luZ0NvbmZpZGVuY2UnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Jsb2NraW5nQ29uZmlkZW5jZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGltZVJhbmdlRmlsdGVyID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGltZVJhbmdlRmlsdGVyJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRpbWVSYW5nZUZpbHRlciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RpbWVSYW5nZUZpbHRlciddLCBmcm9tVGltZVJhbmdlRmlsdGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZUNvbm5lY3RDb25maWdUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUdlbmVyYXRpb25Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdnZW5lcmF0aW9uQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUdlbmVyYXRpb25Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZyddLCBmcm9tR2VuZXJhdGlvbkNvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZU1vZGFsaXRpZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZU1vZGFsaXRpZXMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAncmVzcG9uc2VNb2RhbGl0aWVzJ10sIGZyb21SZXNwb25zZU1vZGFsaXRpZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGVtcGVyYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RlbXBlcmF0dXJlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVGVtcGVyYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICd0ZW1wZXJhdHVyZSddLCBmcm9tVGVtcGVyYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wUCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wUCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvcFAgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICd0b3BQJ10sIGZyb21Ub3BQKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvcEsgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvcEsnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub3BLICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAndG9wSyddLCBmcm9tVG9wSyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXhPdXRwdXRUb2tlbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtYXhPdXRwdXRUb2tlbnMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTWF4T3V0cHV0VG9rZW5zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAnbWF4T3V0cHV0VG9rZW5zJ10sIGZyb21NYXhPdXRwdXRUb2tlbnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWVkaWFSZXNvbHV0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWVkaWFSZXNvbHV0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU1lZGlhUmVzb2x1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ21lZGlhUmVzb2x1dGlvbiddLCBmcm9tTWVkaWFSZXNvbHV0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NlZWQnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TZWVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAnc2VlZCddLCBmcm9tU2VlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TcGVlY2hDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NwZWVjaENvbmZpZyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNwZWVjaENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3NwZWVjaENvbmZpZyddLCB0TGl2ZVNwZWVjaENvbmZpZyhmcm9tU3BlZWNoQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaGlua2luZ0NvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RoaW5raW5nQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRoaW5raW5nQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAndGhpbmtpbmdDb25maWcnXSwgZnJvbVRoaW5raW5nQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuYWJsZUFmZmVjdGl2ZURpYWxvZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2VuYWJsZUFmZmVjdGl2ZURpYWxvZycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FbmFibGVBZmZlY3RpdmVEaWFsb2cgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdlbmFibGVBZmZlY3RpdmVEaWFsb2cnXSwgZnJvbUVuYWJsZUFmZmVjdGl2ZURpYWxvZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TeXN0ZW1JbnN0cnVjdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N5c3RlbUluc3RydWN0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVN5c3RlbUluc3RydWN0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3N5c3RlbUluc3RydWN0aW9uJ10sIGNvbnRlbnRUb01sZGV2KHRDb250ZW50KGZyb21TeXN0ZW1JbnN0cnVjdGlvbikpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29scyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvb2xzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRUb29scyhmcm9tVG9vbHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvb2xUb01sZGV2KHRUb29sKGl0ZW0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICd0b29scyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2Vzc2lvblJlc3VtcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZXNzaW9uUmVzdW1wdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TZXNzaW9uUmVzdW1wdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdzZXNzaW9uUmVzdW1wdGlvbiddLCBzZXNzaW9uUmVzdW1wdGlvbkNvbmZpZ1RvTWxkZXYoZnJvbVNlc3Npb25SZXN1bXB0aW9uKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2lucHV0QXVkaW9UcmFuc2NyaXB0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUlucHV0QXVkaW9UcmFuc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2lucHV0QXVkaW9UcmFuc2NyaXB0aW9uJ10sIGZyb21JbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRBdWRpb1RyYW5zY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXRBdWRpb1RyYW5zY3JpcHRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0QXVkaW9UcmFuc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ291dHB1dEF1ZGlvVHJhbnNjcmlwdGlvbiddLCBmcm9tT3V0cHV0QXVkaW9UcmFuc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlYWx0aW1lSW5wdXRDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZWFsdGltZUlucHV0Q29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVJlYWx0aW1lSW5wdXRDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAncmVhbHRpbWVJbnB1dENvbmZpZyddLCBmcm9tUmVhbHRpbWVJbnB1dENvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250ZXh0V2luZG93Q29tcHJlc3Npb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb250ZXh0V2luZG93Q29tcHJlc3Npb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQ29udGV4dFdpbmRvd0NvbXByZXNzaW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2NvbnRleHRXaW5kb3dDb21wcmVzc2lvbiddLCBmcm9tQ29udGV4dFdpbmRvd0NvbXByZXNzaW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByb2FjdGl2aXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcm9hY3Rpdml0eSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVByb2FjdGl2aXR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3Byb2FjdGl2aXR5J10sIGZyb21Qcm9hY3Rpdml0eSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVDb25uZWN0Q29uc3RyYWludHNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2V0dXAnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbmZpZyddLCBsaXZlQ29ubmVjdENvbmZpZ1RvTWxkZXYoZnJvbUNvbmZpZywgdG9PYmplY3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcGFydFRvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1lZGlhUmVzb2x1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21lZGlhUmVzb2x1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NZWRpYVJlc29sdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZWRpYVJlc29sdXRpb24nXSwgZnJvbU1lZGlhUmVzb2x1dGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvblJlc3VsdCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvblJlc3VsdCddLCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeGVjdXRhYmxlQ29kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2V4ZWN1dGFibGVDb2RlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUV4ZWN1dGFibGVDb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhlY3V0YWJsZUNvZGUnXSwgZnJvbUV4ZWN1dGFibGVDb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlRGF0YSddKTtcbiAgICBpZiAoZnJvbUZpbGVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZURhdGEnXSwgZmlsZURhdGFUb01sZGV2KGZyb21GaWxlRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25DYWxsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmdW5jdGlvbkNhbGwnXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkNhbGwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkNhbGwnXSwgZnVuY3Rpb25DYWxsVG9NbGRldihmcm9tRnVuY3Rpb25DYWxsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvblJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25SZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvblJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25SZXNwb25zZSddLCBmcm9tRnVuY3Rpb25SZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmxpbmVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbmxpbmVEYXRhJ10pO1xuICAgIGlmIChmcm9tSW5saW5lRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lubGluZURhdGEnXSwgYmxvYlRvTWxkZXYoZnJvbUlubGluZURhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RleHQnXSk7XG4gICAgaWYgKGZyb21UZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGV4dCddLCBmcm9tVGV4dCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaG91Z2h0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aG91Z2h0J10pO1xuICAgIGlmIChmcm9tVGhvdWdodCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHQnXSwgZnJvbVRob3VnaHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodFNpZ25hdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Rob3VnaHRTaWduYXR1cmUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGhvdWdodFNpZ25hdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHRTaWduYXR1cmUnXSwgZnJvbVRob3VnaHRTaWduYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmlkZW9NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ZpZGVvTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVmlkZW9NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvTWV0YWRhdGEnXSwgZnJvbVZpZGVvTWV0YWRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzZXNzaW9uUmVzdW1wdGlvbkNvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUhhbmRsZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaGFuZGxlJ10pO1xuICAgIGlmIChmcm9tSGFuZGxlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaGFuZGxlJ10sIGZyb21IYW5kbGUpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0cmFuc3BhcmVudCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndHJhbnNwYXJlbnQgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdG9vbFRvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25EZWNsYXJhdGlvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkRlY2xhcmF0aW9ucyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXRyaWV2YWwnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JldHJpZXZhbCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ29vZ2xlU2VhcmNoUmV0cmlldmFsJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCddLCBmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbXB1dGVyVXNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb21wdXRlclVzZSddKTtcbiAgICBpZiAoZnJvbUNvbXB1dGVyVXNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29tcHV0ZXJVc2UnXSwgZnJvbUNvbXB1dGVyVXNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVTZWFyY2ggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVTZWFyY2gnXSk7XG4gICAgaWYgKGZyb21GaWxlU2VhcmNoICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZVNlYXJjaCddLCBmcm9tRmlsZVNlYXJjaCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvbiddLCBmcm9tQ29kZUV4ZWN1dGlvbik7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VudGVycHJpc2VXZWJTZWFyY2gnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VudGVycHJpc2VXZWJTZWFyY2ggcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZU1hcHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvb2dsZU1hcHMnXSk7XG4gICAgaWYgKGZyb21Hb29nbGVNYXBzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlTWFwcyddLCBnb29nbGVNYXBzVG9NbGRldihmcm9tR29vZ2xlTWFwcykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVTZWFyY2gnXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2ggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2gnXSwgZ29vZ2xlU2VhcmNoVG9NbGRldihmcm9tR29vZ2xlU2VhcmNoKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcmxDb250ZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cmxDb250ZXh0J10pO1xuICAgIGlmIChmcm9tVXJsQ29udGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VybENvbnRleHQnXSwgZnJvbVVybENvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbi8qKlxuICogUmV0dXJucyBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIGZpZWxkIG1hc2tzIGZyb20gYSBnaXZlbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHNldHVwIFRoZSBvYmplY3QgdG8gZXh0cmFjdCBmaWVsZCBtYXNrcyBmcm9tLlxuICogQHJldHVybiBBIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIGZpZWxkIG1hc2tzLlxuICovXG5mdW5jdGlvbiBnZXRGaWVsZE1hc2tzKHNldHVwKSB7XG4gICAgY29uc3QgZmllbGRzID0gW107XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2V0dXApIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXR1cCwga2V5KSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBzZXR1cFtrZXldO1xuICAgICAgICAgICAgLy8gMm5kIGxheWVyLCByZWN1cnNpdmVseSBnZXQgZmllbGQgbWFza3Mgc2VlIFRPRE8oYi80MTgyOTAxMDApXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgIHZhbHVlICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gT2JqZWN0LmtleXModmFsdWUpLm1hcCgoa2spID0+IGAke2tleX0uJHtra31gKTtcbiAgICAgICAgICAgICAgICBmaWVsZHMucHVzaCguLi5maWVsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaWVsZHMucHVzaChrZXkpOyAvLyAxc3QgbGF5ZXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmllbGRzLmpvaW4oJywnKTtcbn1cbi8qKlxuICogQ29udmVydHMgYmlkaUdlbmVyYXRlQ29udGVudFNldHVwLlxuICogQHBhcmFtIHJlcXVlc3REaWN0IC0gVGhlIHJlcXVlc3QgZGljdGlvbmFyeS5cbiAqIEBwYXJhbSBjb25maWcgLSBUaGUgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gKiBAcmV0dXJuIC0gVGhlIG1vZGlmaWVkIHJlcXVlc3QgZGljdGlvbmFyeS5cbiAqL1xuZnVuY3Rpb24gY29udmVydEJpZGlTZXR1cFRvVG9rZW5TZXR1cChyZXF1ZXN0RGljdCwgY29uZmlnKSB7XG4gICAgLy8gQ29udmVydCBiaWRpR2VuZXJhdGVDb250ZW50U2V0dXAgZnJvbSBiaWRpR2VuZXJhdGVDb250ZW50U2V0dXAuc2V0dXAuXG4gICAgbGV0IHNldHVwRm9yTWFza0dlbmVyYXRpb24gPSBudWxsO1xuICAgIGNvbnN0IGJpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cFZhbHVlID0gcmVxdWVzdERpY3RbJ2JpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cCddO1xuICAgIGlmICh0eXBlb2YgYmlkaUdlbmVyYXRlQ29udGVudFNldHVwVmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgIGJpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cFZhbHVlICE9PSBudWxsICYmXG4gICAgICAgICdzZXR1cCcgaW4gYmlkaUdlbmVyYXRlQ29udGVudFNldHVwVmFsdWUpIHtcbiAgICAgICAgLy8gTm93IHdlIGtub3cgYmlkaUdlbmVyYXRlQ29udGVudFNldHVwVmFsdWUgaXMgYW4gb2JqZWN0IGFuZCBoYXMgYSAnc2V0dXAnXG4gICAgICAgIC8vIHByb3BlcnR5LlxuICAgICAgICBjb25zdCBpbm5lclNldHVwID0gYmlkaUdlbmVyYXRlQ29udGVudFNldHVwVmFsdWVcbiAgICAgICAgICAgIC5zZXR1cDtcbiAgICAgICAgaWYgKHR5cGVvZiBpbm5lclNldHVwID09PSAnb2JqZWN0JyAmJiBpbm5lclNldHVwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBWYWxpZCBpbm5lciBzZXR1cCBmb3VuZC5cbiAgICAgICAgICAgIHJlcXVlc3REaWN0WydiaWRpR2VuZXJhdGVDb250ZW50U2V0dXAnXSA9IGlubmVyU2V0dXA7XG4gICAgICAgICAgICBzZXR1cEZvck1hc2tHZW5lcmF0aW9uID0gaW5uZXJTZXR1cDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGBiaWRpR2VuZXJhdGVDb250ZW50U2V0dXBWYWx1ZS5zZXR1cGAgaXMgbm90IGEgdmFsaWQgb2JqZWN0OyB0cmVhdCBhc1xuICAgICAgICAgICAgLy8gaWYgYmlkaUdlbmVyYXRlQ29udGVudFNldHVwIGlzIGludmFsaWQuXG4gICAgICAgICAgICBkZWxldGUgcmVxdWVzdERpY3RbJ2JpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cCddO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGJpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gYGJpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cGAgZXhpc3RzIGJ1dCBub3QgaW4gdGhlIGV4cGVjdGVkXG4gICAgICAgIC8vIHNoYXBlIHtzZXR1cDogey4uLn19OyB0cmVhdCBhcyBpbnZhbGlkLlxuICAgICAgICBkZWxldGUgcmVxdWVzdERpY3RbJ2JpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cCddO1xuICAgIH1cbiAgICBjb25zdCBwcmVFeGlzdGluZ0ZpZWxkTWFzayA9IHJlcXVlc3REaWN0WydmaWVsZE1hc2snXTtcbiAgICAvLyBIYW5kbGUgbWFzayBnZW5lcmF0aW9uIHNldHVwLlxuICAgIGlmIChzZXR1cEZvck1hc2tHZW5lcmF0aW9uKSB7XG4gICAgICAgIGNvbnN0IGdlbmVyYXRlZE1hc2tGcm9tQmlkaSA9IGdldEZpZWxkTWFza3Moc2V0dXBGb3JNYXNrR2VuZXJhdGlvbik7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5sb2NrQWRkaXRpb25hbEZpZWxkcykgJiZcbiAgICAgICAgICAgIChjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcubG9ja0FkZGl0aW9uYWxGaWVsZHMubGVuZ3RoKSA9PT0gMCkge1xuICAgICAgICAgICAgLy8gQ2FzZSAxOiBsb2NrQWRkaXRpb25hbEZpZWxkcyBpcyBhbiBlbXB0eSBhcnJheS4gTG9jayBvbmx5IGZpZWxkcyBmcm9tXG4gICAgICAgICAgICAvLyBiaWRpIHNldHVwLlxuICAgICAgICAgICAgaWYgKGdlbmVyYXRlZE1hc2tGcm9tQmlkaSkge1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgYXNzaWduIGlmIG1hc2sgaXMgbm90IGVtcHR5XG4gICAgICAgICAgICAgICAgcmVxdWVzdERpY3RbJ2ZpZWxkTWFzayddID0gZ2VuZXJhdGVkTWFza0Zyb21CaWRpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHJlcXVlc3REaWN0WydmaWVsZE1hc2snXTsgLy8gSWYgbWFzayBpcyBlbXB0eSwgZWZmZWN0aXZlbHkgbm9cbiAgICAgICAgICAgICAgICAvLyBzcGVjaWZpYyBmaWVsZHMgbG9ja2VkIGJ5IGJpZGlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLmxvY2tBZGRpdGlvbmFsRmllbGRzKSAmJlxuICAgICAgICAgICAgY29uZmlnLmxvY2tBZGRpdGlvbmFsRmllbGRzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgIHByZUV4aXN0aW5nRmllbGRNYXNrICE9PSBudWxsICYmXG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KHByZUV4aXN0aW5nRmllbGRNYXNrKSAmJlxuICAgICAgICAgICAgcHJlRXhpc3RpbmdGaWVsZE1hc2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gQ2FzZSAyOiBMb2NrIGZpZWxkcyBmcm9tIGJpZGkgc2V0dXAgKyBhZGRpdGlvbmFsIGZpZWxkc1xuICAgICAgICAgICAgLy8gKHByZUV4aXN0aW5nRmllbGRNYXNrKS5cbiAgICAgICAgICAgIGNvbnN0IGdlbmVyYXRpb25Db25maWdGaWVsZHMgPSBbXG4gICAgICAgICAgICAgICAgJ3RlbXBlcmF0dXJlJyxcbiAgICAgICAgICAgICAgICAndG9wSycsXG4gICAgICAgICAgICAgICAgJ3RvcFAnLFxuICAgICAgICAgICAgICAgICdtYXhPdXRwdXRUb2tlbnMnLFxuICAgICAgICAgICAgICAgICdyZXNwb25zZU1vZGFsaXRpZXMnLFxuICAgICAgICAgICAgICAgICdzZWVkJyxcbiAgICAgICAgICAgICAgICAnc3BlZWNoQ29uZmlnJyxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBsZXQgbWFwcGVkRmllbGRzRnJvbVByZUV4aXN0aW5nID0gW107XG4gICAgICAgICAgICBpZiAocHJlRXhpc3RpbmdGaWVsZE1hc2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIG1hcHBlZEZpZWxkc0Zyb21QcmVFeGlzdGluZyA9IHByZUV4aXN0aW5nRmllbGRNYXNrLm1hcCgoZmllbGQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdlbmVyYXRpb25Db25maWdGaWVsZHMuaW5jbHVkZXMoZmllbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYGdlbmVyYXRpb25Db25maWcuJHtmaWVsZH1gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWVsZDsgLy8gS2VlcCBvcmlnaW5hbCBmaWVsZCBuYW1lIGlmIG5vdCBpblxuICAgICAgICAgICAgICAgICAgICAvLyBnZW5lcmF0aW9uQ29uZmlnRmllbGRzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmaW5hbE1hc2tQYXJ0cyA9IFtdO1xuICAgICAgICAgICAgaWYgKGdlbmVyYXRlZE1hc2tGcm9tQmlkaSkge1xuICAgICAgICAgICAgICAgIGZpbmFsTWFza1BhcnRzLnB1c2goZ2VuZXJhdGVkTWFza0Zyb21CaWRpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXBwZWRGaWVsZHNGcm9tUHJlRXhpc3RpbmcubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGZpbmFsTWFza1BhcnRzLnB1c2goLi4ubWFwcGVkRmllbGRzRnJvbVByZUV4aXN0aW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaW5hbE1hc2tQYXJ0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdERpY3RbJ2ZpZWxkTWFzayddID0gZmluYWxNYXNrUGFydHMuam9pbignLCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgbm8gZmllbGRzIGZyb20gYmlkaSBhbmQgbm8gdmFsaWQgYWRkaXRpb25hbCBmaWVsZHMgZnJvbVxuICAgICAgICAgICAgICAgIC8vIHByZS1leGlzdGluZyBtYXNrLlxuICAgICAgICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0RGljdFsnZmllbGRNYXNrJ107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBDYXNlIDM6IFwiTG9jayBhbGwgZmllbGRzXCIgKG1lYW5pbmcsIGRvbid0IHNlbmQgYSBmaWVsZF9tYXNrLCBsZXQgc2VydmVyXG4gICAgICAgICAgICAvLyBkZWZhdWx0cyBhcHBseSBvciBhbGwgYXJlIG11dGFibGUpLiBUaGlzIGlzIGhpdCBpZjpcbiAgICAgICAgICAgIC8vICAtIGBjb25maWcubG9ja0FkZGl0aW9uYWxGaWVsZHNgIGlzIHVuZGVmaW5lZC5cbiAgICAgICAgICAgIC8vICAtIGBjb25maWcubG9ja0FkZGl0aW9uYWxGaWVsZHNgIGlzIG5vbi1lbXB0eSwgQlVUXG4gICAgICAgICAgICAvLyAgYHByZUV4aXN0aW5nRmllbGRNYXNrYCBpcyBudWxsLCBub3QgYSBzdHJpbmcsIG9yIGFuIGVtcHR5IHN0cmluZy5cbiAgICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0RGljdFsnZmllbGRNYXNrJ107XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIE5vIHZhbGlkIGBiaWRpR2VuZXJhdGVDb250ZW50U2V0dXBgIHdhcyBmb3VuZCBvciBleHRyYWN0ZWQuXG4gICAgICAgIC8vIFwiTG9jayBhZGRpdGlvbmFsIG51bGwgZmllbGRzIGlmIGFueVwiLlxuICAgICAgICBpZiAocHJlRXhpc3RpbmdGaWVsZE1hc2sgIT09IG51bGwgJiZcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkocHJlRXhpc3RpbmdGaWVsZE1hc2spICYmXG4gICAgICAgICAgICBwcmVFeGlzdGluZ0ZpZWxkTWFzay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSdzIGEgcHJlLWV4aXN0aW5nIGZpZWxkIG1hc2ssIGl0J3MgYSBzdHJpbmcsIGFuZCBpdCdzIG5vdFxuICAgICAgICAgICAgLy8gZW1wdHksIHRoZW4gd2Ugc2hvdWxkIGxvY2sgYWxsIGZpZWxkcy5cbiAgICAgICAgICAgIHJlcXVlc3REaWN0WydmaWVsZE1hc2snXSA9IHByZUV4aXN0aW5nRmllbGRNYXNrLmpvaW4oJywnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0RGljdFsnZmllbGRNYXNrJ107XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcXVlc3REaWN0O1xufVxuY2xhc3MgVG9rZW5zIGV4dGVuZHMgQmFzZU1vZHVsZSB7XG4gICAgY29uc3RydWN0b3IoYXBpQ2xpZW50KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYXBpQ2xpZW50ID0gYXBpQ2xpZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGVwaGVtZXJhbCBhdXRoIHRva2VuIHJlc291cmNlLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBFcGhlbWVyYWwgYXV0aCB0b2tlbnMgaXMgb25seSBzdXBwb3J0ZWQgaW4gdGhlIEdlbWluaSBEZXZlbG9wZXIgQVBJLlxuICAgICAqIEl0IGNhbiBiZSB1c2VkIGZvciB0aGUgc2Vzc2lvbiBjb25uZWN0aW9uIHRvIHRoZSBMaXZlIGNvbnN0cmFpbmVkIEFQSS5cbiAgICAgKiBTdXBwb3J0IGluIHYxYWxwaGEgb25seS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIGNyZWF0ZSByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4gVGhlIGNyZWF0ZWQgYXV0aCB0b2tlbi5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBhaSA9IG5ldyBHb29nbGVHZW5BSSh7XG4gICAgICogICAgIGFwaUtleTogdG9rZW4ubmFtZSxcbiAgICAgKiAgICAgaHR0cE9wdGlvbnM6IHsgYXBpVmVyc2lvbjogJ3YxYWxwaGEnIH0gIC8vIFN1cHBvcnQgaW4gdjFhbHBoYSBvbmx5LlxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogLy8gQ2FzZSAxOiBJZiBMaXZlRXBoZW1lcmFsUGFyYW1ldGVycyBpcyB1bnNldCwgdW5sb2NrIExpdmVDb25uZWN0Q29uZmlnXG4gICAgICogLy8gd2hlbiB1c2luZyB0aGUgdG9rZW4gaW4gTGl2ZSBBUEkgc2Vzc2lvbnMuIEVhY2ggc2Vzc2lvbiBjb25uZWN0aW9uIGNhblxuICAgICAqIC8vIHVzZSBhIGRpZmZlcmVudCBjb25maWd1cmF0aW9uLlxuICAgICAqIGNvbnN0IGNvbmZpZzogQ3JlYXRlQXV0aFRva2VuQ29uZmlnID0ge1xuICAgICAqICAgICB1c2VzOiAzLFxuICAgICAqICAgICBleHBpcmVUaW1lOiAnMjAyNS0wNS0wMVQwMDowMDowMFonLFxuICAgICAqIH1cbiAgICAgKiBjb25zdCB0b2tlbiA9IGF3YWl0IGFpLnRva2Vucy5jcmVhdGUoY29uZmlnKTtcbiAgICAgKlxuICAgICAqIC8vIENhc2UgMjogSWYgTGl2ZUVwaGVtZXJhbFBhcmFtZXRlcnMgaXMgc2V0LCBsb2NrIGFsbCBmaWVsZHMgaW5cbiAgICAgKiAvLyBMaXZlQ29ubmVjdENvbmZpZyB3aGVuIHVzaW5nIHRoZSB0b2tlbiBpbiBMaXZlIEFQSSBzZXNzaW9ucy4gRm9yXG4gICAgICogLy8gZXhhbXBsZSwgY2hhbmdpbmcgYG91dHB1dEF1ZGlvVHJhbnNjcmlwdGlvbmAgaW4gdGhlIExpdmUgQVBJXG4gICAgICogLy8gY29ubmVjdGlvbiB3aWxsIGJlIGlnbm9yZWQgYnkgdGhlIEFQSS5cbiAgICAgKiBjb25zdCBjb25maWc6IENyZWF0ZUF1dGhUb2tlbkNvbmZpZyA9XG4gICAgICogICAgIHVzZXM6IDMsXG4gICAgICogICAgIGV4cGlyZVRpbWU6ICcyMDI1LTA1LTAxVDAwOjAwOjAwWicsXG4gICAgICogICAgIExpdmVFcGhlbWVyYWxQYXJhbWV0ZXJzOiB7XG4gICAgICogICAgICAgIG1vZGVsOiAnZ2VtaW5pLTIuMC1mbGFzaC0wMDEnLFxuICAgICAqICAgICAgICBjb25maWc6IHtcbiAgICAgKiAgICAgICAgICAgJ3Jlc3BvbnNlTW9kYWxpdGllcyc6IFsnQVVESU8nXSxcbiAgICAgKiAgICAgICAgICAgJ3N5c3RlbUluc3RydWN0aW9uJzogJ0Fsd2F5cyBhbnN3ZXIgaW4gRW5nbGlzaC4nLFxuICAgICAqICAgICAgICB9XG4gICAgICogICAgIH1cbiAgICAgKiB9XG4gICAgICogY29uc3QgdG9rZW4gPSBhd2FpdCBhaS50b2tlbnMuY3JlYXRlKGNvbmZpZyk7XG4gICAgICpcbiAgICAgKiAvLyBDYXNlIDM6IElmIExpdmVFcGhlbWVyYWxQYXJhbWV0ZXJzIGlzIHNldCBhbmQgbG9ja0FkZGl0aW9uYWxGaWVsZHMgaXNcbiAgICAgKiAvLyBzZXQsIGxvY2sgTGl2ZUNvbm5lY3RDb25maWcgd2l0aCBzZXQgYW5kIGFkZGl0aW9uYWwgZmllbGRzIChlLmcuXG4gICAgICogLy8gcmVzcG9uc2VNb2RhbGl0aWVzLCBzeXN0ZW1JbnN0cnVjdGlvbiwgdGVtcGVyYXR1cmUgaW4gdGhpcyBleGFtcGxlKSB3aGVuXG4gICAgICogLy8gdXNpbmcgdGhlIHRva2VuIGluIExpdmUgQVBJIHNlc3Npb25zLlxuICAgICAqIGNvbnN0IGNvbmZpZzogQ3JlYXRlQXV0aFRva2VuQ29uZmlnID1cbiAgICAgKiAgICAgdXNlczogMyxcbiAgICAgKiAgICAgZXhwaXJlVGltZTogJzIwMjUtMDUtMDFUMDA6MDA6MDBaJyxcbiAgICAgKiAgICAgTGl2ZUVwaGVtZXJhbFBhcmFtZXRlcnM6IHtcbiAgICAgKiAgICAgICAgbW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoLTAwMScsXG4gICAgICogICAgICAgIGNvbmZpZzoge1xuICAgICAqICAgICAgICAgICAncmVzcG9uc2VNb2RhbGl0aWVzJzogWydBVURJTyddLFxuICAgICAqICAgICAgICAgICAnc3lzdGVtSW5zdHJ1Y3Rpb24nOiAnQWx3YXlzIGFuc3dlciBpbiBFbmdsaXNoLicsXG4gICAgICogICAgICAgIH1cbiAgICAgKiAgICAgfSxcbiAgICAgKiAgICAgbG9ja0FkZGl0aW9uYWxGaWVsZHM6IFsndGVtcGVyYXR1cmUnXSxcbiAgICAgKiB9XG4gICAgICogY29uc3QgdG9rZW4gPSBhd2FpdCBhaS50b2tlbnMuY3JlYXRlKGNvbmZpZyk7XG4gICAgICpcbiAgICAgKiAvLyBDYXNlIDQ6IElmIExpdmVFcGhlbWVyYWxQYXJhbWV0ZXJzIGlzIHNldCBhbmQgbG9ja0FkZGl0aW9uYWxGaWVsZHMgaXNcbiAgICAgKiAvLyBlbXB0eSBhcnJheSwgbG9jayBMaXZlQ29ubmVjdENvbmZpZyB3aXRoIHNldCBmaWVsZHMgKGUuZy5cbiAgICAgKiAvLyByZXNwb25zZU1vZGFsaXRpZXMsIHN5c3RlbUluc3RydWN0aW9uIGluIHRoaXMgZXhhbXBsZSkgd2hlbiB1c2luZyB0aGVcbiAgICAgKiAvLyB0b2tlbiBpbiBMaXZlIEFQSSBzZXNzaW9ucy5cbiAgICAgKiBjb25zdCBjb25maWc6IENyZWF0ZUF1dGhUb2tlbkNvbmZpZyA9XG4gICAgICogICAgIHVzZXM6IDMsXG4gICAgICogICAgIGV4cGlyZVRpbWU6ICcyMDI1LTA1LTAxVDAwOjAwOjAwWicsXG4gICAgICogICAgIExpdmVFcGhlbWVyYWxQYXJhbWV0ZXJzOiB7XG4gICAgICogICAgICAgIG1vZGVsOiAnZ2VtaW5pLTIuMC1mbGFzaC0wMDEnLFxuICAgICAqICAgICAgICBjb25maWc6IHtcbiAgICAgKiAgICAgICAgICAgJ3Jlc3BvbnNlTW9kYWxpdGllcyc6IFsnQVVESU8nXSxcbiAgICAgKiAgICAgICAgICAgJ3N5c3RlbUluc3RydWN0aW9uJzogJ0Fsd2F5cyBhbnN3ZXIgaW4gRW5nbGlzaC4nLFxuICAgICAqICAgICAgICB9XG4gICAgICogICAgIH0sXG4gICAgICogICAgIGxvY2tBZGRpdGlvbmFsRmllbGRzOiBbXSxcbiAgICAgKiB9XG4gICAgICogY29uc3QgdG9rZW4gPSBhd2FpdCBhaS50b2tlbnMuY3JlYXRlKGNvbmZpZyk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBjbGllbnQudG9rZW5zLmNyZWF0ZSBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIEdlbWluaSBEZXZlbG9wZXIgQVBJLicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGNyZWF0ZUF1dGhUb2tlblBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnYXV0aF90b2tlbnMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5Wydjb25maWcnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZEJvZHkgPSBjb252ZXJ0QmlkaVNldHVwVG9Ub2tlblNldHVwKGJvZHksIHBhcmFtcy5jb25maWcpO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh0cmFuc2Zvcm1lZEJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKHJlc3ApID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG4vLyBDb2RlIGdlbmVyYXRlZCBieSB0aGUgR29vZ2xlIEdlbiBBSSBTREsgZ2VuZXJhdG9yIERPIE5PVCBFRElULlxuZnVuY3Rpb24gY3JlYXRlRmlsZVNlYXJjaFN0b3JlQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21EaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWxlU2VhcmNoU3RvcmVQYXJhbWV0ZXJzVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBjcmVhdGVGaWxlU2VhcmNoU3RvcmVDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZGVsZXRlRmlsZVNlYXJjaFN0b3JlQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Gb3JjZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZm9yY2UnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Gb3JjZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAnZm9yY2UnXSwgZnJvbUZvcmNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZGVsZXRlRmlsZVNlYXJjaFN0b3JlUGFyYW1ldGVyc1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgZGVsZXRlRmlsZVNlYXJjaFN0b3JlQ29uZmlnVG9NbGRldihmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdldEZpbGVTZWFyY2hTdG9yZVBhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGltcG9ydEZpbGVDb25maWdUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUN1c3RvbU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY3VzdG9tTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQ3VzdG9tTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUN1c3RvbU1ldGFkYXRhO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnY3VzdG9tTWV0YWRhdGEnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNodW5raW5nQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2h1bmtpbmdDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQ2h1bmtpbmdDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnY2h1bmtpbmdDb25maWcnXSwgZnJvbUNodW5raW5nQ29uZmlnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gaW1wb3J0RmlsZU9wZXJhdGlvbkZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZXRhZGF0YSddKTtcbiAgICBpZiAoZnJvbU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWV0YWRhdGEnXSwgZnJvbU1ldGFkYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURvbmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RvbmUnXSk7XG4gICAgaWYgKGZyb21Eb25lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZG9uZSddLCBmcm9tRG9uZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FcnJvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXJyb3InXSk7XG4gICAgaWYgKGZyb21FcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vycm9yJ10sIGZyb21FcnJvcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVzcG9uc2UnXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlJ10sIGltcG9ydEZpbGVSZXNwb25zZUZyb21NbGRldihmcm9tUmVzcG9uc2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gaW1wb3J0RmlsZVBhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GaWxlU2VhcmNoU3RvcmVOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZmlsZVNlYXJjaFN0b3JlTmFtZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GaWxlU2VhcmNoU3RvcmVOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdmaWxlX3NlYXJjaF9zdG9yZV9uYW1lJ10sIGZyb21GaWxlU2VhcmNoU3RvcmVOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlTmFtZSddKTtcbiAgICBpZiAoZnJvbUZpbGVOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZU5hbWUnXSwgZnJvbUZpbGVOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgaW1wb3J0RmlsZUNvbmZpZ1RvTWxkZXYoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBpbXBvcnRGaWxlUmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYXJlbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcmVudCddKTtcbiAgICBpZiAoZnJvbVBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcmVudCddLCBmcm9tUGFyZW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURvY3VtZW50TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZG9jdW1lbnROYW1lJ10pO1xuICAgIGlmIChmcm9tRG9jdW1lbnROYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZG9jdW1lbnROYW1lJ10sIGZyb21Eb2N1bWVudE5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0RmlsZVNlYXJjaFN0b3Jlc0NvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFnZVNpemUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VTaXplJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVNpemUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VTaXplJ10sIGZyb21QYWdlU2l6ZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VUb2tlbiddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVRva2VuJ10sIGZyb21QYWdlVG9rZW4pO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0RmlsZVNlYXJjaFN0b3Jlc1BhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGxpc3RGaWxlU2VhcmNoU3RvcmVzQ29uZmlnVG9NbGRldihmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RGaWxlU2VhcmNoU3RvcmVzUmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OZXh0UGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbmV4dFBhZ2VUb2tlbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21OZXh0UGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmV4dFBhZ2VUb2tlbiddLCBmcm9tTmV4dFBhZ2VUb2tlbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlU2VhcmNoU3RvcmVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZmlsZVNlYXJjaFN0b3JlcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GaWxlU2VhcmNoU3RvcmVzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21GaWxlU2VhcmNoU3RvcmVzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlU2VhcmNoU3RvcmVzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUN1c3RvbU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY3VzdG9tTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQ3VzdG9tTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUN1c3RvbU1ldGFkYXRhO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnY3VzdG9tTWV0YWRhdGEnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNodW5raW5nQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2h1bmtpbmdDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQ2h1bmtpbmdDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnY2h1bmtpbmdDb25maWcnXSwgZnJvbUNodW5raW5nQ29uZmlnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXBsb2FkVG9GaWxlU2VhcmNoU3RvcmVQYXJhbWV0ZXJzVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRmlsZVNlYXJjaFN0b3JlTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2ZpbGVTZWFyY2hTdG9yZU5hbWUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRmlsZVNlYXJjaFN0b3JlTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnZmlsZV9zZWFyY2hfc3RvcmVfbmFtZSddLCBmcm9tRmlsZVNlYXJjaFN0b3JlTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlQ29uZmlnVG9NbGRldihmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlUmVzdW1hYmxlUmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuLy8gQ29kZSBnZW5lcmF0ZWQgYnkgdGhlIEdvb2dsZSBHZW4gQUkgU0RLIGdlbmVyYXRvciBETyBOT1QgRURJVC5cbmZ1bmN0aW9uIGRlbGV0ZURvY3VtZW50Q29uZmlnVG9NbGRldihmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Gb3JjZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZm9yY2UnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Gb3JjZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAnZm9yY2UnXSwgZnJvbUZvcmNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZGVsZXRlRG9jdW1lbnRQYXJhbWV0ZXJzVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBkZWxldGVEb2N1bWVudENvbmZpZ1RvTWxkZXYoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZXREb2N1bWVudFBhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3REb2N1bWVudHNDb25maWdUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhZ2VTaXplID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlU2l6ZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VTaXplICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlU2l6ZSddLCBmcm9tUGFnZVNpemUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlVG9rZW4nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VUb2tlbiddLCBmcm9tUGFnZVRva2VuKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdERvY3VtZW50c1BhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYXJlbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcmVudCddKTtcbiAgICBpZiAoZnJvbVBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAncGFyZW50J10sIGZyb21QYXJlbnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBsaXN0RG9jdW1lbnRzQ29uZmlnVG9NbGRldihmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3REb2N1bWVudHNSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5leHRQYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICduZXh0UGFnZVRva2VuJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU5leHRQYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduZXh0UGFnZVRva2VuJ10sIGZyb21OZXh0UGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURvY3VtZW50cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZG9jdW1lbnRzJ10pO1xuICAgIGlmIChmcm9tRG9jdW1lbnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21Eb2N1bWVudHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RvY3VtZW50cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmNsYXNzIERvY3VtZW50cyBleHRlbmRzIEJhc2VNb2R1bGUge1xuICAgIGNvbnN0cnVjdG9yKGFwaUNsaWVudCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IGFwaUNsaWVudDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3RzIGRvY3VtZW50cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgbGlzdCByZXF1ZXN0LlxuICAgICAgICAgKiBAcmV0dXJuIC0gQSBwYWdlciBvZiBkb2N1bWVudHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIGNvbnN0IGRvY3VtZW50cyA9IGF3YWl0IGFpLmRvY3VtZW50cy5saXN0KHtjb25maWc6IHsncGFnZVNpemUnOiAyfX0pO1xuICAgICAgICAgKiBmb3IgYXdhaXQgKGNvbnN0IGRvY3VtZW50IG9mIGRvY3VtZW50cykge1xuICAgICAgICAgKiAgIGNvbnNvbGUubG9nKGRvY3VtZW50KTtcbiAgICAgICAgICogfVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGlzdCA9IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGFnZXIoUGFnZWRJdGVtLlBBR0VEX0lURU1fRE9DVU1FTlRTLCAoeCkgPT4gdGhpcy5saXN0SW50ZXJuYWwoe1xuICAgICAgICAgICAgICAgIHBhcmVudDogcGFyYW1zLnBhcmVudCxcbiAgICAgICAgICAgICAgICBjb25maWc6IHguY29uZmlnLFxuICAgICAgICAgICAgfSksIGF3YWl0IHRoaXMubGlzdEludGVybmFsKHBhcmFtcyksIHBhcmFtcyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYSBEb2N1bWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgZ2V0dGluZyBhIGRvY3VtZW50LlxuICAgICAqIEByZXR1cm4gRG9jdW1lbnQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0KHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBHZW1pbmkgRGV2ZWxvcGVyIEFQSS4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZXREb2N1bWVudFBhcmFtZXRlcnNUb01sZGV2KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigocmVzcCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBhIERvY3VtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBkZWxldGluZyBhIGRvY3VtZW50LlxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZShwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIEdlbWluaSBEZXZlbG9wZXIgQVBJLicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGRlbGV0ZURvY3VtZW50UGFyYW1ldGVyc1RvTWxkZXYocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYXBpQ2xpZW50LnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3RzIGFsbCBEb2N1bWVudHMgaW4gYSBGaWxlU2VhcmNoU3RvcmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIGxpc3RpbmcgZG9jdW1lbnRzLlxuICAgICAqIEByZXR1cm4gTGlzdERvY3VtZW50c1Jlc3BvbnNlLlxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgR2VtaW5pIERldmVsb3BlciBBUEkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gbGlzdERvY3VtZW50c1BhcmFtZXRlcnNUb01sZGV2KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7cGFyZW50fS9kb2N1bWVudHMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gbGlzdERvY3VtZW50c1Jlc3BvbnNlRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgTGlzdERvY3VtZW50c1Jlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY2xhc3MgRmlsZVNlYXJjaFN0b3JlcyBleHRlbmRzIEJhc2VNb2R1bGUge1xuICAgIGNvbnN0cnVjdG9yKGFwaUNsaWVudCwgZG9jdW1lbnRzID0gbmV3IERvY3VtZW50cyhhcGlDbGllbnQpKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYXBpQ2xpZW50ID0gYXBpQ2xpZW50O1xuICAgICAgICB0aGlzLmRvY3VtZW50cyA9IGRvY3VtZW50cztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3RzIGZpbGUgc2VhcmNoIHN0b3Jlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgbGlzdCByZXF1ZXN0LlxuICAgICAgICAgKiBAcmV0dXJuIC0gQSBwYWdlciBvZiBmaWxlIHNlYXJjaCBzdG9yZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIGNvbnN0IGZpbGVTZWFyY2hTdG9yZXMgPSBhd2FpdCBhaS5maWxlU2VhcmNoU3RvcmVzLmxpc3Qoe2NvbmZpZzogeydwYWdlU2l6ZSc6IDJ9fSk7XG4gICAgICAgICAqIGZvciBhd2FpdCAoY29uc3QgZmlsZVNlYXJjaFN0b3JlIG9mIGZpbGVTZWFyY2hTdG9yZXMpIHtcbiAgICAgICAgICogICBjb25zb2xlLmxvZyhmaWxlU2VhcmNoU3RvcmUpO1xuICAgICAgICAgKiB9XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5saXN0ID0gYXN5bmMgKHBhcmFtcyA9IHt9KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhZ2VyKFBhZ2VkSXRlbS5QQUdFRF9JVEVNX0ZJTEVfU0VBUkNIX1NUT1JFUywgKHgpID0+IHRoaXMubGlzdEludGVybmFsKHgpLCBhd2FpdCB0aGlzLmxpc3RJbnRlcm5hbChwYXJhbXMpLCBwYXJhbXMpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGxvYWRzIGEgZmlsZSBhc3luY2hyb25vdXNseSB0byBhIGdpdmVuIEZpbGUgU2VhcmNoIFN0b3JlLlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIG5vdCBhdmFpbGFibGUgaW4gVmVydGV4IEFJLlxuICAgICAqIFN1cHBvcnRlZCB1cGxvYWQgc291cmNlczpcbiAgICAgKiAtIE5vZGUuanM6IEZpbGUgcGF0aCAoc3RyaW5nKSBvciBCbG9iIG9iamVjdC5cbiAgICAgKiAtIEJyb3dzZXI6IEJsb2Igb2JqZWN0IChlLmcuLCBGaWxlKS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVGhlIGBtaW1lVHlwZWAgY2FuIGJlIHNwZWNpZmllZCBpbiB0aGUgYGNvbmZpZ2AgcGFyYW1ldGVyLiBJZiBvbWl0dGVkOlxuICAgICAqICAtIEZvciBmaWxlIHBhdGggKHN0cmluZykgaW5wdXRzLCB0aGUgYG1pbWVUeXBlYCB3aWxsIGJlIGluZmVycmVkIGZyb20gdGhlXG4gICAgICogICAgIGZpbGUgZXh0ZW5zaW9uLlxuICAgICAqICAtIEZvciBCbG9iIG9iamVjdCBpbnB1dHMsIHRoZSBgbWltZVR5cGVgIHdpbGwgYmUgc2V0IHRvIHRoZSBCbG9iJ3MgYHR5cGVgXG4gICAgICogICAgIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogVGhpcyBzZWN0aW9uIGNhbiBjb250YWluIG11bHRpcGxlIHBhcmFncmFwaHMgYW5kIGNvZGUgZXhhbXBsZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gT3B0aW9uYWwgcGFyYW1ldGVycyBzcGVjaWZpZWQgaW4gdGhlXG4gICAgICogICAgICAgIGB0eXBlcy5VcGxvYWRUb0ZpbGVTZWFyY2hTdG9yZVBhcmFtZXRlcnNgIGludGVyZmFjZS5cbiAgICAgKiAgICAgICAgIEBzZWUge0BsaW5rIHR5cGVzLlVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlUGFyYW1ldGVycyNjb25maWd9IGZvciB0aGUgb3B0aW9uYWxcbiAgICAgKiAgICAgICAgIGNvbmZpZyBpbiB0aGUgcGFyYW1ldGVycy5cbiAgICAgKiBAcmV0dXJuIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgbG9uZyBydW5uaW5nIG9wZXJhdGlvbi5cbiAgICAgKiBAdGhyb3dzIEFuIGVycm9yIGlmIGNhbGxlZCBvbiBhIFZlcnRleCBBSSBjbGllbnQuXG4gICAgICogQHRocm93cyBBbiBlcnJvciBpZiB0aGUgYG1pbWVUeXBlYCBpcyBub3QgcHJvdmlkZWQgYW5kIGNhbiBub3QgYmUgaW5mZXJyZWQsXG4gICAgICogdGhlIGBtaW1lVHlwZWAgY2FuIGJlIHByb3ZpZGVkIGluIHRoZSBgcGFyYW1zLmNvbmZpZ2AgcGFyYW1ldGVyLlxuICAgICAqIEB0aHJvd3MgQW4gZXJyb3Igb2NjdXJzIGlmIGEgc3VpdGFibGUgdXBsb2FkIGxvY2F0aW9uIGNhbm5vdCBiZSBlc3RhYmxpc2hlZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogVGhlIGZvbGxvd2luZyBjb2RlIHVwbG9hZHMgYSBmaWxlIHRvIGEgZ2l2ZW4gZmlsZSBzZWFyY2ggc3RvcmUuXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IG9wZXJhdGlvbiA9IGF3YWl0IGFpLmZpbGVTZWFyY2hTdG9yZXMudXBsb2FkKHtmaWxlU2VhcmNoU3RvcmVOYW1lOiAnZmlsZVNlYXJjaFN0b3Jlcy9mb28tYmFyJywgZmlsZTogJ2ZpbGUudHh0JywgY29uZmlnOiB7XG4gICAgICogICBtaW1lVHlwZTogJ3RleHQvcGxhaW4nLFxuICAgICAqIH19KTtcbiAgICAgKiBjb25zb2xlLmxvZyhvcGVyYXRpb24ubmFtZSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgdXBsb2FkVG9GaWxlU2VhcmNoU3RvcmUocGFyYW1zKSB7XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVmVydGV4IEFJIGRvZXMgbm90IHN1cHBvcnQgdXBsb2FkaW5nIGZpbGVzIHRvIGEgZmlsZSBzZWFyY2ggc3RvcmUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYXBpQ2xpZW50LnVwbG9hZEZpbGVUb0ZpbGVTZWFyY2hTdG9yZShwYXJhbXMuZmlsZVNlYXJjaFN0b3JlTmFtZSwgcGFyYW1zLmZpbGUsIHBhcmFtcy5jb25maWcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgRmlsZSBTZWFyY2ggU3RvcmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIGNyZWF0aW5nIGEgRmlsZSBTZWFyY2ggU3RvcmUuXG4gICAgICogQHJldHVybiBGaWxlU2VhcmNoU3RvcmUuXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBHZW1pbmkgRGV2ZWxvcGVyIEFQSS4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBjcmVhdGVGaWxlU2VhcmNoU3RvcmVQYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnZmlsZVNlYXJjaFN0b3JlcycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigocmVzcCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIEZpbGUgU2VhcmNoIFN0b3JlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBnZXR0aW5nIGEgRmlsZSBTZWFyY2ggU3RvcmUuXG4gICAgICogQHJldHVybiBGaWxlU2VhcmNoU3RvcmUuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0KHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBHZW1pbmkgRGV2ZWxvcGVyIEFQSS4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZXRGaWxlU2VhcmNoU3RvcmVQYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKHJlc3ApID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgYSBGaWxlIFNlYXJjaCBTdG9yZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgZGVsZXRpbmcgYSBGaWxlIFNlYXJjaCBTdG9yZS5cbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGUocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBHZW1pbmkgRGV2ZWxvcGVyIEFQSS4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBkZWxldGVGaWxlU2VhcmNoU3RvcmVQYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5hcGlDbGllbnQucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdHMgYWxsIEZpbGVTZWFyY2hTdG9yZSBvd25lZCBieSB0aGUgdXNlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgbGlzdGluZyBmaWxlIHNlYXJjaCBzdG9yZXMuXG4gICAgICogQHJldHVybiBMaXN0RmlsZVNlYXJjaFN0b3Jlc1Jlc3BvbnNlLlxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgR2VtaW5pIERldmVsb3BlciBBUEkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gbGlzdEZpbGVTZWFyY2hTdG9yZXNQYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnZmlsZVNlYXJjaFN0b3JlcycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBsaXN0RmlsZVNlYXJjaFN0b3Jlc1Jlc3BvbnNlRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgTGlzdEZpbGVTZWFyY2hTdG9yZXNSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgdXBsb2FkVG9GaWxlU2VhcmNoU3RvcmVJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgR2VtaW5pIERldmVsb3BlciBBUEkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gdXBsb2FkVG9GaWxlU2VhcmNoU3RvcmVQYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgndXBsb2FkL3YxYmV0YS97ZmlsZV9zZWFyY2hfc3RvcmVfbmFtZX06dXBsb2FkVG9GaWxlU2VhcmNoU3RvcmUnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IHVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlUmVzdW1hYmxlUmVzcG9uc2VGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBVcGxvYWRUb0ZpbGVTZWFyY2hTdG9yZVJlc3VtYWJsZVJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbXBvcnRzIGEgRmlsZSBmcm9tIEZpbGUgU2VydmljZSB0byBhIEZpbGVTZWFyY2hTdG9yZS5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgYSBsb25nLXJ1bm5pbmcgb3BlcmF0aW9uLCBzZWUgYWlwLmRldi8xNTFcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgaW1wb3J0aW5nIGEgZmlsZSB0byBhIGZpbGUgc2VhcmNoIHN0b3JlLlxuICAgICAqIEByZXR1cm4gSW1wb3J0RmlsZU9wZXJhdGlvbi5cbiAgICAgKi9cbiAgICBhc3luYyBpbXBvcnRGaWxlKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBHZW1pbmkgRGV2ZWxvcGVyIEFQSS4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBpbXBvcnRGaWxlUGFyYW1ldGVyc1RvTWxkZXYocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tmaWxlX3NlYXJjaF9zdG9yZV9uYW1lfTppbXBvcnRGaWxlJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBpbXBvcnRGaWxlT3BlcmF0aW9uRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgSW1wb3J0RmlsZU9wZXJhdGlvbigpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmNvbnN0IEdPT0dMRV9BUElfS0VZX0hFQURFUiA9ICd4LWdvb2ctYXBpLWtleSc7XG5jb25zdCBSRVFVSVJFRF9WRVJURVhfQUlfU0NPUEUgPSAnaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vYXV0aC9jbG91ZC1wbGF0Zm9ybSc7XG5jbGFzcyBOb2RlQXV0aCB7XG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBpZiAob3B0cy5hcGlLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5hcGlLZXkgPSBvcHRzLmFwaUtleTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2ZXJ0ZXhBdXRoT3B0aW9ucyA9IGJ1aWxkR29vZ2xlQXV0aE9wdGlvbnMob3B0cy5nb29nbGVBdXRoT3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZ29vZ2xlQXV0aCA9IG5ldyBHb29nbGVBdXRoKHZlcnRleEF1dGhPcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgYWRkQXV0aEhlYWRlcnMoaGVhZGVycywgdXJsKSB7XG4gICAgICAgIGlmICh0aGlzLmFwaUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hcGlLZXkuc3RhcnRzV2l0aCgnYXV0aF90b2tlbnMvJykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VwaGVtZXJhbCB0b2tlbnMgYXJlIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBsaXZlIEFQSS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWRkS2V5SGVhZGVyKGhlYWRlcnMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmFkZEdvb2dsZUF1dGhIZWFkZXJzKGhlYWRlcnMsIHVybCk7XG4gICAgfVxuICAgIGFkZEtleUhlYWRlcihoZWFkZXJzKSB7XG4gICAgICAgIGlmIChoZWFkZXJzLmdldChHT09HTEVfQVBJX0tFWV9IRUFERVIpICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYXBpS2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbiwgdGhpcyBtZXRob2QgaXMgb25seSBjYWxsZWRcbiAgICAgICAgICAgIC8vIHdoZW4gYXBpS2V5IGlzIHNldC5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVHJ5aW5nIHRvIHNldCBBUEkga2V5IGhlYWRlciBidXQgYXBpS2V5IGlzIG5vdCBzZXQnKTtcbiAgICAgICAgfVxuICAgICAgICBoZWFkZXJzLmFwcGVuZChHT09HTEVfQVBJX0tFWV9IRUFERVIsIHRoaXMuYXBpS2V5KTtcbiAgICB9XG4gICAgYXN5bmMgYWRkR29vZ2xlQXV0aEhlYWRlcnMoaGVhZGVycywgdXJsKSB7XG4gICAgICAgIGlmICh0aGlzLmdvb2dsZUF1dGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLCBhZGRHb29nbGVBdXRoSGVhZGVycyBzaG91bGQgb25seSBiZVxuICAgICAgICAgICAgLy8gY2FsbGVkIHdoZW4gdGhlcmUgaXMgbm8gYXBpS2V5IHNldCBhbmQgaW4gdGhlc2UgY2FzZXMgZ29vZ2xlQXV0aFxuICAgICAgICAgICAgLy8gaXMgc2V0LlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcnlpbmcgdG8gc2V0IGdvb2dsZS1hdXRoIGhlYWRlcnMgYnV0IGdvb2dsZUF1dGggaXMgdW5zZXQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhdXRoSGVhZGVycyA9IGF3YWl0IHRoaXMuZ29vZ2xlQXV0aC5nZXRSZXF1ZXN0SGVhZGVycyh1cmwpO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBhdXRoSGVhZGVycykge1xuICAgICAgICAgICAgaWYgKGhlYWRlcnMuZ2V0KGtleSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhlYWRlcnMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gYnVpbGRHb29nbGVBdXRoT3B0aW9ucyhnb29nbGVBdXRoT3B0aW9ucykge1xuICAgIGxldCBhdXRoT3B0aW9ucztcbiAgICBpZiAoIWdvb2dsZUF1dGhPcHRpb25zKSB7XG4gICAgICAgIGF1dGhPcHRpb25zID0ge1xuICAgICAgICAgICAgc2NvcGVzOiBbUkVRVUlSRURfVkVSVEVYX0FJX1NDT1BFXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF1dGhPcHRpb25zO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXV0aE9wdGlvbnMgPSBnb29nbGVBdXRoT3B0aW9ucztcbiAgICAgICAgaWYgKCFhdXRoT3B0aW9ucy5zY29wZXMpIHtcbiAgICAgICAgICAgIGF1dGhPcHRpb25zLnNjb3BlcyA9IFtSRVFVSVJFRF9WRVJURVhfQUlfU0NPUEVdO1xuICAgICAgICAgICAgcmV0dXJuIGF1dGhPcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCh0eXBlb2YgYXV0aE9wdGlvbnMuc2NvcGVzID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgYXV0aE9wdGlvbnMuc2NvcGVzICE9PSBSRVFVSVJFRF9WRVJURVhfQUlfU0NPUEUpIHx8XG4gICAgICAgICAgICAoQXJyYXkuaXNBcnJheShhdXRoT3B0aW9ucy5zY29wZXMpICYmXG4gICAgICAgICAgICAgICAgYXV0aE9wdGlvbnMuc2NvcGVzLmluZGV4T2YoUkVRVUlSRURfVkVSVEVYX0FJX1NDT1BFKSA8IDApKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYXV0aCBzY29wZXMuIFNjb3BlcyBtdXN0IGluY2x1ZGU6ICR7UkVRVUlSRURfVkVSVEVYX0FJX1NDT1BFfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhdXRoT3B0aW9ucztcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmNsYXNzIE5vZGVEb3dubG9hZGVyIHtcbiAgICBhc3luYyBkb3dubG9hZChwYXJhbXMsIGFwaUNsaWVudCkge1xuICAgICAgICBpZiAocGFyYW1zLmRvd25sb2FkUGF0aCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBkb3dubG9hZEZpbGUocGFyYW1zLCBhcGlDbGllbnQpO1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlIGluc3RhbmNlb2YgSHR0cFJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd3JpdGVyID0gY3JlYXRlV3JpdGVTdHJlYW0ocGFyYW1zLmRvd25sb2FkUGF0aCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYm9keSA9IFJlYWRhYmxlLmZyb21XZWIocmVzcG9uc2UucmVzcG9uc2VJbnRlcm5hbC5ib2R5KTtcbiAgICAgICAgICAgICAgICBib2R5LnBpcGUod3JpdGVyKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBmaW5pc2hlZCh3cml0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgd3JpdGVGaWxlKHBhcmFtcy5kb3dubG9hZFBhdGgsIHJlc3BvbnNlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGluZzogJ2Jhc2U2NCcsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gd3JpdGUgZmlsZSB0byAke3BhcmFtcy5kb3dubG9hZFBhdGh9OiAke2Vycm9yfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGRvd25sb2FkRmlsZShwYXJhbXMsIGFwaUNsaWVudCkge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGNvbnN0IG5hbWUgPSB0RmlsZU5hbWUocGFyYW1zLmZpbGUpO1xuICAgIGlmIChuYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGFwaUNsaWVudC5yZXF1ZXN0KHtcbiAgICAgICAgICAgIHBhdGg6IGBmaWxlcy8ke25hbWV9OmRvd25sb2FkYCxcbiAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHtcbiAgICAgICAgICAgICAgICAnYWx0JzogJ21lZGlhJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzR2VuZXJhdGVkVmlkZW8ocGFyYW1zLmZpbGUpKSB7XG4gICAgICAgIGNvbnN0IHZpZGVvQnl0ZXMgPSAoX2MgPSBwYXJhbXMuZmlsZS52aWRlbykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnZpZGVvQnl0ZXM7XG4gICAgICAgIGlmICh0eXBlb2YgdmlkZW9CeXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB2aWRlb0J5dGVzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZG93bmxvYWQgZ2VuZXJhdGVkIHZpZGVvLCBVcmkgb3IgdmlkZW9CeXRlcyBub3QgZm91bmQuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNWaWRlbyhwYXJhbXMuZmlsZSkpIHtcbiAgICAgICAgY29uc3QgdmlkZW9CeXRlcyA9IHBhcmFtcy5maWxlLnZpZGVvQnl0ZXM7XG4gICAgICAgIGlmICh0eXBlb2YgdmlkZW9CeXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB2aWRlb0J5dGVzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZG93bmxvYWQgdmlkZW8sIFVyaSBvciB2aWRlb0J5dGVzIG5vdCBmb3VuZC4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBmaWxlIHR5cGUnKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmNsYXNzIE5vZGVXZWJTb2NrZXRGYWN0b3J5IHtcbiAgICBjcmVhdGUodXJsLCBoZWFkZXJzLCBjYWxsYmFja3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlV2ViU29ja2V0KHVybCwgaGVhZGVycywgY2FsbGJhY2tzKTtcbiAgICB9XG59XG5jbGFzcyBOb2RlV2ViU29ja2V0IHtcbiAgICBjb25zdHJ1Y3Rvcih1cmwsIGhlYWRlcnMsIGNhbGxiYWNrcykge1xuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gaGVhZGVycztcbiAgICAgICAgdGhpcy5jYWxsYmFja3MgPSBjYWxsYmFja3M7XG4gICAgfVxuICAgIGNvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMud3MgPSBuZXcgTm9kZVdzLldlYlNvY2tldCh0aGlzLnVybCwgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfSk7XG4gICAgICAgIHRoaXMud3Mub25vcGVuID0gdGhpcy5jYWxsYmFja3Mub25vcGVuO1xuICAgICAgICB0aGlzLndzLm9uZXJyb3IgPSB0aGlzLmNhbGxiYWNrcy5vbmVycm9yO1xuICAgICAgICB0aGlzLndzLm9uY2xvc2UgPSB0aGlzLmNhbGxiYWNrcy5vbmNsb3NlO1xuICAgICAgICB0aGlzLndzLm9ubWVzc2FnZSA9IHRoaXMuY2FsbGJhY2tzLm9ubWVzc2FnZTtcbiAgICB9XG4gICAgc2VuZChtZXNzYWdlKSB7XG4gICAgICAgIGlmICh0aGlzLndzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2ViU29ja2V0IGlzIG5vdCBjb25uZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndzLnNlbmQobWVzc2FnZSk7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy53cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYlNvY2tldCBpcyBub3QgY29ubmVjdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53cy5jbG9zZSgpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuLy8gQ29kZSBnZW5lcmF0ZWQgYnkgdGhlIEdvb2dsZSBHZW4gQUkgU0RLIGdlbmVyYXRvciBETyBOT1QgRURJVC5cbmZ1bmN0aW9uIGNhbmNlbFR1bmluZ0pvYlBhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QsIF9yb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjYW5jZWxUdW5pbmdKb2JQYXJhbWV0ZXJzVG9WZXJ0ZXgoZnJvbU9iamVjdCwgX3Jvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVR1bmluZ0pvYkNvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0LCBfcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmFsaWRhdGlvbkRhdGFzZXQnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZhbGlkYXRpb25EYXRhc2V0IHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UdW5lZE1vZGVsRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0dW5lZE1vZGVsRGlzcGxheU5hbWUnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVHVuZWRNb2RlbERpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10sIGZyb21UdW5lZE1vZGVsRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXNjcmlwdGlvbiddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGVzY3JpcHRpb24gcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVwb2NoQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Vwb2NoQ291bnQnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FcG9jaENvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3R1bmluZ1Rhc2snLCAnaHlwZXJwYXJhbWV0ZXJzJywgJ2Vwb2NoQ291bnQnXSwgZnJvbUVwb2NoQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGVhcm5pbmdSYXRlTXVsdGlwbGllciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2xlYXJuaW5nUmF0ZU11bHRpcGxpZXInLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTGVhcm5pbmdSYXRlTXVsdGlwbGllciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3R1bmluZ1Rhc2snLCAnaHlwZXJwYXJhbWV0ZXJzJywgJ2xlYXJuaW5nUmF0ZU11bHRpcGxpZXInXSwgZnJvbUxlYXJuaW5nUmF0ZU11bHRpcGxpZXIpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydleHBvcnRMYXN0Q2hlY2twb2ludE9ubHknXSkgIT09XG4gICAgICAgIHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cG9ydExhc3RDaGVja3BvaW50T25seSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcmVUdW5lZE1vZGVsQ2hlY2twb2ludElkJ10pICE9PVxuICAgICAgICB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcmVUdW5lZE1vZGVsQ2hlY2twb2ludElkIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FkYXB0ZXJTaXplJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhZGFwdGVyU2l6ZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQmF0Y2hTaXplID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydiYXRjaFNpemUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21CYXRjaFNpemUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndHVuaW5nVGFzaycsICdoeXBlcnBhcmFtZXRlcnMnLCAnYmF0Y2hTaXplJ10sIGZyb21CYXRjaFNpemUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGVhcm5pbmdSYXRlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsZWFybmluZ1JhdGUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21MZWFybmluZ1JhdGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndHVuaW5nVGFzaycsICdoeXBlcnBhcmFtZXRlcnMnLCAnbGVhcm5pbmdSYXRlJ10sIGZyb21MZWFybmluZ1JhdGUpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYWJlbHMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xhYmVscyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydiZXRhJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiZXRhIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVR1bmluZ0pvYkNvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCwgcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgbGV0IGRpc2NyaW1pbmF0b3JWYWxpZGF0aW9uRGF0YXNldCA9IGdldFZhbHVlQnlQYXRoKHJvb3RPYmplY3QsIFtcbiAgICAgICAgJ2NvbmZpZycsXG4gICAgICAgICdtZXRob2QnLFxuICAgIF0pO1xuICAgIGlmIChkaXNjcmltaW5hdG9yVmFsaWRhdGlvbkRhdGFzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkaXNjcmltaW5hdG9yVmFsaWRhdGlvbkRhdGFzZXQgPSAnU1VQRVJWSVNFRF9GSU5FX1RVTklORyc7XG4gICAgfVxuICAgIGlmIChkaXNjcmltaW5hdG9yVmFsaWRhdGlvbkRhdGFzZXQgPT09ICdTVVBFUlZJU0VEX0ZJTkVfVFVOSU5HJykge1xuICAgICAgICBjb25zdCBmcm9tVmFsaWRhdGlvbkRhdGFzZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICAgICAndmFsaWRhdGlvbkRhdGFzZXQnLFxuICAgICAgICBdKTtcbiAgICAgICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21WYWxpZGF0aW9uRGF0YXNldCAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc3VwZXJ2aXNlZFR1bmluZ1NwZWMnXSwgdHVuaW5nVmFsaWRhdGlvbkRhdGFzZXRUb1ZlcnRleChmcm9tVmFsaWRhdGlvbkRhdGFzZXQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChkaXNjcmltaW5hdG9yVmFsaWRhdGlvbkRhdGFzZXQgPT09ICdQUkVGRVJFTkNFX1RVTklORycpIHtcbiAgICAgICAgY29uc3QgZnJvbVZhbGlkYXRpb25EYXRhc2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAgICAgJ3ZhbGlkYXRpb25EYXRhc2V0JyxcbiAgICAgICAgXSk7XG4gICAgICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVmFsaWRhdGlvbkRhdGFzZXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3ByZWZlcmVuY2VPcHRpbWl6YXRpb25TcGVjJ10sIHR1bmluZ1ZhbGlkYXRpb25EYXRhc2V0VG9WZXJ0ZXgoZnJvbVZhbGlkYXRpb25EYXRhc2V0KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZnJvbVR1bmVkTW9kZWxEaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3R1bmVkTW9kZWxEaXNwbGF5TmFtZScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UdW5lZE1vZGVsRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndHVuZWRNb2RlbERpc3BsYXlOYW1lJ10sIGZyb21UdW5lZE1vZGVsRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRGVzY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZGVzY3JpcHRpb24nXSwgZnJvbURlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgbGV0IGRpc2NyaW1pbmF0b3JFcG9jaENvdW50ID0gZ2V0VmFsdWVCeVBhdGgocm9vdE9iamVjdCwgW1xuICAgICAgICAnY29uZmlnJyxcbiAgICAgICAgJ21ldGhvZCcsXG4gICAgXSk7XG4gICAgaWYgKGRpc2NyaW1pbmF0b3JFcG9jaENvdW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGlzY3JpbWluYXRvckVwb2NoQ291bnQgPSAnU1VQRVJWSVNFRF9GSU5FX1RVTklORyc7XG4gICAgfVxuICAgIGlmIChkaXNjcmltaW5hdG9yRXBvY2hDb3VudCA9PT0gJ1NVUEVSVklTRURfRklORV9UVU5JTkcnKSB7XG4gICAgICAgIGNvbnN0IGZyb21FcG9jaENvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlcG9jaENvdW50J10pO1xuICAgICAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUVwb2NoQ291bnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3N1cGVydmlzZWRUdW5pbmdTcGVjJywgJ2h5cGVyUGFyYW1ldGVycycsICdlcG9jaENvdW50J10sIGZyb21FcG9jaENvdW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChkaXNjcmltaW5hdG9yRXBvY2hDb3VudCA9PT0gJ1BSRUZFUkVOQ0VfVFVOSU5HJykge1xuICAgICAgICBjb25zdCBmcm9tRXBvY2hDb3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXBvY2hDb3VudCddKTtcbiAgICAgICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FcG9jaENvdW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwcmVmZXJlbmNlT3B0aW1pemF0aW9uU3BlYycsICdoeXBlclBhcmFtZXRlcnMnLCAnZXBvY2hDb3VudCddLCBmcm9tRXBvY2hDb3VudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGRpc2NyaW1pbmF0b3JMZWFybmluZ1JhdGVNdWx0aXBsaWVyID0gZ2V0VmFsdWVCeVBhdGgocm9vdE9iamVjdCwgW1xuICAgICAgICAnY29uZmlnJyxcbiAgICAgICAgJ21ldGhvZCcsXG4gICAgXSk7XG4gICAgaWYgKGRpc2NyaW1pbmF0b3JMZWFybmluZ1JhdGVNdWx0aXBsaWVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGlzY3JpbWluYXRvckxlYXJuaW5nUmF0ZU11bHRpcGxpZXIgPSAnU1VQRVJWSVNFRF9GSU5FX1RVTklORyc7XG4gICAgfVxuICAgIGlmIChkaXNjcmltaW5hdG9yTGVhcm5pbmdSYXRlTXVsdGlwbGllciA9PT0gJ1NVUEVSVklTRURfRklORV9UVU5JTkcnKSB7XG4gICAgICAgIGNvbnN0IGZyb21MZWFybmluZ1JhdGVNdWx0aXBsaWVyID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAgICAgJ2xlYXJuaW5nUmF0ZU11bHRpcGxpZXInLFxuICAgICAgICBdKTtcbiAgICAgICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21MZWFybmluZ1JhdGVNdWx0aXBsaWVyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzdXBlcnZpc2VkVHVuaW5nU3BlYycsICdoeXBlclBhcmFtZXRlcnMnLCAnbGVhcm5pbmdSYXRlTXVsdGlwbGllciddLCBmcm9tTGVhcm5pbmdSYXRlTXVsdGlwbGllcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZGlzY3JpbWluYXRvckxlYXJuaW5nUmF0ZU11bHRpcGxpZXIgPT09ICdQUkVGRVJFTkNFX1RVTklORycpIHtcbiAgICAgICAgY29uc3QgZnJvbUxlYXJuaW5nUmF0ZU11bHRpcGxpZXIgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICAgICAnbGVhcm5pbmdSYXRlTXVsdGlwbGllcicsXG4gICAgICAgIF0pO1xuICAgICAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUxlYXJuaW5nUmF0ZU11bHRpcGxpZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbXG4gICAgICAgICAgICAgICAgJ3ByZWZlcmVuY2VPcHRpbWl6YXRpb25TcGVjJyxcbiAgICAgICAgICAgICAgICAnaHlwZXJQYXJhbWV0ZXJzJyxcbiAgICAgICAgICAgICAgICAnbGVhcm5pbmdSYXRlTXVsdGlwbGllcicsXG4gICAgICAgICAgICBdLCBmcm9tTGVhcm5pbmdSYXRlTXVsdGlwbGllcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGRpc2NyaW1pbmF0b3JFeHBvcnRMYXN0Q2hlY2twb2ludE9ubHkgPSBnZXRWYWx1ZUJ5UGF0aChyb290T2JqZWN0LCBbJ2NvbmZpZycsICdtZXRob2QnXSk7XG4gICAgaWYgKGRpc2NyaW1pbmF0b3JFeHBvcnRMYXN0Q2hlY2twb2ludE9ubHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkaXNjcmltaW5hdG9yRXhwb3J0TGFzdENoZWNrcG9pbnRPbmx5ID0gJ1NVUEVSVklTRURfRklORV9UVU5JTkcnO1xuICAgIH1cbiAgICBpZiAoZGlzY3JpbWluYXRvckV4cG9ydExhc3RDaGVja3BvaW50T25seSA9PT0gJ1NVUEVSVklTRURfRklORV9UVU5JTkcnKSB7XG4gICAgICAgIGNvbnN0IGZyb21FeHBvcnRMYXN0Q2hlY2twb2ludE9ubHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICAgICAnZXhwb3J0TGFzdENoZWNrcG9pbnRPbmx5JyxcbiAgICAgICAgXSk7XG4gICAgICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRXhwb3J0TGFzdENoZWNrcG9pbnRPbmx5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzdXBlcnZpc2VkVHVuaW5nU3BlYycsICdleHBvcnRMYXN0Q2hlY2twb2ludE9ubHknXSwgZnJvbUV4cG9ydExhc3RDaGVja3BvaW50T25seSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZGlzY3JpbWluYXRvckV4cG9ydExhc3RDaGVja3BvaW50T25seSA9PT0gJ1BSRUZFUkVOQ0VfVFVOSU5HJykge1xuICAgICAgICBjb25zdCBmcm9tRXhwb3J0TGFzdENoZWNrcG9pbnRPbmx5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAgICAgJ2V4cG9ydExhc3RDaGVja3BvaW50T25seScsXG4gICAgICAgIF0pO1xuICAgICAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUV4cG9ydExhc3RDaGVja3BvaW50T25seSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncHJlZmVyZW5jZU9wdGltaXphdGlvblNwZWMnLCAnZXhwb3J0TGFzdENoZWNrcG9pbnRPbmx5J10sIGZyb21FeHBvcnRMYXN0Q2hlY2twb2ludE9ubHkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBkaXNjcmltaW5hdG9yQWRhcHRlclNpemUgPSBnZXRWYWx1ZUJ5UGF0aChyb290T2JqZWN0LCBbXG4gICAgICAgICdjb25maWcnLFxuICAgICAgICAnbWV0aG9kJyxcbiAgICBdKTtcbiAgICBpZiAoZGlzY3JpbWluYXRvckFkYXB0ZXJTaXplID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGlzY3JpbWluYXRvckFkYXB0ZXJTaXplID0gJ1NVUEVSVklTRURfRklORV9UVU5JTkcnO1xuICAgIH1cbiAgICBpZiAoZGlzY3JpbWluYXRvckFkYXB0ZXJTaXplID09PSAnU1VQRVJWSVNFRF9GSU5FX1RVTklORycpIHtcbiAgICAgICAgY29uc3QgZnJvbUFkYXB0ZXJTaXplID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhZGFwdGVyU2l6ZSddKTtcbiAgICAgICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21BZGFwdGVyU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc3VwZXJ2aXNlZFR1bmluZ1NwZWMnLCAnaHlwZXJQYXJhbWV0ZXJzJywgJ2FkYXB0ZXJTaXplJ10sIGZyb21BZGFwdGVyU2l6ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZGlzY3JpbWluYXRvckFkYXB0ZXJTaXplID09PSAnUFJFRkVSRU5DRV9UVU5JTkcnKSB7XG4gICAgICAgIGNvbnN0IGZyb21BZGFwdGVyU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYWRhcHRlclNpemUnXSk7XG4gICAgICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQWRhcHRlclNpemUgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3ByZWZlcmVuY2VPcHRpbWl6YXRpb25TcGVjJywgJ2h5cGVyUGFyYW1ldGVycycsICdhZGFwdGVyU2l6ZSddLCBmcm9tQWRhcHRlclNpemUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2JhdGNoU2l6ZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmF0Y2hTaXplIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGVhcm5pbmdSYXRlJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsZWFybmluZ1JhdGUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFiZWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYWJlbHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21MYWJlbHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnbGFiZWxzJ10sIGZyb21MYWJlbHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQmV0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmV0YSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUJldGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncHJlZmVyZW5jZU9wdGltaXphdGlvblNwZWMnLCAnaHlwZXJQYXJhbWV0ZXJzJywgJ2JldGEnXSwgZnJvbUJldGEpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVUdW5pbmdKb2JQYXJhbWV0ZXJzUHJpdmF0ZVRvTWxkZXYoZnJvbU9iamVjdCwgcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUJhc2VNb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmFzZU1vZGVsJ10pO1xuICAgIGlmIChmcm9tQmFzZU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYmFzZU1vZGVsJ10sIGZyb21CYXNlTW9kZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJlVHVuZWRNb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ByZVR1bmVkTW9kZWwnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJlVHVuZWRNb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ByZVR1bmVkTW9kZWwnXSwgZnJvbVByZVR1bmVkTW9kZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVHJhaW5pbmdEYXRhc2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndHJhaW5pbmdEYXRhc2V0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRyYWluaW5nRGF0YXNldCAhPSBudWxsKSB7XG4gICAgICAgIHR1bmluZ0RhdGFzZXRUb01sZGV2KGZyb21UcmFpbmluZ0RhdGFzZXQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBjcmVhdGVUdW5pbmdKb2JDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlVHVuaW5nSm9iUGFyYW1ldGVyc1ByaXZhdGVUb1ZlcnRleChmcm9tT2JqZWN0LCByb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQmFzZU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydiYXNlTW9kZWwnXSk7XG4gICAgaWYgKGZyb21CYXNlTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydiYXNlTW9kZWwnXSwgZnJvbUJhc2VNb2RlbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QcmVUdW5lZE1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJlVHVuZWRNb2RlbCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21QcmVUdW5lZE1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJlVHVuZWRNb2RlbCddLCBmcm9tUHJlVHVuZWRNb2RlbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UcmFpbmluZ0RhdGFzZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0cmFpbmluZ0RhdGFzZXQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVHJhaW5pbmdEYXRhc2V0ICE9IG51bGwpIHtcbiAgICAgICAgdHVuaW5nRGF0YXNldFRvVmVydGV4KGZyb21UcmFpbmluZ0RhdGFzZXQsIHRvT2JqZWN0LCByb290T2JqZWN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgY3JlYXRlVHVuaW5nSm9iQ29uZmlnVG9WZXJ0ZXgoZnJvbUNvbmZpZywgdG9PYmplY3QsIHJvb3RPYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZXRUdW5pbmdKb2JQYXJhbWV0ZXJzVG9NbGRldihmcm9tT2JqZWN0LCBfcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2V0VHVuaW5nSm9iUGFyYW1ldGVyc1RvVmVydGV4KGZyb21PYmplY3QsIF9yb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0VHVuaW5nSm9ic0NvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0LCBfcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhZ2VTaXplID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlU2l6ZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VTaXplICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlU2l6ZSddLCBmcm9tUGFnZVNpemUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlVG9rZW4nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VUb2tlbiddLCBmcm9tUGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbHRlciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsdGVyJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRmlsdGVyICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdmaWx0ZXInXSwgZnJvbUZpbHRlcik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RUdW5pbmdKb2JzQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0LCBfcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhZ2VTaXplID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlU2l6ZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VTaXplICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlU2l6ZSddLCBmcm9tUGFnZVNpemUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlVG9rZW4nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VUb2tlbiddLCBmcm9tUGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbHRlciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsdGVyJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRmlsdGVyICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdmaWx0ZXInXSwgZnJvbUZpbHRlcik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RUdW5pbmdKb2JzUGFyYW1ldGVyc1RvTWxkZXYoZnJvbU9iamVjdCwgcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgbGlzdFR1bmluZ0pvYnNDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdFR1bmluZ0pvYnNQYXJhbWV0ZXJzVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgbGlzdFR1bmluZ0pvYnNDb25maWdUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RUdW5pbmdKb2JzUmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCwgcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OZXh0UGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbmV4dFBhZ2VUb2tlbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21OZXh0UGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmV4dFBhZ2VUb2tlbiddLCBmcm9tTmV4dFBhZ2VUb2tlbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UdW5pbmdKb2JzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0dW5lZE1vZGVscyddKTtcbiAgICBpZiAoZnJvbVR1bmluZ0pvYnMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVR1bmluZ0pvYnM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHVuaW5nSm9iRnJvbU1sZGV2KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHVuaW5nSm9icyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0VHVuaW5nSm9ic1Jlc3BvbnNlRnJvbVZlcnRleChmcm9tT2JqZWN0LCByb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5leHRQYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICduZXh0UGFnZVRva2VuJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU5leHRQYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduZXh0UGFnZVRva2VuJ10sIGZyb21OZXh0UGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVR1bmluZ0pvYnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3R1bmluZ0pvYnMnXSk7XG4gICAgaWYgKGZyb21UdW5pbmdKb2JzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21UdW5pbmdKb2JzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR1bmluZ0pvYkZyb21WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0dW5pbmdKb2JzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHR1bmVkTW9kZWxGcm9tTWxkZXYoZnJvbU9iamVjdCwgX3Jvb3RPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZWwnXSwgZnJvbU1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuZHBvaW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tRW5kcG9pbnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRwb2ludCddLCBmcm9tRW5kcG9pbnQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0dW5pbmdEYXRhc2V0VG9NbGRldihmcm9tT2JqZWN0LCBfcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ2NzVXJpJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnY3NVcmkgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmVydGV4RGF0YXNldFJlc291cmNlJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd2ZXJ0ZXhEYXRhc2V0UmVzb3VyY2UgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4YW1wbGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydleGFtcGxlcyddKTtcbiAgICBpZiAoZnJvbUV4YW1wbGVzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21FeGFtcGxlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhhbXBsZXMnLCAnZXhhbXBsZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdHVuaW5nRGF0YXNldFRvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCwgcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgbGV0IGRpc2NyaW1pbmF0b3JHY3NVcmkgPSBnZXRWYWx1ZUJ5UGF0aChyb290T2JqZWN0LCBbXG4gICAgICAgICdjb25maWcnLFxuICAgICAgICAnbWV0aG9kJyxcbiAgICBdKTtcbiAgICBpZiAoZGlzY3JpbWluYXRvckdjc1VyaSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRpc2NyaW1pbmF0b3JHY3NVcmkgPSAnU1VQRVJWSVNFRF9GSU5FX1RVTklORyc7XG4gICAgfVxuICAgIGlmIChkaXNjcmltaW5hdG9yR2NzVXJpID09PSAnU1VQRVJWSVNFRF9GSU5FX1RVTklORycpIHtcbiAgICAgICAgY29uc3QgZnJvbUdjc1VyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ2NzVXJpJ10pO1xuICAgICAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUdjc1VyaSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc3VwZXJ2aXNlZFR1bmluZ1NwZWMnLCAndHJhaW5pbmdEYXRhc2V0VXJpJ10sIGZyb21HY3NVcmkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGRpc2NyaW1pbmF0b3JHY3NVcmkgPT09ICdQUkVGRVJFTkNFX1RVTklORycpIHtcbiAgICAgICAgY29uc3QgZnJvbUdjc1VyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ2NzVXJpJ10pO1xuICAgICAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUdjc1VyaSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncHJlZmVyZW5jZU9wdGltaXphdGlvblNwZWMnLCAndHJhaW5pbmdEYXRhc2V0VXJpJ10sIGZyb21HY3NVcmkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBkaXNjcmltaW5hdG9yVmVydGV4RGF0YXNldFJlc291cmNlID0gZ2V0VmFsdWVCeVBhdGgocm9vdE9iamVjdCwgW1xuICAgICAgICAnY29uZmlnJyxcbiAgICAgICAgJ21ldGhvZCcsXG4gICAgXSk7XG4gICAgaWYgKGRpc2NyaW1pbmF0b3JWZXJ0ZXhEYXRhc2V0UmVzb3VyY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkaXNjcmltaW5hdG9yVmVydGV4RGF0YXNldFJlc291cmNlID0gJ1NVUEVSVklTRURfRklORV9UVU5JTkcnO1xuICAgIH1cbiAgICBpZiAoZGlzY3JpbWluYXRvclZlcnRleERhdGFzZXRSZXNvdXJjZSA9PT0gJ1NVUEVSVklTRURfRklORV9UVU5JTkcnKSB7XG4gICAgICAgIGNvbnN0IGZyb21WZXJ0ZXhEYXRhc2V0UmVzb3VyY2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICAgICAndmVydGV4RGF0YXNldFJlc291cmNlJyxcbiAgICAgICAgXSk7XG4gICAgICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVmVydGV4RGF0YXNldFJlc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzdXBlcnZpc2VkVHVuaW5nU3BlYycsICd0cmFpbmluZ0RhdGFzZXRVcmknXSwgZnJvbVZlcnRleERhdGFzZXRSZXNvdXJjZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZGlzY3JpbWluYXRvclZlcnRleERhdGFzZXRSZXNvdXJjZSA9PT0gJ1BSRUZFUkVOQ0VfVFVOSU5HJykge1xuICAgICAgICBjb25zdCBmcm9tVmVydGV4RGF0YXNldFJlc291cmNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAgICAgJ3ZlcnRleERhdGFzZXRSZXNvdXJjZScsXG4gICAgICAgIF0pO1xuICAgICAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVZlcnRleERhdGFzZXRSZXNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncHJlZmVyZW5jZU9wdGltaXphdGlvblNwZWMnLCAndHJhaW5pbmdEYXRhc2V0VXJpJ10sIGZyb21WZXJ0ZXhEYXRhc2V0UmVzb3VyY2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2V4YW1wbGVzJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleGFtcGxlcyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHR1bmluZ0pvYkZyb21NbGRldihmcm9tT2JqZWN0LCByb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdGF0ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RhdGUnXSk7XG4gICAgaWYgKGZyb21TdGF0ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXRlJ10sIHRUdW5pbmdKb2JTdGF0dXMoZnJvbVN0YXRlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DcmVhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjcmVhdGVUaW1lJ10pO1xuICAgIGlmIChmcm9tQ3JlYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSwgZnJvbUNyZWF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RhcnRUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndHVuaW5nVGFzaycsXG4gICAgICAgICdzdGFydFRpbWUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU3RhcnRUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhcnRUaW1lJ10sIGZyb21TdGFydFRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3R1bmluZ1Rhc2snLFxuICAgICAgICAnY29tcGxldGVUaW1lJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUVuZFRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRUaW1lJ10sIGZyb21FbmRUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVwZGF0ZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VwZGF0ZVRpbWUnXSk7XG4gICAgaWYgKGZyb21VcGRhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXBkYXRlVGltZSddLCBmcm9tVXBkYXRlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzY3JpcHRpb24nXSk7XG4gICAgaWYgKGZyb21EZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10sIGZyb21EZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21CYXNlTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Jhc2VNb2RlbCddKTtcbiAgICBpZiAoZnJvbUJhc2VNb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Jhc2VNb2RlbCddLCBmcm9tQmFzZU1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVR1bmVkTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ19zZWxmJ10pO1xuICAgIGlmIChmcm9tVHVuZWRNb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3R1bmVkTW9kZWwnXSwgdHVuZWRNb2RlbEZyb21NbGRldihmcm9tVHVuZWRNb2RlbCkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0dW5pbmdKb2JGcm9tVmVydGV4KGZyb21PYmplY3QsIF9yb290T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdGF0ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RhdGUnXSk7XG4gICAgaWYgKGZyb21TdGF0ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXRlJ10sIHRUdW5pbmdKb2JTdGF0dXMoZnJvbVN0YXRlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DcmVhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjcmVhdGVUaW1lJ10pO1xuICAgIGlmIChmcm9tQ3JlYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSwgZnJvbUNyZWF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RhcnRUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdGFydFRpbWUnXSk7XG4gICAgaWYgKGZyb21TdGFydFRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGFydFRpbWUnXSwgZnJvbVN0YXJ0VGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmRUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmRUaW1lJ10pO1xuICAgIGlmIChmcm9tRW5kVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuZFRpbWUnXSwgZnJvbUVuZFRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXBkYXRlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXBkYXRlVGltZSddKTtcbiAgICBpZiAoZnJvbVVwZGF0ZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cGRhdGVUaW1lJ10sIGZyb21VcGRhdGVUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVycm9yID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlcnJvciddKTtcbiAgICBpZiAoZnJvbUVycm9yICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXJyb3InXSwgZnJvbUVycm9yKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXNjcmlwdGlvbiddKTtcbiAgICBpZiAoZnJvbURlc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVzY3JpcHRpb24nXSwgZnJvbURlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUJhc2VNb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmFzZU1vZGVsJ10pO1xuICAgIGlmIChmcm9tQmFzZU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYmFzZU1vZGVsJ10sIGZyb21CYXNlTW9kZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVHVuZWRNb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndHVuZWRNb2RlbCddKTtcbiAgICBpZiAoZnJvbVR1bmVkTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0dW5lZE1vZGVsJ10sIGZyb21UdW5lZE1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByZVR1bmVkTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVUdW5lZE1vZGVsJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByZVR1bmVkTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcmVUdW5lZE1vZGVsJ10sIGZyb21QcmVUdW5lZE1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN1cGVydmlzZWRUdW5pbmdTcGVjID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3VwZXJ2aXNlZFR1bmluZ1NwZWMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU3VwZXJ2aXNlZFR1bmluZ1NwZWMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdXBlcnZpc2VkVHVuaW5nU3BlYyddLCBmcm9tU3VwZXJ2aXNlZFR1bmluZ1NwZWMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJlZmVyZW5jZU9wdGltaXphdGlvblNwZWMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVmZXJlbmNlT3B0aW1pemF0aW9uU3BlYycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21QcmVmZXJlbmNlT3B0aW1pemF0aW9uU3BlYyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ByZWZlcmVuY2VPcHRpbWl6YXRpb25TcGVjJ10sIGZyb21QcmVmZXJlbmNlT3B0aW1pemF0aW9uU3BlYyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UdW5pbmdEYXRhU3RhdHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0dW5pbmdEYXRhU3RhdHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVHVuaW5nRGF0YVN0YXRzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHVuaW5nRGF0YVN0YXRzJ10sIGZyb21UdW5pbmdEYXRhU3RhdHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5jcnlwdGlvblNwZWMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbmNyeXB0aW9uU3BlYycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FbmNyeXB0aW9uU3BlYyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuY3J5cHRpb25TcGVjJ10sIGZyb21FbmNyeXB0aW9uU3BlYyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYXJ0bmVyTW9kZWxUdW5pbmdTcGVjID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncGFydG5lck1vZGVsVHVuaW5nU3BlYycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21QYXJ0bmVyTW9kZWxUdW5pbmdTcGVjICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFydG5lck1vZGVsVHVuaW5nU3BlYyddLCBmcm9tUGFydG5lck1vZGVsVHVuaW5nU3BlYyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DdXN0b21CYXNlTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjdXN0b21CYXNlTW9kZWwnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ3VzdG9tQmFzZU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY3VzdG9tQmFzZU1vZGVsJ10sIGZyb21DdXN0b21CYXNlTW9kZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhwZXJpbWVudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhwZXJpbWVudCddKTtcbiAgICBpZiAoZnJvbUV4cGVyaW1lbnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleHBlcmltZW50J10sIGZyb21FeHBlcmltZW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxhYmVscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFiZWxzJ10pO1xuICAgIGlmIChmcm9tTGFiZWxzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbGFiZWxzJ10sIGZyb21MYWJlbHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0VXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydvdXRwdXRVcmknXSk7XG4gICAgaWYgKGZyb21PdXRwdXRVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydvdXRwdXRVcmknXSwgZnJvbU91dHB1dFVyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QaXBlbGluZUpvYiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGlwZWxpbmVKb2InXSk7XG4gICAgaWYgKGZyb21QaXBlbGluZUpvYiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BpcGVsaW5lSm9iJ10sIGZyb21QaXBlbGluZUpvYik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZXJ2aWNlQWNjb3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NlcnZpY2VBY2NvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNlcnZpY2VBY2NvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2VydmljZUFjY291bnQnXSwgZnJvbVNlcnZpY2VBY2NvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVR1bmVkTW9kZWxEaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3R1bmVkTW9kZWxEaXNwbGF5TmFtZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UdW5lZE1vZGVsRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0dW5lZE1vZGVsRGlzcGxheU5hbWUnXSwgZnJvbVR1bmVkTW9kZWxEaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21WZW9UdW5pbmdTcGVjID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndmVvVHVuaW5nU3BlYycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21WZW9UdW5pbmdTcGVjICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmVvVHVuaW5nU3BlYyddLCBmcm9tVmVvVHVuaW5nU3BlYyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHR1bmluZ09wZXJhdGlvbkZyb21NbGRldihmcm9tT2JqZWN0LCBfcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21ldGFkYXRhJ10pO1xuICAgIGlmIChmcm9tTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZXRhZGF0YSddLCBmcm9tTWV0YWRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRG9uZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZG9uZSddKTtcbiAgICBpZiAoZnJvbURvbmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkb25lJ10sIGZyb21Eb25lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVycm9yID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlcnJvciddKTtcbiAgICBpZiAoZnJvbUVycm9yICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXJyb3InXSwgZnJvbUVycm9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdHVuaW5nVmFsaWRhdGlvbkRhdGFzZXRUb1ZlcnRleChmcm9tT2JqZWN0LCBfcm9vdE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUdjc1VyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ2NzVXJpJ10pO1xuICAgIGlmIChmcm9tR2NzVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmFsaWRhdGlvbkRhdGFzZXRVcmknXSwgZnJvbUdjc1VyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21WZXJ0ZXhEYXRhc2V0UmVzb3VyY2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd2ZXJ0ZXhEYXRhc2V0UmVzb3VyY2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVmVydGV4RGF0YXNldFJlc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmFsaWRhdGlvbkRhdGFzZXRVcmknXSwgZnJvbVZlcnRleERhdGFzZXRSZXNvdXJjZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY2xhc3MgVHVuaW5ncyBleHRlbmRzIEJhc2VNb2R1bGUge1xuICAgIGNvbnN0cnVjdG9yKGFwaUNsaWVudCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IGFwaUNsaWVudDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgYSBUdW5pbmdKb2IuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBuYW1lIC0gVGhlIHJlc291cmNlIG5hbWUgb2YgdGhlIHR1bmluZyBqb2IuXG4gICAgICAgICAqIEByZXR1cm4gLSBBIFR1bmluZ0pvYiBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleHBlcmltZW50YWwgLSBUaGUgU0RLJ3MgdHVuaW5nIGltcGxlbWVudGF0aW9uIGlzIGV4cGVyaW1lbnRhbCwgYW5kIG1heVxuICAgICAgICAgKiBjaGFuZ2UgaW4gZnV0dXJlIHZlcnNpb25zLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXQgPSBhc3luYyAocGFyYW1zKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRJbnRlcm5hbChwYXJhbXMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdHMgdHVuaW5nIGpvYnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBjb25maWcgLSBUaGUgY29uZmlndXJhdGlvbiBmb3IgdGhlIGxpc3QgcmVxdWVzdC5cbiAgICAgICAgICogQHJldHVybiAtIEEgbGlzdCBvZiB0dW5pbmcgam9icy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4cGVyaW1lbnRhbCAtIFRoZSBTREsncyB0dW5pbmcgaW1wbGVtZW50YXRpb24gaXMgZXhwZXJpbWVudGFsLCBhbmQgbWF5XG4gICAgICAgICAqIGNoYW5nZSBpbiBmdXR1cmUgdmVyc2lvbnMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxpc3QgPSBhc3luYyAocGFyYW1zID0ge30pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGFnZXIoUGFnZWRJdGVtLlBBR0VEX0lURU1fVFVOSU5HX0pPQlMsICh4KSA9PiB0aGlzLmxpc3RJbnRlcm5hbCh4KSwgYXdhaXQgdGhpcy5saXN0SW50ZXJuYWwocGFyYW1zKSwgcGFyYW1zKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBzdXBlcnZpc2VkIGZpbmUtdHVuaW5nIGpvYi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgdHVuaW5nIGpvYi5cbiAgICAgICAgICogQHJldHVybiAtIEEgVHVuaW5nSm9iIG9wZXJhdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4cGVyaW1lbnRhbCAtIFRoZSBTREsncyB0dW5pbmcgaW1wbGVtZW50YXRpb24gaXMgZXhwZXJpbWVudGFsLCBhbmQgbWF5XG4gICAgICAgICAqIGNoYW5nZSBpbiBmdXR1cmUgdmVyc2lvbnMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnR1bmUgPSBhc3luYyAocGFyYW1zKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5iYXNlTW9kZWwuc3RhcnRzV2l0aCgncHJvamVjdHMvJykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJlVHVuZWRNb2RlbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR1bmVkTW9kZWxOYW1lOiBwYXJhbXMuYmFzZU1vZGVsLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnByZVR1bmVkTW9kZWxDaGVja3BvaW50SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZVR1bmVkTW9kZWwuY2hlY2twb2ludElkID0gcGFyYW1zLmNvbmZpZy5wcmVUdW5lZE1vZGVsQ2hlY2twb2ludElkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtc1ByaXZhdGUgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcyksIHsgcHJlVHVuZWRNb2RlbDogcHJlVHVuZWRNb2RlbCB9KTtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zUHJpdmF0ZS5iYXNlTW9kZWwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnR1bmVJbnRlcm5hbChwYXJhbXNQcml2YXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtc1ByaXZhdGUgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50dW5lSW50ZXJuYWwocGFyYW1zUHJpdmF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyYW1zUHJpdmF0ZSA9IE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3BlcmF0aW9uID0gYXdhaXQgdGhpcy50dW5lTWxkZXZJbnRlcm5hbChwYXJhbXNQcml2YXRlKTtcbiAgICAgICAgICAgICAgICBsZXQgdHVuZWRNb2RlbE5hbWUgPSAnJztcbiAgICAgICAgICAgICAgICBpZiAob3BlcmF0aW9uWydtZXRhZGF0YSddICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uWydtZXRhZGF0YSddWyd0dW5lZE1vZGVsJ10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0dW5lZE1vZGVsTmFtZSA9IG9wZXJhdGlvblsnbWV0YWRhdGEnXVsndHVuZWRNb2RlbCddO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvcGVyYXRpb25bJ25hbWUnXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvblsnbmFtZSddLmluY2x1ZGVzKCcvb3BlcmF0aW9ucy8nKSkge1xuICAgICAgICAgICAgICAgICAgICB0dW5lZE1vZGVsTmFtZSA9IG9wZXJhdGlvblsnbmFtZSddLnNwbGl0KCcvb3BlcmF0aW9ucy8nKVswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdHVuaW5nSm9iID0ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiB0dW5lZE1vZGVsTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGU6IEpvYlN0YXRlLkpPQl9TVEFURV9RVUVVRUQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHVuaW5nSm9iO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBnZXRJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2V0VHVuaW5nSm9iUGFyYW1ldGVyc1RvVmVydGV4KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IHR1bmluZ0pvYkZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2V0VHVuaW5nSm9iUGFyYW1ldGVyc1RvTWxkZXYocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gdHVuaW5nSm9iRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGxpc3RJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gbGlzdFR1bmluZ0pvYnNQYXJhbWV0ZXJzVG9WZXJ0ZXgocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3R1bmluZ0pvYnMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGxpc3RUdW5pbmdKb2JzUmVzcG9uc2VGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgTGlzdFR1bmluZ0pvYnNSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gbGlzdFR1bmluZ0pvYnNQYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgndHVuZWRNb2RlbHMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGxpc3RUdW5pbmdKb2JzUmVzcG9uc2VGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBMaXN0VHVuaW5nSm9ic1Jlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYW5jZWxzIGEgdHVuaW5nIGpvYi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIGNhbmNlbCByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4gVGhlIGVtcHR5IHJlc3BvbnNlIHJldHVybmVkIGJ5IHRoZSBBUEkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogYXdhaXQgYWkudHVuaW5ncy5jYW5jZWwoe25hbWU6ICcuLi4nfSk7IC8vIFRoZSBzZXJ2ZXItZ2VuZXJhdGVkIHJlc291cmNlIG5hbWUuXG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgY2FuY2VsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gY2FuY2VsVHVuaW5nSm9iUGFyYW1ldGVyc1RvVmVydGV4KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX06Y2FuY2VsJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5hcGlDbGllbnQucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGNhbmNlbFR1bmluZ0pvYlBhcmFtZXRlcnNUb01sZGV2KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX06Y2FuY2VsJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5hcGlDbGllbnQucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHR1bmVJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGNyZWF0ZVR1bmluZ0pvYlBhcmFtZXRlcnNQcml2YXRlVG9WZXJ0ZXgocGFyYW1zLCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgndHVuaW5nSm9icycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IHR1bmluZ0pvYkZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBWZXJ0ZXggQUkuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgdHVuZU1sZGV2SW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIEdlbWluaSBEZXZlbG9wZXIgQVBJLicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGNyZWF0ZVR1bmluZ0pvYlBhcmFtZXRlcnNQcml2YXRlVG9NbGRldihwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgndHVuZWRNb2RlbHMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSB0dW5pbmdPcGVyYXRpb25Gcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNvbnN0IE1BWF9DSFVOS19TSVpFID0gMTAyNCAqIDEwMjQgKiA4OyAvLyBieXRlc1xuY29uc3QgTUFYX1JFVFJZX0NPVU5UID0gMztcbmNvbnN0IElOSVRJQUxfUkVUUllfREVMQVlfTVMgPSAxMDAwO1xuY29uc3QgREVMQVlfTVVMVElQTElFUiA9IDI7XG5jb25zdCBYX0dPT0dfVVBMT0FEX1NUQVRVU19IRUFERVJfRklFTEQgPSAneC1nb29nLXVwbG9hZC1zdGF0dXMnO1xuYXN5bmMgZnVuY3Rpb24gdXBsb2FkQmxvYihmaWxlLCB1cGxvYWRVcmwsIGFwaUNsaWVudCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHVwbG9hZEJsb2JJbnRlcm5hbChmaWxlLCB1cGxvYWRVcmwsIGFwaUNsaWVudCk7XG4gICAgY29uc3QgcmVzcG9uc2VKc29uID0gKGF3YWl0IChyZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UuanNvbigpKSk7XG4gICAgaWYgKCgoX2EgPSByZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UuaGVhZGVycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW1hfR09PR19VUExPQURfU1RBVFVTX0hFQURFUl9GSUVMRF0pICE9PSAnZmluYWwnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHVwbG9hZCBmaWxlOiBVcGxvYWQgc3RhdHVzIGlzIG5vdCBmaW5hbGl6ZWQuJyk7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZUpzb25bJ2ZpbGUnXTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHVwbG9hZEJsb2JUb0ZpbGVTZWFyY2hTdG9yZShmaWxlLCB1cGxvYWRVcmwsIGFwaUNsaWVudCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHVwbG9hZEJsb2JJbnRlcm5hbChmaWxlLCB1cGxvYWRVcmwsIGFwaUNsaWVudCk7XG4gICAgY29uc3QgcmVzcG9uc2VKc29uID0gKGF3YWl0IChyZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UuanNvbigpKSk7XG4gICAgaWYgKCgoX2EgPSByZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UuaGVhZGVycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW1hfR09PR19VUExPQURfU1RBVFVTX0hFQURFUl9GSUVMRF0pICE9PSAnZmluYWwnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHVwbG9hZCBmaWxlOiBVcGxvYWQgc3RhdHVzIGlzIG5vdCBmaW5hbGl6ZWQuJyk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3AgPSB1cGxvYWRUb0ZpbGVTZWFyY2hTdG9yZU9wZXJhdGlvbkZyb21NbGRldihyZXNwb25zZUpzb24pO1xuICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBVcGxvYWRUb0ZpbGVTZWFyY2hTdG9yZU9wZXJhdGlvbigpO1xuICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICByZXR1cm4gdHlwZWRSZXNwO1xufVxuYXN5bmMgZnVuY3Rpb24gdXBsb2FkQmxvYkludGVybmFsKGZpbGUsIHVwbG9hZFVybCwgYXBpQ2xpZW50KSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBsZXQgZmlsZVNpemUgPSAwO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGxldCByZXNwb25zZSA9IG5ldyBIdHRwUmVzcG9uc2UobmV3IFJlc3BvbnNlKCkpO1xuICAgIGxldCB1cGxvYWRDb21tYW5kID0gJ3VwbG9hZCc7XG4gICAgZmlsZVNpemUgPSBmaWxlLnNpemU7XG4gICAgd2hpbGUgKG9mZnNldCA8IGZpbGVTaXplKSB7XG4gICAgICAgIGNvbnN0IGNodW5rU2l6ZSA9IE1hdGgubWluKE1BWF9DSFVOS19TSVpFLCBmaWxlU2l6ZSAtIG9mZnNldCk7XG4gICAgICAgIGNvbnN0IGNodW5rID0gZmlsZS5zbGljZShvZmZzZXQsIG9mZnNldCArIGNodW5rU2l6ZSk7XG4gICAgICAgIGlmIChvZmZzZXQgKyBjaHVua1NpemUgPj0gZmlsZVNpemUpIHtcbiAgICAgICAgICAgIHVwbG9hZENvbW1hbmQgKz0gJywgZmluYWxpemUnO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXRyeUNvdW50ID0gMDtcbiAgICAgICAgbGV0IGN1cnJlbnREZWxheU1zID0gSU5JVElBTF9SRVRSWV9ERUxBWV9NUztcbiAgICAgICAgd2hpbGUgKHJldHJ5Q291bnQgPCBNQVhfUkVUUllfQ09VTlQpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6ICcnLFxuICAgICAgICAgICAgICAgIGJvZHk6IGNodW5rLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICBhcGlWZXJzaW9uOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgYmFzZVVybDogdXBsb2FkVXJsLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnWC1Hb29nLVVwbG9hZC1Db21tYW5kJzogdXBsb2FkQ29tbWFuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdYLUdvb2ctVXBsb2FkLU9mZnNldCc6IFN0cmluZyhvZmZzZXQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0NvbnRlbnQtTGVuZ3RoJzogU3RyaW5nKGNodW5rU2l6ZSksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKChfYSA9IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5oZWFkZXJzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbWF9HT09HX1VQTE9BRF9TVEFUVVNfSEVBREVSX0ZJRUxEXSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0cnlDb3VudCsrO1xuICAgICAgICAgICAgYXdhaXQgc2xlZXAoY3VycmVudERlbGF5TXMpO1xuICAgICAgICAgICAgY3VycmVudERlbGF5TXMgPSBjdXJyZW50RGVsYXlNcyAqIERFTEFZX01VTFRJUExJRVI7XG4gICAgICAgIH1cbiAgICAgICAgb2Zmc2V0ICs9IGNodW5rU2l6ZTtcbiAgICAgICAgLy8gVGhlIGB4LWdvb2ctdXBsb2FkLXN0YXR1c2AgaGVhZGVyIGZpZWxkIGNhbiBiZSBgYWN0aXZlYCwgYGZpbmFsYCBhbmRcbiAgICAgICAgLy9gY2FuY2VsbGVkYCBpbiByZXNwb3NuZS5cbiAgICAgICAgaWYgKCgoX2IgPSByZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UuaGVhZGVycykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW1hfR09PR19VUExPQURfU1RBVFVTX0hFQURFUl9GSUVMRF0pICE9PSAnYWN0aXZlJykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETyhiLzQwMTM5MTQzMCkgSW52ZXN0aWdhdGUgd2h5IHRoZSB1cGxvYWQgc3RhdHVzIGlzIG5vdCBmaW5hbGl6ZWRcbiAgICAgICAgLy8gZXZlbiB0aG91Z2ggYWxsIGNvbnRlbnQgaGFzIGJlZW4gdXBsb2FkZWQuXG4gICAgICAgIGlmIChmaWxlU2l6ZSA8PSBvZmZzZXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQWxsIGNvbnRlbnQgaGFzIGJlZW4gdXBsb2FkZWQsIGJ1dCB0aGUgdXBsb2FkIHN0YXR1cyBpcyBub3QgZmluYWxpemVkLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldEJsb2JTdGF0KGZpbGUpIHtcbiAgICBjb25zdCBmaWxlU3RhdCA9IHsgc2l6ZTogZmlsZS5zaXplLCB0eXBlOiBmaWxlLnR5cGUgfTtcbiAgICByZXR1cm4gZmlsZVN0YXQ7XG59XG5mdW5jdGlvbiBzbGVlcChtcykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZVByb21pc2UpID0+IHNldFRpbWVvdXQocmVzb2x2ZVByb21pc2UsIG1zKSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmNsYXNzIE5vZGVVcGxvYWRlciB7XG4gICAgYXN5bmMgc3RhdChmaWxlKSB7XG4gICAgICAgIGNvbnN0IGZpbGVTdGF0ID0geyBzaXplOiAwLCB0eXBlOiB1bmRlZmluZWQgfTtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWxlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxTdGF0ID0gYXdhaXQgZnMuc3RhdChmaWxlKTtcbiAgICAgICAgICAgIGZpbGVTdGF0LnNpemUgPSBvcmlnaW5hbFN0YXQuc2l6ZTtcbiAgICAgICAgICAgIGZpbGVTdGF0LnR5cGUgPSB0aGlzLmluZmVyTWltZVR5cGUoZmlsZSk7XG4gICAgICAgICAgICByZXR1cm4gZmlsZVN0YXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgZ2V0QmxvYlN0YXQoZmlsZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgdXBsb2FkKGZpbGUsIHVwbG9hZFVybCwgYXBpQ2xpZW50KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZmlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnVwbG9hZEZpbGVGcm9tUGF0aChmaWxlLCB1cGxvYWRVcmwsIGFwaUNsaWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdXBsb2FkQmxvYihmaWxlLCB1cGxvYWRVcmwsIGFwaUNsaWVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgdXBsb2FkVG9GaWxlU2VhcmNoU3RvcmUoZmlsZSwgdXBsb2FkVXJsLCBhcGlDbGllbnQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWxlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudXBsb2FkRmlsZVRvRmlsZVNlYXJjaFN0b3JlRnJvbVBhdGgoZmlsZSwgdXBsb2FkVXJsLCBhcGlDbGllbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHVwbG9hZEJsb2JUb0ZpbGVTZWFyY2hTdG9yZShmaWxlLCB1cGxvYWRVcmwsIGFwaUNsaWVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5mZXJzIHRoZSBNSU1FIHR5cGUgb2YgYSBmaWxlIGJhc2VkIG9uIGl0cyBleHRlbnNpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmlsZVBhdGggVGhlIHBhdGggdG8gdGhlIGZpbGUuXG4gICAgICogQHJldHVybnMgVGhlIE1JTUUgdHlwZSBvZiB0aGUgZmlsZSwgb3IgdW5kZWZpbmVkIGlmIGl0IGNhbm5vdCBiZSBpbmZlcnJlZC5cbiAgICAgKi9cbiAgICBpbmZlck1pbWVUeXBlKGZpbGVQYXRoKSB7XG4gICAgICAgIC8vIEdldCB0aGUgZmlsZSBleHRlbnNpb24uXG4gICAgICAgIGNvbnN0IGZpbGVFeHRlbnNpb24gPSBmaWxlUGF0aC5zbGljZShmaWxlUGF0aC5sYXN0SW5kZXhPZignLicpICsgMSk7XG4gICAgICAgIC8vIENyZWF0ZSBhIG1hcCBvZiBmaWxlIGV4dGVuc2lvbnMgdG8gTUlNRSB0eXBlcy5cbiAgICAgICAgY29uc3QgbWltZVR5cGVzID0ge1xuICAgICAgICAgICAgJ2FhYyc6ICdhdWRpby9hYWMnLFxuICAgICAgICAgICAgJ2Fidyc6ICdhcHBsaWNhdGlvbi94LWFiaXdvcmQnLFxuICAgICAgICAgICAgJ2FyYyc6ICdhcHBsaWNhdGlvbi94LWZyZWVhcmMnLFxuICAgICAgICAgICAgJ2F2aSc6ICd2aWRlby94LW1zdmlkZW8nLFxuICAgICAgICAgICAgJ2F6dyc6ICdhcHBsaWNhdGlvbi92bmQuYW1hem9uLmVib29rJyxcbiAgICAgICAgICAgICdiaW4nOiAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyxcbiAgICAgICAgICAgICdibXAnOiAnaW1hZ2UvYm1wJyxcbiAgICAgICAgICAgICdieic6ICdhcHBsaWNhdGlvbi94LWJ6aXAnLFxuICAgICAgICAgICAgJ2J6Mic6ICdhcHBsaWNhdGlvbi94LWJ6aXAyJyxcbiAgICAgICAgICAgICdjc2gnOiAnYXBwbGljYXRpb24veC1jc2gnLFxuICAgICAgICAgICAgJ2Nzcyc6ICd0ZXh0L2NzcycsXG4gICAgICAgICAgICAnY3N2JzogJ3RleHQvY3N2JyxcbiAgICAgICAgICAgICdkb2MnOiAnYXBwbGljYXRpb24vbXN3b3JkJyxcbiAgICAgICAgICAgICdkb2N4JzogJ2FwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLmRvY3VtZW50JyxcbiAgICAgICAgICAgICdlb3QnOiAnYXBwbGljYXRpb24vdm5kLm1zLWZvbnRvYmplY3QnLFxuICAgICAgICAgICAgJ2VwdWInOiAnYXBwbGljYXRpb24vZXB1Yit6aXAnLFxuICAgICAgICAgICAgJ2d6JzogJ2FwcGxpY2F0aW9uL2d6aXAnLFxuICAgICAgICAgICAgJ2dpZic6ICdpbWFnZS9naWYnLFxuICAgICAgICAgICAgJ2h0bSc6ICd0ZXh0L2h0bWwnLFxuICAgICAgICAgICAgJ2h0bWwnOiAndGV4dC9odG1sJyxcbiAgICAgICAgICAgICdpY28nOiAnaW1hZ2Uvdm5kLm1pY3Jvc29mdC5pY29uJyxcbiAgICAgICAgICAgICdpY3MnOiAndGV4dC9jYWxlbmRhcicsXG4gICAgICAgICAgICAnamFyJzogJ2FwcGxpY2F0aW9uL2phdmEtYXJjaGl2ZScsXG4gICAgICAgICAgICAnanBlZyc6ICdpbWFnZS9qcGVnJyxcbiAgICAgICAgICAgICdqcGcnOiAnaW1hZ2UvanBlZycsXG4gICAgICAgICAgICAnanMnOiAndGV4dC9qYXZhc2NyaXB0JyxcbiAgICAgICAgICAgICdqc29uJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgJ2pzb25sZCc6ICdhcHBsaWNhdGlvbi9sZCtqc29uJyxcbiAgICAgICAgICAgICdrbWwnOiAnYXBwbGljYXRpb24vdm5kLmdvb2dsZS1lYXJ0aC5rbWwreG1sJyxcbiAgICAgICAgICAgICdrbXonOiAnYXBwbGljYXRpb24vdm5kLmdvb2dsZS1lYXJ0aC5rbXoreG1sJyxcbiAgICAgICAgICAgICdtanMnOiAndGV4dC9qYXZhc2NyaXB0JyxcbiAgICAgICAgICAgICdtcDMnOiAnYXVkaW8vbXBlZycsXG4gICAgICAgICAgICAnbXA0JzogJ3ZpZGVvL21wNCcsXG4gICAgICAgICAgICAnbXBlZyc6ICd2aWRlby9tcGVnJyxcbiAgICAgICAgICAgICdtcGtnJzogJ2FwcGxpY2F0aW9uL3ZuZC5hcHBsZS5pbnN0YWxsZXIreG1sJyxcbiAgICAgICAgICAgICdvZHQnOiAnYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC50ZXh0JyxcbiAgICAgICAgICAgICdvZ2EnOiAnYXVkaW8vb2dnJyxcbiAgICAgICAgICAgICdvZ3YnOiAndmlkZW8vb2dnJyxcbiAgICAgICAgICAgICdvZ3gnOiAnYXBwbGljYXRpb24vb2dnJyxcbiAgICAgICAgICAgICdvcHVzJzogJ2F1ZGlvL29wdXMnLFxuICAgICAgICAgICAgJ290Zic6ICdmb250L290ZicsXG4gICAgICAgICAgICAncG5nJzogJ2ltYWdlL3BuZycsXG4gICAgICAgICAgICAncGRmJzogJ2FwcGxpY2F0aW9uL3BkZicsXG4gICAgICAgICAgICAncGhwJzogJ2FwcGxpY2F0aW9uL3gtaHR0cGQtcGhwJyxcbiAgICAgICAgICAgICdwcHQnOiAnYXBwbGljYXRpb24vdm5kLm1zLXBvd2VycG9pbnQnLFxuICAgICAgICAgICAgJ3BwdHgnOiAnYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnByZXNlbnRhdGlvbm1sLnByZXNlbnRhdGlvbicsXG4gICAgICAgICAgICAncmFyJzogJ2FwcGxpY2F0aW9uL3ZuZC5yYXInLFxuICAgICAgICAgICAgJ3J0Zic6ICdhcHBsaWNhdGlvbi9ydGYnLFxuICAgICAgICAgICAgJ3NoJzogJ2FwcGxpY2F0aW9uL3gtc2gnLFxuICAgICAgICAgICAgJ3N2Zyc6ICdpbWFnZS9zdmcreG1sJyxcbiAgICAgICAgICAgICdzd2YnOiAnYXBwbGljYXRpb24veC1zaG9ja3dhdmUtZmxhc2gnLFxuICAgICAgICAgICAgJ3Rhcic6ICdhcHBsaWNhdGlvbi94LXRhcicsXG4gICAgICAgICAgICAndGlmJzogJ2ltYWdlL3RpZmYnLFxuICAgICAgICAgICAgJ3RpZmYnOiAnaW1hZ2UvdGlmZicsXG4gICAgICAgICAgICAndHMnOiAndmlkZW8vbXAydCcsXG4gICAgICAgICAgICAndHRmJzogJ2ZvbnQvdHRmJyxcbiAgICAgICAgICAgICd0eHQnOiAndGV4dC9wbGFpbicsXG4gICAgICAgICAgICAndnNkJzogJ2FwcGxpY2F0aW9uL3ZuZC52aXNpbycsXG4gICAgICAgICAgICAnd2F2JzogJ2F1ZGlvL3dhdicsXG4gICAgICAgICAgICAnd2ViYSc6ICdhdWRpby93ZWJtJyxcbiAgICAgICAgICAgICd3ZWJtJzogJ3ZpZGVvL3dlYm0nLFxuICAgICAgICAgICAgJ3dlYnAnOiAnaW1hZ2Uvd2VicCcsXG4gICAgICAgICAgICAnd29mZic6ICdmb250L3dvZmYnLFxuICAgICAgICAgICAgJ3dvZmYyJzogJ2ZvbnQvd29mZjInLFxuICAgICAgICAgICAgJ3hodG1sJzogJ2FwcGxpY2F0aW9uL3hodG1sK3htbCcsXG4gICAgICAgICAgICAneGxzJzogJ2FwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbCcsXG4gICAgICAgICAgICAneGxzeCc6ICdhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuc3ByZWFkc2hlZXRtbC5zaGVldCcsXG4gICAgICAgICAgICAneG1sJzogJ2FwcGxpY2F0aW9uL3htbCcsXG4gICAgICAgICAgICAneHVsJzogJ2FwcGxpY2F0aW9uL3ZuZC5tb3ppbGxhLnh1bCt4bWwnLFxuICAgICAgICAgICAgJ3ppcCc6ICdhcHBsaWNhdGlvbi96aXAnLFxuICAgICAgICAgICAgJzNncCc6ICd2aWRlby8zZ3BwJyxcbiAgICAgICAgICAgICczZzInOiAndmlkZW8vM2dwcDInLFxuICAgICAgICAgICAgJzd6JzogJ2FwcGxpY2F0aW9uL3gtN3otY29tcHJlc3NlZCcsXG4gICAgICAgIH07XG4gICAgICAgIC8vIExvb2sgdXAgdGhlIE1JTUUgdHlwZSBiYXNlZCBvbiB0aGUgZmlsZSBleHRlbnNpb24uXG4gICAgICAgIGNvbnN0IG1pbWVUeXBlID0gbWltZVR5cGVzW2ZpbGVFeHRlbnNpb24udG9Mb3dlckNhc2UoKV07XG4gICAgICAgIC8vIFJldHVybiB0aGUgTUlNRSB0eXBlLlxuICAgICAgICByZXR1cm4gbWltZVR5cGU7XG4gICAgfVxuICAgIGFzeW5jIHVwbG9hZEZpbGVGcm9tUGF0aChmaWxlLCB1cGxvYWRVcmwsIGFwaUNsaWVudCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy51cGxvYWRGaWxlRnJvbVBhdGhJbnRlcm5hbChmaWxlLCB1cGxvYWRVcmwsIGFwaUNsaWVudCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlSnNvbiA9IChhd2FpdCAocmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLmpzb24oKSkpO1xuICAgICAgICBpZiAoKChfYSA9IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5oZWFkZXJzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbWF9HT09HX1VQTE9BRF9TVEFUVVNfSEVBREVSX0ZJRUxEXSkgIT09ICdmaW5hbCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHVwbG9hZCBmaWxlOiBVcGxvYWQgc3RhdHVzIGlzIG5vdCBmaW5hbGl6ZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlSnNvblsnZmlsZSddO1xuICAgIH1cbiAgICBhc3luYyB1cGxvYWRGaWxlVG9GaWxlU2VhcmNoU3RvcmVGcm9tUGF0aChmaWxlLCB1cGxvYWRVcmwsIGFwaUNsaWVudCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy51cGxvYWRGaWxlRnJvbVBhdGhJbnRlcm5hbChmaWxlLCB1cGxvYWRVcmwsIGFwaUNsaWVudCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlSnNvbiA9IChhd2FpdCAocmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLmpzb24oKSkpO1xuICAgICAgICBpZiAoKChfYSA9IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5oZWFkZXJzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbWF9HT09HX1VQTE9BRF9TVEFUVVNfSEVBREVSX0ZJRUxEXSkgIT09ICdmaW5hbCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHVwbG9hZCBmaWxlOiBVcGxvYWQgc3RhdHVzIGlzIG5vdCBmaW5hbGl6ZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcCA9IHVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlT3BlcmF0aW9uRnJvbU1sZGV2KHJlc3BvbnNlSnNvbik7XG4gICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBVcGxvYWRUb0ZpbGVTZWFyY2hTdG9yZU9wZXJhdGlvbigpO1xuICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgfVxuICAgIGFzeW5jIHVwbG9hZEZpbGVGcm9tUGF0aEludGVybmFsKGZpbGUsIHVwbG9hZFVybCwgYXBpQ2xpZW50KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCBmaWxlU2l6ZSA9IDA7XG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBuZXcgSHR0cFJlc3BvbnNlKG5ldyBSZXNwb25zZSgpKTtcbiAgICAgICAgbGV0IHVwbG9hZENvbW1hbmQgPSAndXBsb2FkJztcbiAgICAgICAgbGV0IGZpbGVIYW5kbGU7XG4gICAgICAgIGNvbnN0IGZpbGVOYW1lID0gcGF0aC5iYXNlbmFtZShmaWxlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZpbGVIYW5kbGUgPSBhd2FpdCBmcy5vcGVuKGZpbGUsICdyJyk7XG4gICAgICAgICAgICBpZiAoIWZpbGVIYW5kbGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBvcGVuIGZpbGVgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbGVTaXplID0gKGF3YWl0IGZpbGVIYW5kbGUuc3RhdCgpKS5zaXplO1xuICAgICAgICAgICAgd2hpbGUgKG9mZnNldCA8IGZpbGVTaXplKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2h1bmtTaXplID0gTWF0aC5taW4oTUFYX0NIVU5LX1NJWkUsIGZpbGVTaXplIC0gb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0ICsgY2h1bmtTaXplID49IGZpbGVTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwbG9hZENvbW1hbmQgKz0gJywgZmluYWxpemUnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBidWZmZXIgPSBuZXcgVWludDhBcnJheShjaHVua1NpemUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgYnl0ZXNSZWFkOiBieXRlc1JlYWQgfSA9IGF3YWl0IGZpbGVIYW5kbGUucmVhZChidWZmZXIsIDAsIGNodW5rU2l6ZSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBpZiAoYnl0ZXNSZWFkICE9PSBjaHVua1NpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcmVhZCAke2NodW5rU2l6ZX0gYnl0ZXMgZnJvbSBmaWxlIGF0IG9mZnNldCAke29mZnNldH0uIGJ5dGVzIGFjdHVhbGx5IHJlYWQ6ICR7Ynl0ZXNSZWFkfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IG5ldyBCbG9iKFtidWZmZXJdKTtcbiAgICAgICAgICAgICAgICBsZXQgcmV0cnlDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnREZWxheU1zID0gSU5JVElBTF9SRVRSWV9ERUxBWV9NUztcbiAgICAgICAgICAgICAgICB3aGlsZSAocmV0cnlDb3VudCA8IE1BWF9SRVRSWV9DT1VOVCkge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogY2h1bmssXG4gICAgICAgICAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBodHRwT3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwaVZlcnNpb246ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VVcmw6IHVwbG9hZFVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdYLUdvb2ctVXBsb2FkLUNvbW1hbmQnOiB1cGxvYWRDb21tYW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnWC1Hb29nLVVwbG9hZC1PZmZzZXQnOiBTdHJpbmcob2Zmc2V0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0NvbnRlbnQtTGVuZ3RoJzogU3RyaW5nKGJ5dGVzUmVhZCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdYLUdvb2ctVXBsb2FkLUZpbGUtTmFtZSc6IGZpbGVOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChfYSA9IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5oZWFkZXJzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbWF9HT09HX1VQTE9BRF9TVEFUVVNfSEVBREVSX0ZJRUxEXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0cnlDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBzbGVlcChjdXJyZW50RGVsYXlNcyk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnREZWxheU1zID0gY3VycmVudERlbGF5TXMgKiBERUxBWV9NVUxUSVBMSUVSO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gYnl0ZXNSZWFkO1xuICAgICAgICAgICAgICAgIC8vIFRoZSBgeC1nb29nLXVwbG9hZC1zdGF0dXNgIGhlYWRlciBmaWVsZCBjYW4gYmUgYGFjdGl2ZWAsIGBmaW5hbGAgYW5kXG4gICAgICAgICAgICAgICAgLy9gY2FuY2VsbGVkYCBpbiByZXNwb3NuZS5cbiAgICAgICAgICAgICAgICBpZiAoKChfYiA9IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5oZWFkZXJzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbWF9HT09HX1VQTE9BRF9TVEFUVVNfSEVBREVSX0ZJRUxEXSkgIT09ICdhY3RpdmUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZmlsZVNpemUgPD0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQWxsIGNvbnRlbnQgaGFzIGJlZW4gdXBsb2FkZWQsIGJ1dCB0aGUgdXBsb2FkIHN0YXR1cyBpcyBub3QgZmluYWxpemVkLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIC8vIEVuc3VyZSB0aGUgZmlsZSBoYW5kbGUgaXMgYWx3YXlzIGNsb3NlZFxuICAgICAgICAgICAgaWYgKGZpbGVIYW5kbGUpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBmaWxlSGFuZGxlLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmNvbnN0IExBTkdVQUdFX0xBQkVMX1BSRUZJWCA9ICdnbC1ub2RlLyc7XG4vKipcbiAqIFRoZSBHb29nbGUgR2VuQUkgU0RLLlxuICpcbiAqIEByZW1hcmtzXG4gKiBQcm92aWRlcyBhY2Nlc3MgdG8gdGhlIEdlbkFJIGZlYXR1cmVzIHRocm91Z2ggZWl0aGVyIHRoZSB7QGxpbmtcbiAqIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS92ZXJ0ZXgtYWkvZG9jcy9yZWZlcmVuY2UvcmVzdCB8IEdlbWluaSBBUEl9IG9yXG4gKiB0aGUge0BsaW5rIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS92ZXJ0ZXgtYWkvZG9jcy9yZWZlcmVuY2UvcmVzdCB8IFZlcnRleCBBSVxuICogQVBJfS5cbiAqXG4gKiBUaGUge0BsaW5rIEdvb2dsZUdlbkFJT3B0aW9ucy52ZXJ0ZXhhaX0gdmFsdWUgZGV0ZXJtaW5lcyB3aGljaCBvZiB0aGUgQVBJXG4gKiBzZXJ2aWNlcyB0byB1c2UuXG4gKlxuICogV2hlbiB1c2luZyB0aGUgR2VtaW5pIEFQSSwgYSB7QGxpbmsgR29vZ2xlR2VuQUlPcHRpb25zLmFwaUtleX0gbXVzdCBhbHNvIGJlXG4gKiBzZXQuIFdoZW4gdXNpbmcgVmVydGV4IEFJLCBib3RoIHtAbGluayBHb29nbGVHZW5BSU9wdGlvbnMucHJvamVjdH0gYW5kIHtAbGlua1xuICogR29vZ2xlR2VuQUlPcHRpb25zLmxvY2F0aW9ufSBtdXN0IGJlIHNldCwgb3IgYSB7QGxpbmtcbiAqIEdvb2dsZUdlbkFJT3B0aW9ucy5hcGlLZXl9IG11c3QgYmUgc2V0IHdoZW4gdXNpbmcgRXhwcmVzcyBNb2RlLlxuICpcbiAqIEV4cGxpY2l0bHkgcGFzc2VkIGluIHZhbHVlcyBpbiB7QGxpbmsgR29vZ2xlR2VuQUlPcHRpb25zfSB3aWxsIGFsd2F5cyB0YWtlXG4gKiBwcmVjZWRlbmNlIG92ZXIgZW52aXJvbm1lbnQgdmFyaWFibGVzLiBJZiBib3RoIHByb2plY3QvbG9jYXRpb24gYW5kIGFwaV9rZXlcbiAqIGV4aXN0IGluIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMsIHRoZSBwcm9qZWN0L2xvY2F0aW9uIHdpbGwgYmUgdXNlZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogSW5pdGlhbGl6aW5nIHRoZSBTREsgZm9yIHVzaW5nIHRoZSBHZW1pbmkgQVBJOlxuICogYGBgdHNcbiAqIGltcG9ydCB7R29vZ2xlR2VuQUl9IGZyb20gJ0Bnb29nbGUvZ2VuYWknO1xuICogY29uc3QgYWkgPSBuZXcgR29vZ2xlR2VuQUkoe2FwaUtleTogJ0dFTUlOSV9BUElfS0VZJ30pO1xuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIEluaXRpYWxpemluZyB0aGUgU0RLIGZvciB1c2luZyB0aGUgVmVydGV4IEFJIEFQSTpcbiAqIGBgYHRzXG4gKiBpbXBvcnQge0dvb2dsZUdlbkFJfSBmcm9tICdAZ29vZ2xlL2dlbmFpJztcbiAqIGNvbnN0IGFpID0gbmV3IEdvb2dsZUdlbkFJKHtcbiAqICAgdmVydGV4YWk6IHRydWUsXG4gKiAgIHByb2plY3Q6ICdQUk9KRUNUX0lEJyxcbiAqICAgbG9jYXRpb246ICdQUk9KRUNUX0xPQ0FUSU9OJ1xuICogfSk7XG4gKiBgYGBcbiAqXG4gKi9cbmNsYXNzIEdvb2dsZUdlbkFJIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICAvLyBWYWxpZGF0ZSBleHBsaWNpdGx5IHNldCBpbml0aWFsaXplciB2YWx1ZXMuXG4gICAgICAgIGlmICgob3B0aW9ucy5wcm9qZWN0IHx8IG9wdGlvbnMubG9jYXRpb24pICYmIG9wdGlvbnMuYXBpS2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2plY3QvbG9jYXRpb24gYW5kIEFQSSBrZXkgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZSBpbiB0aGUgY2xpZW50IGluaXRpYWxpemVyLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmVydGV4YWkgPVxuICAgICAgICAgICAgKF9iID0gKF9hID0gb3B0aW9ucy52ZXJ0ZXhhaSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZ2V0Qm9vbGVhbkVudignR09PR0xFX0dFTkFJX1VTRV9WRVJURVhBSScpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmYWxzZTtcbiAgICAgICAgY29uc3QgZW52QXBpS2V5ID0gZ2V0QXBpS2V5RnJvbUVudigpO1xuICAgICAgICBjb25zdCBlbnZQcm9qZWN0ID0gZ2V0RW52KCdHT09HTEVfQ0xPVURfUFJPSkVDVCcpO1xuICAgICAgICBjb25zdCBlbnZMb2NhdGlvbiA9IGdldEVudignR09PR0xFX0NMT1VEX0xPQ0FUSU9OJyk7XG4gICAgICAgIHRoaXMuYXBpS2V5ID0gKF9jID0gb3B0aW9ucy5hcGlLZXkpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGVudkFwaUtleTtcbiAgICAgICAgdGhpcy5wcm9qZWN0ID0gKF9kID0gb3B0aW9ucy5wcm9qZWN0KSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBlbnZQcm9qZWN0O1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gKF9lID0gb3B0aW9ucy5sb2NhdGlvbikgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogZW52TG9jYXRpb247XG4gICAgICAgIC8vIEhhbmRsZSB3aGVuIHRvIHVzZSBWZXJ0ZXggQUkgaW4gZXhwcmVzcyBtb2RlIChhcGkga2V5KVxuICAgICAgICBpZiAob3B0aW9ucy52ZXJ0ZXhhaSkge1xuICAgICAgICAgICAgaWYgKChfZiA9IG9wdGlvbnMuZ29vZ2xlQXV0aE9wdGlvbnMpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5jcmVkZW50aWFscykge1xuICAgICAgICAgICAgICAgIC8vIEV4cGxpY2l0IGNyZWRlbnRpYWxzIHRha2UgcHJlY2VkZW5jZSBvdmVyIGltcGxpY2l0IGFwaV9rZXkuXG4gICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnVGhlIHVzZXIgcHJvdmlkZWQgR29vZ2xlIENsb3VkIGNyZWRlbnRpYWxzIHdpbGwgdGFrZSBwcmVjZWRlbmNlJyArXG4gICAgICAgICAgICAgICAgICAgICcgb3ZlciB0aGUgQVBJIGtleSBmcm9tIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZS4nKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFwaUtleSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEV4cGxpY2l0IGFwaV9rZXkgYW5kIGV4cGxpY2l0IHByb2plY3QvbG9jYXRpb24gYWxyZWFkeSBoYW5kbGVkIGFib3ZlLlxuICAgICAgICAgICAgaWYgKChlbnZQcm9qZWN0IHx8IGVudkxvY2F0aW9uKSAmJiBvcHRpb25zLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIC8vIEV4cGxpY2l0IGFwaV9rZXkgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGltcGxpY2l0IHByb2plY3QvbG9jYXRpb24uXG4gICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnVGhlIHVzZXIgcHJvdmlkZWQgVmVydGV4IEFJIEFQSSBrZXkgd2lsbCB0YWtlIHByZWNlZGVuY2Ugb3ZlcicgK1xuICAgICAgICAgICAgICAgICAgICAnIHRoZSBwcm9qZWN0L2xvY2F0aW9uIGZyb20gdGhlIGVudmlyb25tZW50IHZhcmlhYmxlcy4nKTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2plY3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKChvcHRpb25zLnByb2plY3QgfHwgb3B0aW9ucy5sb2NhdGlvbikgJiYgZW52QXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgLy8gRXhwbGljaXQgcHJvamVjdC9sb2NhdGlvbiB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgaW1wbGljaXQgYXBpX2tleS5cbiAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKCdUaGUgdXNlciBwcm92aWRlZCBwcm9qZWN0L2xvY2F0aW9uIHdpbGwgdGFrZSBwcmVjZWRlbmNlIG92ZXInICtcbiAgICAgICAgICAgICAgICAgICAgJyB0aGUgQVBJIGtleSBmcm9tIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMuJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5hcGlLZXkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgoZW52UHJvamVjdCB8fCBlbnZMb2NhdGlvbikgJiYgZW52QXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgLy8gSW1wbGljaXQgcHJvamVjdC9sb2NhdGlvbiB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgaW1wbGljaXQgYXBpX2tleS5cbiAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKCdUaGUgcHJvamVjdC9sb2NhdGlvbiBmcm9tIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMgd2lsbCB0YWtlJyArXG4gICAgICAgICAgICAgICAgICAgICcgcHJlY2VkZW5jZSBvdmVyIHRoZSBBUEkga2V5IGZyb20gdGhlIGVudmlyb25tZW50IHZhcmlhYmxlcy4nKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFwaUtleSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5sb2NhdGlvbiAmJiAhdGhpcy5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2F0aW9uID0gJ2dsb2JhbCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmFzZVVybCA9IGdldEJhc2VVcmwob3B0aW9ucy5odHRwT3B0aW9ucywgb3B0aW9ucy52ZXJ0ZXhhaSwgZ2V0RW52KCdHT09HTEVfVkVSVEVYX0JBU0VfVVJMJyksIGdldEVudignR09PR0xFX0dFTUlOSV9CQVNFX1VSTCcpKTtcbiAgICAgICAgaWYgKGJhc2VVcmwpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmh0dHBPcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5odHRwT3B0aW9ucy5iYXNlVXJsID0gYmFzZVVybDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuaHR0cE9wdGlvbnMgPSB7IGJhc2VVcmw6IGJhc2VVcmwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFwaVZlcnNpb24gPSBvcHRpb25zLmFwaVZlcnNpb247XG4gICAgICAgIGNvbnN0IGF1dGggPSBuZXcgTm9kZUF1dGgoe1xuICAgICAgICAgICAgYXBpS2V5OiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgIGdvb2dsZUF1dGhPcHRpb25zOiBvcHRpb25zLmdvb2dsZUF1dGhPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBuZXcgQXBpQ2xpZW50KHtcbiAgICAgICAgICAgIGF1dGg6IGF1dGgsXG4gICAgICAgICAgICBwcm9qZWN0OiB0aGlzLnByb2plY3QsXG4gICAgICAgICAgICBsb2NhdGlvbjogdGhpcy5sb2NhdGlvbixcbiAgICAgICAgICAgIGFwaVZlcnNpb246IHRoaXMuYXBpVmVyc2lvbixcbiAgICAgICAgICAgIGFwaUtleTogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICB2ZXJ0ZXhhaTogdGhpcy52ZXJ0ZXhhaSxcbiAgICAgICAgICAgIGh0dHBPcHRpb25zOiBvcHRpb25zLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgdXNlckFnZW50RXh0cmE6IExBTkdVQUdFX0xBQkVMX1BSRUZJWCArIHByb2Nlc3MudmVyc2lvbixcbiAgICAgICAgICAgIHVwbG9hZGVyOiBuZXcgTm9kZVVwbG9hZGVyKCksXG4gICAgICAgICAgICBkb3dubG9hZGVyOiBuZXcgTm9kZURvd25sb2FkZXIoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubW9kZWxzID0gbmV3IE1vZGVscyh0aGlzLmFwaUNsaWVudCk7XG4gICAgICAgIHRoaXMubGl2ZSA9IG5ldyBMaXZlKHRoaXMuYXBpQ2xpZW50LCBhdXRoLCBuZXcgTm9kZVdlYlNvY2tldEZhY3RvcnkoKSk7XG4gICAgICAgIHRoaXMuYmF0Y2hlcyA9IG5ldyBCYXRjaGVzKHRoaXMuYXBpQ2xpZW50KTtcbiAgICAgICAgdGhpcy5jaGF0cyA9IG5ldyBDaGF0cyh0aGlzLm1vZGVscywgdGhpcy5hcGlDbGllbnQpO1xuICAgICAgICB0aGlzLmNhY2hlcyA9IG5ldyBDYWNoZXModGhpcy5hcGlDbGllbnQpO1xuICAgICAgICB0aGlzLmZpbGVzID0gbmV3IEZpbGVzKHRoaXMuYXBpQ2xpZW50KTtcbiAgICAgICAgdGhpcy5vcGVyYXRpb25zID0gbmV3IE9wZXJhdGlvbnModGhpcy5hcGlDbGllbnQpO1xuICAgICAgICB0aGlzLmF1dGhUb2tlbnMgPSBuZXcgVG9rZW5zKHRoaXMuYXBpQ2xpZW50KTtcbiAgICAgICAgdGhpcy50dW5pbmdzID0gbmV3IFR1bmluZ3ModGhpcy5hcGlDbGllbnQpO1xuICAgICAgICB0aGlzLmZpbGVTZWFyY2hTdG9yZXMgPSBuZXcgRmlsZVNlYXJjaFN0b3Jlcyh0aGlzLmFwaUNsaWVudCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0RW52KGVudikge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIHJldHVybiAoX2MgPSAoX2IgPSAoX2EgPSBwcm9jZXNzID09PSBudWxsIHx8IHByb2Nlc3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb2Nlc3MuZW52KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbZW52XSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnRyaW0oKSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gZ2V0Qm9vbGVhbkVudihlbnYpIHtcbiAgICByZXR1cm4gc3RyaW5nVG9Cb29sZWFuKGdldEVudihlbnYpKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ1RvQm9vbGVhbihzdHIpIHtcbiAgICBpZiAoc3RyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gc3RyLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcbn1cbmZ1bmN0aW9uIGdldEFwaUtleUZyb21FbnYoKSB7XG4gICAgY29uc3QgZW52R29vZ2xlQXBpS2V5ID0gZ2V0RW52KCdHT09HTEVfQVBJX0tFWScpO1xuICAgIGNvbnN0IGVudkdlbWluaUFwaUtleSA9IGdldEVudignR0VNSU5JX0FQSV9LRVknKTtcbiAgICBpZiAoZW52R29vZ2xlQXBpS2V5ICYmIGVudkdlbWluaUFwaUtleSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0JvdGggR09PR0xFX0FQSV9LRVkgYW5kIEdFTUlOSV9BUElfS0VZIGFyZSBzZXQuIFVzaW5nIEdPT0dMRV9BUElfS0VZLicpO1xuICAgIH1cbiAgICByZXR1cm4gZW52R29vZ2xlQXBpS2V5IHx8IGVudkdlbWluaUFwaUtleSB8fCB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCB7IEFjdGl2aXR5SGFuZGxpbmcsIEFkYXB0ZXJTaXplLCBBcGlFcnJvciwgQXBpU3BlYywgQXV0aFR5cGUsIEJhdGNoZXMsIEJlaGF2aW9yLCBCbG9ja2VkUmVhc29uLCBDYWNoZXMsIENoYXQsIENoYXRzLCBDb21wdXRlVG9rZW5zUmVzcG9uc2UsIENvbnRlbnRSZWZlcmVuY2VJbWFnZSwgQ29udHJvbFJlZmVyZW5jZUltYWdlLCBDb250cm9sUmVmZXJlbmNlVHlwZSwgQ291bnRUb2tlbnNSZXNwb25zZSwgQ3JlYXRlRmlsZVJlc3BvbnNlLCBEZWxldGVDYWNoZWRDb250ZW50UmVzcG9uc2UsIERlbGV0ZUZpbGVSZXNwb25zZSwgRGVsZXRlTW9kZWxSZXNwb25zZSwgRG9jdW1lbnRTdGF0ZSwgRHluYW1pY1JldHJpZXZhbENvbmZpZ01vZGUsIEVkaXRJbWFnZVJlc3BvbnNlLCBFZGl0TW9kZSwgRW1iZWRDb250ZW50UmVzcG9uc2UsIEVuZFNlbnNpdGl2aXR5LCBFbnZpcm9ubWVudCwgRmVhdHVyZVNlbGVjdGlvblByZWZlcmVuY2UsIEZpbGVTb3VyY2UsIEZpbGVTdGF0ZSwgRmlsZXMsIEZpbmlzaFJlYXNvbiwgRnVuY3Rpb25DYWxsaW5nQ29uZmlnTW9kZSwgRnVuY3Rpb25SZXNwb25zZSwgRnVuY3Rpb25SZXNwb25zZUJsb2IsIEZ1bmN0aW9uUmVzcG9uc2VGaWxlRGF0YSwgRnVuY3Rpb25SZXNwb25zZVBhcnQsIEZ1bmN0aW9uUmVzcG9uc2VTY2hlZHVsaW5nLCBHZW5lcmF0ZUNvbnRlbnRSZXNwb25zZSwgR2VuZXJhdGVDb250ZW50UmVzcG9uc2VQcm9tcHRGZWVkYmFjaywgR2VuZXJhdGVDb250ZW50UmVzcG9uc2VVc2FnZU1ldGFkYXRhLCBHZW5lcmF0ZUltYWdlc1Jlc3BvbnNlLCBHZW5lcmF0ZVZpZGVvc09wZXJhdGlvbiwgR2VuZXJhdGVWaWRlb3NSZXNwb25zZSwgR29vZ2xlR2VuQUksIEhhcm1CbG9ja01ldGhvZCwgSGFybUJsb2NrVGhyZXNob2xkLCBIYXJtQ2F0ZWdvcnksIEhhcm1Qcm9iYWJpbGl0eSwgSGFybVNldmVyaXR5LCBIdHRwRWxlbWVudExvY2F0aW9uLCBIdHRwUmVzcG9uc2UsIEltYWdlUHJvbXB0TGFuZ3VhZ2UsIEltcG9ydEZpbGVPcGVyYXRpb24sIEltcG9ydEZpbGVSZXNwb25zZSwgSW5saW5lZEVtYmVkQ29udGVudFJlc3BvbnNlLCBJbmxpbmVkUmVzcG9uc2UsIEpvYlN0YXRlLCBMYW5ndWFnZSwgTGlzdEJhdGNoSm9ic1Jlc3BvbnNlLCBMaXN0Q2FjaGVkQ29udGVudHNSZXNwb25zZSwgTGlzdERvY3VtZW50c1Jlc3BvbnNlLCBMaXN0RmlsZVNlYXJjaFN0b3Jlc1Jlc3BvbnNlLCBMaXN0RmlsZXNSZXNwb25zZSwgTGlzdE1vZGVsc1Jlc3BvbnNlLCBMaXN0VHVuaW5nSm9ic1Jlc3BvbnNlLCBMaXZlLCBMaXZlQ2xpZW50VG9vbFJlc3BvbnNlLCBMaXZlTXVzaWNQbGF5YmFja0NvbnRyb2wsIExpdmVNdXNpY1NlcnZlck1lc3NhZ2UsIExpdmVTZW5kVG9vbFJlc3BvbnNlUGFyYW1ldGVycywgTGl2ZVNlcnZlck1lc3NhZ2UsIE1hc2tSZWZlcmVuY2VJbWFnZSwgTWFza1JlZmVyZW5jZU1vZGUsIE1lZGlhTW9kYWxpdHksIE1lZGlhUmVzb2x1dGlvbiwgTW9kYWxpdHksIE1vZGUsIE1vZGVscywgTXVzaWNHZW5lcmF0aW9uTW9kZSwgT3BlcmF0aW9ucywgT3V0Y29tZSwgUGFnZWRJdGVtLCBQYWdlciwgUGFydE1lZGlhUmVzb2x1dGlvbkxldmVsLCBQZXJzb25HZW5lcmF0aW9uLCBQaGlzaEJsb2NrVGhyZXNob2xkLCBSYXdSZWZlcmVuY2VJbWFnZSwgUmVjb250ZXh0SW1hZ2VSZXNwb25zZSwgUmVwbGF5UmVzcG9uc2UsIFNhZmV0eUZpbHRlckxldmVsLCBTY2FsZSwgU2VnbWVudEltYWdlUmVzcG9uc2UsIFNlZ21lbnRNb2RlLCBTZXNzaW9uLCBTaW5nbGVFbWJlZENvbnRlbnRSZXNwb25zZSwgU3RhcnRTZW5zaXRpdml0eSwgU3R5bGVSZWZlcmVuY2VJbWFnZSwgU3ViamVjdFJlZmVyZW5jZUltYWdlLCBTdWJqZWN0UmVmZXJlbmNlVHlwZSwgVGhpbmtpbmdMZXZlbCwgVG9rZW5zLCBUcmFmZmljVHlwZSwgVHVuaW5nTWV0aG9kLCBUdW5pbmdNb2RlLCBUdW5pbmdUYXNrLCBUdXJuQ29tcGxldGVSZWFzb24sIFR1cm5Db3ZlcmFnZSwgVHlwZSwgVXBsb2FkVG9GaWxlU2VhcmNoU3RvcmVPcGVyYXRpb24sIFVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlUmVzcG9uc2UsIFVwbG9hZFRvRmlsZVNlYXJjaFN0b3JlUmVzdW1hYmxlUmVzcG9uc2UsIFVwc2NhbGVJbWFnZVJlc3BvbnNlLCBVcmxSZXRyaWV2YWxTdGF0dXMsIFZpZGVvQ29tcHJlc3Npb25RdWFsaXR5LCBWaWRlb0dlbmVyYXRpb25NYXNrTW9kZSwgVmlkZW9HZW5lcmF0aW9uUmVmZXJlbmNlVHlwZSwgY3JlYXRlRnVuY3Rpb25SZXNwb25zZVBhcnRGcm9tQmFzZTY0LCBjcmVhdGVGdW5jdGlvblJlc3BvbnNlUGFydEZyb21VcmksIGNyZWF0ZU1vZGVsQ29udGVudCwgY3JlYXRlUGFydEZyb21CYXNlNjQsIGNyZWF0ZVBhcnRGcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCwgY3JlYXRlUGFydEZyb21FeGVjdXRhYmxlQ29kZSwgY3JlYXRlUGFydEZyb21GdW5jdGlvbkNhbGwsIGNyZWF0ZVBhcnRGcm9tRnVuY3Rpb25SZXNwb25zZSwgY3JlYXRlUGFydEZyb21UZXh0LCBjcmVhdGVQYXJ0RnJvbVVyaSwgY3JlYXRlVXNlckNvbnRlbnQsIG1jcFRvVG9vbCwgc2V0RGVmYXVsdEJhc2VVcmxzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@google/genai/dist/node/index.mjs\n");

/***/ })

};
;